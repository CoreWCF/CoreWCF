<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Target Name="GenerateResourcesSource" 
      Inputs="$(StringResourcesPath)"
	  Outputs="$(IntermediateResOutputFileFullPath)"
	  DependsOnTargets="ReadAndSplitResourceFile;FilterAndCreateResourceSourceLines"
	  BeforeTargets="BeforeCompile">
	<PropertyGroup>
	  <!-- MSBuild trims item group strings so need to use a property value to get the source code indented -->
	  <_Indent>%20%20%20%20</_Indent>
	</PropertyGroup>

	<ItemGroup>
      <SRCodePreamble Include="// Do not edit this file manually it is auto-generated during the build based on the .resx file for this project." />
      <SRCodePreamble Include="namespace System" />
      <SRCodePreamble Include="{" />
      <SRCodePreamble Include="$(_Indent)internal static partial class SR" />
      <SRCodePreamble Include="$(_Indent){" />
      <SRCodePreamble Include="#pragma warning disable 0414" />
      <SRCodePreamble Include="$(_Indent)private const string s_resourceName = &quot;FxResources.$(AssemblyName).SR&quot;%3b" />
      <SRCodePreamble Include="#pragma warning restore 0414" />
      <SRCodePreamble Include="$(_Indent)" />
	</ItemGroup>
	<ItemGroup>
      <SRCodePostamble Include="$(_Indent)$(_Indent)internal static Type ResourceType =&gt; typeof(FxResources.$(AssemblyName).SR)%3b" />
      <SRCodePostamble Include="$(_Indent)}" />
      <SRCodePostamble Include="}" />
      <SRCodePostamble Include="$(_Indent)" />
      <SRCodePostamble Include="namespace FxResources.$(AssemblyName)" />
      <SRCodePostamble Include="{" />
      <SRCodePostamble Include="$(_Indent)internal static class SR { }" />
      <SRCodePostamble Include="}" />
	</ItemGroup>
	
	<Message Text="Writing resources source file $(IntermediateResOutputFileFullPath)" Importance="high"/>
	<WriteLinesToFile File="$(IntermediateResOutputFileFullPath)" Lines="@(SRCodePreamble)" Overwrite="true" />
	<WriteLinesToFile File="$(IntermediateResOutputFileFullPath)" Lines="@(ResourceItemSourceLine)" Overwrite="false" />
	<WriteLinesToFile File="$(IntermediateResOutputFileFullPath)" Lines="@(SRCodePostamble)" Overwrite="false" />

	<ItemGroup>
      <Compile Include="$(IntermediateResOutputFileFullPath)" />
    </ItemGroup>
  </Target>
  
  <Target Name="FilterAndCreateResourceSourceLines" Inputs="@ResourceStringItems" Outputs="%(ResourceStringItems.Identity)" DependsOnTargets="ReadAndSplitResourceFile">
	<!-- Check if line from resource file contains a string resource -->
    <PropertyGroup>
      <!-- MSBuild doesn't allow property functions to be used for ItemGroup conditions so need to evaluate whether the line
           contains a resouce string using a property, then use the stored property value in ItemGroup conditions -->
	  <ResourceStringValueContainsResName>$([System.String]::new('%(ResourceStringItems.Identity)').Contains(`resName`))</ResourceStringValueContainsResName>
	  <!-- MSBuild trims item group strings so need to use a property value to get the source code indented -->
	  <_Indent>%20%20%20%20</_Indent>
	</PropertyGroup>

	<!-- Parse resource line to extract resource name and value -->
	<PropertyGroup Condition="'$(ResourceStringValueContainsResName)' == 'True'">
	    <ResourceName>$([System.Text.RegularExpressions.Regex]::Match($([System.String]::new('%(ResourceStringItems.Identity)')),`(?&lt;=\s*&lt;resName&gt;)(.*?)(?=&lt;/resName&gt;)`))</ResourceName>
		<ResourceValue>$([System.Text.RegularExpressions.Regex]::Match($([System.String]::new('%(ResourceStringItems.Identity)')),`(?&lt;=\s*&lt;resValue&gt;)(.*?)(?=&lt;/resValue&gt;.*)`))</ResourceValue>
	    <!-- Replace single quotes with double quotes as resources will be emitted to a source file contained inside a string literal: @"..." -->
		<ResourceValue>$([System.Text.RegularExpressions.Regex]::Replace($(ResourceValue),`"`,`""`))</ResourceValue>
	</PropertyGroup>
	
	<!-- Save parsed resource name and value into ResourceFileContentsClean. This only contains data from actual resource items and excludes items such as resource file headers -->
	<ItemGroup Condition="'$(ResourceStringValueContainsResName)' == 'True'">
	  <ResourceItemSourceLine Include="$(_Indent)$(_Indent)internal static string $(ResourceName) =&gt; SR.GetResourceString(&quot;$(ResourceName)&quot;, @&quot;$(ResourceValue)&quot;)%3b" />
	  <ResourceItemSourceLine Include="$(_Indent)" />
	</ItemGroup>
  </Target>
  
  <Target Name="ReadAndSplitResourceFile">
    <Message Text="Resource File Name = $(StringResourcesPath)" Importance="high" />
	<PropertyGroup>
	  <ResourceFileContents>$([System.IO.File]::ReadAllText($(StringResourcesPath)))</ResourceFileContents>

	  <!-- Remove comment block as it contains some example resource items which would otherwise be picked up by a later regex -->
	  <ResourceFileContents>$([System.Text.RegularExpressions.Regex]::Replace($(ResourceFileContents), `&lt;!--.*--&gt;`, ``, System.Text.RegularExpressions.RegexOptions.Singleline))</ResourceFileContents>

	  <!-- Rearrange resources to be on single lines. E.g.
	         <data name = "SampleResourceString" xml:space="preserve">
				<value>This is a resource string</value>
			</data>
			Becomes
		    <resName>SampleResourceString</resName><resValue>This is a resource string</resValue>
      -->
	  <ResourceRegexExpression>&lt;data\s+name\s*=\s*"(?&lt;name&gt;.*?)"\s*(?:xml:space\s*=\s*"\w+")?&gt;\s*&lt;value&gt;(?&lt;value&gt;.*?)&lt;/value&gt;\s*&lt;/data&gt;</ResourceRegexExpression>
	  <ResourceFileContents>$([System.Text.RegularExpressions.Regex]::Replace($(ResourceFileContents), `$(ResourceRegexExpression)`, `&lt;resName&gt;$1&lt;/resName&gt;&lt;resValue&gt;$2&lt;/resValue&gt;`))</ResourceFileContents>
	</PropertyGroup>
	
	<!-- Split each resource item to be it's own item in the item group -->
	<ItemGroup>
	  <ResourceStringItems Include="$(ResourceFileContents.Split('%0d'))"/>
	</ItemGroup>
  </Target>
</Project>
