diff --git a/global.json b/global.json
index b6ce100..36a1435 100644
--- a/global.json
+++ b/global.json
@@ -1,6 +1,6 @@
 {
   "sdk": {
-    "version": "3.1.101",
+    "version": "3.1.201",
     "rollForward": "disable"
   }
 }
\ No newline at end of file
diff --git a/src/Common/src/DuplexChannels/CoreWCF/Channels/ServiceChannelBase.cs b/src/Common/src/DuplexChannels/CoreWCF/Channels/ServiceChannelBase.cs
index 97cc5df..3ae6b46 100644
--- a/src/Common/src/DuplexChannels/CoreWCF/Channels/ServiceChannelBase.cs
+++ b/src/Common/src/DuplexChannels/CoreWCF/Channels/ServiceChannelBase.cs
@@ -1,4 +1,4 @@
-﻿using CoreWCF.Configuration;
+using CoreWCF.Configuration;
 using System;
 
 namespace CoreWCF.Channels
diff --git a/src/Common/src/DuplexChannels/CoreWCF/Channels/TransportDuplexSessionChannel.cs b/src/Common/src/DuplexChannels/CoreWCF/Channels/TransportDuplexSessionChannel.cs
index df6ca8d..61675f3 100644
--- a/src/Common/src/DuplexChannels/CoreWCF/Channels/TransportDuplexSessionChannel.cs
+++ b/src/Common/src/DuplexChannels/CoreWCF/Channels/TransportDuplexSessionChannel.cs
@@ -1,4 +1,4 @@
-﻿using CoreWCF.Configuration;
+using CoreWCF.Configuration;
 using CoreWCF.Diagnostics;
 using CoreWCF.Dispatcher;
 using CoreWCF.Runtime;
@@ -131,29 +131,6 @@ namespace CoreWCF.Channels
             }
         }
 
-        public async Task<bool> WaitForMessageAsync(CancellationToken token)
-        {
-            if (this.DoneReceivingInCurrentState())
-            {
-                return true;
-            }
-
-            bool shouldFault = true;
-            try
-            {
-                bool success = await MessageSource.WaitForMessageAsync(token);
-                shouldFault = !success; // need to fault if we've timed out because we're now toast
-                return success;
-            }
-            finally
-            {
-                if (shouldFault)
-                {
-                    Fault();
-                }
-            }
-        }
-
         protected void SetChannelBinding(ChannelBinding channelBinding)
         {
             Fx.Assert(_channelBindingToken == null, "ChannelBinding token can only be set once.");
diff --git a/src/CoreWCF.Http/src/CoreWCF.Http.csproj b/src/CoreWCF.Http/src/CoreWCF.Http.csproj
index d571d06..dc54b27 100644
--- a/src/CoreWCF.Http/src/CoreWCF.Http.csproj
+++ b/src/CoreWCF.Http/src/CoreWCF.Http.csproj
@@ -10,6 +10,7 @@
   <ItemGroup>
     <PackageReference Include="Microsoft.AspNetCore.WebSockets" Version="2.1.7" />
     <PackageReference Include="Microsoft.Extensions.DependencyInjection.Abstractions" Version="2.1.1" />
+    <PackageReference Include="Microsoft.Extensions.Logging.Abstractions" Version="2.1.1" />
   </ItemGroup>
   <ItemGroup>
     <ProjectReference Include="..\..\CoreWCF.Primitives\src\CoreWCF.Primitives.csproj" />
diff --git a/src/CoreWCF.Http/src/CoreWCF/Channels/HttpTransportBindingElement.cs b/src/CoreWCF.Http/src/CoreWCF/Channels/HttpTransportBindingElement.cs
index 6394d1c..754c538 100644
--- a/src/CoreWCF.Http/src/CoreWCF/Channels/HttpTransportBindingElement.cs
+++ b/src/CoreWCF.Http/src/CoreWCF/Channels/HttpTransportBindingElement.cs
@@ -1,6 +1,9 @@
+using CoreWCF.Configuration;
+using Microsoft.AspNetCore.Builder;
 using System;
 using System.ComponentModel;
 using System.Net;
+using System.Security.Authentication.ExtendedProtection;
 
 namespace CoreWCF.Channels
 {
@@ -11,6 +14,7 @@ namespace CoreWCF.Channels
         private string _realm;
         private TransferMode _transferMode;
         private WebSocketTransportSettings _webSocketSettings;
+        private ExtendedProtectionPolicy _extendedProtectionPolicy;
 
         //HttpAnonymousUriPrefixMatcher _anonymousUriPrefixMatcher;
 
@@ -128,13 +132,46 @@ namespace CoreWCF.Channels
             return new HttpTransportBindingElement(this);
         }
 
+        public override IServiceDispatcher BuildServiceDispatcher<TChannel>(BindingContext context, IServiceDispatcher innerDispatcher)
+        {
+            var app = context.BindingParameters.Find<IApplicationBuilder>();
+            if (app == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgument(nameof(IApplicationBuilder));
+            }
+
+            // Wire up inner dispatcher to ServiceModelHttpMiddleware so that incoming requests get dispatched
+            //ServiceModelHttpMiddleware.ConfigureDispatcher(app, innerDispatcher);
+            // Return the previous inner dispatcher as we don't create a wrapping dispatcher here.
+            return innerDispatcher;
+        }
+
+        public override bool CanBuildServiceDispatcher<TChannel>(BindingContext context)
+        {
+            if (typeof(TChannel) == typeof(IReplyChannel))
+            {
+                return this.WebSocketSettings.TransportUsage != WebSocketTransportUsage.Always;
+            }
+            else if (typeof(TChannel) == typeof(IDuplexSessionChannel))
+            {
+                return this.WebSocketSettings.TransportUsage != WebSocketTransportUsage.Never;
+            }
+
+            return false;
+        }
+
         public override T GetProperty<T>(BindingContext context)
         {
             if (context == null)
             {
                 throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(context));
             }
-            //if (typeof(T) == typeof(ISecurityCapabilities))
+
+            if (typeof(T) == typeof(ITransportServiceBuilder))
+            {
+                return (T)(object)new HttpTransportServiceBuilder();
+            }
+            //else if (typeof(T) == typeof(ISecurityCapabilities))
             //{
             //    AuthenticationSchemes effectiveAuthenticationSchemes = HttpTransportBindingElement.GetEffectiveAuthenticationSchemes(this.AuthenticationScheme,
             //        context.BindingParameters);
@@ -149,7 +186,7 @@ namespace CoreWCF.Channels
             //{
             //    return (T)(object)new BindingDeliveryCapabilitiesHelper();
             //}
-            /*else*/ if (typeof(T) == typeof(TransferMode))
+            else if (typeof(T) == typeof(TransferMode))
             {
                 return (T)(object)TransferMode;
             }
@@ -222,7 +259,29 @@ namespace CoreWCF.Channels
                 return currentAuthenticationSchemes & hostSupportedAuthenticationSchemes;
             //}
         }
+        public ExtendedProtectionPolicy ExtendedProtectionPolicy
+        {
+            get
+            {
+                return _extendedProtectionPolicy;
+            }
+            set
+            {
+                if (value == null)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(value));
+                }
+
+                if (value.PolicyEnforcement == PolicyEnforcement.Always &&
+                    !System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.OSSupportsExtendedProtection)
+                {
+                    // ExceptionHelper.PlatformNotSupported(SR.ExtendedProtectionNotSupported);
+                }
+
+                _extendedProtectionPolicy = value;
+            }
+        }
 
-        public override Type MiddlewareType => typeof(ServiceModelHttpMiddleware);
+      //  public override Type MiddlewareType => typeof(ServiceModelHttpMiddleware);
     }
 }
\ No newline at end of file
diff --git a/src/CoreWCF.Http/src/CoreWCF/Channels/HttpTransportServiceBuilder.cs b/src/CoreWCF.Http/src/CoreWCF/Channels/HttpTransportServiceBuilder.cs
new file mode 100644
index 0000000..c0c25e4
--- /dev/null
+++ b/src/CoreWCF.Http/src/CoreWCF/Channels/HttpTransportServiceBuilder.cs
@@ -0,0 +1,43 @@
+﻿using CoreWCF.Configuration;
+using Microsoft.AspNetCore.Builder;
+using Microsoft.Extensions.DependencyInjection;
+using Microsoft.Extensions.Logging;
+using System;
+
+namespace CoreWCF.Channels
+{
+    internal class HttpTransportServiceBuilder : ITransportServiceBuilder
+    {
+        private bool _configured = false;
+        private DateTime _configuredTime = DateTime.MinValue;
+        private object _lock = new object();
+
+        public void Configure(IApplicationBuilder app)
+        {
+            var logger = app.ApplicationServices.GetRequiredService<ILogger<HttpTransportServiceBuilder>>();
+            logger.LogDebug($"Configure called _configured:{_configured} _configuredTime:{_configuredTime}");
+            if (!_configured)
+            {
+                logger.LogDebug("!Configured");
+                lock (_lock)
+                {
+                    if (!_configured)
+                    {
+                        logger.LogDebug("Still !Configured");
+                        ConfigureCore(app);
+                        _configured = true;
+                        _configuredTime = DateTime.UtcNow;
+                    }
+
+                }
+            }
+        }
+
+        private void ConfigureCore(IApplicationBuilder app)
+        {
+            var logger = app.ApplicationServices.GetRequiredService<ILogger<HttpTransportServiceBuilder>>();
+            logger.LogDebug("Adding ServiceModelHttpMiddleware to app builder");
+            app.UseMiddleware<ServiceModelHttpMiddleware>(app);
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/CoreWCF.Http/src/CoreWCF/Channels/RequestDelegateHandler.cs b/src/CoreWCF.Http/src/CoreWCF/Channels/RequestDelegateHandler.cs
index 56c28f7..15596bc 100644
--- a/src/CoreWCF.Http/src/CoreWCF/Channels/RequestDelegateHandler.cs
+++ b/src/CoreWCF.Http/src/CoreWCF/Channels/RequestDelegateHandler.cs
@@ -2,6 +2,7 @@
 using Microsoft.Extensions.DependencyInjection;
 using CoreWCF.Runtime;
 using CoreWCF.Configuration;
+using CoreWCF.Dispatcher;
 using System;
 using System.Threading;
 using System.Threading.Tasks;
@@ -67,6 +68,7 @@ namespace CoreWCF.Channels
 
             _httpSettings = httpSettings;
             WebSocketOptions = CreateWebSocketOptions(tbe);
+
             if (WebSocketOptions == null)
             {
                 _replyChannel = new AspNetCoreReplyChannel(_servicesScopeFactory.CreateScope().ServiceProvider, _httpSettings);
@@ -93,6 +95,7 @@ namespace CoreWCF.Channels
 
         internal async Task HandleRequest(HttpContext context)
         {
+
             if (!context.WebSockets.IsWebSocketRequest)
             {
                 if (_replyChannelDispatcher == null)
@@ -178,7 +181,19 @@ namespace CoreWCF.Channels
                 WebSocketHelper.ThrowCorrectException(ex);
                 throw;
             }
+        }
 
+        private void SendUpgradeRequiredResponseMessageWithSubProtocol()
+        {
+        }
+
+        internal async Task HandleDuplexConnection(HttpContext context)
+        {
+            if (context.WebSockets.IsWebSocketRequest)
+            {
+                WebSocket webSocket = await context.WebSockets.AcceptWebSocketAsync();
+                
+            }
         }
     }
 }
\ No newline at end of file
diff --git a/src/CoreWCF.Http/src/CoreWCF/Channels/ServiceModelHttpMiddleware.cs b/src/CoreWCF.Http/src/CoreWCF/Channels/ServiceModelHttpMiddleware.cs
index b318637..3f876c4 100644
--- a/src/CoreWCF.Http/src/CoreWCF/Channels/ServiceModelHttpMiddleware.cs
+++ b/src/CoreWCF.Http/src/CoreWCF/Channels/ServiceModelHttpMiddleware.cs
@@ -7,20 +7,24 @@ using System;
 using System.Collections.Generic;
 using System.Text;
 using System.Threading.Tasks;
+using System.Threading;
+using Microsoft.Extensions.Logging;
+using CoreWCF.Description;
+using CoreWCF.Security;
 
 namespace CoreWCF.Channels
 {
     public partial class ServiceModelHttpMiddleware
     {
-        private IServiceBuilder _serviceBuilder;
         private RequestDelegate _next;
-        private readonly RequestDelegate _branch;
+        private ILogger<ServiceModelHttpMiddleware> _logger;
+        private RequestDelegate _branch;
 
-        public ServiceModelHttpMiddleware(RequestDelegate next, IApplicationBuilder app, IServiceBuilder serviceBuilder, IDispatcherBuilder dispatcherBuilder)
+        public ServiceModelHttpMiddleware(RequestDelegate next, IApplicationBuilder app, IServiceBuilder serviceBuilder, IDispatcherBuilder dispatcherBuilder, ILogger<ServiceModelHttpMiddleware> logger)
         {
-            _serviceBuilder = serviceBuilder;
             _next = next;
-            _branch = BuildBranch(app, _serviceBuilder, dispatcherBuilder);
+            _logger = logger;
+            _branch = BuildBranch(app, serviceBuilder, dispatcherBuilder);
         }
 
         public Task InvokeAsync(HttpContext context)
@@ -30,10 +34,12 @@ namespace CoreWCF.Channels
 
         private RequestDelegate BuildBranch(IApplicationBuilder app, IServiceBuilder serviceBuilder, IDispatcherBuilder dispatcherBuilder)
         {
+            _logger.LogDebug("Building branch map");
             var branchApp = app.New();
-            var serverAddresses = app.ServerFeatures.Get<IServerAddressesFeature>();
-            foreach (var address in serverAddresses.Addresses)
+            var serverAddressesFeature = app.ServerFeatures.Get<IServerAddressesFeature>();
+            foreach (var address in serverAddressesFeature.Addresses)
             {
+                _logger.LogDebug($"Adding base address {address} to serviceBuilder");
                 serviceBuilder.BaseAddresses.Add(new Uri(address));
             }
 
@@ -48,46 +54,90 @@ namespace CoreWCF.Channels
                         continue;
                     }
 
-                    var scheme = dispatcher.BaseAddress?.Scheme;
-                    if (!"http".Equals(scheme, StringComparison.OrdinalIgnoreCase) &&
-                        !"https".Equals(scheme, StringComparison.OrdinalIgnoreCase))
+                    var binding = new CustomBinding(dispatcher.Binding);
+                    if (binding.Elements.Find<HttpTransportBindingElement>() == null)
                     {
+                        _logger.LogDebug($"Binding for address {dispatcher.BaseAddress} is not an HTTP[S] binding ao skipping");
                         continue; // Not an HTTP(S) dispatcher
                     }
 
-                    bool matching = false;
-                    foreach (var serverAddress in serverAddresses.Addresses)
+                    var parameters = new BindingParameterCollection();
+                    parameters.Add(app);
+                    parameters.Add(serverAddressesFeature);
+                    Type supportedChannelType = null;
+                    IServiceDispatcher serviceDispatcher = null;
+                    var supportedChannels = dispatcher.SupportedChannelTypes;
+                    for (int i = 0; i < supportedChannels.Count; i++)
                     {
-                        // TODO: Might not be necessary to compare paths
-                        var serverUri = new Uri(serverAddress);
-                        var serverAddressNormalized = string.Join(":",
-                            serverUri.GetComponents(UriComponents.Port | UriComponents.Path, UriFormat.SafeUnescaped));
-                        var dispatcherAddressNormalized = string.Join(":",
-                            dispatcher.BaseAddress.GetComponents(UriComponents.Port | UriComponents.Path, UriFormat.SafeUnescaped));
-                        if (dispatcherAddressNormalized.StartsWith(serverAddressNormalized, StringComparison.OrdinalIgnoreCase))
+                        Type channelType = supportedChannels[i];
+
+                        if (channelType == typeof(IInputChannel))
                         {
-                            matching = true;
-                            break; // Dispatcher address is based on server listening address;
+                            if (binding.CanBuildServiceDispatcher<IInputChannel>(parameters))
+                            {
+                                serviceDispatcher = binding.BuildServiceDispatcher<IInputChannel>(parameters, dispatcher);
+                                supportedChannelType = typeof(IInputChannel);
+                                break;
+                            }
                         }
-                    }
+                        if (channelType == typeof(IReplyChannel))
+                        {
+                            if (binding.CanBuildServiceDispatcher<IReplyChannel>(parameters))
+                            {
+                                serviceDispatcher = binding.BuildServiceDispatcher<IReplyChannel>(parameters, dispatcher);
+                                supportedChannelType = typeof(IReplyChannel);
+                            }
+                        }
+                        if (channelType == typeof(IDuplexChannel))
+                        {
+                            if (binding.CanBuildServiceDispatcher<IDuplexChannel>(parameters))
+                            {
 
-                    if (matching)
-                    {
-                        branchApp.Map(dispatcher.BaseAddress.AbsolutePath, wcfApp =>
+                                serviceDispatcher = binding.BuildServiceDispatcher<IDuplexChannel>(parameters, dispatcher);
+                                supportedChannelType = typeof(IDuplexChannel);
+                            }
+                        }
+                        if (channelType == typeof(IInputSessionChannel))
                         {
-                            var servicesScopeFactory = wcfApp.ApplicationServices.GetRequiredService<IServiceScopeFactory>();
-                            var requestHandler = new RequestDelegateHandler(dispatcher, servicesScopeFactory);
-                            if (requestHandler.WebSocketOptions != null)
+                            if (binding.CanBuildServiceDispatcher<IInputSessionChannel>(parameters))
                             {
-                                wcfApp.UseWebSockets(requestHandler.WebSocketOptions);
+                                serviceDispatcher = binding.BuildServiceDispatcher<IInputSessionChannel>(parameters, dispatcher);
+                                supportedChannelType = typeof(IInputSessionChannel);
                             }
-                            wcfApp.Run(requestHandler.HandleRequest);
-                        });
+                        }
+                        if (channelType == typeof(IReplySessionChannel))
+                        {
+                            if (binding.CanBuildServiceDispatcher<IReplySessionChannel>(parameters))
+                            {
+                                serviceDispatcher = binding.BuildServiceDispatcher<IReplySessionChannel>(parameters, dispatcher);
+                                supportedChannelType = typeof(IReplySessionChannel);
+                            }
+                        }
+                        if (channelType == typeof(IDuplexSessionChannel))
+                        {
+                            if (binding.CanBuildServiceDispatcher<IDuplexSessionChannel>(parameters))
+                            {
+                                serviceDispatcher = binding.BuildServiceDispatcher<IDuplexSessionChannel>(parameters, dispatcher);
+                                supportedChannelType = typeof(IDuplexSessionChannel);
+                            }
+                        }
                     }
+
+                    _logger.LogInformation($"Mapping CoreWCF branch app for path {dispatcher.BaseAddress.AbsolutePath}");
+                    branchApp.Map(dispatcher.BaseAddress.AbsolutePath, wcfApp =>
+                    {
+                        var servicesScopeFactory = wcfApp.ApplicationServices.GetRequiredService<IServiceScopeFactory>();
+                        var requestHandler = new RequestDelegateHandler(serviceDispatcher, servicesScopeFactory);
+                        if (requestHandler.WebSocketOptions != null)
+                        {
+                            wcfApp.UseWebSockets(requestHandler.WebSocketOptions);
+                        }
+                        wcfApp.Run(requestHandler.HandleRequest);
+                    });
                 }
             }
 
-            branchApp.Use(_ => { return context => _next(context); });
+            branchApp.Use(_ => { return reqContext => _next(reqContext); });
             return branchApp.Build();
         }
     }
diff --git a/src/CoreWCF.Http/src/CoreWCF/HttpBindingBase.cs b/src/CoreWCF.Http/src/CoreWCF/HttpBindingBase.cs
index 1d3b56c..b930194 100644
--- a/src/CoreWCF.Http/src/CoreWCF/HttpBindingBase.cs
+++ b/src/CoreWCF.Http/src/CoreWCF/HttpBindingBase.cs
@@ -17,16 +17,19 @@ namespace CoreWCF
         internal HttpBindingBase()
         {
             _httpTransport = new HttpTransportBindingElement();
+            _httpsTransport = new HttpsTransportBindingElement();
             _textEncoding = new TextMessageEncodingBindingElement();
             _textEncoding.MessageVersion = MessageVersion.Soap11;
         }
         // [System.ComponentModel.DefaultValueAttribute(false)]
         // public bool AllowCookies { get { return default(bool); } set { } }
-        public EnvelopeVersion EnvelopeVersion { get { return default(EnvelopeVersion); } }
+        
         // [System.ComponentModel.DefaultValueAttribute((long)524288)]
         // public long MaxBufferPoolSize { get { return default(long); } set { } }
         // [System.ComponentModel.DefaultValueAttribute(65536)]
         // public int MaxBufferSize { get { return default(int); } set { } }
+
+        [DefaultValue(TransportDefaults.MaxReceivedMessageSize)]
         public long MaxReceivedMessageSize
         {
             get
@@ -39,6 +42,7 @@ namespace CoreWCF
                 //_httpsTransport.MaxReceivedMessageSize = value;
             }
         }
+
         public int MaxBufferSize
         {
             get { return _httpTransport.MaxBufferSize; }
@@ -71,9 +75,35 @@ namespace CoreWCF
         }
 
         public override string Scheme { get { return GetTransport().Scheme; } }
-        public Encoding TextEncoding { get { return default(Encoding); } set { } }
-        // [System.ComponentModel.DefaultValueAttribute((System.ServiceModel.TransferMode)(0))]
-        // public System.ServiceModel.TransferMode TransferMode { get { return default(System.ServiceModel.TransferMode); } set { } }
+
+        public Encoding TextEncoding
+        {
+            get
+            {
+                return _textEncoding.WriteEncoding;
+            }
+
+            set
+            {
+                _textEncoding.WriteEncoding = value;
+                //_mtomEncoding.WriteEncoding = value;
+            }
+        }
+
+        [DefaultValue(HttpTransportDefaults.TransferMode)]
+        public TransferMode TransferMode
+        {
+            get
+            {   
+                return _httpTransport.TransferMode;
+            }
+
+            set
+            {
+                _httpTransport.TransferMode = value;
+                _httpsTransport.TransferMode = value;
+            }
+        }
 
         internal TextMessageEncodingBindingElement TextMessageEncodingBindingElement
         {
diff --git a/src/CoreWCF.Http/src/CoreWCF/HttpTransportSecurity.cs b/src/CoreWCF.Http/src/CoreWCF/HttpTransportSecurity.cs
index d67988e..445040a 100644
--- a/src/CoreWCF.Http/src/CoreWCF/HttpTransportSecurity.cs
+++ b/src/CoreWCF.Http/src/CoreWCF/HttpTransportSecurity.cs
@@ -67,11 +67,11 @@ namespace CoreWCF
             }
         }
 
-        //internal void ConfigureTransportProtectionOnly(HttpsTransportBindingElement https)
-        //{
-        //    DisableAuthentication(https);
-        //    https.RequireClientCertificate = false;
-        //}
+        internal void ConfigureTransportProtectionOnly(HttpsTransportBindingElement https)
+        {
+            DisableAuthentication(https);
+            https.RequireClientCertificate = false;
+        }
 
         void ConfigureAuthentication(HttpTransportBindingElement http)
         {
@@ -80,13 +80,13 @@ namespace CoreWCF
             //http.ExtendedProtectionPolicy = extendedProtectionPolicy;
         }
 
-        //static void ConfigureAuthentication(HttpTransportBindingElement http, HttpTransportSecurity transportSecurity)
-        //{
-        //    transportSecurity.clientCredentialType = HttpClientCredentialTypeHelper.MapToClientCredentialType(http.AuthenticationScheme);
-        //    transportSecurity.proxyCredentialType = HttpProxyCredentialTypeHelper.MapToProxyCredentialType(http.ProxyAuthenticationScheme);
-        //    transportSecurity.Realm = http.Realm;
-        //    transportSecurity.extendedProtectionPolicy = http.ExtendedProtectionPolicy;
-        //}
+        static void ConfigureAuthentication(HttpTransportBindingElement http, HttpTransportSecurity transportSecurity)
+        {
+            transportSecurity.clientCredentialType = HttpClientCredentialTypeHelper.MapToClientCredentialType(http.AuthenticationScheme);
+            // transportSecurity.pro = httpproxycredentialtypehelper.maptoproxycredentialtype(http.proxyauthenticationscheme);
+            transportSecurity.realm = http.Realm;
+            transportSecurity.extendedProtectionPolicy = http.ExtendedProtectionPolicy;
+        }
 
         void DisableAuthentication(HttpTransportBindingElement http)
         {
@@ -108,12 +108,12 @@ namespace CoreWCF
             https.RequireClientCertificate = (clientCredentialType == HttpClientCredentialType.Certificate);
         }
 
-        //internal static void ConfigureTransportProtectionAndAuthentication(HttpsTransportBindingElement https, HttpTransportSecurity transportSecurity)
-        //{
-        //    ConfigureAuthentication(https, transportSecurity);
-        //    if (https.RequireClientCertificate)
-        //        transportSecurity.ClientCredentialType = HttpClientCredentialType.Certificate;
-        //}
+        internal static void ConfigureTransportProtectionAndAuthentication(HttpsTransportBindingElement https, HttpTransportSecurity transportSecurity)
+        {
+            ConfigureAuthentication(https, transportSecurity);
+            if (https.RequireClientCertificate)
+                transportSecurity.ClientCredentialType = HttpClientCredentialType.Certificate;
+        }
 
         internal void ConfigureTransportAuthentication(HttpTransportBindingElement http)
         {
diff --git a/src/CoreWCF.Http/src/CoreWCF/WSHTTPSecurity.cs b/src/CoreWCF.Http/src/CoreWCF/WSHTTPSecurity.cs
new file mode 100644
index 0000000..24453ae
--- /dev/null
+++ b/src/CoreWCF.Http/src/CoreWCF/WSHTTPSecurity.cs
@@ -0,0 +1,160 @@
+﻿using System;
+using System.Collections.Generic;
+using System.ComponentModel;
+using System.Text;
+using CoreWCF.Channels;
+using CoreWCF.Runtime;
+using CoreWCF.Security;
+using CoreWCF;
+
+namespace CoreWCF
+{
+    public sealed class WSHttpSecurity
+    {
+        internal const SecurityMode DefaultMode = SecurityMode.Message;
+
+        SecurityMode mode;
+        HttpTransportSecurity transportSecurity;
+        NonDualMessageSecurityOverHttp messageSecurity;
+
+        public WSHttpSecurity()
+            : this(DefaultMode, GetDefaultHttpTransportSecurity(), new NonDualMessageSecurityOverHttp())
+        {
+        }
+
+        internal WSHttpSecurity(SecurityMode mode, HttpTransportSecurity transportSecurity, NonDualMessageSecurityOverHttp messageSecurity)
+        {
+            this.mode = mode;
+            this.transportSecurity = transportSecurity == null ? GetDefaultHttpTransportSecurity() : transportSecurity;
+            this.messageSecurity = messageSecurity == null ? new NonDualMessageSecurityOverHttp() : messageSecurity;
+        }
+
+        internal static HttpTransportSecurity GetDefaultHttpTransportSecurity()
+        {
+            HttpTransportSecurity transportSecurity = new HttpTransportSecurity();
+            transportSecurity.ClientCredentialType = HttpClientCredentialType.Windows;
+            return transportSecurity;
+        }
+
+        public SecurityMode Mode
+        {
+            get { return this.mode; }
+            set
+            {
+                if (!SecurityModeHelper.IsDefined(value))
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("value"));
+                }
+                this.mode = value;
+            }
+        }
+
+        public HttpTransportSecurity Transport
+        {
+            get { return this.transportSecurity; }
+            set
+            {
+                if (value == null)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException("value"));
+                }
+                this.transportSecurity = value;
+            }
+        }
+
+        public NonDualMessageSecurityOverHttp Message
+        {
+            get { return this.messageSecurity; }
+            set
+            {
+                if (value == null)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException("value"));
+                }
+                this.messageSecurity = value;
+            }
+        }
+
+        internal void ApplyTransportSecurity(HttpsTransportBindingElement https)
+        {
+            if (this.mode == SecurityMode.TransportWithMessageCredential)
+            {
+                this.transportSecurity.ConfigureTransportProtectionOnly(https);
+            }
+            else
+            {
+                this.transportSecurity.ConfigureTransportProtectionAndAuthentication(https);
+            }
+        }
+
+        internal static void ApplyTransportSecurity(HttpsTransportBindingElement transport, HttpTransportSecurity transportSecurity)
+        {
+            HttpTransportSecurity.ConfigureTransportProtectionAndAuthentication(transport, transportSecurity);
+        }
+
+        internal SecurityBindingElement CreateMessageSecurity(bool isReliableSessionEnabled, MessageSecurityVersion version)
+        {
+            if (this.mode == SecurityMode.Message || this.mode == SecurityMode.TransportWithMessageCredential)
+            {
+                return this.messageSecurity.CreateSecurityBindingElement(this.Mode == SecurityMode.TransportWithMessageCredential, isReliableSessionEnabled, version);
+            }
+            else
+            {
+                return null;
+            }
+        }
+
+        //internal static bool TryCreate(SecurityBindingElement sbe, UnifiedSecurityMode mode, HttpTransportSecurity transportSecurity, bool isReliableSessionEnabled, out WSHttpSecurity security)
+        //{
+        //    security = null;
+        //    NonDualMessageSecurityOverHttp messageSecurity = null;
+        //    SecurityMode securityMode = SecurityMode.None;
+        //    if (sbe != null)
+        //    {
+        //        mode &= UnifiedSecurityMode.Message | UnifiedSecurityMode.TransportWithMessageCredential;
+        //        securityMode = SecurityModeHelper.ToSecurityMode(mode);
+        //        Fx.Assert(SecurityModeHelper.IsDefined(securityMode), string.Format("Invalid SecurityMode value: {0}.", mode.ToString()));
+        //        if (!MessageSecurityOverHttp.TryCreate(sbe, securityMode == SecurityMode.TransportWithMessageCredential, isReliableSessionEnabled, out messageSecurity))
+        //        {
+        //            return false;
+        //        }
+        //    }
+        //    else
+        //    {
+        //        mode &= ~(UnifiedSecurityMode.Message | UnifiedSecurityMode.TransportWithMessageCredential);
+        //        securityMode = SecurityModeHelper.ToSecurityMode(mode);
+        //    }
+        //    Fx.Assert(SecurityModeHelper.IsDefined(securityMode), string.Format("Invalid SecurityMode value: {0}.", securityMode.ToString()));
+        //    security = new WSHttpSecurity(securityMode, transportSecurity, messageSecurity);
+        //    return true;
+        //}
+
+        //internal bool InternalShouldSerialize()
+        //{
+        //    return this.ShouldSerializeMode()
+        //        || this.ShouldSerializeMessage()
+        //        || this.ShouldSerializeTransport();
+        //}
+
+        [EditorBrowsable(EditorBrowsableState.Never)]
+        public bool ShouldSerializeMode()
+        {
+            return this.Mode != DefaultMode;
+        }
+
+        //[EditorBrowsable(EditorBrowsableState.Never)]
+        //public bool ShouldSerializeMessage()
+        //{
+        //    return this.Message.InternalShouldSerialize();
+        //}
+
+        //[EditorBrowsable(EditorBrowsableState.Never)]
+        //public bool ShouldSerializeTransport()
+        //{
+        //    return this.Transport.ClientCredentialType != HttpClientCredentialType.Windows
+        //        || this.Transport.ShouldSerializeProxyCredentialType()
+        //        || this.Transport.ShouldSerializeRealm();
+        //}
+
+    }
+}
diff --git a/src/CoreWCF.Http/src/CoreWCF/WSHttpBinding.cs b/src/CoreWCF.Http/src/CoreWCF/WSHttpBinding.cs
new file mode 100644
index 0000000..a8aafad
--- /dev/null
+++ b/src/CoreWCF.Http/src/CoreWCF/WSHttpBinding.cs
@@ -0,0 +1,86 @@
+﻿using CoreWCF.Channels;
+using CoreWCF.Security;
+using System;
+using System.Collections.Generic;
+using System.ComponentModel;
+using System.Text;
+
+namespace CoreWCF
+{
+   public class WSHttpBinding: WSHttpBindingBase
+    {
+        private static readonly MessageSecurityVersion s_WSMessageSecurityVersion = MessageSecurityVersion.WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11BasicSecurityProfile10;
+
+        private WSHttpSecurity _security = new WSHttpSecurity();
+
+        public WSHttpBinding() : base() { }
+
+        public WSHttpBinding(SecurityMode securityMode) : this(securityMode, false) { }
+
+        public WSHttpBinding(SecurityMode securityMode, bool reliableSessionEnabled) : base(reliableSessionEnabled)
+        {
+            _security.Mode = securityMode;
+        }
+
+        internal WSHttpBinding(WSHttpSecurity security, bool reliableSessionEnabled) : base(reliableSessionEnabled)
+        {
+            _security = security == null ? new WSHttpSecurity() : security;
+        }
+
+        /*
+        [DefaultValue(HttpTransportDefaults.AllowCookies)]
+        public bool AllowCookies
+        {
+            get { return HttpTransport.AllowCookies; }
+            set
+            {
+                HttpTransport.AllowCookies = value;
+                HttpsTransport.AllowCookies = value;
+            }
+        }*/
+
+        public WSHttpSecurity Security
+        {
+            get { return _security; }
+            set
+            {
+                _security = value ?? throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException(nameof(value)));
+            }
+        }
+
+        //public override IChannelFactory<TChannel> BuildChannelFactory<TChannel>(BindingParameterCollection parameters)
+        //{
+        //    if ((_security.Mode == SecurityMode.Transport) &&
+        //        _security.Transport.ClientCredentialType == HttpClientCredentialType.InheritedFromHost)
+        //    {
+        //        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.HttpClientCredentialTypeInvalid, _security.Transport.ClientCredentialType)));
+        //    }
+
+        //    return base.BuildChannelFactory<TChannel>(parameters);
+        //}
+
+        public override BindingElementCollection CreateBindingElements()
+        {
+            return base.CreateBindingElements();
+        }
+
+        protected override TransportBindingElement GetTransport()
+        {
+            if (_security.Mode == SecurityMode.None || _security.Mode == SecurityMode.Message)
+            {
+                this.HttpTransport.ExtendedProtectionPolicy = _security.Transport.ExtendedProtectionPolicy;
+                return this.HttpTransport;
+            }
+            else
+            {
+                _security.ApplyTransportSecurity(this.HttpsTransport);
+                return this.HttpsTransport;
+            }
+        }
+
+        protected override SecurityBindingElement CreateMessageSecurity()
+        {
+            return _security.CreateMessageSecurity(false, s_WSMessageSecurityVersion);
+        }
+    }
+}
diff --git a/src/CoreWCF.Http/src/CoreWCF/WSHttpBindingBase.cs b/src/CoreWCF.Http/src/CoreWCF/WSHttpBindingBase.cs
new file mode 100644
index 0000000..0e73ebc
--- /dev/null
+++ b/src/CoreWCF.Http/src/CoreWCF/WSHttpBindingBase.cs
@@ -0,0 +1,173 @@
+﻿using System;
+using System.Collections.Generic;
+using System.ComponentModel;
+using System.Text;
+using CoreWCF.Channels;
+using CoreWCF.Runtime;
+
+using System.Xml;
+using CoreWCF.Configuration;
+
+namespace CoreWCF
+{
+   public abstract class  WSHttpBindingBase : Binding //, IBindingRuntimePreferences
+    {
+        private TextMessageEncodingBindingElement _textEncoding;
+
+        protected WSHttpBindingBase()
+            : base()
+        {
+            Initialize();
+        }
+
+        protected WSHttpBindingBase(bool reliableSessionEnabled) : this()
+        {
+            if (reliableSessionEnabled)
+            {
+                throw new PlatformNotSupportedException();
+            }
+        }
+
+        //[DefaultValue(HttpTransportDefaults.BypassProxyOnLocal)]
+        //public bool BypassProxyOnLocal
+        //{
+        //    get { return HttpTransport.BypassProxyOnLocal; }
+        //    set
+        //    {
+        //        HttpTransport.BypassProxyOnLocal = value;
+        //        HttpsTransport.BypassProxyOnLocal = value;
+        //    }
+        //}
+
+        [DefaultValue(false)]
+        public bool TransactionFlow
+        {
+            get { return false; }
+            set
+            {
+                if (value)
+                {
+                    throw new PlatformNotSupportedException();
+                }
+            }
+        }
+
+       // [DefaultValue(TransportDefaults.MaxBufferPoolSize)]
+        public long MaxBufferPoolSize
+        {
+            get { return HttpTransport.MaxBufferPoolSize; }
+            set
+            {
+                HttpTransport.MaxBufferPoolSize = value;
+                HttpsTransport.MaxBufferPoolSize = value;
+            }
+        }
+
+        [DefaultValue(TransportDefaults.MaxReceivedMessageSize)]
+        public long MaxReceivedMessageSize
+        {
+            get { return HttpTransport.MaxReceivedMessageSize; }
+            set
+            {
+                if (value > int.MaxValue)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(
+                        new ArgumentOutOfRangeException(nameof(MaxReceivedMessageSize),
+                        SR.MaxReceivedMessageSizeMustBeInIntegerRange));
+                }
+                HttpTransport.MaxReceivedMessageSize = value;
+                HttpsTransport.MaxReceivedMessageSize = value;
+            }
+        }
+
+        //[DefaultValue(HttpTransportDefaults.ProxyAddress)]
+        //public Uri ProxyAddress
+        //{
+        //    get { return HttpTransport.ProxyAddress; }
+        //    set
+        //    {
+        //        HttpTransport.ProxyAddress = value;
+        //        HttpsTransport.ProxyAddress = value;
+        //    }
+        //}
+
+        public XmlDictionaryReaderQuotas ReaderQuotas
+        {
+            get { return _textEncoding.ReaderQuotas; }
+            set
+            {
+                if (value == null)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(value));
+                }
+
+                value.CopyTo(_textEncoding.ReaderQuotas);
+            }
+        }
+
+        public override string Scheme { get { return GetTransport().Scheme; } }
+
+        public EnvelopeVersion EnvelopeVersion
+        {
+            get { return EnvelopeVersion.Soap12; }
+        }
+
+        //public Text.Encoding TextEncoding
+        //{
+        //    get { return _textEncoding.WriteEncoding; }
+        //    set
+        //    {
+        //        _textEncoding.WriteEncoding = value;
+        //    }
+        //}
+
+        //[DefaultValue(HttpTransportDefaults.UseDefaultWebProxy)]
+        //public bool UseDefaultWebProxy
+        //{
+        //    get { return HttpTransport.UseDefaultWebProxy; }
+        //    set
+        //    {
+        //        HttpTransport.UseDefaultWebProxy = value;
+        //        HttpsTransport.UseDefaultWebProxy = value;
+        //    }
+        //}
+
+        internal HttpTransportBindingElement HttpTransport { get; private set; }
+
+        internal HttpsTransportBindingElement HttpsTransport { get; private set; }
+
+        private void Initialize()
+        {
+            HttpTransport = new HttpTransportBindingElement();
+            HttpsTransport = new HttpsTransportBindingElement();
+            _textEncoding = new TextMessageEncodingBindingElement();
+            _textEncoding.MessageVersion = MessageVersion.Soap12WSAddressing10;
+        }
+
+        public override BindingElementCollection CreateBindingElements()
+        {   // return collection of BindingElements
+            BindingElementCollection bindingElements = new BindingElementCollection();
+            // order of BindingElements is important
+            // context
+
+            // add security (*optional)
+            SecurityBindingElement wsSecurity = CreateMessageSecurity();
+            if (wsSecurity != null)
+            {
+                bindingElements.Add(wsSecurity);
+            }
+            
+            // add encoding
+            bindingElements.Add(_textEncoding);
+
+            // add transport (http or https)
+            bindingElements.Add(GetTransport());
+
+            return bindingElements.Clone();
+        }
+
+        protected abstract TransportBindingElement GetTransport();
+        protected abstract SecurityBindingElement CreateMessageSecurity();
+    }
+
+}
diff --git a/src/CoreWCF.Http/tests/AggregateExceptionTests.cs b/src/CoreWCF.Http/tests/AggregateExceptionTests.cs
new file mode 100644
index 0000000..2f38fae
--- /dev/null
+++ b/src/CoreWCF.Http/tests/AggregateExceptionTests.cs
@@ -0,0 +1,121 @@
+﻿using CoreWCF.Configuration;
+using Helpers;
+using Microsoft.AspNetCore.Builder;
+using Microsoft.AspNetCore.Hosting;
+using Microsoft.Extensions.DependencyInjection;
+using ServiceContract;
+using System;
+using System.Text;
+using System.Threading.Tasks;
+using Xunit;
+using Xunit.Abstractions;
+
+namespace CoreWCF.Http.Tests
+{
+    public class AggregateExceptionTests
+    {
+        private ITestOutputHelper _output;
+        public AggregateExceptionTests(ITestOutputHelper output)
+        {
+            _output = output;
+        }
+
+        [Theory]
+        [InlineData("ServiceOpWithChainedTasks_ThrowFaultExceptionInOneTask")]
+        [InlineData("ServiceOpWithChainedTasks_ThrowFaultExceptionInOneTask_WithTask")]
+        [InlineData("ServiceOpWithMultipleTasks")]
+        [InlineData("ServiceOpWithMultipleTasks_WithTask")]
+        [InlineData("SimpleOperationThrowingFault")]
+        [InlineData("SimpleOperationThrowingFault_WithTask")]
+        public void ServiceOp_ThrowsFaultException(string serviceOpType)
+        {
+            var host = ServiceHelper.CreateWebHostBuilder<AggregateExceptionStartup>(_output).Build();
+            using (host)
+            {
+                host.Start();
+                var sampleServiceClient = ClientHelper.GetProxy<ClientContract.IAggregateExceptionService>();
+                try
+                {
+                    switch (serviceOpType)
+                    {
+                        case "SimpleOperationThrowingFault":
+                            sampleServiceClient.SimpleOperationThrowingFault();
+                            break;
+                        case "SimpleOperationThrowingFault_WithTask":
+                            {
+                                Task task = sampleServiceClient.SimpleOperationThrowingFaultAsync();
+                                task.Wait();
+                                break;
+                            }
+                        case "ServiceOpWithMultipleTasks":
+                            sampleServiceClient.ServiceOpWithMultipleTasks();
+                            break;
+                        case "ServiceOpWithMultipleTasks_WithTask":
+                            {
+                                Task task2 = sampleServiceClient.ServiceOpWithMultipleTasksAsync();
+                                task2.Wait();
+                                break;
+                            }
+                        case "ServiceOpWithChainedTasks_ThrowFaultExceptionInOneTask":
+                            sampleServiceClient.ServiceOpWithChainedTasks_ThrowFaultExceptionInOneTask();
+                            break;
+                        case "ServiceOpWithChainedTasks_ThrowFaultExceptionInOneTask_WithTask":
+                            {
+                                Task task3 = sampleServiceClient.ServiceOpWithChainedTasks_ThrowFaultExceptionInOneTaskAsync();
+                                task3.Wait();
+                                break;
+                            }
+                    }
+                    throw new Exception("Expected fault but got result successfully.");
+                }
+                catch (System.ServiceModel.FaultException<ClientContract.SampleServiceFault> faultEx)
+                {
+                    this.VerifyFaultThrown(faultEx);
+                }
+                catch (AggregateException ex)
+                {
+                    System.ServiceModel.FaultException<ClientContract.SampleServiceFault> faultEx2 = ex.InnerExceptions[0] as System.ServiceModel.FaultException<ClientContract.SampleServiceFault>;
+                    this.VerifyFaultThrown(faultEx2);
+                }
+                catch (Exception ex2)
+                {
+                    StringBuilder stringBuilder = new StringBuilder();
+                    stringBuilder.AppendLine();
+                    stringBuilder.AppendLine("Expected a fault exception of type 'SampleServiceFault' but got the following.");
+                    stringBuilder.Append("Message: " + ex2.GetType().ToString());
+                    stringBuilder.AppendLine(ex2.Message);
+                    stringBuilder.Append("StackTrace: ");
+                    stringBuilder.AppendLine(ex2.StackTrace);
+                    throw new Exception(stringBuilder.ToString());
+                }
+            }
+        }
+
+        private void VerifyFaultThrown(System.ServiceModel.FaultException<ClientContract.SampleServiceFault> faultEx)
+        {
+            if (faultEx == null)
+            {
+                throw new ArgumentNullException("faultEx");
+            }
+            ClientContract.SampleServiceFault detail = faultEx.Detail;
+            Assert.True(detail.ID.Equals("101") && detail.Message.Equals("Error has occurred while performing an operation."));
+        }
+    }
+
+    internal class AggregateExceptionStartup
+    {
+        public void ConfigureServices(IServiceCollection services)
+        {
+            services.AddServiceModelServices();
+        }
+
+        public void Configure(IApplicationBuilder app, IHostingEnvironment env)
+        {
+            app.UseServiceModel(builder =>
+            {
+                builder.AddService<Services.AggregateExceptionService>();
+                builder.AddServiceEndpoint<Services.AggregateExceptionService, IAggregateExceptionService>(new CoreWCF.BasicHttpBinding(), "/BasicWcfService/basichttp.svc");
+            });
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/CoreWCF.Http/tests/BasicScenariosTest.cs b/src/CoreWCF.Http/tests/BasicScenariosTest.cs
new file mode 100644
index 0000000..feaf78d
--- /dev/null
+++ b/src/CoreWCF.Http/tests/BasicScenariosTest.cs
@@ -0,0 +1,95 @@
+﻿using CoreWCF.Configuration;
+using Helpers;
+using Microsoft.AspNetCore.Builder;
+using Microsoft.AspNetCore.Hosting;
+using Microsoft.Extensions.DependencyInjection;
+using System;
+using System.ServiceModel.Channels;
+using Xunit;
+using Xunit.Abstractions;
+
+namespace CoreWCF.Http.Tests
+{
+    public class BasicScenariosTest
+    {
+        private ITestOutputHelper _output;
+
+        public BasicScenariosTest(ITestOutputHelper output)
+        {
+            _output = output;
+        }
+
+        [Fact]
+        public void BasicScenariosAndOps()
+        {
+            var host = ServiceHelper.CreateWebHostBuilder<Startup>(_output).Build();
+            using (host)
+            {
+                host.Start();
+                var httpBinding = ClientHelper.GetBufferedModeBinding();
+                var factory = new System.ServiceModel.ChannelFactory<ClientContract.ITestBasicScenarios>(httpBinding,
+                    new System.ServiceModel.EndpointAddress(new Uri("http://localhost:8080/BasicWcfService/ITestBasicScenariosService.svc")));
+                var channel = factory.CreateChannel();
+
+                var factory2 = new System.ServiceModel.ChannelFactory<ClientContract.ITestBasicScenariosClientService>(httpBinding,
+                    new System.ServiceModel.EndpointAddress(new Uri("http://localhost:8080/BasicWcfService/ITestBasicScenariosService.svc")));
+                var channel2 = factory2.CreateChannel();
+
+                //Variation string TestMethodDefaults
+                int ID = 1;
+                string name = "Defaults";
+                string result = channel.TestMethodDefaults(ID, name);
+                Assert.NotNull(result);
+                Assert.Equal(result, name);
+
+                //Variation_void TestMethodSetAction
+                ID = 1;
+                name = "Action";
+                channel.TestMethodSetAction(ID, name);
+
+                //Variation_int TestMethodSetReplyAction               
+                ID = 1;
+                name = "ReplyAction";
+                int resultInt = channel.TestMethodSetReplyAction(ID, name);
+                Assert.Equal(resultInt, ID);
+
+                //Variation_void TestMethodUntypedAction                
+                Message clientMessage = Message.CreateMessage(MessageVersion.Soap11, "myUntypedAction");
+                channel.TestMethodUntypedAction(clientMessage);
+
+                //Variation_Message TestMethodUntypedreplyAction                
+                Message msg = channel.TestMethodUntypedReplyAction();
+                Assert.NotNull(msg);
+
+                //Variation_void TestMethodSetUntypedAction                                  
+                Message clientUntypedActionMessage = Message.CreateMessage(MessageVersion.Soap11, "mySetUntypedAction");
+                channel.TestMethodSetUntypedAction(clientUntypedActionMessage);
+
+                //Variation_sting TestMethodasync                
+                ID = 1;
+                name = "Async";
+                result = channel2.TestMethodAsync(ID, name).GetAwaiter().GetResult();
+                Assert.NotNull(result);
+                Assert.Equal(result, name);
+            }
+        }
+
+        internal class Startup
+        {
+            public void ConfigureServices(IServiceCollection services)
+            {
+                services.AddServiceModelServices();
+            }
+
+            public void Configure(IApplicationBuilder app, IHostingEnvironment env)
+            {
+                app.UseServiceModel(builder =>
+                {
+                    builder.AddService<Services.TestBasicScenariosService>();
+                    builder.AddServiceEndpoint<Services.TestBasicScenariosService, ServiceContract.ITestBasicScenarios>(new BasicHttpBinding(), "/BasicWcfService/ITestBasicScenariosService.svc");
+                });
+            }
+        }
+    }
+
+}
diff --git a/src/CoreWCF.Http/tests/BasicValidationSoapTests.cs b/src/CoreWCF.Http/tests/BasicValidationSoapTests.cs
new file mode 100644
index 0000000..3db22fc
--- /dev/null
+++ b/src/CoreWCF.Http/tests/BasicValidationSoapTests.cs
@@ -0,0 +1,77 @@
+﻿using CoreWCF.Configuration;
+using Helpers;
+using Microsoft.AspNetCore.Builder;
+using Microsoft.AspNetCore.Hosting;
+using Microsoft.Extensions.DependencyInjection;
+using ServiceContract;
+using System;
+using System.IO;
+using Xunit;
+using Xunit.Abstractions;
+
+namespace CoreWCF.Http.Tests
+{
+    public class BasicValidationSoapTests
+    {
+        private ITestOutputHelper _output;
+        public BasicValidationSoapTests(ITestOutputHelper output)
+        {
+            _output = output;
+        }
+
+        [Fact]
+        public void BasicRequestReplySoap()
+        {
+            var host = ServiceHelper.CreateWebHostBuilder<BasicValidationSoapTestsStartup>(_output).Build();
+            using (host)
+            {
+                host.Start();
+                var client = ClientHelper.GetProxy<ClientContract.IRequestReplyService>();
+                _output.WriteLine("Invoking service operation DownloadData");
+                _output.WriteLine("Response = {0}", client.DownloadData());
+
+                _output.WriteLine("Invoking service operation UploadData");
+                client.UploadData("ContentToReplace");
+
+                _output.WriteLine("Invoking service operation DownloadStream");
+                Stream downloadedStream = client.DownloadStream();
+                _output.WriteLine("Response = ...");
+
+                // Read from the stream...
+                StreamReader reader = new StreamReader(downloadedStream);
+                string content = reader.ReadToEnd();
+                _output.WriteLine(content);
+
+                _output.WriteLine("Invoking service operation UploadStream");
+                byte[] buffer = new byte[1024];
+                Random rand = new Random();
+                rand.NextBytes(buffer);
+                MemoryStream uploadStream = new MemoryStream(buffer);
+                client.UploadStream(uploadStream);
+
+                _output.WriteLine("Getting Log from service.  Result: ...");
+                foreach (string logItem in client.GetLog())
+                {
+                    _output.WriteLine(logItem);
+                }
+            }
+        }
+    }
+
+    internal class BasicValidationSoapTestsStartup
+    {
+        public void ConfigureServices(IServiceCollection services)
+        {
+            services.AddServiceModelServices();
+        }
+
+        public void Configure(IApplicationBuilder app, IHostingEnvironment env)
+        {
+            app.UseServiceModel(builder =>
+            {
+                builder.AddService<Services.RequestReplyService>();
+                builder.AddServiceEndpoint<Services.RequestReplyService, IRequestReplyService>(new CoreWCF.BasicHttpBinding(), "/BasicWcfService/basichttp.svc");
+            });
+        }
+    }
+}
diff --git a/src/CoreWCF.Http/tests/ClientContract/IAggregateExceptionService.cs b/src/CoreWCF.Http/tests/ClientContract/IAggregateExceptionService.cs
new file mode 100644
index 0000000..581007b
--- /dev/null
+++ b/src/CoreWCF.Http/tests/ClientContract/IAggregateExceptionService.cs
@@ -0,0 +1,42 @@
+﻿using System.Runtime.Serialization;
+using System.ServiceModel;
+using System.Threading.Tasks;
+
+namespace ClientContract
+{
+    [DataContract(Namespace = "http://Microsoft.ServiceModel.Samples")]
+    public class SampleServiceFault
+    {
+        [DataMember]
+        public string Message { get; set; }
+
+        [DataMember]
+        public string ID { get; set; }
+    }
+
+    [ServiceContractAttribute]
+    public interface IAggregateExceptionService
+    {
+
+        [OperationContractAttribute]
+        [FaultContractAttribute(typeof(SampleServiceFault))]
+        void SimpleOperationThrowingFault();
+
+        [OperationContractAttribute]
+        Task SimpleOperationThrowingFaultAsync();
+
+        [OperationContractAttribute]
+        [FaultContractAttribute(typeof(SampleServiceFault))]
+        void ServiceOpWithMultipleTasks();
+
+        [OperationContractAttribute]
+        Task ServiceOpWithMultipleTasksAsync();
+
+        [OperationContractAttribute]
+        [FaultContractAttribute(typeof(SampleServiceFault))]
+        void ServiceOpWithChainedTasks_ThrowFaultExceptionInOneTask();
+
+        [OperationContractAttribute]
+        Task ServiceOpWithChainedTasks_ThrowFaultExceptionInOneTaskAsync();
+    }
+}
diff --git a/src/CoreWCF.Http/tests/ClientContract/IOpContractInvalidActionReplyAction.cs b/src/CoreWCF.Http/tests/ClientContract/IOpContractInvalidActionReplyAction.cs
new file mode 100644
index 0000000..d915141
--- /dev/null
+++ b/src/CoreWCF.Http/tests/ClientContract/IOpContractInvalidActionReplyAction.cs
@@ -0,0 +1,18 @@
+﻿using System.ServiceModel;
+
+namespace ClientContract
+{
+    [ServiceContract]
+    interface IOpContractInvalidAction
+    {
+        [OperationContract(Action = null)]
+        void TestMethodNullAction(int id);
+    }
+
+    [ServiceContract]
+    interface IOpContractInvalidReplyAction
+    {
+        [OperationContract(ReplyAction = null)]
+        int TestMethodNullReplyAction(int id);
+    }
+}
diff --git a/src/CoreWCF.Http/tests/ClientContract/IRequestReplyService.cs b/src/CoreWCF.Http/tests/ClientContract/IRequestReplyService.cs
new file mode 100644
index 0000000..ba2cb58
--- /dev/null
+++ b/src/CoreWCF.Http/tests/ClientContract/IRequestReplyService.cs
@@ -0,0 +1,35 @@
+﻿using System;
+using System.Collections.Generic;
+using System.IO;
+using System.ServiceModel;
+
+namespace ClientContract
+{
+    [ServiceContract]
+    public interface IRequestReplyService
+    {
+        [OperationContract]
+        void UploadData(string data);
+
+        [OperationContract]
+        string DownloadData();
+
+        [OperationContract]
+        void UploadStream(Stream stream);
+
+        [OperationContract]
+        Stream DownloadStream();
+
+        [OperationContract]
+        Stream DownloadCustomizedStream(TimeSpan readThrottle, TimeSpan streamDuration);
+
+        [OperationContract]
+        void ThrowingOperation(Exception exceptionToThrow);
+
+        [OperationContract]
+        string DelayOperation(TimeSpan delay);
+
+        [OperationContract]
+        List<string> GetLog();
+    }
+}
diff --git a/src/CoreWCF.Http/tests/ClientContract/ITaskCollectionsTest.cs b/src/CoreWCF.Http/tests/ClientContract/ITaskCollectionsTest.cs
new file mode 100644
index 0000000..5e6a225
--- /dev/null
+++ b/src/CoreWCF.Http/tests/ClientContract/ITaskCollectionsTest.cs
@@ -0,0 +1,43 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Runtime.Serialization;
+using System.ServiceModel;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace ClientContract
+{
+        [ServiceContract(Namespace = "http://microsoft.samples", Name = "ICollectionsTest")]
+        public interface ITaskCollectionsTest
+        {
+            [OperationContract]
+            Task<LinkedList<int>> GetList();
+
+            [OperationContract]
+            Task<Dictionary<string, int>> GetDictionary();
+
+            [OperationContract]
+            Task<HashSet<Book>> GetSet();
+
+            [OperationContract]
+            Task<Stack<byte>> GetStack();
+
+            [OperationContract]
+            Task<Queue<string>> GetQueue();
+        }
+
+        [DataContract]
+        public class Book
+        {
+            [DataMember]
+            public string Name;
+
+            [DataMember]
+            public Guid ISBN;
+
+            [DataMember]
+            public string Publisher;
+        }
+}
+
+
diff --git a/src/CoreWCF.Http/tests/ClientContract/ITaskPrimitives.cs b/src/CoreWCF.Http/tests/ClientContract/ITaskPrimitives.cs
new file mode 100644
index 0000000..d00129b
--- /dev/null
+++ b/src/CoreWCF.Http/tests/ClientContract/ITaskPrimitives.cs
@@ -0,0 +1,88 @@
+﻿using System;
+using System.Globalization;
+using System.ServiceModel;
+using System.Threading.Tasks;
+
+namespace ClientContract
+{
+    public static class AsyncNetAdoptionConstants
+    {
+        public static DateTime TestDateTime = new DateTime(2010, 09, 04, new GregorianCalendar(GregorianCalendarTypes.USEnglish));
+    }
+   
+    [ServiceContract(Namespace = "http://microsoft.samples", Name = "ITestPrimitives")]
+    public interface ITestPrimitives
+    {
+        [OperationContract]
+        Task<int> GetInt();
+
+        [OperationContract]
+        Task<byte> GetByte();
+
+        [OperationContract]
+        Task<sbyte> GetSByte();
+
+        [OperationContract]
+        Task<short> GetShort();
+
+        [OperationContract]
+        Task<ushort> GetUShort();
+
+        [OperationContract]
+        Task<double> GetDouble();
+
+        [OperationContract]
+        Task<uint> GetUInt();
+
+        [OperationContract]
+        Task<long> GetLong();
+
+        [OperationContract]
+        Task<ulong> GetULong();
+
+        [OperationContract]
+        Task<char> GetChar();
+
+        [OperationContract]
+        Task<bool> GetBool();
+
+        [OperationContract]
+        Task<float> GetFloat();
+
+        [OperationContract]
+        Task<decimal> GetDecimal();
+
+        [OperationContract]
+        Task<string> GetString();
+
+        [OperationContract]
+        Task<DateTime> GetDateTime();
+
+        [OperationContract]
+        Task<int[][]> GetintArr2D();
+
+        [OperationContract]
+        Task<float[]> GetfloatArr();
+
+        [OperationContract]
+        Task<byte[]> GetbyteArr();
+
+        [OperationContract]
+        Task<int?> GetnullableInt();
+
+        [OperationContract]
+        Task<TimeSpan> GetTimeSpan();
+
+        [OperationContract]
+        Task<Guid> GetGuid();
+
+        [OperationContract]
+        Task<Color> GetEnum();
+    }
+    public enum Color
+    {
+        Red,
+        Green,
+        Blue
+    }
+}
diff --git a/src/CoreWCF.Http/tests/ClientContract/ITestBasicScenarios.cs b/src/CoreWCF.Http/tests/ClientContract/ITestBasicScenarios.cs
new file mode 100644
index 0000000..4df0dd2
--- /dev/null
+++ b/src/CoreWCF.Http/tests/ClientContract/ITestBasicScenarios.cs
@@ -0,0 +1,34 @@
+﻿using System.ServiceModel.Channels;
+using System.ServiceModel;
+
+namespace ClientContract
+{    
+    [ServiceContract]
+    public interface ITestBasicScenarios
+    {
+        [OperationContract]
+        string TestMethodDefaults(int ID, string name);
+
+        [OperationContract(Action = "myAction")]
+        void TestMethodSetAction(int ID, string name);
+
+        [OperationContract(ReplyAction = "myReplyAction")]
+        int TestMethodSetReplyAction(int ID, string name);
+
+        [OperationContract(Action = "myUntypedAction")]
+        void TestMethodUntypedAction(Message m);
+
+        [OperationContract(ReplyAction = "myUntypedReplyAction")]
+        Message TestMethodUntypedReplyAction();
+
+        [OperationContract(Action = "*")]
+        void TestMethodSetUntypedAction(Message m);
+    }
+
+    [ServiceContract(Name = "ITestBasicScenarios")]
+    public interface ITestBasicScenariosClientService
+    {
+        [OperationContract(Action = "myAsyncAction", ReplyAction = "myAsyncReplyAction")]        
+        System.Threading.Tasks.Task<string> TestMethodAsync(int ID, string name);
+    }
+}
diff --git a/src/CoreWCF.Http/tests/ClientContract/ITestDataContractFault.cs b/src/CoreWCF.Http/tests/ClientContract/ITestDataContractFault.cs
new file mode 100644
index 0000000..4d5c330
--- /dev/null
+++ b/src/CoreWCF.Http/tests/ClientContract/ITestDataContractFault.cs
@@ -0,0 +1,117 @@
+﻿using System.IO;
+using System.Runtime.Serialization;
+using System.ServiceModel;
+using System.ServiceModel.Channels;
+
+namespace ClientContract
+{
+    #region Contract w/ FaultContract using DataContract (ITestDataContractFault)
+    [DataContract(Namespace = "http://Microsoft.ServiceModel.Samples")]
+    public class SomeFault
+    {
+        public SomeFault(int errID, string errMsg)
+        {
+            ID = errID;
+            message = errMsg;
+        }
+        [DataMember]
+        public int ID;
+        [DataMember]
+        public string message;
+    }
+
+    [DataContract(Namespace = "http://Microsoft.ServiceModel.Samples")]
+    public class OuterFault
+    {
+        [DataMember]
+        public SomeFault InnerFault { get; set; }
+    }
+
+    [DataContract(Namespace = "http://Microsoft.ServiceModel.Samples")]
+    public class ComplexFault
+    {
+        [DataMember]
+        public int ErrorInt { get; set; }
+
+        [DataMember]
+        public string ErrorString { get; set; }
+
+        [DataMember]
+        public SomeFault SomeFault { get; set; }
+
+        [DataMember]
+        public byte[] ErrorByteArray { get; set; }
+
+        [DataMember]
+        public int[] ErrorIntArray { get; set; }
+
+        [DataMember]
+        public string[] ErrorStringArray { get; set; }
+
+        [DataMember]
+        public SomeFault[] SomeFaultArray { get; set; }
+    }
+
+    [ServiceContract]
+    public interface ITestDataContractFault
+    {
+        [OperationContract]
+        [FaultContract(typeof(SomeFault))]
+        [FaultContract(typeof(OuterFault))]
+        [FaultContract(typeof(ComplexFault))]
+        string TwoWay_Method(string s);
+
+        [OperationContract]
+        [FaultContract(typeof(SomeFault))]
+        [FaultContract(typeof(OuterFault))]
+        [FaultContract(typeof(ComplexFault))]
+        void TwoWayVoid_Method(string s);
+
+        [OperationContract]
+        [FaultContract(typeof(SomeFault))]
+        [FaultContract(typeof(OuterFault))]
+        [FaultContract(typeof(ComplexFault))]
+        Stream TwoWayStream_Method(Stream s);
+
+        [OperationContract(AsyncPattern = true)]
+        [FaultContract(typeof(SomeFault))]
+        [FaultContract(typeof(OuterFault))]
+        [FaultContract(typeof(ComplexFault))]
+        System.Threading.Tasks.Task<string> TwoWayAsync_Method(string s);
+
+        [OperationContract]
+        [FaultContract(typeof(SomeFault))]
+        [FaultContract(typeof(OuterFault))]
+        [FaultContract(typeof(ComplexFault))]
+        FaultMsgContract MessageContract_Method(FaultMsgContract fmc);
+
+        [OperationContract]
+        [FaultContract(typeof(SomeFault))]
+        [FaultContract(typeof(OuterFault))]
+        [FaultContract(typeof(ComplexFault))]
+        Message Untyped_Method(Message m);
+
+        [OperationContract]
+        [FaultContract(typeof(SomeFault))]
+        [FaultContract(typeof(OuterFault))]
+        [FaultContract(typeof(ComplexFault))]
+        Message Untyped_MethodReturns(Message m);
+    }
+
+    [ServiceContract(Name = "ITestDataContractFault")]
+    public interface ITestDataContractFaultTypedClient
+    {
+        [OperationContract]
+        [FaultContract(typeof(SomeFault))]
+        [FaultContract(typeof(OuterFault))]
+        [FaultContract(typeof(ComplexFault))]
+        string Untyped_Method(string s);
+
+        [OperationContract]
+        [FaultContract(typeof(SomeFault))]
+        [FaultContract(typeof(OuterFault))]
+        [FaultContract(typeof(ComplexFault))]
+        string Untyped_MethodReturns(string s);
+    }
+    #endregion
+}
diff --git a/src/CoreWCF.Http/tests/ClientContract/ITestFaultContractName.cs b/src/CoreWCF.Http/tests/ClientContract/ITestFaultContractName.cs
new file mode 100644
index 0000000..51f817b
--- /dev/null
+++ b/src/CoreWCF.Http/tests/ClientContract/ITestFaultContractName.cs
@@ -0,0 +1,95 @@
+﻿using System.IO;
+using System.ServiceModel;
+
+namespace ClientContract
+{
+    #region Contract w/ FaultContract on Operations (ITestFaultContractName)
+    [ServiceContract]
+    public interface ITestFaultContractName
+    {
+        [OperationContract]
+        [FaultContract(typeof(string), Name = "Method1")]
+        string Method1(string s);
+
+        [OperationContract]
+        [FaultContract(typeof(string), Name = "Method2")]
+        string Method2(string s);
+
+        [OperationContract]
+        [FaultContract(typeof(string), Name = "ITestFaultContractAction.Method3")]
+        string Method3(string s);
+
+        [OperationContract]
+        [FaultContract(typeof(string), Name = "<hello>\"\'")]
+        string Method4(string s);
+
+        [OperationContract]
+        [FaultContract(typeof(string), Name = "t t n")]
+        string Method5(string s);
+
+        [OperationContract]
+        [FaultContract(typeof(string), Name = "&lt;&gt;&gt;")]
+        string Method6(string s);
+
+        [OperationContract]
+        [FaultContract(typeof(string), Name = "http://y.c/5")]
+        string Method7(string s);
+
+        [OperationContract]
+        [FaultContract(typeof(string), Name = "İüğmeIiiçeI")]
+        string Method8(string s);
+
+        [OperationContract]
+        [FaultContract(typeof(string), Name = "esÅeoplÀÁð")]
+        string Method9(string s);
+
+        [OperationContract]
+        [FaultContract(typeof(string), Name = "http://hello/\0")]
+        string Method10(string s);
+
+        [OperationContract]
+        [FaultContract(typeof(string), Name = "http://www.yahoo.com")]
+        string Method11(string s);
+
+        [OperationContract]
+        [FaultContract(typeof(string), Name = "null")]
+        string Method12(string s);
+
+        [OperationContract]
+        [FaultContract(typeof(string), Name = "<hello>\"\'\0")]
+        string Method13(string s);
+
+        [OperationContract]
+        [FaultContract(typeof(string), Name = "esÅeoplÀÁð")]
+        string Method14(string s);
+
+        [OperationContract]
+        [FaultContract(typeof(string), Name = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA")]
+        string Method15(string s);
+
+        [OperationContract]
+        [FaultContract(typeof(string), Name = "123456789012345")]
+        string Method16(string s);
+
+        [OperationContract]
+        [FaultContract(typeof(string), Name = "u")]
+        string Method17(string s);
+
+        [OperationContract]
+        [FaultContract(typeof(string), Name = "ÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅ")]
+        string Method18(string s);
+
+        [OperationContract]
+        [FaultContract(typeof(string), Name = "a_b - c - d_g()")]
+        string Method19(string s);
+
+        [OperationContract]
+        [FaultContract(typeof(string), Name = "\\//\\/////////// /")]
+        string Method20(string s);
+
+        [OperationContract]
+        [FaultContract(typeof(string), Name = "*")]
+        string Method21(string s);
+    }
+    #endregion
+}
diff --git a/src/CoreWCF.Http/tests/ClientContract/SCInterfaceAB_1144850.cs b/src/CoreWCF.Http/tests/ClientContract/SCInterfaceAB_1144850.cs
new file mode 100644
index 0000000..d0605bd
--- /dev/null
+++ b/src/CoreWCF.Http/tests/ClientContract/SCInterfaceAB_1144850.cs
@@ -0,0 +1,11 @@
+﻿using System.ServiceModel;
+
+namespace ClientContract
+{
+	[ServiceContract, XmlSerializerFormat]
+	public interface SCInterfaceAB_1144850 : SCInterfaceA_1144850, SCInterfaceB_1144850
+	{
+		[OperationContract]
+		string StringMethodAB(string str);
+	}
+}
diff --git a/src/CoreWCF.Http/tests/ClientContract/SCInterfaceA_1144850.cs b/src/CoreWCF.Http/tests/ClientContract/SCInterfaceA_1144850.cs
new file mode 100644
index 0000000..1a41890
--- /dev/null
+++ b/src/CoreWCF.Http/tests/ClientContract/SCInterfaceA_1144850.cs
@@ -0,0 +1,11 @@
+﻿using System.ServiceModel;
+
+namespace ClientContract
+{
+	[ServiceContract, XmlSerializerFormat]
+	public interface SCInterfaceA_1144850
+	{
+		[OperationContract]
+		string StringMethodA(string str);
+	}
+}
diff --git a/src/CoreWCF.Http/tests/ClientContract/SCInterfaceB_1144850.cs b/src/CoreWCF.Http/tests/ClientContract/SCInterfaceB_1144850.cs
new file mode 100644
index 0000000..46556d2
--- /dev/null
+++ b/src/CoreWCF.Http/tests/ClientContract/SCInterfaceB_1144850.cs
@@ -0,0 +1,11 @@
+﻿using System.ServiceModel;
+
+namespace ClientContract
+{
+	[ServiceContract, XmlSerializerFormat]
+	public interface SCInterfaceB_1144850
+	{
+		[OperationContract]
+		string StringMethodB(string str);
+	}
+}
diff --git a/src/CoreWCF.Http/tests/ClientContract/SanityAParentB_857419.cs b/src/CoreWCF.Http/tests/ClientContract/SanityAParentB_857419.cs
new file mode 100644
index 0000000..dbab43f
--- /dev/null
+++ b/src/CoreWCF.Http/tests/ClientContract/SanityAParentB_857419.cs
@@ -0,0 +1,39 @@
+using System.Runtime.Serialization;
+using System.ServiceModel;
+
+namespace ClientContract
+{    
+    [ServiceContract]
+    public interface ISanityAParentB_857419_ContractDerived : ISanityAParentB_857419_ContractBase
+    {
+        [OperationContract(IsOneWay = true)]
+        void OneWayMethod(object o);
+
+        [OperationContract(IsOneWay = false)]
+        string StringMethod(string s);
+
+        [OperationContract(Name = "DerivedMethod")]
+        new string Method(string input);
+    }
+
+    [ServiceContract]
+    public interface ISanityAParentB_857419_ContractBase 
+    {
+        [OperationContract(IsOneWay = false)]
+        string TwoWayMethod(string input);
+
+        [OperationContract(IsOneWay = false)]
+        [ServiceKnownType(typeof(MyBaseDataType))]
+        object DataContractMethod(object o);
+
+        [OperationContract(Name = "BaseMethod")]
+        string Method(string input);
+    }
+
+    [DataContract]
+    public class MyBaseDataType
+    {
+        [DataMember]
+        public string data = null;
+    }
+}
\ No newline at end of file
diff --git a/src/CoreWCF.Http/tests/ClientContract/ServiceContractName_784749_Interfaces.cs b/src/CoreWCF.Http/tests/ClientContract/ServiceContractName_784749_Interfaces.cs
new file mode 100644
index 0000000..a7a469c
--- /dev/null
+++ b/src/CoreWCF.Http/tests/ClientContract/ServiceContractName_784749_Interfaces.cs
@@ -0,0 +1,60 @@
+﻿using System.ServiceModel;
+
+namespace ClientContract
+{
+    [ServiceContract(Name = "<hello>\"'")]
+    public interface IServiceContractName_784749_XmlCharacters_Service
+    {
+        [OperationContract]
+        string Method1(string input);
+    }
+
+    [ServiceContract(Name = "   \t \t \n ")]
+    public interface IServiceContractName_784749_WhiteSpace_Service
+    {
+        [OperationContract(Action = "WhiteSpaceInName")]
+        string Method2(string input);
+    }
+
+    [ServiceContract(Name = "&lt;&gt;&gt;")]
+    public interface IServiceContractName_784749_XMLEncoded_Service
+    {
+        [OperationContract]
+        string Method3(string input);
+    }
+
+    [ServiceContract(Name = "http://y.c/5")]
+    public interface IServiceContractName_784749_NonAlphaCharacters_Service
+    {
+        [OperationContract]
+        string Method4(string input);
+    }
+
+    [ServiceContract(Name = "İüğmeIiiçeI")]
+    public interface IServiceContractName_784749_LocalizedCharacters_Service
+    {
+        [OperationContract(Action = "localizedCharsInName")]
+        string Method5(string input);
+    }
+
+    [ServiceContract(Name = "esÅeoplÀÁð")]
+    public interface IServiceContractName_784749_SurrogateCharacters_Service
+    {
+        [OperationContract]
+        string Method6(string input);
+    }
+
+    [ServiceContract(Name = "http://hello/\0")]
+    public interface IServiceContractName_784749_XMLReservedCharacters_Service
+    {
+        [OperationContract(Action = "xmlReservedCharInName")]
+        string Method7(string input);
+    }
+
+    [ServiceContract(Name = "http://www.yahoo.com")]
+    public interface IServiceContractName_784749_URI_Service
+    {
+        [OperationContract]
+        string Method8(string input);
+    }
+}
diff --git a/src/CoreWCF.Http/tests/ClientContract/ServiceContract_Namespace_Interfaces.cs b/src/CoreWCF.Http/tests/ClientContract/ServiceContract_Namespace_Interfaces.cs
new file mode 100644
index 0000000..00f473b
--- /dev/null
+++ b/src/CoreWCF.Http/tests/ClientContract/ServiceContract_Namespace_Interfaces.cs
@@ -0,0 +1,60 @@
+﻿using System.ServiceModel;
+
+namespace ClientContract
+{
+    [ServiceContract(Namespace = "<hello>\"\'")]
+    public interface IServiceContractNamespace_784756_XmlCharacters_Service
+    {
+        [OperationContract]
+        string Method1(string input);
+    }
+
+    [ServiceContract(Namespace = "   \t \t \n ")]
+    public interface IServiceContractNamespace_784756_WhiteSpace_Service
+    {
+        [OperationContract(Action = "WhiteSpaceInNamespace")]
+        string Method2(string input);
+    }
+
+    [ServiceContract(Namespace = "&lt;&gt;&gt;")]
+    public interface IServiceContractNamespace_784756_XMLEncoded_Service
+    {
+        [OperationContract]
+        string Method3(string input);
+    }
+
+    [ServiceContract(Namespace = "http://y.c/5")]
+    public interface IServiceContractNamespace_784756_NonAlphaCharacters_Service
+    {
+        [OperationContract]
+        string Method4(string input);
+    }
+
+    [ServiceContract(Namespace = "İüğmeIiiçeI")]
+    public interface IServiceContractNamespace_784756_LocalizedCharacters_Service
+    {
+        [OperationContract(Action = "LocalizedCharInNamespace")]
+        string Method5(string input);
+    }
+
+    [ServiceContract(Namespace = "esÅeoplÀÁð")]
+    public interface IServiceContractNamespace_784756_SurrogateCharacters_Service
+    {
+        [OperationContract]
+        string Method6(string input);
+    }
+
+    [ServiceContract(Namespace = "http://hello/\0")]
+    public interface IServiceContractNamespace_784756_XMLReservedCharacters_Service
+    {
+        [OperationContract(Action = "XmlReservedCharInNamespace")]
+        string Method7(string input);
+    }
+
+    [ServiceContract(Namespace = "http://www.yahoo.com")]
+    public interface IServiceContractNamespace_784756_URI_Service
+    {
+        [OperationContract]
+        string Method8(string input);
+    }
+}
diff --git a/src/CoreWCF.Http/tests/CoreWCF.Http.Tests.csproj b/src/CoreWCF.Http/tests/CoreWCF.Http.Tests.csproj
index d69dc56..82a9c33 100644
--- a/src/CoreWCF.Http/tests/CoreWCF.Http.Tests.csproj
+++ b/src/CoreWCF.Http/tests/CoreWCF.Http.Tests.csproj
@@ -5,7 +5,8 @@
     <GenerateRuntimeConfigurationFiles>true</GenerateRuntimeConfigurationFiles>
     <GenerateAssemblyConfigurationAttribute>false</GenerateAssemblyConfigurationAttribute>
     <GenerateAssemblyCompanyAttribute>false</GenerateAssemblyCompanyAttribute>
-    <GenerateAssemblyProductAttribute>false</GenerateAssemblyProductAttribute>  </PropertyGroup>
+    <GenerateAssemblyProductAttribute>false</GenerateAssemblyProductAttribute>
+  </PropertyGroup>
   <ItemGroup>
     <PackageReference Include="coverlet.msbuild" Version="2.7.0">
       <PrivateAssets>all</PrivateAssets>
@@ -25,4 +26,4 @@
     <ProjectReference Include="..\..\CoreWCF.Primitives\src\CoreWCF.Primitives.csproj" />
     <ProjectReference Include="..\src\CoreWCF.Http.csproj" />
   </ItemGroup>
-</Project>
\ No newline at end of file
+</Project>
diff --git a/src/CoreWCF.Http/tests/FaultContractNameTests.cs b/src/CoreWCF.Http/tests/FaultContractNameTests.cs
new file mode 100644
index 0000000..40a8261
--- /dev/null
+++ b/src/CoreWCF.Http/tests/FaultContractNameTests.cs
@@ -0,0 +1,372 @@
+﻿using System;
+using CoreWCF.Configuration;
+using Helpers;
+using Microsoft.AspNetCore.Builder;
+using Microsoft.AspNetCore.Hosting;
+using Microsoft.Extensions.DependencyInjection;
+using Xunit;
+using Xunit.Abstractions;
+
+namespace CoreWCF.Http.Tests
+{
+    public class FaultContractNameTests
+    {
+        private ITestOutputHelper _output;
+
+        public FaultContractNameTests(ITestOutputHelper output)
+        {
+            _output = output;
+        }
+
+        [Fact]
+        public void FaultOnDiffString()
+        {
+            var host = ServiceHelper.CreateWebHostBuilder<Startup>(_output).Build();
+            using (host)
+            {
+                host.Start();
+                var httpBinding = ClientHelper.GetBufferedModeBinding();
+                var factory = new System.ServiceModel.ChannelFactory<ClientContract.ITestFaultContractName>(httpBinding, new System.ServiceModel.EndpointAddress(new Uri("http://localhost:8080/BasicWcfService/TestFaultContractNameService.svc")));
+                var channel = factory.CreateChannel();
+
+                //test variations count
+                int count = 21;
+                string faultToThrow = "Test fault thrown from a service";
+
+                //variation method1
+                try
+                {
+                    string s = channel.Method1("");
+                }
+                catch (Exception e)
+                {
+                    count--;
+                    Assert.NotNull(e);
+
+                    Assert.IsType<System.ServiceModel.FaultException<string>>(e);
+                    var ex = (System.ServiceModel.FaultException<string>)e;
+                    Assert.Equal(faultToThrow, ex.Detail.ToString());
+                }
+
+                //variation method2
+                try
+                {
+                    string s = channel.Method2("");
+                }
+                catch (Exception e)
+                {
+                    count--;
+                    Assert.NotNull(e);
+
+                    Assert.IsType<System.ServiceModel.FaultException<string>>(e);
+                    var ex = (System.ServiceModel.FaultException<string>)e;
+                    Assert.Equal(faultToThrow, ex.Detail.ToString());
+                }
+
+                //variation method3
+                try
+                {
+                    string s = channel.Method3("");
+                }
+                catch (Exception e)
+                {
+                    count--;
+                    Assert.NotNull(e);
+
+                    Assert.IsType<System.ServiceModel.FaultException<string>>(e);
+                    var ex = (System.ServiceModel.FaultException<string>)e;
+                    Assert.Equal(faultToThrow, ex.Detail.ToString());
+                }
+
+                //variation method4
+                try
+                {
+                    string s = channel.Method4("");
+                }
+                catch (Exception e)
+                {
+                    count--;
+                    Assert.NotNull(e);
+
+                    Assert.IsType<System.ServiceModel.FaultException<string>>(e);
+                    var ex = (System.ServiceModel.FaultException<string>)e;
+                    Assert.Equal(faultToThrow, ex.Detail.ToString());
+                }
+
+                //variation method5
+                try
+                {
+                    string s = channel.Method5("");
+                }
+                catch (Exception e)
+                {
+                    count--;
+                    Assert.NotNull(e);
+
+                    Assert.IsType<System.ServiceModel.FaultException<string>>(e);
+                    var ex = (System.ServiceModel.FaultException<string>)e;
+                    Assert.Equal(faultToThrow, ex.Detail.ToString());
+                }
+
+                //variation method6
+                try
+                {
+                    string s = channel.Method6("");
+                }
+                catch (Exception e)
+                {
+                    count--;
+                    Assert.NotNull(e);
+
+                    Assert.IsType<System.ServiceModel.FaultException<string>>(e);
+                    var ex = (System.ServiceModel.FaultException<string>)e;
+                    Assert.Equal(faultToThrow, ex.Detail.ToString());
+                }
+
+                //variation method7
+                try
+                {
+                    string s = channel.Method7("");
+                }
+                catch (Exception e)
+                {
+                    count--;
+                    Assert.NotNull(e);
+
+                    Assert.IsType<System.ServiceModel.FaultException<string>>(e);
+                    var ex = (System.ServiceModel.FaultException<string>)e;
+                    Assert.Equal(faultToThrow, ex.Detail.ToString());
+                }
+
+                //variation method8
+                try
+                {
+                    string s = channel.Method8("");
+                }
+                catch (Exception e)
+                {
+                    count--;
+                    Assert.NotNull(e);
+
+                    Assert.IsType<System.ServiceModel.FaultException<string>>(e);
+                    var ex = (System.ServiceModel.FaultException<string>)e;
+                    Assert.Equal(faultToThrow, ex.Detail.ToString());
+                }
+
+                //variation method9
+                try
+                {
+                    string s = channel.Method9("");
+                }
+                catch (Exception e)
+                {
+                    count--;
+                    Assert.NotNull(e);
+
+                    Assert.IsType<System.ServiceModel.FaultException<string>>(e);
+                    var ex = (System.ServiceModel.FaultException<string>)e;
+                    Assert.Equal(faultToThrow, ex.Detail.ToString());
+                }
+
+                //variation method10
+                try
+                {
+                    string s = channel.Method10("");
+                }
+                catch (Exception e)
+                {
+                    count--;
+                    Assert.NotNull(e);
+
+                    Assert.IsType<System.ServiceModel.FaultException<string>>(e);
+                    var ex = (System.ServiceModel.FaultException<string>)e;
+                    Assert.Equal(faultToThrow, ex.Detail.ToString());
+                }
+
+                //variation method11
+                try
+                {
+                    string s = channel.Method11("");
+                }
+                catch (Exception e)
+                {
+                    count--;
+                    Assert.NotNull(e);
+
+                    Assert.IsType<System.ServiceModel.FaultException<string>>(e);
+                    var ex = (System.ServiceModel.FaultException<string>)e;
+                    Assert.Equal(faultToThrow, ex.Detail.ToString());
+                }
+
+                //variation method12
+                try
+                {
+                    string s = channel.Method12("");
+                }
+                catch (Exception e)
+                {
+                    count--;
+                    Assert.NotNull(e);
+
+                    Assert.IsType<System.ServiceModel.FaultException<string>>(e);
+                    var ex = (System.ServiceModel.FaultException<string>)e;
+                    Assert.Equal(faultToThrow, ex.Detail.ToString());
+                }
+
+                //variation method13
+                try
+                {
+                    string s = channel.Method13("");
+                }
+                catch (Exception e)
+                {
+                    count--;
+                    Assert.NotNull(e);
+
+                    Assert.IsType<System.ServiceModel.FaultException<string>>(e);
+                    var ex = (System.ServiceModel.FaultException<string>)e;
+                    Assert.Equal(faultToThrow, ex.Detail.ToString());
+                }
+
+                //variation method14
+                try
+                {
+                    string s = channel.Method14("");
+                }
+                catch (Exception e)
+                {
+                    count--;
+                    Assert.NotNull(e);
+
+                    Assert.IsType<System.ServiceModel.FaultException<string>>(e);
+                    var ex = (System.ServiceModel.FaultException<string>)e;
+                    Assert.Equal(faultToThrow, ex.Detail.ToString());
+                }
+
+                //variation method15
+                try
+                {
+                    string s = channel.Method15("");
+                }
+                catch (Exception e)
+                {
+                    count--;
+                    Assert.NotNull(e);
+
+                    Assert.IsType<System.ServiceModel.FaultException<string>>(e);
+                    var ex = (System.ServiceModel.FaultException<string>)e;
+                    Assert.Equal(faultToThrow, ex.Detail.ToString());
+                }
+
+                //variation method16
+                try
+                {
+                    string s = channel.Method16("");
+                }
+                catch (Exception e)
+                {
+                    count--;
+                    Assert.NotNull(e);
+
+                    Assert.IsType<System.ServiceModel.FaultException<string>>(e);
+                    var ex = (System.ServiceModel.FaultException<string>)e;
+                    Assert.Equal(faultToThrow, ex.Detail.ToString());
+                }
+
+                //variation method17
+                try
+                {
+                    string s = channel.Method17("");
+                }
+                catch (Exception e)
+                {
+                    count--;
+                    Assert.NotNull(e);
+
+                    Assert.IsType<System.ServiceModel.FaultException<string>>(e);
+                    var ex = (System.ServiceModel.FaultException<string>)e;
+                    Assert.Equal(faultToThrow, ex.Detail.ToString());
+                }
+
+                //variation method18
+                try
+                {
+                    string s = channel.Method18("");
+                }
+                catch (Exception e)
+                {
+                    count--;
+                    Assert.NotNull(e);
+
+                    Assert.IsType<System.ServiceModel.FaultException<string>>(e);
+                    var ex = (System.ServiceModel.FaultException<string>)e;
+                    Assert.Equal(faultToThrow, ex.Detail.ToString());
+                }
+
+                //variation method19
+                try
+                {
+                    string s = channel.Method19("");
+                }
+                catch (Exception e)
+                {
+                    count--;
+                    Assert.NotNull(e);
+
+                    Assert.IsType<System.ServiceModel.FaultException<string>>(e);
+                    var ex = (System.ServiceModel.FaultException<string>)e;
+                    Assert.Equal(faultToThrow, ex.Detail.ToString());
+                }
+
+                //variation method20
+                try
+                {
+                    string s = channel.Method20("");
+                }
+                catch (Exception e)
+                {
+                    count--;
+                    Assert.NotNull(e);
+
+                    Assert.IsType<System.ServiceModel.FaultException<string>>(e);
+                    var ex = (System.ServiceModel.FaultException<string>)e;
+                    Assert.Equal(faultToThrow, ex.Detail.ToString());
+                }
+
+                //variation method21
+                try
+                {
+                    string s = channel.Method21("");
+                }
+                catch (Exception e)
+                {
+                    count--;
+                    Assert.NotNull(e);
+
+                    Assert.IsType<System.ServiceModel.FaultException<string>>(e);
+                    var ex = (System.ServiceModel.FaultException<string>)e;
+                    Assert.Equal(faultToThrow, ex.Detail.ToString());
+                }
+                Assert.Equal(0, count);
+            }
+        }
+
+        internal class Startup
+        {
+            public void ConfigureServices(IServiceCollection services)
+            {
+                services.AddServiceModelServices();
+            }
+
+            public void Configure(IApplicationBuilder app, IHostingEnvironment env)
+            {
+                app.UseServiceModel(builder =>
+                {
+                    builder.AddService<Services.TestFaultContractNameService>();
+                    builder.AddServiceEndpoint<Services.TestFaultContractNameService, ServiceContract.ITestFaultContractName>(new CoreWCF.BasicHttpBinding(), "/BasicWcfService/TestFaultContractNameService.svc");
+                });
+            }
+        }
+
+    }
+}
diff --git a/src/CoreWCF.Http/tests/FaultContractTests.cs b/src/CoreWCF.Http/tests/FaultContractTests.cs
index 16f0e1c..d77305a 100644
--- a/src/CoreWCF.Http/tests/FaultContractTests.cs
+++ b/src/CoreWCF.Http/tests/FaultContractTests.cs
@@ -1,9 +1,9 @@
-﻿using CoreWCF.Channels;
-using CoreWCF.Configuration;
+﻿using CoreWCF.Configuration;
 using Helpers;
 using Microsoft.AspNetCore.Builder;
 using Microsoft.AspNetCore.Hosting;
 using Microsoft.Extensions.DependencyInjection;
+using Services;
 using System;
 using System.IO;
 using System.Text;
@@ -113,7 +113,7 @@ namespace CoreWCF.Http.Tests
                 fmc.Name = "";
                 try
                 {
-                    ClientContract.FaultMsgContract fmcResult = channel.MessageContract_Method(fmc); ;
+                    ClientContract.FaultMsgContract fmcResult = channel.MessageContract_Method(fmc);
                 }
                 catch (Exception e)
                 {
@@ -174,147 +174,263 @@ namespace CoreWCF.Http.Tests
                 }
 
                 Assert.Equal(0, count);
-            }            
+            }
         }
 
-        internal class Startup
+        [Theory]
+        [InlineData("somefault")]
+        [InlineData("outerfault")]
+        [InlineData("complexfault")]
+        public void DatacontractFaults(string f)
         {
-            public void ConfigureServices(IServiceCollection services)
+            var host = ServiceHelper.CreateWebHostBuilder<Startup>(_output).Build();
+            using (host)
             {
-                services.AddServiceModelServices();
-            }
+                host.Start();
+                var httpBinding = ClientHelper.GetBufferedModeBinding();
+                var factory = new System.ServiceModel.ChannelFactory<ClientContract.ITestDataContractFault>(httpBinding,
+                    new System.ServiceModel.EndpointAddress(new Uri("http://localhost:8080/BasicWcfService/DatacontractFaults.svc")));
+                var channel = factory.CreateChannel();
 
-            public void Configure(IApplicationBuilder app, IHostingEnvironment env)
-            {
-                app.UseServiceModel(builder =>
+                var factory2 = new System.ServiceModel.ChannelFactory<ClientContract.ITestDataContractFaultTypedClient>(httpBinding,
+                    new System.ServiceModel.EndpointAddress(new Uri("http://localhost:8080/BasicWcfService/DatacontractFaults.svc")));
+                var channel2 = factory2.CreateChannel();
+
+                //test variations
+                int count = 9;
+                try
                 {
-                    builder.AddService<FaultOnDiffContractsAndOpsService>();
-                    builder.AddServiceEndpoint<FaultOnDiffContractsAndOpsService, ServiceContract.ITestFaultOpContract>(new BasicHttpBinding(), "/BasicWcfService/FaultOnDiffContractsAndOpsService.svc");
-                });
-            }
-        }
-    }
+                    channel.TwoWayVoid_Method(f);
+                }
+                catch (Exception e)
+                {
+                    count--;
+                    FaultExceptionValidation(f, e);
+                }
 
-    [ServiceBehavior]
-    public class FaultOnDiffContractsAndOpsService : ServiceContract.ITestFaultOpContract
-    {
-        #region TwoWay_Methods
-        public string TwoWay_Method(string s)
-        {
-            if (s.Length == 0)
-            {
-                string faultToThrow = "Test fault thrown from a service";
-                throw new FaultException<string>(faultToThrow);
-            }
+                try
+                {
+                    string s = channel.TwoWay_Method(f);
+                }
+                catch (Exception e)
+                {
+                    count--;
+                    FaultExceptionValidation(f, e);
+                }
 
-            return s;
-        }
+                try
+                {
+                    Stream inputStream = new MemoryStream();
+                    byte[] bytes = Encoding.UTF8.GetBytes(f.ToCharArray());
+                    foreach (byte b in bytes)
+                        inputStream.WriteByte(b);
+                    inputStream.Position = 0;
+                    Stream outputStream = channel.TwoWayStream_Method(inputStream);
+                    StreamReader sr = new StreamReader(outputStream, Encoding.UTF8);
+                    string outputText = sr.ReadToEnd();
+                    Assert.False(true, $"Error, Received Input: {outputText}");
+                }
+                catch (Exception e)
+                {
+                    count--;
+                    FaultExceptionValidation(f, e);
+                }
 
-        public void TwoWayVoid_Method(string s)
-        {
-            if (s.Length == 0)
-            {
-                string faultToThrow = "Test fault thrown from a service";
-                throw new FaultException<string>(faultToThrow);
-            }
+                try
+                {
+                    string response = channel.TwoWayAsync_Method(f).GetAwaiter().GetResult();
+                    Assert.False(true, $"Error, Client received: {response}");
+                }
+                catch (Exception e)
+                {
+                    count--;
+                    FaultExceptionValidation(f, e);
+                }
 
-            return;
-        }
-        #endregion
+                try
+                {
+                    var fmc = new ClientContract.FaultMsgContract();
+                    fmc.ID = 123;
+                    fmc.Name = f;
+                    ClientContract.FaultMsgContract fmcResult = channel.MessageContract_Method(fmc);
+                    Assert.False(true, $"Error, Client received: {fmcResult.Name}");
+                }
+                catch (Exception e)
+                {
+                    count--;
+                    FaultExceptionValidation(f, e);
+                }
 
-        #region TwoWayStream Method
-        public Stream TwoWayStream_Method(Stream s)
-        {
-            if (s.ReadByte() != -1)
-            {
-                string faultToThrow = "Test fault thrown from a service";
-                throw new FaultException<string>(faultToThrow);
-            }
-            else
-            {
-                StreamReader sr = new StreamReader(s, Encoding.UTF8);
-                sr.ReadToEnd();
-            }
+                System.ServiceModel.Channels.Message msgOut = System.ServiceModel.Channels.Message.CreateMessage(System.ServiceModel.Channels.MessageVersion.Soap11, "http://tempuri.org/ITestDataContractFault/Untyped_Method", f);
+                System.ServiceModel.Channels.Message msgIn = channel.Untyped_Method(msgOut);
+                if (msgIn.IsFault)
+                {
+                    System.ServiceModel.Channels.MessageFault mf = System.ServiceModel.Channels.MessageFault.CreateFault(msgIn, int.MaxValue);
+                    switch (f.ToLower())
+                    {
+                        case "somefault":
+                            count--;
+                            ClientContract.SomeFault sf = mf.GetDetail<ClientContract.SomeFault>();
+                            Assert.Equal(123456789, sf.ID);
+                            Assert.Equal("SomeFault", sf.message);
+                            break;
+                        case "outerfault":
+                            count--;
+                            ClientContract.OuterFault of = mf.GetDetail<ClientContract.OuterFault>();
+                            sf = of.InnerFault;
+                            Assert.Equal(123456789, sf.ID);
+                            Assert.Equal("SomeFault as innerfault", sf.message);
+                            break;
+                        case "complexfault":
+                            count--;
+                            ClientContract.ComplexFault cf = mf.GetDetail<ClientContract.ComplexFault>();
+                            string exp = "50:This is a test error string for fault tests.:123456789:SomeFault in complexfault:0123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127:2147483647-214748364801-150-50:123456789:SomeFault in complexfaultnull234:Second somefault in complexfault";
+                            Assert.Equal(exp, ComplexFaultToString(cf));
+                            break;
+                        default:
+                            break;
+                    }
+                }
 
-            return new MemoryStream();
-        }
-        #endregion
+                msgOut = System.ServiceModel.Channels.Message.CreateMessage(System.ServiceModel.Channels.MessageVersion.Soap11, "http://tempuri.org/ITestDataContractFault/Untyped_MethodReturns", f);
+                msgIn = channel.Untyped_MethodReturns(msgOut);
+                if (msgIn.IsFault)
+                {
+                    System.ServiceModel.Channels.MessageFault mf = System.ServiceModel.Channels.MessageFault.CreateFault(msgIn, int.MaxValue);
+                    switch (f)
+                    {
+                        case "somefault":
+                            count--;
+                            ClientContract.SomeFault sf = mf.GetDetail<ClientContract.SomeFault>();
+                            Assert.Equal(123456789, sf.ID);
+                            Assert.Equal("SomeFault", sf.message);
+                            break;
+                        case "outerfault":
+                            count--;
+                            ClientContract.OuterFault of = mf.GetDetail<ClientContract.OuterFault>();
+                            sf = of.InnerFault;
+                            Assert.Equal(123456789, sf.ID);
+                            Assert.Equal("SomeFault as innerfault", sf.message);
+                            break;
+                        case "complexfault":
+                            count--;
+                            ClientContract.ComplexFault cf = mf.GetDetail<ClientContract.ComplexFault>();
+                            string exp = "50:This is a test error string for fault tests.:123456789:SomeFault in complexfault:0123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127:2147483647-214748364801-150-50:123456789:SomeFault in complexfaultnull234:Second somefault in complexfault";
+                            Assert.Equal(exp, ComplexFaultToString(cf));
+                            break;
+                        default:
+                            break;
+                    }
+                }
 
-        #region TwoWayAsync Method
-        delegate string TwoWayMethodAsync(string s);
+                try
+                {
+                    string response = channel2.Untyped_Method(f);
+                }
+                catch (Exception e)
+                {
+                    count--;
+                    FaultExceptionValidation(f, e);
+                }
 
-        public async System.Threading.Tasks.Task<string> TwoWayAsync_MethodAsync(string s)
-        {
-            TwoWayMethodAsync del = ProcessTwoWayAsync;
-            var workTask = System.Threading.Tasks.Task.Run(() => del.Invoke(s));
-            return await workTask;
-        }
+                try
+                {
+                    string response = channel2.Untyped_MethodReturns(f);
+                }
+                catch (Exception e)
+                {
+                    count--;
+                    FaultExceptionValidation(f, e);
+                }
 
-        // Worker
-        public string ProcessTwoWayAsync(string s)
-        {
-            // This is where the incoming message processing is handled.
-            if (s.Length == 0)
-            {
-                string faultToThrow = "Test fault thrown from a service";
-                throw new FaultException<string>(faultToThrow);
+                Assert.Equal(0, count);
             }
-
-            return "Async call was valid";
         }
-        #endregion
 
-        #region MessageContract Methods
-        public ServiceContract.FaultMsgContract MessageContract_Method(ServiceContract.FaultMsgContract fmc)
+        private void FaultExceptionValidation(string faultType, Exception e)
         {
-            if (fmc.Name.Length == 0)
+            switch (faultType)
             {
-                string faultToThrow = "Test fault thrown from a service";
-                throw new FaultException<string>(faultToThrow);
+                case "somefault":
+                    Assert.NotNull(e);
+                    Assert.IsType<System.ServiceModel.FaultException<ClientContract.SomeFault>>(e);
+                    var ex = (System.ServiceModel.FaultException<ClientContract.SomeFault>)e;
+                    ClientContract.SomeFault sf = ex.Detail;
+                    Assert.Equal(123456789, sf.ID);
+                    Assert.Equal("SomeFault", sf.message);
+                    break;
+                case "outerfault":
+                    Assert.NotNull(e);
+                    Assert.IsType<System.ServiceModel.FaultException<ClientContract.OuterFault>>(e);
+                    var oex = (System.ServiceModel.FaultException<ClientContract.OuterFault>)e;
+                    ClientContract.OuterFault of = oex.Detail;
+                    sf = of.InnerFault;
+                    Assert.Equal(123456789, sf.ID);
+                    Assert.Equal("SomeFault as innerfault", sf.message);
+                    break;
+                case "complexfault":
+                    string exp = "50:This is a test error string for fault tests.:123456789:SomeFault in complexfault:0123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127:2147483647-214748364801-150-50:123456789:SomeFault in complexfaultnull234:Second somefault in complexfault";
+                    Assert.NotNull(e);
+                    Assert.IsType<System.ServiceModel.FaultException<ClientContract.ComplexFault>>(e);
+                    var cex = (System.ServiceModel.FaultException<ClientContract.ComplexFault>)e;
+                    Assert.Equal(exp, ComplexFaultToString(cex.Detail));
+                    break;
+                default:
+                    break;
             }
-
-            return fmc;
         }
 
-        public string MessageContractParams_Method(int id, string name, DateTime dateTime)
+        private string ComplexFaultToString(ClientContract.ComplexFault cf)
         {
-            if (name.Length == 0)
+            StringBuilder sb = new StringBuilder();
+            sb.Append(cf.ErrorInt);
+            sb.Append(':');
+            sb.Append(cf.ErrorString);
+            sb.Append(':');
+            sb.Append(cf.SomeFault.ID);
+            sb.Append(':');
+            sb.Append(cf.SomeFault.message);
+            sb.Append(':');
+            for (int i = 0; i < cf.ErrorByteArray.Length; i++)
+                sb.Append(cf.ErrorByteArray[i]);
+            sb.Append(':');
+            for (int i = 0; i < cf.ErrorIntArray.Length; i++)
+                sb.Append(cf.ErrorIntArray[i]);
+            sb.Append(':');
+            for (int i = 0; i < cf.SomeFaultArray.Length; i++)
             {
-                string faultToThrow = "Test fault thrown from a service";
-                throw new FaultException<string>(faultToThrow);
+                if (cf.SomeFaultArray[i] != null)
+                {
+                    sb.Append(cf.SomeFaultArray[i].ID);
+                    sb.Append(':');
+                    sb.Append(cf.SomeFaultArray[i].message);
+                }
+                else
+                {
+                    sb.Append("null");
+                }
             }
 
-            return $"{id} {name} {dateTime}";
+            return sb.ToString();
         }
-        #endregion
 
-        #region Untyped Method
-        public Message Untyped_Method(Message msgIn)
+        internal class Startup
         {
-            MessageVersion mv = OperationContext.Current.IncomingMessageHeaders.MessageVersion;
-            string faultToThrow = "Test fault thrown from a service";
-            if (msgIn != null)
+            public void ConfigureServices(IServiceCollection services)
             {
-                throw new FaultException<string>(faultToThrow);
+                services.AddServiceModelServices();
             }
 
-            return Message.CreateMessage(mv, MessageFault.CreateFault(new FaultCode("Sender"), new FaultReason("Unspecified ServiceModel Fault"), "unspecified",
-                new System.Runtime.Serialization.DataContractSerializer(typeof(string)), "", ""), "");
-        }
-
-        public Message Untyped_MethodReturns(Message msgIn)
-        {
-            MessageVersion mv = OperationContext.Current.IncomingMessageHeaders.MessageVersion;
-            string faultToThrow = "Test fault thrown from a service";
-            if (msgIn != null)
+            public void Configure(IApplicationBuilder app, IHostingEnvironment env)
             {
-                return Message.CreateMessage(mv, MessageFault.CreateFault(new FaultCode("Sender"), new FaultReason("Unspecified ServiceModel Fault"), faultToThrow,
-                new System.Runtime.Serialization.DataContractSerializer(typeof(string)), "", ""), "");
+                app.UseServiceModel(builder =>
+                {
+                    builder.AddService<FaultOnDiffContractsAndOpsService>();
+                    builder.AddServiceEndpoint<FaultOnDiffContractsAndOpsService, ServiceContract.ITestFaultOpContract>(new BasicHttpBinding(), "/BasicWcfService/FaultOnDiffContractsAndOpsService.svc");
+                    builder.AddService<DatacontractFaultService>();
+                    builder.AddServiceEndpoint<DatacontractFaultService, ServiceContract.ITestDataContractFault>(new BasicHttpBinding(), "/BasicWcfService/DatacontractFaults.svc");
+                });
             }
-
-            return Message.CreateMessage(mv, MessageFault.CreateFault(new FaultCode("Sender"), new FaultReason("Unspecified ServiceModel Fault"), "unspeficied",
-                new System.Runtime.Serialization.DataContractSerializer(typeof(string)), "", ""), "");
         }
-        #endregion
     }
 }
diff --git a/src/CoreWCF.Http/tests/Helpers/ClientHelper.cs b/src/CoreWCF.Http/tests/Helpers/ClientHelper.cs
index 2f39ca3..8a9c327 100644
--- a/src/CoreWCF.Http/tests/Helpers/ClientHelper.cs
+++ b/src/CoreWCF.Http/tests/Helpers/ClientHelper.cs
@@ -16,6 +16,13 @@ namespace Helpers
             return binding;
         }
 
+        public static WSHttpBinding GetBufferedModeWSHttpBinding(SecurityMode securityMode)
+        {
+            var binding = new WSHttpBinding(securityMode);
+            ApplyDebugTimeouts(binding);
+            return binding;
+        }
+
         public static BasicHttpsBinding GetBufferedModeHttpsBinding()
         {
             var binding = new BasicHttpsBinding();
@@ -62,6 +69,13 @@ namespace Helpers
                     binding.ReceiveTimeout = s_debugTimeout;
             }
         }
-    }
-}
 
+        public static T GetProxy<T>()
+        {
+            var httpBinding = ClientHelper.GetBufferedModeBinding();
+            ChannelFactory<T> channelFactory = new ChannelFactory<T>(httpBinding, new EndpointAddress(new Uri("http://localhost:8080/BasicWcfService/basichttp.svc")));
+            T proxy = channelFactory.CreateChannel();
+            return proxy;
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/CoreWCF.Http/tests/Helpers/CommonUtility.cs b/src/CoreWCF.Http/tests/Helpers/CommonUtility.cs
new file mode 100644
index 0000000..e41dd3d
--- /dev/null
+++ b/src/CoreWCF.Http/tests/Helpers/CommonUtility.cs
@@ -0,0 +1,40 @@
+﻿using System;
+
+namespace Helpers
+{
+    public class CommonUtility
+    {
+        public static string CreateInterestingString(int length)
+        {
+            char[] chars = new char[length];
+            int index = 0;
+
+            // Arrays of odd length will start with a single char.
+            // The rest of the entries will be surrogate pairs.
+            if (length % 2 == 1)
+            {
+                chars[index] = 'a';
+                index++;
+            }
+
+            // Fill remaining entries with surrogate pairs
+            int seed = DateTime.Now.Millisecond;
+            Random rand = new Random(seed);
+            char highSurrogate;
+            char lowSurrogate;
+
+            while (index < length)
+            {
+                highSurrogate = Convert.ToChar(rand.Next(0xD800, 0xDC00));
+                lowSurrogate = Convert.ToChar(rand.Next(0xDC00, 0xE000));
+
+                chars[index] = highSurrogate;
+                ++index;
+                chars[index] = lowSurrogate;
+                ++index;
+            }
+
+            return new string(chars, 0, chars.Length);
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/CoreWCF.Http/tests/Helpers/FlowControlledStream.cs b/src/CoreWCF.Http/tests/Helpers/FlowControlledStream.cs
new file mode 100644
index 0000000..2cb5687
--- /dev/null
+++ b/src/CoreWCF.Http/tests/Helpers/FlowControlledStream.cs
@@ -0,0 +1,112 @@
+﻿using System;
+using System.IO;
+using System.Threading;
+
+namespace Helpers
+{
+    public class FlowControlledStream : Stream
+    {
+        // Used to control when Read will return 0.
+        public bool StopStreaming { get; set; }
+        //bool readCalledWithStopStreaming = false;
+
+        public TimeSpan ReadThrottle { get; set; }
+
+        // Only set this if you don't want to manually control when 
+        // the stream stops.
+        // Keep it low - less than 1 second.  The server can send bytes very quickly, so
+        // sending a continuous stream will easily blow the MaxReceivedMessageSize buffer.
+        public TimeSpan StreamDuration { get; set; }
+
+        DateTime readStartedTime;
+        long totalBytesRead = 0;
+
+        public override bool CanRead
+        {
+            get { return !StopStreaming; }
+        }
+
+        public override bool CanSeek
+        {
+            get { return false; }
+        }
+
+        public override bool CanWrite
+        {
+            get { return false; }
+        }
+
+        public override void Flush()
+        {
+        }
+
+        public override long Length
+        {
+            get { throw new NotImplementedException(); }
+        }
+
+        public override long Position
+        {
+            get
+            {
+                return totalBytesRead;
+            }
+            set
+            {
+                totalBytesRead = value;
+            }
+        }
+
+        public override int Read(byte[] buffer, int offset, int count)
+        {
+            // Duration-based streaming logic: Control the "StopStreaming" flag based on a Duration
+            if (StreamDuration != TimeSpan.Zero)
+            {
+                if (readStartedTime == DateTime.MinValue)
+                {
+                    readStartedTime = DateTime.Now;
+                }
+                if (DateTime.Now - readStartedTime >= StreamDuration)
+                {
+                    StopStreaming = true;
+                }
+            }
+
+            if (StopStreaming)
+            {
+                buffer[offset] = 0;
+                return 0;
+            }
+
+            // Allow Read to continue as long as StopStreaming is false.
+            // Just fill buffer with as many random bytes as necessary.
+            int seed = DateTime.Now.Millisecond;
+            Random rand = new Random(seed);
+            byte[] randomBuffer = new byte[count];
+            rand.NextBytes(randomBuffer);
+            randomBuffer.CopyTo(buffer, offset);
+            totalBytesRead += count;
+
+            if (ReadThrottle != TimeSpan.Zero)
+            {
+                Thread.CurrentThread.Join(ReadThrottle);
+            }
+            return count;
+        }
+
+        public override long Seek(long offset, SeekOrigin origin)
+        {
+            throw new NotImplementedException();
+        }
+
+        public override void SetLength(long value)
+        {
+            throw new NotImplementedException();
+        }
+
+        public override void Write(byte[] buffer, int offset, int count)
+        {
+            throw new NotImplementedException();
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/CoreWCF.Http/tests/Helpers/ManagerDataContractResolver.cs b/src/CoreWCF.Http/tests/Helpers/ManagerDataContractResolver.cs
new file mode 100644
index 0000000..df93a1c
--- /dev/null
+++ b/src/CoreWCF.Http/tests/Helpers/ManagerDataContractResolver.cs
@@ -0,0 +1,46 @@
+﻿using System;
+using System.Runtime.Serialization;
+using System.Xml;
+
+namespace Helpers
+{
+    public  class ManagerDataContractResolver<T> : DataContractResolver
+    {
+        private string Namespace
+        {
+            get { return typeof(T).Namespace ?? "global"; }
+        }
+
+        private string Name
+        {
+            get { return typeof(T).Name; }
+        }
+
+        public override Type ResolveName(string typeName, string typeNamespace, Type declaredType, DataContractResolver knownTypeResolver)
+        {
+            if (typeName == this.Name && typeNamespace == this.Namespace)
+            {
+                return typeof(T);
+            }
+            else
+            {
+                return knownTypeResolver.ResolveName(typeName, typeNamespace, declaredType, null);
+            }
+        }
+
+        public override bool TryResolveType(Type type, Type declaredType, DataContractResolver knownTypeResolver, out XmlDictionaryString typeName, out XmlDictionaryString typeNamespace)
+        {
+            if (type == typeof(T))
+            {
+                XmlDictionary dic = new XmlDictionary();
+                typeName = dic.Add(this.Name);
+                typeNamespace = dic.Add(this.Namespace);
+                return true;
+            }
+            else
+            {
+                return knownTypeResolver.TryResolveType(type, declaredType, null, out typeName, out typeNamespace);
+            }
+        }
+    }
+}
diff --git a/src/CoreWCF.Http/tests/Helpers/ServiceHelper.cs b/src/CoreWCF.Http/tests/Helpers/ServiceHelper.cs
index 02c32b9..8935652 100644
--- a/src/CoreWCF.Http/tests/Helpers/ServiceHelper.cs
+++ b/src/CoreWCF.Http/tests/Helpers/ServiceHelper.cs
@@ -3,7 +3,9 @@ using Microsoft.AspNetCore.Hosting;
 using Microsoft.Extensions.Logging;
 using System;
 using System.Net;
+#if NET472
 using System.Security.Authentication;
+#endif // NET472
 using Xunit.Abstractions;
 
 namespace Helpers
@@ -21,7 +23,6 @@ namespace Helpers
                 logging.SetMinimumLevel(LogLevel.Debug);
             })
 #endif // DEBUG
-            .UseKestrel()
             .UseUrls("http://localhost:8080")
             .UseStartup<TStartup>();
 
diff --git a/src/CoreWCF.Http/tests/OpContractInvalidActionReplyActionTests.cs b/src/CoreWCF.Http/tests/OpContractInvalidActionReplyActionTests.cs
new file mode 100644
index 0000000..a4b09b5
--- /dev/null
+++ b/src/CoreWCF.Http/tests/OpContractInvalidActionReplyActionTests.cs
@@ -0,0 +1,99 @@
+﻿using CoreWCF.Configuration;
+using Helpers;
+using Microsoft.AspNetCore.Builder;
+using Microsoft.AspNetCore.Hosting;
+using Microsoft.Extensions.DependencyInjection;
+using Services;
+using System;
+using Xunit;
+using Xunit.Abstractions;
+
+namespace CoreWCF.Http.Tests
+{
+    public class OpContractInvalidActionReplyActionTests
+    {
+        private ITestOutputHelper _output;
+        public OpContractInvalidActionReplyActionTests(ITestOutputHelper output)
+        {
+            _output = output;
+        }
+
+        [Fact]
+        public void NullAction()
+        {
+            var host = ServiceHelper.CreateWebHostBuilder<Startup>(_output).Build();
+            using (host)
+            {
+                InvalidOperationException exception = null;
+                try
+                {
+                    host.Start();
+                }
+                catch (InvalidOperationException ex)
+                {
+                    exception = ex;
+                }
+
+                Assert.NotNull(exception);
+                Assert.NotNull(exception.InnerException);
+                Assert.IsType<ArgumentNullException>(exception.InnerException);
+            }
+        }
+
+        [Fact]
+        public void NullReplyAction()
+        {
+            var host = ServiceHelper.CreateWebHostBuilder<Startup2>(_output).Build();
+            using (host)
+            {
+                InvalidOperationException exception = null;
+                try
+                {
+                    host.Start();
+                }
+                catch (InvalidOperationException ex)
+                {
+                    exception = ex;
+                }
+
+                Assert.NotNull(exception);
+                Assert.NotNull(exception.InnerException);
+                Assert.IsType<ArgumentNullException>(exception.InnerException);
+            }
+        }
+
+        internal class Startup
+        {
+            public void ConfigureServices(IServiceCollection services)
+            {
+                services.AddServiceModelServices();
+            }
+
+            public void Configure(IApplicationBuilder app, IHostingEnvironment env)
+            {
+                app.UseServiceModel(builder =>
+                {
+                    builder.AddService<OpContractInvalidActionSerivce>();
+                    builder.AddServiceEndpoint<OpContractInvalidActionSerivce, ServiceContract.IOpContractInvalidAction>(new BasicHttpBinding(), "/BasicWcfService/OpContractInvalidActionSerivce.svc");
+                });
+            }
+        }
+
+        internal class Startup2
+        {
+            public void ConfigureServices(IServiceCollection services)
+            {
+                services.AddServiceModelServices();
+            }
+
+            public void Configure(IApplicationBuilder app, IHostingEnvironment env)
+            {
+                app.UseServiceModel(builder =>
+                {
+                    builder.AddService<OpContractInvalidReplyActionSerivce>();
+                    builder.AddServiceEndpoint<OpContractInvalidReplyActionSerivce, ServiceContract.IOpContractInvalidReplyAction>(new BasicHttpBinding(), "/BasicWcfService/OpContractInvalidReplyActionSerivce.svc");
+                });
+            }
+        }
+    }
+}
diff --git a/src/CoreWCF.Http/tests/ServiceContract/IAggregateExceptionService.cs b/src/CoreWCF.Http/tests/ServiceContract/IAggregateExceptionService.cs
new file mode 100644
index 0000000..908e0d2
--- /dev/null
+++ b/src/CoreWCF.Http/tests/ServiceContract/IAggregateExceptionService.cs
@@ -0,0 +1,32 @@
+﻿using CoreWCF;
+using System.Runtime.Serialization;
+using System.Threading.Tasks;
+
+namespace ServiceContract
+{
+    [DataContract(Namespace = "http://Microsoft.ServiceModel.Samples")]
+    public class SampleServiceFault
+    {
+        [DataMember]
+        public string Message { get; set; }
+
+        [DataMember]
+        public string ID { get; set; }
+    }
+
+    [ServiceContract]
+    public interface IAggregateExceptionService
+    {
+        [OperationContract]
+        [FaultContract(typeof(SampleServiceFault))]
+        Task SimpleOperationThrowingFault();
+
+        [OperationContract]
+        [FaultContract(typeof(SampleServiceFault))]
+        void ServiceOpWithMultipleTasks();
+
+        [OperationContract]
+        [FaultContract(typeof(SampleServiceFault))]
+        Task ServiceOpWithChainedTasks_ThrowFaultExceptionInOneTask();
+    }
+}
diff --git a/src/CoreWCF.Http/tests/ServiceContract/IOpContractInvalidActionReplyAction.cs b/src/CoreWCF.Http/tests/ServiceContract/IOpContractInvalidActionReplyAction.cs
new file mode 100644
index 0000000..e2c4be6
--- /dev/null
+++ b/src/CoreWCF.Http/tests/ServiceContract/IOpContractInvalidActionReplyAction.cs
@@ -0,0 +1,18 @@
+﻿using CoreWCF;
+
+namespace ServiceContract
+{
+    [ServiceContract]
+    interface IOpContractInvalidAction
+    {
+        [OperationContract(Action = null)]
+        void TestMethodNullAction(int id);
+    }
+
+    [ServiceContract]
+    interface IOpContractInvalidReplyAction
+    {
+        [OperationContract(ReplyAction = null)]
+        int TestMethodNullReplyAction(int id);
+    }
+}
diff --git a/src/CoreWCF.Http/tests/ServiceContract/IRequestReplyService.cs b/src/CoreWCF.Http/tests/ServiceContract/IRequestReplyService.cs
new file mode 100644
index 0000000..5f37f45
--- /dev/null
+++ b/src/CoreWCF.Http/tests/ServiceContract/IRequestReplyService.cs
@@ -0,0 +1,35 @@
+﻿using CoreWCF;
+using System;
+using System.Collections.Generic;
+using System.IO;
+
+namespace ServiceContract
+{
+    [ServiceContract]
+    public interface IRequestReplyService
+    {
+        [OperationContract]
+        void UploadData(string data);
+
+        [OperationContract]
+        string DownloadData();
+
+        [OperationContract]
+        void UploadStream(Stream stream);
+
+        [OperationContract]
+        Stream DownloadStream();
+
+        [OperationContract]
+        Stream DownloadCustomizedStream(TimeSpan readThrottle, TimeSpan streamDuration);
+
+        [OperationContract]
+        void ThrowingOperation(Exception exceptionToThrow);
+
+        [OperationContract]
+        string DelayOperation(TimeSpan delay);
+
+        [OperationContract]
+        List<string> GetLog();
+    }
+}
diff --git a/src/CoreWCF.Http/tests/ServiceContract/ITaskCollectionsTest.cs b/src/CoreWCF.Http/tests/ServiceContract/ITaskCollectionsTest.cs
new file mode 100644
index 0000000..9f55c02
--- /dev/null
+++ b/src/CoreWCF.Http/tests/ServiceContract/ITaskCollectionsTest.cs
@@ -0,0 +1,40 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Runtime.Serialization;
+using System.Threading.Tasks;
+using CoreWCF;
+
+namespace ServiceContract
+{
+    [ServiceContract(Namespace = "http://microsoft.samples", Name = "ICollectionsTest")]
+    public interface ITaskCollectionsTest
+    {
+        [OperationContract]
+        Task<LinkedList<int>> GetList();
+
+        [OperationContract]
+        Task<Dictionary<string, int>> GetDictionary();
+
+        [OperationContract]
+        Task<HashSet<Book>> GetSet();
+
+        [OperationContract]
+        Task<Stack<byte>> GetStack();
+
+        [OperationContract]
+        Task<Queue<string>> GetQueue();
+    }
+
+    [DataContract]
+    public class Book
+    {
+        [DataMember]
+        public string Name;
+
+        [DataMember]
+        public Guid ISBN;
+
+        [DataMember]
+        public string Publisher;
+    }
+}
diff --git a/src/CoreWCF.Http/tests/ServiceContract/ITaskPrimitives.cs b/src/CoreWCF.Http/tests/ServiceContract/ITaskPrimitives.cs
new file mode 100644
index 0000000..c411550
--- /dev/null
+++ b/src/CoreWCF.Http/tests/ServiceContract/ITaskPrimitives.cs
@@ -0,0 +1,88 @@
+﻿using CoreWCF;
+using System;
+using System.Globalization;
+using System.Threading.Tasks;
+
+namespace ServiceContract
+{
+    public static class AsyncNetAdoptionConstants
+    {
+        public static DateTime TestDateTime = new DateTime(2010, 09, 04, new GregorianCalendar(GregorianCalendarTypes.USEnglish));
+    }
+
+    [ServiceContract(Namespace = "http://microsoft.samples", Name = "ITestPrimitives")]
+    public interface ITestPrimitives
+    {
+        [OperationContract]
+        Task<int> GetInt();
+
+        [OperationContract]
+        Task<byte> GetByte();
+
+        [OperationContract]
+        Task<sbyte> GetSByte();
+
+        [OperationContract]
+        Task<short> GetShort();
+
+        [OperationContract]
+        Task<ushort> GetUShort();
+
+        [OperationContract]
+        Task<double> GetDouble();
+
+        [OperationContract]
+        Task<uint> GetUInt();
+
+        [OperationContract]
+        Task<long> GetLong();
+
+        [OperationContract]
+        Task<ulong> GetULong();
+
+        [OperationContract]
+        Task<char> GetChar();
+
+        [OperationContract]
+        Task<bool> GetBool();
+
+        [OperationContract]
+        Task<float> GetFloat();
+
+        [OperationContract]
+        Task<decimal> GetDecimal();
+
+        [OperationContract]
+        Task<string> GetString();
+
+        [OperationContract]
+        Task<DateTime> GetDateTime();
+
+        [OperationContract]
+        Task<int[][]> GetintArr2D();
+
+        [OperationContract]
+        Task<float[]> GetfloatArr();
+
+        [OperationContract]
+        Task<byte[]> GetbyteArr();
+
+        [OperationContract]
+        Task<int?> GetnullableInt();
+
+        [OperationContract]
+        Task<TimeSpan> GetTimeSpan();
+
+        [OperationContract]
+        Task<Guid> GetGuid();
+
+        [OperationContract]
+        Task<Color> GetEnum();
+    }
+    public enum Color
+    {
+        Red,
+        Green,
+        Blue
+    }
+}
diff --git a/src/CoreWCF.Http/tests/ServiceContract/ITestBasicScenarios.cs b/src/CoreWCF.Http/tests/ServiceContract/ITestBasicScenarios.cs
new file mode 100644
index 0000000..d5698f7
--- /dev/null
+++ b/src/CoreWCF.Http/tests/ServiceContract/ITestBasicScenarios.cs
@@ -0,0 +1,30 @@
+﻿using CoreWCF;
+using CoreWCF.Channels;
+
+namespace ServiceContract
+{
+    [ServiceContract]
+    public interface ITestBasicScenarios
+    {
+        [OperationContract]
+        string TestMethodDefaults(int ID, string name);
+
+        [OperationContract(Action = "myAction")]
+        void TestMethodSetAction(int ID, string name);
+
+        [OperationContract(ReplyAction = "myReplyAction")]
+        int TestMethodSetReplyAction(int ID, string name);
+
+        [OperationContract(Action = "myUntypedAction")]
+        void TestMethodUntypedAction(Message m);
+
+        [OperationContract(ReplyAction = "myUntypedReplyAction")]
+        Message TestMethodUntypedReplyAction();
+
+        [OperationContract(Action = "mySetUntypedAction")]
+        void TestMethodSetUntypedAction(Message m);
+
+        [OperationContract(AsyncPattern = true, Action = "myAsyncAction", ReplyAction = "myAsyncReplyAction")]     
+        System.Threading.Tasks.Task<string> TestMethodAsync(int ID, string name);      
+    }
+}
diff --git a/src/CoreWCF.Http/tests/ServiceContract/ITestDataContractFault.cs b/src/CoreWCF.Http/tests/ServiceContract/ITestDataContractFault.cs
new file mode 100644
index 0000000..71cf8f3
--- /dev/null
+++ b/src/CoreWCF.Http/tests/ServiceContract/ITestDataContractFault.cs
@@ -0,0 +1,118 @@
+﻿using System.IO;
+using System.Runtime.Serialization;
+using CoreWCF;
+using CoreWCF.Channels;
+
+namespace ServiceContract
+{
+    #region Contract w/ FaultContract using DataContract (ITestDataContractFault)
+    [DataContract(Namespace = "http://Microsoft.ServiceModel.Samples")]
+    public class SomeFault
+    {
+        public SomeFault(int errID, string errMsg)
+        {
+            ID = errID;
+            message = errMsg;
+        }
+        [DataMember]
+        public int ID;
+        [DataMember]
+        public string message;
+    }
+
+    [DataContract(Namespace = "http://Microsoft.ServiceModel.Samples")]
+    public class OuterFault
+    {
+        [DataMember]
+        public SomeFault InnerFault { get; set; }
+    }
+
+    [DataContract(Namespace = "http://Microsoft.ServiceModel.Samples")]
+    public class ComplexFault
+    {
+        [DataMember]
+        public int ErrorInt { get; set; }
+
+        [DataMember]
+        public string ErrorString { get; set; }
+
+        [DataMember]
+        public SomeFault SomeFault { get; set; }
+
+        [DataMember]
+        public byte[] ErrorByteArray { get; set; }
+
+        [DataMember]
+        public int[] ErrorIntArray { get; set; }
+
+        [DataMember]
+        public string[] ErrorStringArray { get; set; }
+
+        [DataMember]
+        public SomeFault[] SomeFaultArray { get; set; }
+    }
+
+    [ServiceContract]
+    [System.ServiceModel.ServiceContract]
+    public interface ITestDataContractFault
+    {
+        [OperationContract]
+        [FaultContract(typeof(SomeFault))]
+        [FaultContract(typeof(OuterFault))]
+        [FaultContract(typeof(ComplexFault))]
+        string TwoWay_Method(string s);
+
+        [OperationContract]
+        [FaultContract(typeof(SomeFault))]
+        [FaultContract(typeof(OuterFault))]
+        [FaultContract(typeof(ComplexFault))]
+        void TwoWayVoid_Method(string s);
+
+        [OperationContract]
+        [FaultContract(typeof(SomeFault))]
+        [FaultContract(typeof(OuterFault))]
+        [FaultContract(typeof(ComplexFault))]
+        Stream TwoWayStream_Method(Stream s);
+
+        [OperationContract(AsyncPattern = true)]
+        [FaultContract(typeof(SomeFault))]
+        [FaultContract(typeof(OuterFault))]
+        [FaultContract(typeof(ComplexFault))]
+        System.Threading.Tasks.Task<string> TwoWayAsync_Method(string s);
+
+        [OperationContract]
+        [FaultContract(typeof(SomeFault))]
+        [FaultContract(typeof(OuterFault))]
+        [FaultContract(typeof(ComplexFault))]
+        FaultMsgContract MessageContract_Method(FaultMsgContract fmc);
+
+        [OperationContract]
+        [FaultContract(typeof(SomeFault))]
+        [FaultContract(typeof(OuterFault))]
+        [FaultContract(typeof(ComplexFault))]
+        Message Untyped_Method(Message m);
+
+        [OperationContract]
+        [FaultContract(typeof(SomeFault))]
+        [FaultContract(typeof(OuterFault))]
+        [FaultContract(typeof(ComplexFault))]
+        Message Untyped_MethodReturns(Message m);
+    }
+
+    [ServiceContract(Name = "ITestDataContractFault")]
+    public interface ITestDataContractFaultTypedClient
+    {
+        [OperationContract]
+        [FaultContract(typeof(SomeFault))]
+        [FaultContract(typeof(OuterFault))]
+        [FaultContract(typeof(ComplexFault))]
+        string Untyped_Method(string s);
+
+        [OperationContract]
+        [FaultContract(typeof(SomeFault))]
+        [FaultContract(typeof(OuterFault))]
+        [FaultContract(typeof(ComplexFault))]
+        string Untyped_MethodReturns(string s);
+    }
+    #endregion
+}
\ No newline at end of file
diff --git a/src/CoreWCF.Http/tests/ServiceContract/ITestFaultContractName.cs b/src/CoreWCF.Http/tests/ServiceContract/ITestFaultContractName.cs
new file mode 100644
index 0000000..2e8c72e
--- /dev/null
+++ b/src/CoreWCF.Http/tests/ServiceContract/ITestFaultContractName.cs
@@ -0,0 +1,96 @@
+﻿using System.IO;
+using CoreWCF;
+using CoreWCF.Channels;
+
+namespace ServiceContract
+{
+    #region Contract w/ FaultContract on Operations (ITestFaultContractName)
+    [ServiceContract]
+    public interface ITestFaultContractName
+    {
+        [OperationContract]
+        [FaultContract(typeof(string), Name = "Method1")]
+        string Method1(string s);
+
+        [OperationContract]
+        [FaultContract(typeof(string), Name = "Method2")]
+        string Method2(string s);
+
+        [OperationContract]
+        [FaultContract(typeof(string), Name = "ITestFaultContractAction.Method3")]
+        string Method3(string s);
+
+        [OperationContract]
+        [FaultContract(typeof(string), Name = "<hello>\"\'")]
+        string Method4(string s);
+
+        [OperationContract]
+        [FaultContract(typeof(string), Name = "t t n")]
+        string Method5(string s);
+
+        [OperationContract]
+        [FaultContract(typeof(string), Name = "&lt;&gt;&gt;")]
+        string Method6(string s);
+
+        [OperationContract]
+        [FaultContract(typeof(string), Name = "http://y.c/5")]
+        string Method7(string s);
+
+        [OperationContract]
+        [FaultContract(typeof(string), Name = "İüğmeIiiçeI")]
+        string Method8(string s);
+
+        [OperationContract]
+        [FaultContract(typeof(string), Name = "esÅeoplÀÁð")]
+        string Method9(string s);
+
+        [OperationContract]
+        [FaultContract(typeof(string), Name = "http://hello/\0")]
+        string Method10(string s);
+
+        [OperationContract]
+        [FaultContract(typeof(string), Name = "http://www.yahoo.com")]
+        string Method11(string s);
+
+        [OperationContract]
+        [FaultContract(typeof(string), Name = "null")]
+        string Method12(string s);
+
+        [OperationContract]
+        [FaultContract(typeof(string), Name = "<hello>\"\'\0")]
+        string Method13(string s);
+
+        [OperationContract]
+        [FaultContract(typeof(string), Name = "esÅeoplÀÁð")]
+        string Method14(string s);
+
+        [OperationContract]
+        [FaultContract(typeof(string), Name = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA")]
+        string Method15(string s);
+
+        [OperationContract]
+        [FaultContract(typeof(string), Name = "123456789012345")]
+        string Method16(string s);
+
+        [OperationContract]
+        [FaultContract(typeof(string), Name = "u")]
+        string Method17(string s);
+
+        [OperationContract]
+        [FaultContract(typeof(string), Name = "ÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅ")]
+        string Method18(string s);
+
+        [OperationContract]
+        [FaultContract(typeof(string), Name = "a_b - c - d_g()")]
+        string Method19(string s);
+
+        [OperationContract]
+        [FaultContract(typeof(string), Name = "\\//\\/////////// /")]
+        string Method20(string s);
+
+        [OperationContract]
+        [FaultContract(typeof(string), Name = "*")]
+        string Method21(string s);
+    }
+    #endregion
+}
diff --git a/src/CoreWCF.Http/tests/ServiceContract/NonSCExtendingSC_1138907.cs b/src/CoreWCF.Http/tests/ServiceContract/NonSCExtendingSC_1138907.cs
new file mode 100644
index 0000000..aae3a69
--- /dev/null
+++ b/src/CoreWCF.Http/tests/ServiceContract/NonSCExtendingSC_1138907.cs
@@ -0,0 +1,7 @@
+﻿namespace ServiceContract
+{
+	public interface NonSCExtendingSC_1138907 : SCInterface_1138907
+	{
+		string NonSCStringMethod(string str);
+	}
+}
diff --git a/src/CoreWCF.Http/tests/ServiceContract/SCInterfaceAB_1144850.cs b/src/CoreWCF.Http/tests/ServiceContract/SCInterfaceAB_1144850.cs
new file mode 100644
index 0000000..719d1fc
--- /dev/null
+++ b/src/CoreWCF.Http/tests/ServiceContract/SCInterfaceAB_1144850.cs
@@ -0,0 +1,11 @@
+﻿using CoreWCF;
+
+namespace ServiceContract
+{
+	[ServiceContract, XmlSerializerFormat]
+	public interface SCInterfaceAB_1144850 : SCInterfaceA_1144850, SCInterfaceB_1144850
+	{
+		[OperationContract]
+		string StringMethodAB(string str);
+	}
+}
diff --git a/src/CoreWCF.Http/tests/ServiceContract/SCInterfaceA_1144850.cs b/src/CoreWCF.Http/tests/ServiceContract/SCInterfaceA_1144850.cs
new file mode 100644
index 0000000..31a8beb
--- /dev/null
+++ b/src/CoreWCF.Http/tests/ServiceContract/SCInterfaceA_1144850.cs
@@ -0,0 +1,11 @@
+﻿using CoreWCF;
+
+namespace ServiceContract
+{
+	[ServiceContract, XmlSerializerFormat]
+	public interface SCInterfaceA_1144850
+	{
+		[OperationContract]
+		string StringMethodA(string str);
+	}
+}
diff --git a/src/CoreWCF.Http/tests/ServiceContract/SCInterfaceB_1144850.cs b/src/CoreWCF.Http/tests/ServiceContract/SCInterfaceB_1144850.cs
new file mode 100644
index 0000000..1583a19
--- /dev/null
+++ b/src/CoreWCF.Http/tests/ServiceContract/SCInterfaceB_1144850.cs
@@ -0,0 +1,11 @@
+﻿using CoreWCF;
+
+namespace ServiceContract
+{
+	[ServiceContract, XmlSerializerFormat]
+	public interface SCInterfaceB_1144850
+	{
+		[OperationContract]
+		string StringMethodB(string str);
+	}
+}
diff --git a/src/CoreWCF.Http/tests/ServiceContract/SCInterface_1138907.cs b/src/CoreWCF.Http/tests/ServiceContract/SCInterface_1138907.cs
new file mode 100644
index 0000000..930452c
--- /dev/null
+++ b/src/CoreWCF.Http/tests/ServiceContract/SCInterface_1138907.cs
@@ -0,0 +1,11 @@
+﻿using CoreWCF;
+
+namespace ServiceContract
+{
+	[ServiceContract]
+	public interface SCInterface_1138907
+	{
+		[OperationContract]
+		string SCStringMethod(string str);
+	}
+}
diff --git a/src/CoreWCF.Http/tests/ServiceContract/SanityAParentB_857419.cs b/src/CoreWCF.Http/tests/ServiceContract/SanityAParentB_857419.cs
new file mode 100644
index 0000000..64661d7
--- /dev/null
+++ b/src/CoreWCF.Http/tests/ServiceContract/SanityAParentB_857419.cs
@@ -0,0 +1,39 @@
+using CoreWCF;
+using System.Runtime.Serialization;
+
+namespace ServiceContract
+{
+    [ServiceContract]
+    public interface ISanityAParentB_857419_ContractDerived : ISanityAParentB_857419_ContractBase
+    {
+        [OperationContract(IsOneWay = true)]
+        void OneWayMethod(object o);
+
+        [OperationContract(IsOneWay = false)]
+        string StringMethod(string s);
+
+        [OperationContract(Name = "DerivedMethod")]
+        new string Method(string input);
+    }
+
+    [ServiceContract]
+    public interface ISanityAParentB_857419_ContractBase 
+    {
+        [OperationContract(IsOneWay = false)]
+        string TwoWayMethod(string input);
+
+        [OperationContract(IsOneWay = false)]
+        [ServiceKnownType(typeof(MyBaseDataType))]
+        object DataContractMethod(object o);
+
+        [OperationContract(Name = "BaseMethod")]
+        string Method(string input);
+    }
+
+    [DataContract]
+    public class MyBaseDataType
+    {
+        [DataMember]
+        public string data = null;
+    }
+}
\ No newline at end of file
diff --git a/src/CoreWCF.Http/tests/ServiceContract/ServiceContractName_784749_Interfaces.cs b/src/CoreWCF.Http/tests/ServiceContract/ServiceContractName_784749_Interfaces.cs
new file mode 100644
index 0000000..3bc8bde
--- /dev/null
+++ b/src/CoreWCF.Http/tests/ServiceContract/ServiceContractName_784749_Interfaces.cs
@@ -0,0 +1,60 @@
+﻿using CoreWCF;
+
+namespace ServiceContract
+{
+    [ServiceContract(Name = "<hello>\"'")]
+    public interface IServiceContractName_784749_XmlCharacters_Service
+    {
+        [OperationContract]
+        string Method1(string input);
+    }
+
+    [ServiceContract(Name = "   \t \t \n ")]
+    public interface IServiceContractName_784749_WhiteSpace_Service
+    {
+        [OperationContract(Action = "WhiteSpaceInName")]
+        string Method2(string input);
+    }
+
+    [ServiceContract(Name = "&lt;&gt;&gt;")]
+    public interface IServiceContractName_784749_XMLEncoded_Service
+    {
+        [OperationContract]
+        string Method3(string input);
+    }
+
+    [ServiceContract(Name = "http://y.c/5")]
+    public interface IServiceContractName_784749_NonAlphaCharacters_Service
+    {
+        [OperationContract]
+        string Method4(string input);
+    }
+
+    [ServiceContract(Name = "İüğmeIiiçeI")]
+    public interface IServiceContractName_784749_LocalizedCharacters_Service
+    {
+        [OperationContract(Action = "localizedCharsInName")]
+        string Method5(string input);
+    }
+
+    [ServiceContract(Name = "esÅeoplÀÁð")]
+    public interface IServiceContractName_784749_SurrogateCharacters_Service
+    {
+        [OperationContract]
+        string Method6(string input);
+    }
+
+    [ServiceContract(Name = "http://hello/\0")]
+    public interface IServiceContractName_784749_XMLReservedCharacters_Service
+    {
+        [OperationContract(Action = "xmlReservedCharInName")]
+        string Method7(string input);
+    }
+
+    [ServiceContract(Name = "http://www.yahoo.com")]
+    public interface IServiceContractName_784749_URI_Service
+    {
+        [OperationContract]
+        string Method8(string input);
+    }
+}
\ No newline at end of file
diff --git a/src/CoreWCF.Http/tests/ServiceContract/ServiceContract_Namespace_Interfaces.cs b/src/CoreWCF.Http/tests/ServiceContract/ServiceContract_Namespace_Interfaces.cs
new file mode 100644
index 0000000..2a1d222
--- /dev/null
+++ b/src/CoreWCF.Http/tests/ServiceContract/ServiceContract_Namespace_Interfaces.cs
@@ -0,0 +1,60 @@
+﻿using CoreWCF;
+
+namespace ServiceContract
+{
+    [ServiceContract(Namespace = "<hello>\"\'")]
+    public interface IServiceContractNamespace_784756_XmlCharacters_Service
+    {
+        [OperationContract]
+        string Method1(string input);
+    }
+
+    [ServiceContract(Namespace = "   \t \t \n ")]
+    public interface IServiceContractNamespace_784756_WhiteSpace_Service
+    {
+        [OperationContract(Action = "WhiteSpaceInNamespace")]
+        string Method2(string input);
+    }
+
+    [ServiceContract(Namespace = "&lt;&gt;&gt;")]
+    public interface IServiceContractNamespace_784756_XMLEncoded_Service
+    {
+        [OperationContract]
+        string Method3(string input);
+    }
+
+    [ServiceContract(Namespace = "http://y.c/5")]
+    public interface IServiceContractNamespace_784756_NonAlphaCharacters_Service
+    {
+        [OperationContract]
+        string Method4(string input);
+    }
+
+    [ServiceContract(Namespace = "İüğmeIiiçeI")]
+    public interface IServiceContractNamespace_784756_LocalizedCharacters_Service
+    {
+        [OperationContract(Action = "LocalizedCharInNamespace")]
+        string Method5(string input);
+    }
+
+    [ServiceContract(Namespace = "esÅeoplÀÁð")]
+    public interface IServiceContractNamespace_784756_SurrogateCharacters_Service
+    {
+        [OperationContract]
+        string Method6(string input);
+    }
+
+    [ServiceContract(Namespace = "http://hello/\0")]
+    public interface IServiceContractNamespace_784756_XMLReservedCharacters_Service
+    {
+        [OperationContract(Action = "XmlReservedCharInNamespace")]
+        string Method7(string input);
+    }
+
+    [ServiceContract(Namespace = "http://www.yahoo.com")]
+    public interface IServiceContractNamespace_784756_URI_Service
+    {
+        [OperationContract]
+        string Method8(string input);
+    }
+}
\ No newline at end of file
diff --git a/src/CoreWCF.Http/tests/ServiceContractNameSpaceTests.cs b/src/CoreWCF.Http/tests/ServiceContractNameSpaceTests.cs
new file mode 100644
index 0000000..233113e
--- /dev/null
+++ b/src/CoreWCF.Http/tests/ServiceContractNameSpaceTests.cs
@@ -0,0 +1,243 @@
+﻿using CoreWCF.Configuration;
+using Helpers;
+using Microsoft.AspNetCore.Builder;
+using Microsoft.AspNetCore.Hosting;
+using Microsoft.Extensions.DependencyInjection;
+using ServiceContract;
+using System;
+using Xunit;
+using Xunit.Abstractions;
+
+namespace CoreWCF.Http.Tests
+{
+    public class ServiceContractNameSpaceTests
+    {
+        private ITestOutputHelper _output;
+        public ServiceContractNameSpaceTests(ITestOutputHelper output)
+        {
+            _output = output;
+        }
+
+        [Theory]
+#if NET472
+        [InlineData("XmlCharacters", "String From Client")]
+        [InlineData("WhiteSpace", "String From Client")]
+        [InlineData("XMLEncoded", "String From Client")]        
+        [InlineData("XMLReservedCharacters", "String From Client")]
+#endif
+        [InlineData("NonAlphaCharacters", "String From Client")]
+        [InlineData("LocalizedCharacters", "String From Client")]
+        [InlineData("SurrogateCharacters", "String From Client")]
+        [InlineData("URI", "String From Client")]
+        public void SerivceContractNameSpace_784756(string method, string clientString)
+        {
+            string result = null;
+            SerivceContractNameSpace._method = method;
+            var host = ServiceHelper.CreateWebHostBuilder<SerivceContractNameSpace>(_output).Build();
+            using (host)
+            {
+                host.Start();
+                switch (method)
+                {
+                    case "XmlCharacters":
+                        {
+                            result = this.Variation_Service_XmlCharacters(clientString);
+                            Assert.Equal(clientString, result);
+                        }
+                        break;
+                    case "WhiteSpace":
+                        {
+                            result = this.Variation_Service_WhiteSpace(clientString);
+                            Assert.Equal(clientString, result);
+                        }
+                        break;
+                    case "XMLEncoded":
+                        {
+                            result = this.Variation_Service_XMLEncoded(clientString);
+                            Assert.Equal(clientString, result);
+                        }
+                        break;
+
+                    case "XMLReservedCharacters":
+                        {
+                            result = this.Variation_Service_XMLReservedCharacters(clientString);
+                            Assert.Equal(clientString, result);
+                        }
+                        break;
+                    case "NonAlphaCharacters":
+                        {
+                            result = this.Variation_Service_NonAlphaCharacters(clientString);
+                            Assert.Equal(clientString, result);
+                        }
+                        break;
+                    case "LocalizedCharacters":
+                        {
+                            result = this.Variation_Service_LocalizedCharacters(clientString);
+                            Assert.Equal(clientString, result);
+                        }
+                        break;
+                    case "SurrogateCharacters":
+                        {
+                            result = this.Variation_Service_SurrogateCharacters(clientString);
+                            Assert.Equal(clientString, result);
+                        }
+                        break;
+                    case "URI":
+                        {
+                            result = this.Variation_Service_URI(clientString);
+                            Assert.Equal(clientString, result);
+                        }
+                        break;
+                    default:
+                        {
+                            _output.WriteLine("Unknown ID : " + method);
+                            Assert.Equal(clientString, result);
+                            break;
+                        }
+                }
+            }
+        }
+
+        private string Variation_Service_XmlCharacters(string clientString)
+        {
+            // Create the proxy
+            var clientProxy = ClientHelper.GetProxy<ClientContract.IServiceContractNamespace_784756_XmlCharacters_Service>();
+            // Send the two way message
+            _output.WriteLine("Testing [Variation_Service_XmlCharacters]");
+            string response = clientProxy.Method1(clientString);
+            _output.WriteLine("Testing [Variation_Service_XmlCharacters] returned <{0}>", response);
+            return response;
+        }
+
+        private string Variation_Service_WhiteSpace(string clientString)
+        {
+            // Create the proxy            
+            var clientProxy = ClientHelper.GetProxy<ClientContract.IServiceContractNamespace_784756_WhiteSpace_Service>();
+            // Send the two way message
+            _output.WriteLine("Testing [Variation_Service_WhiteSpace]");
+            string response = clientProxy.Method2(clientString);
+            _output.WriteLine("Testing [Variation_Service_WhiteSpace] returned <{0}>", response);
+            return response;
+        }
+
+        private string Variation_Service_XMLEncoded(string clientString)
+        {
+            // Create the proxy           
+            var clientProxy = ClientHelper.GetProxy<ClientContract.IServiceContractNamespace_784756_XMLEncoded_Service>();
+            // Send the two way message
+            _output.WriteLine("Testing [Variation_Service_XMLEncoded]");
+            string response = clientProxy.Method3(clientString);
+            _output.WriteLine("Testing [Variation_Service_XMLEncoded] returned <{0}>", response);
+            return response;
+        }
+
+        private string Variation_Service_NonAlphaCharacters(string clientString)
+        {
+            // Create the proxy         
+            var clientProxy = ClientHelper.GetProxy<ClientContract.IServiceContractNamespace_784756_NonAlphaCharacters_Service>();
+            // Send the two way message
+            _output.WriteLine("Testing [Variation_Service_NonAlphaCharacters]");
+            string response = clientProxy.Method4(clientString);
+            _output.WriteLine("Testing [Variation_Service_NonAlphaCharacters] returned <{0}>", response);
+            return response;
+        }
+
+        private string Variation_Service_LocalizedCharacters(string clientString)
+        {
+            // Create the proxy            
+            var clientProxy = ClientHelper.GetProxy<ClientContract.IServiceContractNamespace_784756_LocalizedCharacters_Service>();
+            // Send the two way message
+            _output.WriteLine("Testing [Variation_Service_LocalizedCharacters]");
+            string response = clientProxy.Method5(clientString);
+            _output.WriteLine("Testing [Variation_Service_LocalizedCharacters] returned <{0}>", response);
+            return response;
+        }
+
+        private string Variation_Service_SurrogateCharacters(string clientString)
+        {
+            // Create the proxy           
+            var clientProxy = ClientHelper.GetProxy<ClientContract.IServiceContractNamespace_784756_SurrogateCharacters_Service>();
+            // Send the two way message
+            _output.WriteLine("Testing [Variation_Service_SurrogateCharacters]");
+            string response = clientProxy.Method6(clientString);
+            _output.WriteLine("Testing [Variation_Service_SurrogateCharacters] returned <{0}>", response);
+            return response;
+        }
+
+        private string Variation_Service_XMLReservedCharacters(string clientString)
+        {
+            // Create the proxy        
+            var clientProxy = ClientHelper.GetProxy<ClientContract.IServiceContractNamespace_784756_XMLReservedCharacters_Service>();
+            // Send the two way message
+            _output.WriteLine("Testing [Variation_Service_XMLReservedCharacters]");
+            string response = clientProxy.Method7(clientString);
+            _output.WriteLine("Testing [Variation_Service_XMLReservedCharacters] returned <{0}>", response);
+            return response;
+        }
+
+        private string Variation_Service_URI(string clientString)
+        {
+            // Create the proxy           
+            var clientProxy = ClientHelper.GetProxy<ClientContract.IServiceContractNamespace_784756_URI_Service>();
+            // Send the two way message
+            _output.WriteLine("Testing [Variation_Service_URI]");
+            string response = clientProxy.Method8(clientString);
+            _output.WriteLine("Testing [Variation_Service_URI] returned <{0}>", response);
+            return response;
+        }
+    }
+
+    internal class SerivceContractNameSpace
+    {
+        public static string _method;
+
+        public void ConfigureServices(IServiceCollection services)
+        {
+            services.AddServiceModelServices();
+        }
+
+        public void Configure(IApplicationBuilder app, IHostingEnvironment env)
+        {
+            app.UseServiceModel(builder =>
+            {
+                switch (_method)
+                {
+                    case "XmlCharacters":
+                        builder.AddService<Services.ServiceContractNamespace_784756_XmlCharacters_Service>();
+                        builder.AddServiceEndpoint<Services.ServiceContractNamespace_784756_XmlCharacters_Service, IServiceContractNamespace_784756_XmlCharacters_Service>(new CoreWCF.BasicHttpBinding(), "/BasicWcfService/basichttp.svc");
+                        break;
+                    case "WhiteSpace":
+                        builder.AddService<Services.ServiceContractNamespace_784756_WhiteSpace_Service>();
+                        builder.AddServiceEndpoint<Services.ServiceContractNamespace_784756_WhiteSpace_Service, IServiceContractNamespace_784756_WhiteSpace_Service>(new CoreWCF.BasicHttpBinding(), "/BasicWcfService/basichttp.svc");
+                        break;
+                    case "XMLEncoded":
+                        builder.AddService<Services.ServiceContractNamespace_784756_XMLEncoded_Service>();
+                        builder.AddServiceEndpoint<Services.ServiceContractNamespace_784756_XMLEncoded_Service, IServiceContractNamespace_784756_XMLEncoded_Service>(new CoreWCF.BasicHttpBinding(), "/BasicWcfService/basichttp.svc");
+                        break;
+                    case "NonAlphaCharacters":
+                        builder.AddService<Services.ServiceContractNamespace_784756_NonAlphaCharacters_Service>();
+                        builder.AddServiceEndpoint<Services.ServiceContractNamespace_784756_NonAlphaCharacters_Service, IServiceContractNamespace_784756_NonAlphaCharacters_Service>(new CoreWCF.BasicHttpBinding(), "/BasicWcfService/basichttp.svc");
+                        break;
+                    case "LocalizedCharacters":
+                        builder.AddService<Services.ServiceContractNamespace_784756_LocalizedCharacters_Service>();
+                        builder.AddServiceEndpoint<Services.ServiceContractNamespace_784756_LocalizedCharacters_Service, IServiceContractNamespace_784756_LocalizedCharacters_Service>(new CoreWCF.BasicHttpBinding(), "/BasicWcfService/basichttp.svc");
+                        break;
+                    case "SurrogateCharacters":
+                        builder.AddService<Services.ServiceContractNamespace_784756_SurrogateCharacters_Service>();
+                        builder.AddServiceEndpoint<Services.ServiceContractNamespace_784756_SurrogateCharacters_Service, IServiceContractNamespace_784756_SurrogateCharacters_Service>(new CoreWCF.BasicHttpBinding(), "/BasicWcfService/basichttp.svc");
+                        break;
+                    case "XMLReservedCharacters":
+                        builder.AddService<Services.ServiceContractNamespace_784756_XMLReservedCharacters_Service>();
+                        builder.AddServiceEndpoint<Services.ServiceContractNamespace_784756_XMLReservedCharacters_Service, IServiceContractNamespace_784756_XMLReservedCharacters_Service>(new CoreWCF.BasicHttpBinding(), "/BasicWcfService/basichttp.svc");
+                        break;
+                    case "URI":
+                        builder.AddService<Services.ServiceContractNamespace_784756_URI_Service>();
+                        builder.AddServiceEndpoint<Services.ServiceContractNamespace_784756_URI_Service, IServiceContractNamespace_784756_URI_Service>(new CoreWCF.BasicHttpBinding(), "/BasicWcfService/basichttp.svc");
+                        break;
+                    default:
+                        throw new ApplicationException("Unsupported ServiceType");
+                }
+            });
+        }
+    }
+}
diff --git a/src/CoreWCF.Http/tests/ServiceContractNameTests.cs b/src/CoreWCF.Http/tests/ServiceContractNameTests.cs
new file mode 100644
index 0000000..988cb35
--- /dev/null
+++ b/src/CoreWCF.Http/tests/ServiceContractNameTests.cs
@@ -0,0 +1,239 @@
+﻿using CoreWCF.Configuration;
+using Helpers;
+using Microsoft.AspNetCore.Builder;
+using Microsoft.AspNetCore.Hosting;
+using Microsoft.Extensions.DependencyInjection;
+using ServiceContract;
+using System;
+using Xunit;
+using Xunit.Abstractions;
+
+namespace CoreWCF.Http.Tests
+{
+    public class ServiceContractNameTests
+    {
+        private ITestOutputHelper _output;
+        public ServiceContractNameTests(ITestOutputHelper output)
+        {
+            _output = output;
+        }
+
+        [Theory]
+        [InlineData("XmlCharacters", "String From Client")]
+        [InlineData("WhiteSpace", "String From Client")]
+        [InlineData("XMLEncoded", "String From Client")]
+        [InlineData("NonAlphaCharacters", "String From Client")]
+        [InlineData("LocalizedCharacters", "String From Client")]
+        [InlineData("SurrogateCharacters", "String From Client")]
+        [InlineData("XMLReservedCharacters", "String From Client")]
+        [InlineData("URI", "String From Client")]
+        public void SerivceContractName_784749(string method, string clientString)
+        {
+            string result = null;
+            SerivceContractName._method = method;
+            var host = ServiceHelper.CreateWebHostBuilder<SerivceContractName>(_output).Build();
+            using (host)
+            {
+                host.Start();
+                switch (method)
+                {
+                    case "XmlCharacters":
+                        {
+                            result = this.Variation_Service_XmlCharacters(clientString);
+                            Assert.Equal(clientString, result);
+                        }
+                        break;
+                    case "WhiteSpace":
+                        {
+                            result = this.Variation_Service_WhiteSpace(clientString);
+                            Assert.Equal(clientString, result);
+                        }
+                        break;
+                    case "XMLEncoded":
+                        {
+                            result = this.Variation_Service_XMLEncoded(clientString);
+                            Assert.Equal(clientString, result);
+                        }
+                        break;
+                    case "NonAlphaCharacters":
+                        {
+                            result = this.Variation_Service_NonAlphaCharacters(clientString);
+                            Assert.Equal(clientString, result);
+                        }
+                        break;
+                    case "LocalizedCharacters":
+                        {
+                            result = this.Variation_Service_LocalizedCharacters(clientString);
+                            Assert.Equal(clientString, result);
+                        }
+                        break;
+                    case "SurrogateCharacters":
+                        {
+                            result = this.Variation_Service_SurrogateCharacters(clientString);
+                            Assert.Equal(clientString, result);
+                        }
+                        break;
+                    case "XMLReservedCharacters":
+                        {
+                            result = this.Variation_Service_XMLReservedCharacters(clientString);
+                            Assert.Equal(clientString, result);
+                        }
+                        break;
+                    case "URI":
+                        {
+                            result = this.Variation_Service_URI(clientString);
+                            Assert.Equal(clientString, result);
+                        }
+                        break;
+                    default:
+                        {
+                            _output.WriteLine("Unknown ID : " + method);
+                            break;
+                        }
+                }
+            }
+        }
+
+        private string Variation_Service_XmlCharacters(string clientString)
+        {
+            // Create the proxy
+            var clientProxy = ClientHelper.GetProxy<ClientContract.IServiceContractName_784749_XmlCharacters_Service>();
+            // Send the two way message
+            _output.WriteLine("Testing [Variation_Service_XmlCharacters]");
+            string response = clientProxy.Method1(clientString);
+            _output.WriteLine("Testing [Variation_Service_XmlCharacters] returned <{0}>", response);
+            return response;
+        }
+
+        private string Variation_Service_WhiteSpace(string clientString)
+        {
+            // Create the proxy            
+            var clientProxy = ClientHelper.GetProxy<ClientContract.IServiceContractName_784749_WhiteSpace_Service>();
+            // Send the two way message
+            _output.WriteLine("Testing [Variation_Service_WhiteSpace]");
+            string response = clientProxy.Method2(clientString);
+            _output.WriteLine("Testing [Variation_Service_WhiteSpace] returned <{0}>", response);
+            return response;
+        }
+
+        private string Variation_Service_XMLEncoded(string clientString)
+        {
+            // Create the proxy           
+            var clientProxy = ClientHelper.GetProxy<ClientContract.IServiceContractName_784749_XMLEncoded_Service>();
+            // Send the two way message
+            _output.WriteLine("Testing [Variation_Service_XMLEncoded]");
+            string response = clientProxy.Method3(clientString);
+            _output.WriteLine("Testing [Variation_Service_XMLEncoded] returned <{0}>", response);
+            return response;
+        }
+
+        private string Variation_Service_NonAlphaCharacters(string clientString)
+        {
+            // Create the proxy         
+            var clientProxy = ClientHelper.GetProxy<ClientContract.IServiceContractName_784749_NonAlphaCharacters_Service>();
+            // Send the two way message
+            _output.WriteLine("Testing [Variation_Service_NonAlphaCharacters]");
+            string response = clientProxy.Method4(clientString);
+            _output.WriteLine("Testing [Variation_Service_NonAlphaCharacters] returned <{0}>", response);
+            return response;
+        }
+
+        private string Variation_Service_LocalizedCharacters(string clientString)
+        {
+            // Create the proxy            
+            var clientProxy = ClientHelper.GetProxy<ClientContract.IServiceContractName_784749_LocalizedCharacters_Service>();
+            // Send the two way message
+            _output.WriteLine("Testing [Variation_Service_LocalizedCharacters]");
+            string response = clientProxy.Method5(clientString);
+            _output.WriteLine("Testing [Variation_Service_LocalizedCharacters] returned <{0}>", response);
+            return response;
+        }
+
+        private string Variation_Service_SurrogateCharacters(string clientString)
+        {
+            // Create the proxy           
+            var clientProxy = ClientHelper.GetProxy<ClientContract.IServiceContractName_784749_SurrogateCharacters_Service>();
+            // Send the two way message
+            _output.WriteLine("Testing [Variation_Service_SurrogateCharacters]");
+            string response = clientProxy.Method6(clientString);
+            _output.WriteLine("Testing [Variation_Service_SurrogateCharacters] returned <{0}>", response);
+            return response;
+        }
+
+        private string Variation_Service_XMLReservedCharacters(string clientString)
+        {
+            // Create the proxy        
+            var clientProxy = ClientHelper.GetProxy<ClientContract.IServiceContractName_784749_XMLReservedCharacters_Service>();
+            // Send the two way message
+            _output.WriteLine("Testing [Variation_Service_XMLReservedCharacters]");
+            string response = clientProxy.Method7(clientString);
+            _output.WriteLine("Testing [Variation_Service_XMLReservedCharacters] returned <{0}>", response);
+            return response;
+        }
+
+        private string Variation_Service_URI(string clientString)
+        {
+            // Create the proxy           
+            var clientProxy = ClientHelper.GetProxy<ClientContract.IServiceContractName_784749_URI_Service>();
+            // Send the two way message
+            _output.WriteLine("Testing [Variation_Service_URI]");
+            string response = clientProxy.Method8(clientString);
+            _output.WriteLine("Testing [Variation_Service_URI] returned <{0}>", response);
+            return response;
+        }
+    }
+
+    internal class SerivceContractName
+    {
+        public static string _method;
+
+        public void ConfigureServices(IServiceCollection services)
+        {
+            services.AddServiceModelServices();
+        }
+
+        public void Configure(IApplicationBuilder app, IHostingEnvironment env)
+        {
+            app.UseServiceModel(builder =>
+            {
+                switch (_method)
+                {
+                    case "XmlCharacters":
+                        builder.AddService<Services.ServiceContractName_784749_XmlCharacters_Service>();
+                        builder.AddServiceEndpoint<Services.ServiceContractName_784749_XmlCharacters_Service, IServiceContractName_784749_XmlCharacters_Service>(new CoreWCF.BasicHttpBinding(), "/BasicWcfService/basichttp.svc");
+                        break;
+                    case "WhiteSpace":
+                        builder.AddService<Services.ServiceContractName_784749_WhiteSpace_Service>();
+                        builder.AddServiceEndpoint<Services.ServiceContractName_784749_WhiteSpace_Service, IServiceContractName_784749_WhiteSpace_Service>(new CoreWCF.BasicHttpBinding(), "/BasicWcfService/basichttp.svc");
+                        break;
+                    case "XMLEncoded":
+                        builder.AddService<Services.ServiceContractName_784749_XMLEncoded_Service>();
+                        builder.AddServiceEndpoint<Services.ServiceContractName_784749_XMLEncoded_Service, IServiceContractName_784749_XMLEncoded_Service>(new CoreWCF.BasicHttpBinding(), "/BasicWcfService/basichttp.svc");
+                        break;
+                    case "NonAlphaCharacters":
+                        builder.AddService<Services.ServiceContractName_784749_NonAlphaCharacters_Service>();
+                        builder.AddServiceEndpoint<Services.ServiceContractName_784749_NonAlphaCharacters_Service, IServiceContractName_784749_NonAlphaCharacters_Service>(new CoreWCF.BasicHttpBinding(), "/BasicWcfService/basichttp.svc");
+                        break;
+                    case "LocalizedCharacters":
+                        builder.AddService<Services.ServiceContractName_784749_LocalizedCharacters_Service>();
+                        builder.AddServiceEndpoint<Services.ServiceContractName_784749_LocalizedCharacters_Service, IServiceContractName_784749_LocalizedCharacters_Service>(new CoreWCF.BasicHttpBinding(), "/BasicWcfService/basichttp.svc");
+                        break;
+                    case "SurrogateCharacters":
+                        builder.AddService<Services.ServiceContractName_784749_SurrogateCharacters_Service>();
+                        builder.AddServiceEndpoint<Services.ServiceContractName_784749_SurrogateCharacters_Service, IServiceContractName_784749_SurrogateCharacters_Service>(new CoreWCF.BasicHttpBinding(), "/BasicWcfService/basichttp.svc");
+                        break;
+                    case "XMLReservedCharacters":
+                        builder.AddService<Services.ServiceContractName_784749_XMLReservedCharacters_Service>();
+                        builder.AddServiceEndpoint<Services.ServiceContractName_784749_XMLReservedCharacters_Service, IServiceContractName_784749_XMLReservedCharacters_Service>(new CoreWCF.BasicHttpBinding(), "/BasicWcfService/basichttp.svc");
+                        break;
+                    case "URI":
+                        builder.AddService<Services.ServiceContractName_784749_URI_Service>();
+                        builder.AddServiceEndpoint<Services.ServiceContractName_784749_URI_Service, IServiceContractName_784749_URI_Service>(new CoreWCF.BasicHttpBinding(), "/BasicWcfService/basichttp.svc");
+                        break;
+                    default:
+                        throw new ApplicationException("Unsupported ServiceType");
+                }
+            });
+        }
+    }
+}
diff --git a/src/CoreWCF.Http/tests/ServiceWithContractInheritanceTests.cs b/src/CoreWCF.Http/tests/ServiceWithContractInheritanceTests.cs
new file mode 100644
index 0000000..6b9b923
--- /dev/null
+++ b/src/CoreWCF.Http/tests/ServiceWithContractInheritanceTests.cs
@@ -0,0 +1,426 @@
+﻿using CoreWCF.Configuration;
+using Helpers;
+using Microsoft.AspNetCore.Builder;
+using Microsoft.AspNetCore.Hosting;
+using Microsoft.Extensions.DependencyInjection;
+using ServiceContract;
+using System;
+using System.Linq;
+using System.ServiceModel.Description;
+using Xunit;
+using Xunit.Abstractions;
+
+namespace CoreWCF.Http.Tests
+{
+    public class ServiceWithContractInheritanceTests
+    {
+        private ITestOutputHelper _output;
+
+        public ServiceWithContractInheritanceTests(ITestOutputHelper output)
+        {
+            _output = output;
+        }
+
+        [Theory]
+        [InlineData(typeof(Services.ServiceWithSCExtendingFromServiceWithSC), typeof(Services.ServiceWithSC))]
+        [InlineData(typeof(Services.ServiceWithSCDerivingFromNonSCExtendingSC), typeof(ServiceContract.SCInterface_1138907))]
+        [InlineData(typeof(Services.ServiceWithSCDerivingFromSC), typeof(ServiceContract.SCInterface_1138907))]
+        public void ServiceWithContractNegative(Type service, Type interf)
+        {
+            string expectResults = string.Format("The service class of type {0} both defines a ServiceContract and inherits a ServiceContract from type {1}. Contract inheritance can only be used among interface types.  If a class is marked with ServiceContractAttribute, it must be the only type in the hierarchy with ServiceContractAttribute.  Consider moving the ServiceContractAttribute on type {1} to a separate interface that type {1} implements.", service, interf);
+            Startup._service = service;
+            Startup._interface = interf;
+
+            var host = ServiceHelper.CreateWebHostBuilder<Startup>(_output).Build();
+            try
+            {
+                using (host)
+                {
+                    host.Start();
+                }
+            }
+            catch (Exception ex)
+            {
+                _output.WriteLine(ex.ToString());
+                string actual = ex.Message.ToString();
+                Assert.Equal(expectResults, actual);
+            }
+        }
+
+        [Theory]
+        [InlineData("AClient", "ABService")]
+        [InlineData("BClient", "ABService")]
+        [InlineData("ABClient", "ABService")]
+        [InlineData("ABClient", "BService")]
+        public void EndpointsWithContractInheritance(string clientType, string serviceType)
+        {
+            StartupEndpoints.ServiceType = serviceType;
+            StartupEndpoints.ClientType = clientType;
+
+            var host = ServiceHelper.CreateWebHostBuilder<StartupEndpoints>(_output).Build();
+            using (host)
+            {
+                host.Start();
+
+                switch (clientType.ToLower())
+                {
+                    case "abclient":
+                        ClientContract.SCInterfaceAB_1144850 abProxy = GetProxy<ClientContract.SCInterfaceAB_1144850>();
+                        if (serviceType.ToLower().Equals("aservice"))
+                            Assert.Equal("Hello", abProxy.StringMethodA("Hello"));
+                        else if (serviceType.ToLower().Equals("bservice"))
+                            Assert.Equal("Hello", abProxy.StringMethodB("Hello"));
+                        else
+                            _output.WriteLine("This ClientType and ServiceType combination is not supported");
+                        break;
+                    case "aclient":
+                        ClientContract.SCInterfaceA_1144850 aProxy = GetProxy<ClientContract.SCInterfaceA_1144850>();
+                        Assert.Equal("Hello", aProxy.StringMethodA("Hello"));
+                        break;
+                    case "bclient":
+                        ClientContract.SCInterfaceB_1144850 bProxy = GetProxy<ClientContract.SCInterfaceB_1144850>();
+                        Assert.Equal("Hello", bProxy.StringMethodB("Hello"));
+                        break;
+                    default:
+                        throw new ApplicationException("Unsupported ClientType");
+                }
+            }
+        }
+
+        [Theory]
+        //[InlineData("DerivedOneWay", "One Way Method")]
+        [InlineData("DerivedStringMethod", "Send String to fro on Derived")]
+        [InlineData("DerivedReNameMethod", "Method conflicts with Base implementation")]
+        [InlineData("BaseTwoWayMethod", "Call Two way voids on Base")]
+        // [InlineData("BaseDataContractMethod", "Send Data Contract on Base")]
+        [InlineData("BaseReNameMethod", "Method conflicts with Derived implementation")]
+        [InlineData("DerivedCallingBaseTwoWayMethod", "Call Two way voids on Base")]
+        //[InlineData("DerivedCallingBaseDataContractMethod", "Send Data Contract on Base")]
+        [InlineData("DerivedCallingBaseReNameMethod", "Method conflicts with Derived implementation")]
+        public void SanityAParentB_857419_Service_Both(string method, string clientString)
+        {
+            _output.WriteLine("Entered SanityAParentB_857419_Client.Run");
+            // Client type: OneWay and TwoWay
+            string result = null;
+            StartupSanityAParentB._method = method;
+            var host = ServiceHelper.CreateWebHostBuilder<StartupSanityAParentB>(_output).Build();
+
+            using (host)
+            {
+                host.Start();
+                switch (method)
+                {
+                    case "DerivedOneWay":
+                        {
+                            result = this.Variation_Service_DerivedOneWay(clientString);
+                            Assert.Equal(clientString, result);
+                        }
+                        break;
+                    case "DerivedStringMethod":
+                        {
+                            result = this.Variation_Service_DerivedStringMethod(clientString);
+                            Assert.Equal(clientString, result);
+                        }
+                        break;
+                    case "DerivedReNameMethod":
+                        {
+                            result = this.Variation_Service_DerivedReNameMethod();
+                            Assert.Equal("derived", result);
+                        }
+                        break;
+                    case "BaseTwoWayMethod":
+                        {
+                            result = this.Variation_Service_BaseTwoWayMethod(clientString);
+                            Assert.Equal(clientString, result);
+                        }
+                        break;
+                    case "BaseDataContractMethod":
+                        {
+                            result = this.Variation_Service_BaseDataContractMethod(clientString);
+                            Assert.Equal(clientString, result);
+                        }
+                        break;
+                    case "BaseReNameMethod":
+                        {
+                            result = this.Variation_Service_BaseReNameMethod();
+                            Assert.Equal("base", result);
+                        }
+                        break;
+                    case "DerivedCallingBaseTwoWayMethod":
+                        {
+                            result = this.Variation_Service_DerivedCallingBaseTwoWayMethod(clientString);
+                            Assert.Equal(clientString, result);
+                        }
+                        break;
+                    case "DerivedCallingBaseDataContractMethod":
+                        {
+                            result = this.Variation_Service_DerivedCallingBaseDataContractMethod(clientString);
+                            Assert.Equal(clientString, result);
+                        }
+                        break;
+                    case "DerivedCallingBaseReNameMethod":
+                        {
+                            result = this.Variation_Service_DerivedCallingBaseReNameMethod();
+                            Assert.Equal("Derived", result);
+                        }
+                        break;
+                    default:
+                        {
+                            throw new Exception("Unknown ID : " + method);
+                        }
+                }
+            }
+        }
+
+        T GetProxy<T>()
+        {
+            var httpBinding = ClientHelper.GetBufferedModeBinding();
+            System.ServiceModel.ChannelFactory<T> channelFactory = new System.ServiceModel.ChannelFactory<T>(httpBinding, new System.ServiceModel.EndpointAddress(new Uri("http://localhost:8080/BasicWcfService/basichttp.svc")));
+
+            T proxy = channelFactory.CreateChannel();
+            return proxy;
+        }
+
+        #region Variation       
+
+        private string Variation_Service_DerivedOneWay(string clientString)
+        {
+            // Create the proxy
+            ClientContract.ISanityAParentB_857419_ContractDerived clientProxy = GetProxy<ClientContract.ISanityAParentB_857419_ContractDerived>();
+            // Send the two way message
+            _output.WriteLine("Testing [Variation_Service_DerivedOneWay]");
+            clientProxy.OneWayMethod(clientString);
+            string response = clientString;
+            _output.WriteLine($"Testing [Variation_Service_DerivedOneWay] returned <{response}>");
+            return response;
+        }
+
+        private string Variation_Service_DerivedStringMethod(string clientString)
+        {
+            // Create the proxy
+            var clientProxy = this.GetProxy<ClientContract.ISanityAParentB_857419_ContractDerived>();
+            // Send the two way message
+            _output.WriteLine("Testing [Variation_Service_DerivedStringMethod]");
+
+            string response = clientProxy.StringMethod(clientString);
+            _output.WriteLine($"Testing [Variation_Service_DerivedStringMethod] returned <{response}>");
+            return response;
+        }
+
+        private string Variation_Service_DerivedReNameMethod()
+        {
+            // Create the proxy          
+            var clientProxy = this.GetProxy<ClientContract.ISanityAParentB_857419_ContractDerived>();
+            // Send the two way message
+            _output.WriteLine("Testing [Variation_Service_DerivedReNameMethod]");
+            string response = clientProxy.Method("derived");
+            _output.WriteLine($"Testing [Variation_Service_DerivedReNameMethod] returned <{response}>");
+            return response;
+        }
+
+        private string Variation_Service_BaseTwoWayMethod(string clientString)
+        {
+            //// Create the proxy
+            var clientProxy = this.GetProxy<ClientContract.ISanityAParentB_857419_ContractBase>();
+            // Send the two way message
+            _output.WriteLine("Testing [Variation_Service_BaseTwoWayMethod]");
+            string response = clientProxy.TwoWayMethod(clientString);
+            _output.WriteLine($"Testing [Variation_Service_BaseTwoWayMethod] returned <{response}>");
+            return response;
+        }
+
+        private string Variation_Service_BaseDataContractMethod(string clientString)
+        {
+            // Create the proxy
+            var httpBinding = ClientHelper.GetBufferedModeBinding();
+            System.ServiceModel.ChannelFactory<ClientContract.ISanityAParentB_857419_ContractBase> channelFactory = new System.ServiceModel.ChannelFactory<ClientContract.ISanityAParentB_857419_ContractBase>(httpBinding, new System.ServiceModel.EndpointAddress(new Uri("http://localhost:8080/BasicWcfService/basichttp.svc")));
+
+
+            // var clientProxy = this.GetProxy<ClientContract.ISanityAParentB_857419_ContractBase>();
+            foreach (var operation in channelFactory.Endpoint.Contract.Operations)
+            {
+                DataContractSerializerOperationBehavior behavior =
+                         operation.OperationBehaviors.FirstOrDefault(
+                             x => x.GetType() == typeof(DataContractSerializerOperationBehavior)) as DataContractSerializerOperationBehavior;
+                behavior.DataContractResolver = new ManagerDataContractResolver<ClientContract.MyBaseDataType>();
+            }
+            var clientProxy = channelFactory.CreateChannel();
+
+            // Send the two way message
+            _output.WriteLine("Testing [Variation_Service_BaseTwoWayMethod]");
+            var dataObj = new ClientContract.MyBaseDataType();
+            dataObj.data = clientString;
+
+            var result = (ClientContract.MyBaseDataType)clientProxy.DataContractMethod(dataObj);
+            string response = result.data;
+
+            _output.WriteLine($"Testing [Variation_Service_BaseTwoWayMethod] returned <{response}>");
+            return response;
+        }
+
+        private string Variation_Service_BaseReNameMethod()
+        {
+            // Create the proxy
+            var clientProxy = this.GetProxy<ClientContract.ISanityAParentB_857419_ContractBase>();
+            // Send the two way message
+            _output.WriteLine("Testing [Variation_Service_BaseReNameMethod]");
+            string response = clientProxy.Method("base");
+            _output.WriteLine($"Testing [Variation_Service_BaseReNameMethod] returned <{response}>");
+            return response;
+        }
+
+        private string Variation_Service_DerivedCallingBaseTwoWayMethod(string clientString)
+        {
+            // Create the proxy
+            var clientProxy = this.GetProxy<ClientContract.ISanityAParentB_857419_ContractDerived>();
+            // Send the two way message
+            _output.WriteLine("Testing [Variation_Service_DerivedTwoWayMethod]");
+            clientProxy.TwoWayMethod(clientString);
+            string response = clientString;
+            _output.WriteLine($"Testing [Variation_Service_DerivedTwoWayMethod] returned <{response}>");
+            return response;
+        }
+
+        private string Variation_Service_DerivedCallingBaseDataContractMethod(string clientString)
+        {
+            // Create the proxy           
+            var clientProxy = this.GetProxy<ClientContract.ISanityAParentB_857419_ContractDerived>();
+
+            // Send the two way message
+            _output.WriteLine("Testing [Variation_Service_DerivedTwoWayMethod]");
+
+            //Form the DataContract input
+            var dataObj = new ClientContract.MyBaseDataType();
+            dataObj.data = clientString;
+
+            var result = (MyBaseDataType)clientProxy.DataContractMethod(dataObj);
+            string response = result.data;
+
+            _output.WriteLine($"Testing [Variation_Service_DerivedTwoWayMethod] returned <{response}>");
+            return response;
+        }
+
+        private string Variation_Service_DerivedCallingBaseReNameMethod()
+        {
+            // Create the proxy
+            var clientProxy = this.GetProxy<ClientContract.ISanityAParentB_857419_ContractDerived>();
+
+            // Send the two way message
+            _output.WriteLine("Testing [Variation_Service_DerivedReNameMethod]");
+            string response = clientProxy.Method("Derived");
+            _output.WriteLine($"Testing [Variation_Service_DerivedReNameMethod] returned <{response}>");
+            return response;
+        }
+
+        #endregion
+
+        internal class Startup
+        {
+            public static Type _service, _interface;
+
+            public void ConfigureServices(IServiceCollection services)
+            {
+                services.AddServiceModelServices();
+            }
+
+            public void Configure(IApplicationBuilder app, IHostingEnvironment env)
+            {
+                app.UseServiceModel(builder =>
+                {
+                    if (_service == typeof(Services.ServiceWithSCExtendingFromServiceWithSC))
+                    {
+                        builder.AddService<Services.ServiceWithSCExtendingFromServiceWithSC>();
+                        builder.AddServiceEndpoint<Services.ServiceWithSCExtendingFromServiceWithSC>(_service, new CoreWCF.BasicHttpBinding(), "/BasicWcfService/basichttp.svc");
+                    }
+
+                    if (_service == typeof(Services.ServiceWithSCDerivingFromNonSCExtendingSC))
+                    {
+                        builder.AddService<Services.ServiceWithSCDerivingFromNonSCExtendingSC>();
+                        builder.AddServiceEndpoint<Services.ServiceWithSCDerivingFromNonSCExtendingSC, ServiceContract.NonSCExtendingSC_1138907>(new CoreWCF.BasicHttpBinding(), "/BasicWcfService/basichttp.svc");
+                    }
+
+                    if (_service == typeof(Services.ServiceWithSCDerivingFromSC))
+                    {
+                        builder.AddService<Services.ServiceWithSCDerivingFromSC>();
+                        builder.AddServiceEndpoint<Services.ServiceWithSCDerivingFromSC, ServiceContract.SCInterface_1138907>(new CoreWCF.BasicHttpBinding(), "/BasicWcfService/basichttp.svc");
+                    }
+                });
+            }
+        }
+
+        internal class StartupEndpoints
+        {
+            public static string ServiceType;
+            public static string ClientType;
+
+            public void ConfigureServices(IServiceCollection services)
+            {
+                services.AddServiceModelServices();
+            }
+
+            public void Configure(IApplicationBuilder app, IHostingEnvironment env)
+            {
+                Type serviceContractType = null;
+                app.UseServiceModel(builder =>
+                {
+                    builder.AddService<Services.Service_1144850>();
+
+                    switch (ServiceType.ToLower())
+                    {
+                        case "abservice":
+                            serviceContractType = typeof(SCInterfaceAB_1144850);
+                            builder.AddServiceEndpoint<Services.Service_1144850, SCInterfaceAB_1144850>(new CoreWCF.BasicHttpBinding(), "/BasicWcfService/basichttp.svc");
+                            break;
+                        case "aservice":
+                            serviceContractType = typeof(SCInterfaceA_1144850);
+                            builder.AddServiceEndpoint<Services.Service_1144850, SCInterfaceA_1144850>(new CoreWCF.BasicHttpBinding(), "/BasicWcfService/basichttp.svc");
+                            break;
+                        case "bservice":
+                            serviceContractType = typeof(SCInterfaceB_1144850);
+                            builder.AddServiceEndpoint<Services.Service_1144850, SCInterfaceB_1144850>(new CoreWCF.BasicHttpBinding(), "/BasicWcfService/basichttp.svc");
+                            break;
+                        default:
+                            throw new ApplicationException("Unsupported ServiceType in tef");
+                    }
+                });
+            }
+        }
+
+        internal class StartupSanityAParentB
+        {
+            public static string _method;
+
+            public void ConfigureServices(IServiceCollection services)
+            {
+                services.AddServiceModelServices();
+            }
+
+            public void Configure(IApplicationBuilder app, IHostingEnvironment env)
+            {
+                app.UseServiceModel(builder =>
+                {
+                    builder.AddService<Services.SanityAParentB_857419_Service_Both>();
+
+                    switch (_method)
+                    {
+                        case "DerivedOneWay":
+                        case "DerivedStringMethod":
+                        case "DerivedReNameMethod":
+                        case "DerivedCallingBaseTwoWayMethod":
+                        case "DerivedCallingBaseDataContractMethod":
+                        case "DerivedCallingBaseReNameMethod":
+                            builder.AddServiceEndpoint<Services.SanityAParentB_857419_Service_Both, ISanityAParentB_857419_ContractDerived>(new CoreWCF.BasicHttpBinding(), "/BasicWcfService/basichttp.svc");
+                            break;
+                        case "BaseTwoWayMethod":
+                        case "BaseReNameMethod":
+                        case "BaseDataContractMethod":
+                            builder.AddServiceEndpoint<Services.SanityAParentB_857419_Service_Both, ISanityAParentB_857419_ContractBase>(new CoreWCF.BasicHttpBinding(), "/BasicWcfService/basichttp.svc");
+                            break;
+                        default:
+                            throw new ApplicationException("Unsupported ServiceType");
+                    }
+                });
+            }
+        }
+    }
+}
diff --git a/src/CoreWCF.Http/tests/Services/AggregateExceptionServices.cs b/src/CoreWCF.Http/tests/Services/AggregateExceptionServices.cs
new file mode 100644
index 0000000..080852d
--- /dev/null
+++ b/src/CoreWCF.Http/tests/Services/AggregateExceptionServices.cs
@@ -0,0 +1,69 @@
+﻿using CoreWCF;
+using ServiceContract;
+using System;
+using System.Threading.Tasks;
+
+namespace Services
+{
+    public class AggregateExceptionService : IAggregateExceptionService
+    {
+        public const string FaultId = "101";
+
+        public const string ErrorMessage = "Error has occurred while performing an operation.";
+
+        public Task SimpleOperationThrowingFault()
+        {
+            Task resultTsk = Task.Factory.StartNew(() =>
+            {
+                throw new FaultException<SampleServiceFault>(new SampleServiceFault() { ID = FaultId, Message = ErrorMessage }, new FaultReason("SampleServiceFault"));
+            });
+
+            return resultTsk;
+        }
+
+        public void ServiceOpWithMultipleTasks()
+        {
+            Task resultTsk1 = Task.Factory.StartNew(() =>
+            {
+                throw new InvalidOperationException("Invalid operation is being performed");
+            });
+
+            Task resultTsk2 = Task.Factory.StartNew(() =>
+            {
+                throw new ArgumentNullException("Some param");
+            });
+
+            Task resultTsk3 = Task.Factory.StartNew(() =>
+            {
+                throw new NullReferenceException("object reference is null.");
+            });
+
+            try
+            {
+                Task.WaitAll(resultTsk1, resultTsk2, resultTsk3);
+            }
+            catch (AggregateException)
+            {
+                throw new FaultException<SampleServiceFault>(
+                                                    new SampleServiceFault() { ID = FaultId, Message = ErrorMessage },
+                                                    new FaultReason("SampleServiceFault"));
+            }
+        }
+
+        public Task ServiceOpWithChainedTasks_ThrowFaultExceptionInOneTask()
+        {
+            Task chainedTask = Task.Factory.StartNew(() =>
+            {
+                throw new InvalidOperationException("Invalid operation is being performed");
+            }).ContinueWith((tsk) =>
+            {
+                throw new ArgumentNullException("param1");
+            }).ContinueWith((tsk) =>
+            {
+                throw new FaultException<SampleServiceFault>(new SampleServiceFault() { ID = FaultId, Message = ErrorMessage }, new FaultReason("SampleServiceFault"));
+            });
+
+            return chainedTask;
+        }
+    }
+}
diff --git a/src/CoreWCF.Http/tests/Services/FaultContractServices.cs b/src/CoreWCF.Http/tests/Services/FaultContractServices.cs
new file mode 100644
index 0000000..0cc48fc
--- /dev/null
+++ b/src/CoreWCF.Http/tests/Services/FaultContractServices.cs
@@ -0,0 +1,354 @@
+﻿using CoreWCF;
+using CoreWCF.Channels;
+using System;
+using System.IO;
+using System.Linq;
+using System.Text;
+
+namespace Services
+{
+    [ServiceBehavior]
+    public class FaultOnDiffContractsAndOpsService : ServiceContract.ITestFaultOpContract
+    {
+        #region TwoWay_Methods
+        public string TwoWay_Method(string s)
+        {
+            if (s.Length == 0)
+            {
+                string faultToThrow = "Test fault thrown from a service";
+                throw new FaultException<string>(faultToThrow);
+            }
+
+            return s;
+        }
+
+        public void TwoWayVoid_Method(string s)
+        {
+            if (s.Length == 0)
+            {
+                string faultToThrow = "Test fault thrown from a service";
+                throw new FaultException<string>(faultToThrow);
+            }
+
+            return;
+        }
+        #endregion
+
+        #region TwoWayStream Method
+        public Stream TwoWayStream_Method(Stream s)
+        {
+            if (s.ReadByte() != -1)
+            {
+                string faultToThrow = "Test fault thrown from a service";
+                throw new FaultException<string>(faultToThrow);
+            }
+            else
+            {
+                StreamReader sr = new StreamReader(s, Encoding.UTF8);
+                sr.ReadToEnd();
+            }
+
+            return new MemoryStream();
+        }
+        #endregion
+
+        #region TwoWayAsync Method
+        delegate string TwoWayMethodAsync(string s);
+
+        public async System.Threading.Tasks.Task<string> TwoWayAsync_MethodAsync(string s)
+        {
+            TwoWayMethodAsync del = ProcessTwoWayAsync;
+            var workTask = System.Threading.Tasks.Task.Run(() => del.Invoke(s));
+            return await workTask;
+        }
+
+        // Worker
+        public string ProcessTwoWayAsync(string s)
+        {
+            // This is where the incoming message processing is handled.
+            if (s.Length == 0)
+            {
+                string faultToThrow = "Test fault thrown from a service";
+                throw new FaultException<string>(faultToThrow);
+            }
+
+            return "Async call was valid";
+        }
+        #endregion
+
+        #region MessageContract Methods
+        public ServiceContract.FaultMsgContract MessageContract_Method(ServiceContract.FaultMsgContract fmc)
+        {
+            if (fmc.Name.Length == 0)
+            {
+                string faultToThrow = "Test fault thrown from a service";
+                throw new FaultException<string>(faultToThrow);
+            }
+
+            return fmc;
+        }
+
+        public string MessageContractParams_Method(int id, string name, DateTime dateTime)
+        {
+            if (name.Length == 0)
+            {
+                string faultToThrow = "Test fault thrown from a service";
+                throw new FaultException<string>(faultToThrow);
+            }
+
+            return $"{id} {name} {dateTime}";
+        }
+        #endregion
+
+        #region Untyped Method
+        public CoreWCF.Channels.Message Untyped_Method(CoreWCF.Channels.Message msgIn)
+        {
+            CoreWCF.Channels.MessageVersion mv = OperationContext.Current.IncomingMessageHeaders.MessageVersion;
+            string faultToThrow = "Test fault thrown from a service";
+            if (msgIn != null)
+            {
+                throw new FaultException<string>(faultToThrow);
+            }
+
+            return CoreWCF.Channels.Message.CreateMessage(mv, CoreWCF.Channels.MessageFault.CreateFault(new FaultCode("Sender"), new FaultReason("Unspecified ServiceModel Fault"), "unspecified",
+                new System.Runtime.Serialization.DataContractSerializer(typeof(string)), "", ""), "");
+        }
+
+        public CoreWCF.Channels.Message Untyped_MethodReturns(CoreWCF.Channels.Message msgIn)
+        {
+            CoreWCF.Channels.MessageVersion mv = OperationContext.Current.IncomingMessageHeaders.MessageVersion;
+            string faultToThrow = "Test fault thrown from a service";
+            if (msgIn != null)
+            {
+                return CoreWCF.Channels.Message.CreateMessage(mv, CoreWCF.Channels.MessageFault.CreateFault(new FaultCode("Sender"), new FaultReason("Unspecified ServiceModel Fault"), faultToThrow,
+                new System.Runtime.Serialization.DataContractSerializer(typeof(string)), "", ""), "");
+            }
+
+            return CoreWCF.Channels.Message.CreateMessage(mv, CoreWCF.Channels.MessageFault.CreateFault(new FaultCode("Sender"), new FaultReason("Unspecified ServiceModel Fault"), "unspeficied",
+                new System.Runtime.Serialization.DataContractSerializer(typeof(string)), "", ""), "");
+        }
+        #endregion
+    }
+
+    [ServiceBehavior]
+    public class DatacontractFaultService : ServiceContract.ITestDataContractFault
+    {
+        private const string VarSomeFault = "somefault";
+        private const string VarOuterFault = "outerfault";
+        private const string VarComplexFault = "complexfault";
+
+        private void ThrowTestFault(string faultType)
+        {
+            //this.tenv.ExecutionEngine.Results.Write("Throwing Fault'[{0}]", faultToThrow);
+            switch (faultType.ToLower())
+            {
+                case VarSomeFault:
+                    throw new FaultException<ServiceContract.SomeFault>(new ServiceContract.SomeFault(123456789, "SomeFault"));
+                case VarOuterFault:
+                    ServiceContract.SomeFault sf = new ServiceContract.SomeFault(123456789, "SomeFault as innerfault");
+                    ServiceContract.OuterFault of = new ServiceContract.OuterFault
+                    {
+                        InnerFault = sf
+                    };
+                    throw new FaultException<ServiceContract.OuterFault>(of);
+                case VarComplexFault:
+                    ServiceContract.ComplexFault cf = GetComplexFault();
+                    throw new FaultException<ServiceContract.ComplexFault>(cf);
+                default:
+                    throw new ApplicationException("Unknown value of FaultString specified: " + faultType);
+            }
+        }
+
+        #region TwoWay_Methods
+        public string TwoWay_Method(string s)
+        {
+            if (s.Length != 0)
+            {
+                ThrowTestFault(s);
+            }
+
+            return s;
+        }
+
+        public void TwoWayVoid_Method(string s)
+        {
+            if (s.Length != 0)
+            {
+                ThrowTestFault(s);
+            }
+
+            return;
+        }
+        #endregion
+
+        #region TwoWayStream Method
+        public Stream TwoWayStream_Method(Stream s)
+        {
+            StreamReader sr = new StreamReader(s, Encoding.UTF8);
+            ThrowTestFault(sr.ReadToEnd());
+            Stream outStream = new MemoryStream();
+            return outStream;
+        }
+        #endregion
+
+        #region TwoWayAsync Method
+
+        public async System.Threading.Tasks.Task<string> TwoWayAsync_Method(string s)
+        {
+            var workTask = System.Threading.Tasks.Task.Run(() => ProcessTwoWayAsync(s));
+            return await workTask;
+        }
+
+        // Worker
+        public string ProcessTwoWayAsync(string s)
+        {
+            // This is where the incoming message processing is handled.
+            if (s.Length != 0)
+            {
+                ThrowTestFault(s);
+            }
+
+            string response = "Async call was valid";
+            return response;
+        }
+        #endregion
+
+        #region MessageContract Methods
+        public ServiceContract.FaultMsgContract MessageContract_Method(ServiceContract.FaultMsgContract fmc)
+        {
+            if (fmc.Name.Length != 0)
+            {
+                ThrowTestFault(fmc.Name);
+            }
+
+            return fmc;
+        }
+
+#pragma warning disable IDE0060 // Remove unused parameter
+        public string MessageContractParams_Method(int id, string Name, DateTime dateTime)
+#pragma warning restore IDE0060 // Remove unused parameter
+        {
+            if (Name.Length != 0)
+            {
+                ThrowTestFault(Name);
+            }
+
+            return Name;
+        }
+        #endregion
+
+        #region Untyped Method
+        public CoreWCF.Channels.Message Untyped_Method(CoreWCF.Channels.Message msgIn)
+        {
+            if (null != msgIn)
+            {
+                ThrowTestFault(GetTestStrFromMsg(msgIn));
+            }
+
+            return CoreWCF.Channels.Message.CreateMessage(CoreWCF.Channels.MessageVersion.Soap11, CoreWCF.Channels.MessageFault.CreateFault(new FaultCode("Sender"), new FaultReason("Unspecified ServiceModel Fault"), "unspecified",
+                new System.Runtime.Serialization.DataContractSerializer(typeof(string)), "", ""), "http://www.w3.org/2005/08/addressing/fault");
+        }
+
+        public CoreWCF.Channels.Message Untyped_MethodReturns(CoreWCF.Channels.Message msgIn)
+        {
+            MessageVersion mv = MessageVersion.Soap11;
+
+            if (null != msgIn)
+            {
+                string faultString = GetTestStrFromMsg(msgIn);
+                switch (faultString)
+                {
+                    case VarSomeFault:
+                        return CoreWCF.Channels.Message.CreateMessage(mv, CoreWCF.Channels.MessageFault.CreateFault(new FaultCode("Sender"), new FaultReason("Unspecified ServiceModel Fault"), (object)new ServiceContract.SomeFault(123456789, "SomeFault"),
+        new System.Runtime.Serialization.DataContractSerializer(typeof(ServiceContract.SomeFault)), "", ""), "http://tempuri.org/ITestDataContractFault/Untyped_MethodReturnsSomeFaultFault");
+                    case VarOuterFault:
+                        ServiceContract.SomeFault sf = new ServiceContract.SomeFault(123456789, "SomeFault as innerfault");
+                        ServiceContract.OuterFault of = new ServiceContract.OuterFault();
+                        of.InnerFault = sf;
+                        return CoreWCF.Channels.Message.CreateMessage(mv, CoreWCF.Channels.MessageFault.CreateFault(new FaultCode("Sender"), new FaultReason("Unspecified ServiceModel Fault"), (object)of,
+                new System.Runtime.Serialization.DataContractSerializer(typeof(ServiceContract.OuterFault)), "", ""), "http://tempuri.org/ITestDataContractFault/Untyped_MethodReturnsOuterFaultFault");
+                    case VarComplexFault:
+                        ServiceContract.ComplexFault cf = GetComplexFault();
+                        return CoreWCF.Channels.Message.CreateMessage(mv, CoreWCF.Channels.MessageFault.CreateFault(new FaultCode("Sender"), new FaultReason("Unspecified ServiceModel Fault"), (object)cf,
+        new System.Runtime.Serialization.DataContractSerializer(typeof(ServiceContract.ComplexFault)), "", ""), "http://tempuri.org/ITestDataContractFault/Untyped_MethodReturnsComplexFaultFault");
+
+                    default:
+                        throw new ApplicationException("Unknown value of FaultString specified: " + faultString);
+                }
+            }
+
+            return CoreWCF.Channels.Message.CreateMessage(mv, CoreWCF.Channels.MessageFault.CreateFault(new FaultCode("Sender"), new FaultReason("Unspecified ServiceModel Fault"), "unspecified",
+        new System.Runtime.Serialization.DataContractSerializer(typeof(string)), "", ""), "http://www.w3.org/2005/08/addressing/fault");
+        }
+        #endregion
+
+        private string GetTestStrFromMsg(Message msgIn)
+        {
+            string msgBody = msgIn.GetReaderAtBodyContents().ReadInnerXml();
+            if (msgBody.Contains(VarSomeFault))
+            {
+                return VarSomeFault;
+            }
+
+            if (msgBody.Contains(VarOuterFault))
+            {
+                return VarOuterFault;
+            }
+
+            if (msgBody.Contains(VarComplexFault))
+            {
+                return VarComplexFault;
+            }
+
+            return "";
+        }
+
+        private ServiceContract.ComplexFault GetComplexFault()
+        {
+            int errorInt = 50;
+            string errorString = "This is a test error string for fault tests.";
+
+            ServiceContract.SomeFault errorSomeFault = new ServiceContract.SomeFault(123456789, "SomeFault in complexfault");
+
+            int[] errorIntArray = new int[]
+                    {
+                        int.MaxValue,
+                        int.MinValue,
+                        0,
+                        1,
+                        -1,
+                        50,
+                        -50
+                    };
+
+            string[] errorStringArray = new string[]
+                    {
+                        string.Empty,
+                        null,
+                        "String Value"
+                    };
+
+            byte[] errorByteArray = new byte[128];
+            for (int i = 0; i < errorByteArray.Length; i++)
+                errorByteArray[i] = (byte)i;
+
+            ServiceContract.SomeFault[] errorSomeFaultArray = new ServiceContract.SomeFault[]
+                    {
+                        errorSomeFault,
+                        null,
+                        new ServiceContract.SomeFault(234, "Second somefault in complexfault")
+                    };
+
+            ServiceContract.ComplexFault cf = new ServiceContract.ComplexFault();
+            cf.ErrorInt = errorInt;
+            cf.ErrorString = errorString;
+            cf.ErrorByteArray = errorByteArray;
+            cf.SomeFault = errorSomeFault;
+            cf.ErrorIntArray = errorIntArray;
+            cf.ErrorStringArray = errorStringArray;
+            cf.SomeFaultArray = errorSomeFaultArray;
+
+            return cf;
+        }
+    }
+}
diff --git a/src/CoreWCF.Http/tests/Services/OpContractInvalidActionReplyActionSerivce.cs b/src/CoreWCF.Http/tests/Services/OpContractInvalidActionReplyActionSerivce.cs
new file mode 100644
index 0000000..7d92adf
--- /dev/null
+++ b/src/CoreWCF.Http/tests/Services/OpContractInvalidActionReplyActionSerivce.cs
@@ -0,0 +1,21 @@
+﻿using Xunit;
+
+namespace Services
+{
+    public class OpContractInvalidActionSerivce : ServiceContract.IOpContractInvalidAction
+    {
+        public void TestMethodNullAction(int id)
+        {
+            Assert.False(true, $"Parameter in: {id}, but service should throw before reaching here.");
+        }
+    }
+
+    public class OpContractInvalidReplyActionSerivce : ServiceContract.IOpContractInvalidReplyAction
+    {
+        public int TestMethodNullReplyAction(int id)
+        {
+            Assert.False(true, $"Parameter in: {id}, but service should throw before reaching here.");
+            return id;
+        }
+    }
+}
diff --git a/src/CoreWCF.Http/tests/Services/RequestReplyService.cs b/src/CoreWCF.Http/tests/Services/RequestReplyService.cs
new file mode 100644
index 0000000..c35853b
--- /dev/null
+++ b/src/CoreWCF.Http/tests/Services/RequestReplyService.cs
@@ -0,0 +1,113 @@
+﻿using CoreWCF;
+using CoreWCF.Channels;
+using Helpers;
+using ServiceContract;
+using System;
+using System.Collections.Generic;
+using System.IO;
+using System.Net;
+using System.Threading;
+
+namespace Services
+{
+    [ServiceBehavior(InstanceContextMode = InstanceContextMode.Single)]
+    public class RequestReplyService : IRequestReplyService
+    {
+        static List<string> log = new List<string>();
+        static int seed = DateTime.Now.Millisecond;
+        static Random rand = new Random(seed);
+        FlowControlledStream localStream;
+
+        public void UploadData(string data)
+        {
+            if (data.Contains("ContentToReplace") || data.Contains("ReplacedContent") || data.Contains("ResponseReplaceThisContent"))
+            {
+                log.Add(string.Format("UploadData received {0}", data));
+            }
+            else
+            {
+                log.Add(string.Format("UploadData received {0} length string.", data.Length));
+            }
+
+            // Access the RemoteEndpointMessageProperty
+            RemoteEndpointMessageProperty remp = OperationContext.Current.IncomingMessageProperties[RemoteEndpointMessageProperty.Name] as RemoteEndpointMessageProperty;
+            IPHostEntry hostEntry = Dns.GetHostEntry(Environment.MachineName);
+            bool success = false;
+            foreach (IPAddress address in hostEntry.AddressList)
+            {
+                if (remp.Address == address.ToString())
+                {
+                    success = true;
+                    break;
+                }
+            }
+
+            if (!success)
+            {
+                log.Add("RemoteEndpointMessageProperty did not contain the address of this machine.");
+            }
+        }
+
+        public string DownloadData()
+        {
+            string data = CommonUtility.CreateInterestingString(rand.Next(512, 4096));
+            log.Add(string.Format("DownloadData returning {0} length string.", data.Length));
+            return data;
+        }
+
+        public void UploadStream(Stream stream)
+        {
+            int readResult;
+            int bytesRead = 0;
+            byte[] buffer = new byte[1000];
+            do
+            {
+                readResult = stream.Read(buffer, 0, buffer.Length);
+                bytesRead += readResult;
+            }
+            while (readResult != 0);
+
+            stream.Close();
+
+            log.Add(string.Format("UploadStream read {0} bytes from the client's stream.", bytesRead));
+        }
+
+        public Stream DownloadStream()
+        {
+            log.Add("DownloadStream");
+            localStream = new FlowControlledStream();
+            localStream.ReadThrottle = TimeSpan.FromMilliseconds(500);
+            localStream.StreamDuration = TimeSpan.FromSeconds(1);
+
+            return localStream;
+        }
+
+        public Stream DownloadCustomizedStream(TimeSpan readThrottle, TimeSpan streamDuration)
+        {
+            log.Add("DownloadStream");
+            localStream = new FlowControlledStream();
+            localStream.ReadThrottle = readThrottle;
+            localStream.StreamDuration = streamDuration;
+
+            return localStream;
+        }
+
+        public void ThrowingOperation(Exception exceptionToThrow)
+        {
+            log.Add("ThrowingOperation");
+            throw exceptionToThrow;
+        }
+
+        public string DelayOperation(TimeSpan delay)
+        {
+            log.Add("DelayOperation");
+            Thread.CurrentThread.Join(delay);
+            return "Done with delay.";
+        }
+
+        public List<string> GetLog()
+        {
+            return log;
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/CoreWCF.Http/tests/Services/SanityAParentB_857419_Service.cs b/src/CoreWCF.Http/tests/Services/SanityAParentB_857419_Service.cs
new file mode 100644
index 0000000..0ddf19d
--- /dev/null
+++ b/src/CoreWCF.Http/tests/Services/SanityAParentB_857419_Service.cs
@@ -0,0 +1,63 @@
+using CoreWCF;
+using ServiceContract;
+using System;
+
+namespace Services
+{
+    [ServiceBehavior]
+    public class SanityAParentB_857419_Service_Both : ISanityAParentB_857419_ContractBase, ISanityAParentB_857419_ContractDerived
+    {
+        #region IContractDerived Members
+
+        public void OneWayMethod(object o)
+        {
+            string input = o as string;
+            if (input == null) throw new NullReferenceException("clientString was not in the SharedContext");
+            return;
+        }
+
+        public string StringMethod(string s)
+        {
+            Console.WriteLine(s);           
+            return s;
+        }
+
+        string ISanityAParentB_857419_ContractDerived.Method(string input)
+        {
+            if (input == null || input.ToLower().Contains("derived") == false)
+            {
+                throw new Exception("Wrong value received = <" + input + ">");
+            }
+           
+            return input;
+        }
+
+        #endregion
+
+        public string TwoWayMethod(string input)
+        {
+            if (input == null) throw new NullReferenceException("clientString was not in the SharedContext");
+            return input;
+        }
+
+        public object DataContractMethod(object o)
+        {
+            MyBaseDataType data = o as MyBaseDataType;
+            if (data == null) throw new NullReferenceException("DataContractMethod received null " + o);
+            string input = data.data;
+            if (input == null) throw new NullReferenceException("clientString was not in the SharedContext");
+
+            return data;
+        }
+
+        public string Method(string input)
+        {
+            if (input == null || input.ToLower().Contains("base") == false)
+            {
+                throw new Exception("Wrong value received = <" + input + ">");
+            }
+            return input;
+        }
+    }
+}
+
diff --git a/src/CoreWCF.Http/tests/Services/ServiceContractName_784749_Services.cs b/src/CoreWCF.Http/tests/Services/ServiceContractName_784749_Services.cs
new file mode 100644
index 0000000..60a238f
--- /dev/null
+++ b/src/CoreWCF.Http/tests/Services/ServiceContractName_784749_Services.cs
@@ -0,0 +1,77 @@
+﻿using CoreWCF;
+using ServiceContract;
+
+namespace Services
+{
+    [ServiceBehavior]
+    public class ServiceContractName_784749_XmlCharacters_Service : IServiceContractName_784749_XmlCharacters_Service
+    {
+        string IServiceContractName_784749_XmlCharacters_Service.Method1(string input)
+        {
+            return input;
+        }
+    }
+
+    [ServiceBehavior]
+    public class ServiceContractName_784749_WhiteSpace_Service : IServiceContractName_784749_WhiteSpace_Service
+    {
+        string IServiceContractName_784749_WhiteSpace_Service.Method2(string input)
+        {
+            return input;
+        }
+    }
+
+    [ServiceBehavior]
+    public class ServiceContractName_784749_XMLEncoded_Service : IServiceContractName_784749_XMLEncoded_Service
+    {
+        string IServiceContractName_784749_XMLEncoded_Service.Method3(string input)
+        {
+            return input;
+        }
+    }
+
+    [ServiceBehavior]
+    public class ServiceContractName_784749_NonAlphaCharacters_Service : IServiceContractName_784749_NonAlphaCharacters_Service
+    {
+        string IServiceContractName_784749_NonAlphaCharacters_Service.Method4(string input)
+        {
+            return input;
+        }
+    }
+
+    [ServiceBehavior]
+    public class ServiceContractName_784749_LocalizedCharacters_Service : IServiceContractName_784749_LocalizedCharacters_Service
+    {
+        string IServiceContractName_784749_LocalizedCharacters_Service.Method5(string input)
+        {
+            return input;
+        }
+    }
+
+    [ServiceBehavior]
+    public class ServiceContractName_784749_SurrogateCharacters_Service : IServiceContractName_784749_SurrogateCharacters_Service
+    {
+        string IServiceContractName_784749_SurrogateCharacters_Service.Method6(string input)
+        {
+            return input;
+        }
+    }
+
+    [ServiceBehavior]
+    public class ServiceContractName_784749_XMLReservedCharacters_Service : IServiceContractName_784749_XMLReservedCharacters_Service
+    {
+        string IServiceContractName_784749_XMLReservedCharacters_Service.Method7(string input)
+        {
+            return input;
+        }
+    }
+
+    [ServiceBehavior]
+    public class ServiceContractName_784749_URI_Service : IServiceContractName_784749_URI_Service
+    {
+        string IServiceContractName_784749_URI_Service.Method8(string input)
+        {
+            return input;
+        }
+    }
+}
diff --git a/src/CoreWCF.Http/tests/Services/ServiceContractNamespace_784756_Services.cs b/src/CoreWCF.Http/tests/Services/ServiceContractNamespace_784756_Services.cs
new file mode 100644
index 0000000..2bdadb0
--- /dev/null
+++ b/src/CoreWCF.Http/tests/Services/ServiceContractNamespace_784756_Services.cs
@@ -0,0 +1,77 @@
+﻿using CoreWCF;
+using ServiceContract;
+
+namespace Services
+{
+    [ServiceBehavior]
+    public class ServiceContractNamespace_784756_XmlCharacters_Service : IServiceContractNamespace_784756_XmlCharacters_Service
+    {
+        string IServiceContractNamespace_784756_XmlCharacters_Service.Method1(string input)
+        {
+            return input;
+        }
+    }
+
+    [ServiceBehavior]
+    public class ServiceContractNamespace_784756_WhiteSpace_Service : IServiceContractNamespace_784756_WhiteSpace_Service
+    {
+        string IServiceContractNamespace_784756_WhiteSpace_Service.Method2(string input)
+        {
+            return input;
+        }
+    }
+
+    [ServiceBehavior]
+    public class ServiceContractNamespace_784756_XMLEncoded_Service : IServiceContractNamespace_784756_XMLEncoded_Service
+    {
+        string IServiceContractNamespace_784756_XMLEncoded_Service.Method3(string input)
+        {
+            return input;
+        }
+    }
+
+    [ServiceBehavior]
+    public class ServiceContractNamespace_784756_NonAlphaCharacters_Service : IServiceContractNamespace_784756_NonAlphaCharacters_Service
+    {
+        string IServiceContractNamespace_784756_NonAlphaCharacters_Service.Method4(string input)
+        {
+            return input;
+        }
+    }
+
+    [ServiceBehavior]
+    public class ServiceContractNamespace_784756_LocalizedCharacters_Service : IServiceContractNamespace_784756_LocalizedCharacters_Service
+    {
+        string IServiceContractNamespace_784756_LocalizedCharacters_Service.Method5(string input)
+        {
+            return input;
+        }
+    }
+
+    [ServiceBehavior]
+    public class ServiceContractNamespace_784756_SurrogateCharacters_Service : IServiceContractNamespace_784756_SurrogateCharacters_Service
+    {      
+        string IServiceContractNamespace_784756_SurrogateCharacters_Service.Method6(string input)
+        {            
+            return input;
+        }
+    }
+
+    [ServiceBehavior]
+    public class ServiceContractNamespace_784756_XMLReservedCharacters_Service : IServiceContractNamespace_784756_XMLReservedCharacters_Service
+    {
+        string IServiceContractNamespace_784756_XMLReservedCharacters_Service.Method7(string input)
+        {
+            return input;
+        }
+    }
+
+    [ServiceBehavior]
+    public class ServiceContractNamespace_784756_URI_Service : IServiceContractNamespace_784756_URI_Service
+    {
+        string IServiceContractNamespace_784756_URI_Service.Method8(string input)
+        {
+            return input;
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/CoreWCF.Http/tests/Services/ServiceWithSC.cs b/src/CoreWCF.Http/tests/Services/ServiceWithSC.cs
new file mode 100644
index 0000000..3707648
--- /dev/null
+++ b/src/CoreWCF.Http/tests/Services/ServiceWithSC.cs
@@ -0,0 +1,14 @@
+﻿using CoreWCF;
+
+namespace Services
+{
+	[ServiceContract]
+	public class ServiceWithSC
+	{
+		[OperationContract]
+		public string BaseStringMethod(string str)
+		{
+			return str;
+		}
+	}
+}
diff --git a/src/CoreWCF.Http/tests/Services/ServiceWithSCDerivingFromNonSCExtendingSC.cs b/src/CoreWCF.Http/tests/Services/ServiceWithSCDerivingFromNonSCExtendingSC.cs
new file mode 100644
index 0000000..4840476
--- /dev/null
+++ b/src/CoreWCF.Http/tests/Services/ServiceWithSCDerivingFromNonSCExtendingSC.cs
@@ -0,0 +1,26 @@
+﻿using CoreWCF;
+using ServiceContract;
+using System;
+
+namespace Services
+{
+	[ServiceContract]
+	public class ServiceWithSCDerivingFromNonSCExtendingSC : NonSCExtendingSC_1138907, SCInterface_1138907
+	{
+		public string SCStringMethod(string str)
+		{
+			throw new ApplicationException("Failed:Not expected to be invoked!!");
+		}
+
+		public string NonSCStringMethod(string str)
+		{
+			throw new ApplicationException("Failed:Not expected to be invoked!!");
+		}
+
+		[OperationContract]
+		public string ServiceWithSCStringMethod(string str)
+		{
+			throw new ApplicationException("Failed:Not expected to be invoked!!");
+		}
+	}
+}
diff --git a/src/CoreWCF.Http/tests/Services/ServiceWithSCDerivingFromSC.cs b/src/CoreWCF.Http/tests/Services/ServiceWithSCDerivingFromSC.cs
new file mode 100644
index 0000000..61fad5b
--- /dev/null
+++ b/src/CoreWCF.Http/tests/Services/ServiceWithSCDerivingFromSC.cs
@@ -0,0 +1,20 @@
+﻿using CoreWCF;
+using System;
+
+namespace Services
+{
+	[ServiceContract]
+	public class ServiceWithSCDerivingFromSC : ServiceContract.SCInterface_1138907
+	{
+		public string SCStringMethod(string str)
+		{
+			throw new ApplicationException("Failed:Not expected to be invoked!!");
+		}
+
+		[OperationContract]
+		public string ServiceWithSCStringMethod(string str)
+		{
+			throw new ApplicationException("Failed:Not expected to be invoked!!");
+		}
+	}
+}
diff --git a/src/CoreWCF.Http/tests/Services/ServiceWithSCExtendingFromServiceWithSC.cs b/src/CoreWCF.Http/tests/Services/ServiceWithSCExtendingFromServiceWithSC.cs
new file mode 100644
index 0000000..6768b5b
--- /dev/null
+++ b/src/CoreWCF.Http/tests/Services/ServiceWithSCExtendingFromServiceWithSC.cs
@@ -0,0 +1,15 @@
+﻿using CoreWCF;
+using System;
+
+namespace Services
+{
+	[ServiceContract]
+	public class ServiceWithSCExtendingFromServiceWithSC : ServiceWithSC
+	{
+		[OperationContract]
+		private string DerivedStringMethod(string str)
+		{
+			throw new ApplicationException("Failed:Not expected to be invoked!!");
+		}
+	}
+}
diff --git a/src/CoreWCF.Http/tests/Services/Service_1144850.cs b/src/CoreWCF.Http/tests/Services/Service_1144850.cs
new file mode 100644
index 0000000..47dd06b
--- /dev/null
+++ b/src/CoreWCF.Http/tests/Services/Service_1144850.cs
@@ -0,0 +1,22 @@
+﻿using ServiceContract;
+
+namespace Services
+{
+	public class Service_1144850 : SCInterfaceAB_1144850, SCInterfaceA_1144850, SCInterfaceB_1144850
+	{
+		public string StringMethodAB(string str)
+		{
+			return str;
+		}
+
+		public string StringMethodA(string str)
+		{
+			return str;
+		}
+
+		public string StringMethodB(string str)
+		{
+			return str;
+		}
+	}
+}
diff --git a/src/CoreWCF.Http/tests/Services/TaskCollectionsTestService.cs b/src/CoreWCF.Http/tests/Services/TaskCollectionsTestService.cs
new file mode 100644
index 0000000..d36b113
--- /dev/null
+++ b/src/CoreWCF.Http/tests/Services/TaskCollectionsTestService.cs
@@ -0,0 +1,89 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Text;
+using System.Threading.Tasks;
+using ServiceContract;
+
+namespace Services
+{
+    public class TaskCollectionsTest : ITaskCollectionsTest
+    {
+        public Task<LinkedList<int>> GetList()
+        {
+            Task<LinkedList<int>> task = new Task<LinkedList<int>>(delegate
+            {
+                LinkedList<int> linkedList = new LinkedList<int>();
+                linkedList.AddFirst(100);
+                linkedList.AddFirst(40);
+                return linkedList;
+            });
+            task.Start();
+            return task;
+        }
+
+        public Task<Dictionary<string, int>> GetDictionary()
+        {
+            Task<Dictionary<string, int>> task = new Task<Dictionary<string, int>>(() => new Dictionary<string, int>
+            {
+                {
+                    "Sam",
+                    1
+                },
+                {
+                    "Sara",
+                    2
+                },
+                {
+                    "Tom",
+                    3
+                }
+            });
+            task.Start();
+            return task;
+        }
+
+        public Task<HashSet<Book>> GetSet()
+        {
+            Task<HashSet<Book>> task = new Task<HashSet<Book>>(() => new HashSet<Book>
+            {
+                new Book
+                {
+                    Name = "Whoa"
+                },
+                new Book
+                {
+                    Name = "Dipper"
+                }
+            });
+            task.Start();
+            return task;
+        }
+
+        public Task<Stack<byte>> GetStack()
+        {
+            Task<Stack<byte>> task = new Task<Stack<byte>>(delegate
+            {
+                Stack<byte> stack = new Stack<byte>();
+                stack.Push(45);
+                stack.Push(10);
+                return stack;
+            });
+            task.Start();
+            return task;
+        }
+
+        public Task<Queue<string>> GetQueue()
+        {
+            Task<Queue<string>> task = new Task<Queue<string>>(delegate
+            {
+                Queue<string> queue = new Queue<string>();
+                queue.Enqueue("Panasonic");
+                queue.Enqueue("Sony");
+                queue.Enqueue("Kodak");
+                return queue;
+            });
+            task.Start();
+            return task;
+        }
+    }
+}
diff --git a/src/CoreWCF.Http/tests/Services/TaskPrimitivesService.cs b/src/CoreWCF.Http/tests/Services/TaskPrimitivesService.cs
new file mode 100644
index 0000000..d2a2d2f
--- /dev/null
+++ b/src/CoreWCF.Http/tests/Services/TaskPrimitivesService.cs
@@ -0,0 +1,231 @@
+﻿using CoreWCF;
+using ServiceContract;
+using System;
+using System.Threading.Tasks;
+
+namespace Services
+{
+    [ServiceBehavior]
+    public class TestPrimitives : ITestPrimitives
+    {
+        public Task<int> GetInt()
+        {
+            Task<int> task = new Task<int>(() =>
+            {
+                return 12566 + 34;
+            });
+            task.Start();
+            return task;
+        }
+
+        public Task<byte> GetByte()
+        {
+            Task<byte> task = new Task<byte>(() =>
+            {
+                return 120 + 4;
+            });
+            task.Start();
+            return task;
+        }
+
+        public Task<sbyte> GetSByte()
+        {
+            Task<sbyte> task = new Task<sbyte>(() =>
+            {
+                return -120 - 4;
+            });
+            task.Start();
+            return task;
+        }
+
+        public Task<short> GetShort()
+        {
+            Task<short> task = new Task<short>(() =>
+            {
+                return 566 + 1;
+            });
+            task.Start();
+            return task;
+        }
+
+        public Task<ushort> GetUShort()
+        {
+            Task<ushort> task = new Task<ushort>(() =>
+            {
+                return 111 + 1;
+            });
+            task.Start();
+            return task;
+        }
+
+        public Task<double> GetDouble()
+        {
+            Task<double> task = new Task<Double>(() =>
+            {
+                return 588.1200;
+            });
+            task.Start();
+            return task;
+        }
+
+        public Task<UInt32> GetUInt()
+        {
+            Task<UInt32> task = new Task<UInt32>(() =>
+            {
+                return 12566;
+            });
+            task.Start();
+            return task;
+        }
+
+        public Task<long> GetLong()
+        {
+            Task<long> task = new Task<long>(() =>
+            {
+                return 12566;
+            });
+            task.Start();
+            return task;
+        }
+
+        public Task<ulong> GetULong()
+        {
+            Task<ulong> task = new Task<ulong>(() =>
+            {
+                return 12566;
+            });
+            task.Start();
+            return task;
+        }
+
+        public Task<char> GetChar()
+        {
+            Task<char> task = new Task<char>(() =>
+            {
+                return 'r';
+            });
+            task.Start();
+            return task;
+        }
+
+        public Task<bool> GetBool()
+        {
+            Task<bool> task = new Task<bool>(() =>
+            {
+                return true;
+            });
+            task.Start();
+            return task;
+        }
+
+        public Task<float> GetFloat()
+        {
+            Task<float> task = new Task<float>(() =>
+            {
+                return 12566;
+            });
+            task.Start();
+            return task;
+        }
+
+        public Task<decimal> GetDecimal()
+        {
+            Task<decimal> task = new Task<decimal>(() =>
+            {
+                return 12566.4565m;
+            });
+            task.Start();
+            return task;
+        }
+
+        public Task<string> GetString()
+        {
+            Task<String> task = new Task<String>(() =>
+            {
+                return "Hello Seattle";
+            });
+            task.Start();
+            return task;
+        }
+
+        public Task<DateTime> GetDateTime()
+        {
+            Task<DateTime> task = new Task<DateTime>(() =>
+            {
+                return AsyncNetAdoptionConstants.TestDateTime;
+            });
+            task.Start();
+            return task;
+        }
+
+        public Task<int[][]> GetintArr2D()
+        {
+            Task<int[][]> task = new Task<int[][]>(() =>
+            {
+                return new int[2][] { new int[] { 2, 3, 4 }, new int[] { 5, 6, 7, 8, 9 } };
+            });
+            task.Start();
+            return task;
+        }
+
+        public Task<float[]> GetfloatArr()
+        {
+            Task<float[]> task = new Task<float[]>(() =>
+            {
+                return new float[20];
+            });
+            task.Start();
+            return task;
+        }
+
+        public Task<byte[]> GetbyteArr()
+        {
+            Task<byte[]> task = new Task<byte[]>(() =>
+            {
+                return new byte[10];
+            });
+            task.Start();
+            return task;
+        }
+
+        public Task<int?> GetnullableInt()
+        {
+            Task<int?> task = new Task<int?>(() =>
+            {
+                return 100;
+            });
+            task.Start();
+            return task;
+        }
+
+        public Task<TimeSpan> GetTimeSpan()
+        {
+            Task<TimeSpan> task = new Task<TimeSpan>(() =>
+            {
+                return TimeSpan.FromSeconds(5);
+            });
+            task.Start();
+            return task;
+        }
+
+        public Task<Guid> GetGuid()
+        {
+            Task<Guid> task = new Task<Guid>(() =>
+            {
+                return new Guid("7a1c7e9a-f4ce-4861-852c-c05ec59fad4d");
+            });
+            task.Start();
+            return task;
+        }
+
+        public Task<Color> GetEnum()
+        {
+            Task<Color> task = new Task<Color>(() =>
+            {
+                return Color.Blue;
+            });
+            task.Start();
+            return task;
+        }
+    }   
+}
diff --git a/src/CoreWCF.Http/tests/Services/TestBasicScenariosService.cs b/src/CoreWCF.Http/tests/Services/TestBasicScenariosService.cs
new file mode 100644
index 0000000..76212e8
--- /dev/null
+++ b/src/CoreWCF.Http/tests/Services/TestBasicScenariosService.cs
@@ -0,0 +1,56 @@
+﻿using System.Threading.Tasks;
+using Xunit;
+using CoreWCF;
+
+namespace Services
+{
+    [ServiceBehavior]
+    public class TestBasicScenariosService : ServiceContract.ITestBasicScenarios
+    {
+        private delegate string myDelegate(int ID, string name);
+        public async Task<string> TestMethodAsync(int ID, string name)
+        {
+            myDelegate del = ProcessAsync;
+            var workTask = System.Threading.Tasks.Task.Run(() => del.Invoke(ID, name));
+            return await workTask;
+        }
+
+        public string ProcessAsync(int ID, string name)
+        {
+            return name;
+        }
+
+        public string TestMethodDefaults(int ID, string name)
+        {
+            return name;
+        }
+
+        public void TestMethodSetAction(int ID, string name)
+        {
+            Assert.NotNull(name);
+            Assert.Equal("Action", name);
+        }
+
+        public int TestMethodSetReplyAction(int ID, string name)
+        {
+            return ID;
+        }
+
+        public void TestMethodSetUntypedAction(CoreWCF.Channels.Message msg)
+        {
+            Assert.NotNull(msg);
+        }
+
+        public void TestMethodUntypedAction(CoreWCF.Channels.Message msg)
+        {
+            Assert.NotNull(msg);
+        }
+
+        public CoreWCF.Channels.Message TestMethodUntypedReplyAction()
+        {
+            CoreWCF.Channels.Message serviceMessage = CoreWCF.Channels.Message.CreateMessage(CoreWCF.Channels.MessageVersion.Soap11, "myUntypedReplyAction");
+            return serviceMessage;
+        }
+    }
+}
+
diff --git a/src/CoreWCF.Http/tests/Services/TestFaultContractNameService.cs b/src/CoreWCF.Http/tests/Services/TestFaultContractNameService.cs
new file mode 100644
index 0000000..2654a1f
--- /dev/null
+++ b/src/CoreWCF.Http/tests/Services/TestFaultContractNameService.cs
@@ -0,0 +1,242 @@
+﻿using CoreWCF;
+
+namespace Services
+{
+    public class TestFaultContractNameService : ServiceContract.ITestFaultContractName
+    {
+     
+        #region TwoWay_Methods
+        public string Method1(string s)
+        {
+            if (s.Length == 0)
+            {
+                string faultToThrow = "Test fault thrown from a service";
+                throw new FaultException<string>(faultToThrow);
+            }
+
+            return s;
+        }
+
+        public string Method2(string s)
+        {
+            if (s.Length == 0)
+            {
+                string faultToThrow = "Test fault thrown from a service";
+                throw new FaultException<string>(faultToThrow);
+            }
+
+            return s;
+        }
+
+        public string Method3(string s)
+        {
+            if (s.Length == 0)
+            {
+                string faultToThrow = "Test fault thrown from a service";
+                throw new FaultException<string>(faultToThrow);
+            }
+
+            return s;
+        }
+
+        public string Method4(string s)
+        {
+            if (s.Length == 0)
+            {
+                string faultToThrow = "Test fault thrown from a service";
+                throw new FaultException<string>(faultToThrow);
+            }
+
+            return s;
+        }
+
+        public string Method5(string s)
+        {
+            if (s.Length == 0)
+            {
+                string faultToThrow = "Test fault thrown from a service";
+                throw new FaultException<string>(faultToThrow);
+            }
+
+            return s;
+        }
+
+        public string Method6(string s)
+        {
+                if (s.Length == 0)
+                {
+                    string faultToThrow = "Test fault thrown from a service";
+                    throw new FaultException<string>(faultToThrow);
+                }
+
+                return s;
+            }
+
+        public string Method7(string s)
+        {
+            if (s.Length == 0)
+            {
+                string faultToThrow = "Test fault thrown from a service";
+                throw new FaultException<string>(faultToThrow);
+            }
+
+            return s;
+        }
+
+        public string Method8(string s)
+        {
+            if (s.Length == 0)
+            {
+                string faultToThrow = "Test fault thrown from a service";
+                throw new FaultException<string>(faultToThrow);
+            }
+
+            return s;
+        }
+
+        public string Method9(string s)
+        {
+            if (s.Length == 0)
+            {
+                string faultToThrow = "Test fault thrown from a service";
+                throw new FaultException<string>(faultToThrow);
+            }
+
+            return s;
+        }
+
+        public string Method10(string s)
+        {
+            if (s.Length == 0)
+            {
+                string faultToThrow = "Test fault thrown from a service";
+                throw new FaultException<string>(faultToThrow);
+            }
+
+            return s;
+        }
+
+        public string Method11(string s)
+        {
+            if (s.Length == 0)
+            {
+                string faultToThrow = "Test fault thrown from a service";
+                throw new FaultException<string>(faultToThrow);
+            }
+
+            return s;
+        }
+
+        public string Method12(string s)
+        {
+            if (s.Length == 0)
+            {
+                string faultToThrow = "Test fault thrown from a service";
+                throw new FaultException<string>(faultToThrow);
+            }
+
+            return s;
+        }
+
+        public string Method13(string s)
+        {
+            if (s.Length == 0)
+            {
+                string faultToThrow = "Test fault thrown from a service";
+                throw new FaultException<string>(faultToThrow);
+            }
+
+            return s;
+        }
+
+        public string Method14(string s)
+        {
+            if (s.Length == 0)
+            {
+                string faultToThrow = "Test fault thrown from a service";
+                throw new FaultException<string>(faultToThrow);
+            }
+
+            return s;
+        }
+
+        public string Method15(string s)
+        {
+            if (s.Length == 0)
+            {
+                string faultToThrow = "Test fault thrown from a service";
+                throw new FaultException<string>(faultToThrow);
+            }
+
+            return s;
+        }
+
+        public string Method16(string s)
+        {
+            if (s.Length == 0)
+            {
+                string faultToThrow = "Test fault thrown from a service";
+                throw new FaultException<string>(faultToThrow);
+            }
+
+            return s;
+        }
+
+        public string Method17(string s)
+        {
+            if (s.Length == 0)
+            {
+                string faultToThrow = "Test fault thrown from a service";
+                throw new FaultException<string>(faultToThrow);
+            }
+
+            return s;
+        }
+
+        public string Method18(string s)
+        {
+            if (s.Length == 0)
+            {
+                string faultToThrow = "Test fault thrown from a service";
+                throw new FaultException<string>(faultToThrow);
+            }
+
+            return s;
+        }
+
+        public string Method19(string s)
+        {
+            if (s.Length == 0)
+            {
+                string faultToThrow = "Test fault thrown from a service";
+                throw new FaultException<string>(faultToThrow);
+            }
+
+            return s;
+        }
+
+        public string Method20(string s)
+        {
+            if (s.Length == 0)
+            {
+                string faultToThrow = "Test fault thrown from a service";
+                throw new FaultException<string>(faultToThrow);
+            }
+
+            return s;
+        }
+
+        public string Method21(string s)
+        {
+            if (s.Length == 0)
+            {
+                string faultToThrow = "Test fault thrown from a service";
+                throw new FaultException<string>(faultToThrow);
+            }
+
+            return s;
+        }
+        #endregion
+    }
+}
+
diff --git a/src/CoreWCF.Http/tests/SimpleTest.cs b/src/CoreWCF.Http/tests/SimpleTest.cs
index 874f370..dc30873 100644
--- a/src/CoreWCF.Http/tests/SimpleTest.cs
+++ b/src/CoreWCF.Http/tests/SimpleTest.cs
@@ -7,6 +7,7 @@ using Helpers;
 using Microsoft.AspNetCore;
 using Microsoft.AspNetCore.Builder;
 using Microsoft.AspNetCore.Hosting;
+using Microsoft.AspNetCore.Http;
 using Microsoft.Extensions.DependencyInjection;
 using Microsoft.Extensions.Logging;
 using Xunit;
diff --git a/src/CoreWCF.Http/tests/SimpleWSHTTPTest.cs b/src/CoreWCF.Http/tests/SimpleWSHTTPTest.cs
new file mode 100644
index 0000000..0aa5d6b
--- /dev/null
+++ b/src/CoreWCF.Http/tests/SimpleWSHTTPTest.cs
@@ -0,0 +1,142 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Net;
+using System.Net.Security;
+using System.Security.Cryptography.X509Certificates;
+using System.ServiceModel.Channels;
+using System.ServiceModel.Description;
+using System.Threading.Tasks;
+using CoreWCF;
+using CoreWCF.Configuration;
+using CoreWCF.Description;
+using CoreWCF.IdentityModel.Selectors;
+using Helpers;
+using Microsoft.AspNetCore;
+using Microsoft.AspNetCore.Builder;
+using Microsoft.AspNetCore.Hosting;
+using Microsoft.Extensions.DependencyInjection;
+using Microsoft.Extensions.Logging;
+using Xunit;
+using Xunit.Abstractions;
+
+namespace WSHttp
+{
+    public class SimpleWSHTTPTest
+    {
+        private ITestOutputHelper _output;
+
+        public SimpleWSHTTPTest(ITestOutputHelper output)
+        {
+            _output = output;
+        }
+
+        [Fact]
+        public void WSHttpRequestReplyEchoString()
+        {
+            string testString = new string('a', 3000);
+            var host = ServiceHelper.CreateWebHostBuilder<WSHttpNoSecurity>(_output).Build();
+            using (host)
+            {
+                host.Start();
+                var wsHttpBinding = ClientHelper.GetBufferedModeWSHttpBinding(System.ServiceModel.SecurityMode.None);
+                var factory = new System.ServiceModel.ChannelFactory<ClientContract.IEchoService>(wsHttpBinding,
+                    new System.ServiceModel.EndpointAddress(new Uri("http://localhost:8080/WSHttpWcfService/basichttp.svc")));
+                var channel = factory.CreateChannel();
+                var result = channel.EchoString(testString);
+                Assert.Equal(testString, result);
+            }
+        }
+        [Fact]
+        public void WSHttpRequestReplyWithTransportMessageEchoString()
+        {
+            ServicePointManager.ServerCertificateValidationCallback += new RemoteCertificateValidationCallback(ValidateCertificate);
+            string testString = new string('a', 3000);
+            var host = ServiceHelper.CreateHttpsWebHostBuilder<WSHttpTransportWithMessageCredential>(_output).Build();
+            using (host)
+            {
+                host.Start();
+
+                
+               
+                var wsHttpBinding = ClientHelper.GetBufferedModeWSHttpBinding(System.ServiceModel.SecurityMode.TransportWithMessageCredential);
+                wsHttpBinding.Security.Message.ClientCredentialType = System.ServiceModel.MessageCredentialType.UserName;
+
+                var factory = new System.ServiceModel.ChannelFactory<ClientContract.IEchoService>(wsHttpBinding,
+                    new System.ServiceModel.EndpointAddress(new Uri("https://localhost:8443/WSHttpWcfService/basichttp.svc")));
+                ClientCredentials clientCredentials = (ClientCredentials) factory.Endpoint.EndpointBehaviors[typeof(ClientCredentials)];
+                clientCredentials.UserName.UserName = "Administrator";
+                clientCredentials.UserName.Password = "fakeone";
+                ClientContract.IEchoService channel = factory.CreateChannel();
+                ((IChannel)channel).Open();
+                var result = channel.EchoString(testString);
+                Assert.Equal(testString, result);
+            }
+        }
+
+        static bool ValidateCertificate(object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors errors)
+        {
+            return true;
+        }
+
+        internal class CustomTestValidator : UserNamePasswordValidator
+        {
+            public override void Validate(string userName, string password)
+            {
+                return;
+            }
+        }
+        internal class WSHttpTransportWithMessageCredential : StartupWSHttpBase
+        {
+            public WSHttpTransportWithMessageCredential() : base(CoreWCF.SecurityMode.TransportWithMessageCredential)
+            {
+            }
+
+        }
+        internal class WSHttpNoSecurity : StartupWSHttpBase
+        {
+            public WSHttpNoSecurity() : base(CoreWCF.SecurityMode.None)
+            {
+            }
+
+        }
+        internal class StartupWSHttpBase
+        {
+            CoreWCF.SecurityMode wsHttpSecurityMode;
+            public StartupWSHttpBase(CoreWCF.SecurityMode securityMode )
+            {
+                this.wsHttpSecurityMode = securityMode;
+            }
+            public void ConfigureServices(IServiceCollection services)
+            {
+                services.AddServiceModelServices();
+                services.AddSingleton(typeof(ServiceConfigurationDelegateHolder<>));
+
+            }
+
+            public void Configure(IApplicationBuilder app, IHostingEnvironment env)
+            {
+                CoreWCF.WSHttpBinding serverBinding = new CoreWCF.WSHttpBinding(this.wsHttpSecurityMode);
+                serverBinding.Security.Message.ClientCredentialType = MessageCredentialType.UserName;
+                //TODO move above to WSHttpTransportWithMessageCredential by creating virtual to override binding
+                app.UseServiceModel(builder =>
+                {
+                builder.AddService<Services.EchoService>();
+                //  ServiceDescription.GetService()
+                builder.AddServiceEndpoint<Services.EchoService, ServiceContract.IEchoService>(serverBinding, "/WSHttpWcfService/basichttp.svc");
+                 Action<ServiceHostBase> serviceHost = host =>
+                    {
+                        var srvCredentials = new CoreWCF.Description.ServiceCredentials();
+                        srvCredentials.UserNameAuthentication.UserNamePasswordValidationMode
+                            = CoreWCF.Security.UserNamePasswordValidationMode.Custom;
+                        srvCredentials.UserNameAuthentication.CustomUserNamePasswordValidator
+                            = new CustomTestValidator();
+                        host.Description.Behaviors.Add(srvCredentials);
+                    };
+                    
+                    builder.ConfigureService<Services.EchoService>(serviceHost);
+                });
+            }
+        }
+    }
+}
diff --git a/src/CoreWCF.Http/tests/TaskCollectionsTests.cs b/src/CoreWCF.Http/tests/TaskCollectionsTests.cs
new file mode 100644
index 0000000..34705db
--- /dev/null
+++ b/src/CoreWCF.Http/tests/TaskCollectionsTests.cs
@@ -0,0 +1,143 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Text;
+using System.Threading.Tasks;
+using ClientContract;
+using CoreWCF.Channels;
+using CoreWCF.Configuration;
+using Helpers;
+using Microsoft.AspNetCore.Builder;
+using Microsoft.AspNetCore.Hosting;
+using Microsoft.Extensions.DependencyInjection;
+using Services;
+using Xunit;
+using Xunit.Abstractions;
+
+namespace CoreWCF.Http.Tests
+{
+    public class TaskCollectionsTests
+    {
+        private ITestOutputHelper _output;
+
+        public TaskCollectionsTests(ITestOutputHelper output)
+        {
+            _output = output;
+        }
+
+        [Fact]
+        public void VariousCollections()
+        {
+            var host = ServiceHelper.CreateWebHostBuilder<Startup>(_output).Build();
+            using (host)
+            {
+                ClientContract.ITaskCollectionsTest collectionsTest = null;
+                System.ServiceModel.ChannelFactory<ClientContract.ITaskCollectionsTest> channelFactory = null;
+                host.Start();
+                var httpBinding = ClientHelper.GetBufferedModeBinding();
+                channelFactory = new System.ServiceModel.ChannelFactory<ClientContract.ITaskCollectionsTest>(httpBinding,
+                    new System.ServiceModel.EndpointAddress(new Uri("http://localhost:8080/BasicWcfService/TaskCollectionsTest.svc")));
+                collectionsTest = channelFactory.CreateChannel();
+                
+                Task[] array;
+                array = new Task[5];
+                array[0] = collectionsTest.GetDictionary();
+                array[1] = collectionsTest.GetList();
+                array[2] = collectionsTest.GetSet();
+                array[3] = collectionsTest.GetQueue();
+                array[4] = collectionsTest.GetStack();
+                Task.WaitAll(array,TimeSpan.FromSeconds(30));
+
+                bool flag = true;
+                Task<Dictionary<string, int>> task = array[0] as Task<Dictionary<string, int>>;
+                Assert.True(task.Result.ContainsKey("Sam"));
+                Assert.True(task.Result.ContainsKey("Sara"));
+                if (!task.Result.ContainsKey("Sam") || !task.Result.ContainsKey("Sara"))
+                {
+                    flag = false;
+                    _output.WriteLine("Expected collection to contain Sara and Sam.");
+                    _output.WriteLine("Actual Result");
+                    foreach (string text in task.Result.Keys)
+                    {
+                        _output.WriteLine(text);
+                    }
+                }
+
+                Task<LinkedList<int>> task2 = array[1] as Task<LinkedList<int>>;
+                Assert.Contains(100, task2.Result);
+                Assert.Contains(40, task2.Result);
+                if (!task2.Result.Contains(100) || !task2.Result.Contains(40))
+                {
+                    flag = false;
+                    _output.WriteLine("Expected collection to contain 100 and 40.");
+                    _output.WriteLine("Actual Result");
+                    foreach (int num in task2.Result)
+                    {
+                        _output.WriteLine(num.ToString());
+                    }
+                }
+
+                Task<HashSet<Book>> task3 = array[2] as Task<HashSet<Book>>;
+                foreach (Book book in task3.Result)
+                {
+                    Assert.False(!book.Name.Equals("Whoa") && !book.Name.Equals("Dipper"));
+                    if (!book.Name.Equals("Whoa") && !book.Name.Equals("Dipper"))
+                    {
+                        _output.WriteLine("Expected collection to contain Whoa and Dipper.");
+                        _output.WriteLine(string.Format("Actual Result {0}", book.Name));
+                        flag = false;
+                    }
+                }
+
+                Task<Queue<string>> task4 = array[3] as Task<Queue<string>>;
+                Assert.True(task4.Result.Contains("Panasonic"));
+                Assert.True(task4.Result.Contains("Kodak"));
+                if (!task4.Result.Contains("Panasonic") || !task4.Result.Contains("Kodak"))
+                {
+                    flag = false;
+                    _output.WriteLine("Expected collection to contain Panasonic and Kodak.");
+                    _output.WriteLine("Actual Result");
+                    foreach (string text2 in task4.Result)
+                    {
+                        _output.WriteLine(text2);
+                    }
+                }
+
+                Task<Stack<byte>> task5 = array[4] as Task<Stack<byte>>;
+                Assert.True(task5.Result.Contains(45));
+                Assert.True(task5.Result.Contains(10));
+                if (!task5.Result.Contains(45) || !task5.Result.Contains(10))
+                {
+                    flag = false;
+                    _output.WriteLine("Expected collection to contain 45 and 10.");
+                    _output.WriteLine("Actual Result");
+                    foreach (byte b in task5.Result)
+                    {
+                        _output.WriteLine(b.ToString());
+                    }
+                }
+                if (!flag)
+                {
+                    throw new Exception("Test Failed");
+                }                              
+
+            }
+        }
+
+        internal class Startup
+        {
+            public void ConfigureServices(IServiceCollection services)
+            {
+                services.AddServiceModelServices();
+            }
+
+            public void Configure(IApplicationBuilder app, IHostingEnvironment env)
+            {
+                app.UseServiceModel(builder =>
+                {
+                    builder.AddService<TaskCollectionsTest>();
+                    builder.AddServiceEndpoint<TaskCollectionsTest, ServiceContract.ITaskCollectionsTest>(new BasicHttpBinding(), "/BasicWcfService/TaskCollectionsTest.svc");
+                });
+            }
+        }
+    }
+}
diff --git a/src/CoreWCF.Http/tests/TaskPrimitivesTest.cs b/src/CoreWCF.Http/tests/TaskPrimitivesTest.cs
new file mode 100644
index 0000000..323fff9
--- /dev/null
+++ b/src/CoreWCF.Http/tests/TaskPrimitivesTest.cs
@@ -0,0 +1,103 @@
+﻿using ClientContract;
+using CoreWCF.Configuration;
+using Helpers;
+using Microsoft.AspNetCore.Builder;
+using Microsoft.AspNetCore.Hosting;
+using Microsoft.Extensions.DependencyInjection;
+using System;
+using System.Globalization;
+using System.Threading.Tasks;
+using Xunit;
+using Xunit.Abstractions;
+
+namespace BasicHttp
+{
+    public class TaskPrimitivesTest
+    {
+        private ITestOutputHelper _output;
+        public static DateTime TestDateTime = new DateTime(2010, 09, 04, new GregorianCalendar(GregorianCalendarTypes.USEnglish));
+        public TaskPrimitivesTest(ITestOutputHelper output)
+        {
+            _output = output;
+        }
+
+        [Fact]
+        public void InvokeTaskBaseAsycn()
+        {
+            var host = ServiceHelper.CreateWebHostBuilder<Startup>(_output).Build();
+            using (host)
+            {
+                host.Start();
+                var httpBinding = ClientHelper.GetBufferedModeBinding();
+                var factory = new System.ServiceModel.ChannelFactory<ClientContract.ITestPrimitives>(httpBinding,
+                    new System.ServiceModel.EndpointAddress(new Uri("http://localhost:8080/TaskPrimitives/basichttp.svc")));
+                var channel = factory.CreateChannel();
+
+                Task[] tasks = new Task[22];
+                tasks[0] = channel.GetInt();
+                tasks[1] = channel.GetByte();
+                tasks[2] = channel.GetSByte();
+                tasks[3] = channel.GetShort();
+                tasks[4] = channel.GetUShort();
+                tasks[5] = channel.GetDouble();
+                tasks[6] = channel.GetUInt();
+                tasks[7] = channel.GetLong();
+                tasks[8] = channel.GetULong();
+                tasks[9] = channel.GetChar();
+                tasks[10] = channel.GetBool();
+                tasks[11] = channel.GetFloat();
+                tasks[12] = channel.GetDecimal();
+                tasks[13] = channel.GetString();
+                tasks[14] = channel.GetDateTime();
+                tasks[15] = channel.GetintArr2D();
+                tasks[16] = channel.GetfloatArr();
+                tasks[17] = channel.GetbyteArr();
+                tasks[18] = channel.GetnullableInt();
+                tasks[19] = channel.GetTimeSpan();
+                tasks[20] = channel.GetGuid();
+                tasks[21] = channel.GetEnum();
+                Task.WaitAll(tasks);
+
+                Assert.Equal(12600, ((Task<int>)tasks[0]).Result);
+                Assert.Equal(124, ((Task<byte>)tasks[1]).Result);
+                Assert.Equal(-124, ((Task<sbyte>)tasks[2]).Result);
+                Assert.Equal(567, ((Task<short>)tasks[3]).Result);
+                Assert.Equal(112, ((Task<ushort>)tasks[4]).Result);
+                Assert.Equal(588.1200, ((Task<double>)tasks[5]).Result);
+                Assert.Equal(12566, (double)((Task<uint>)tasks[6]).Result);
+                Assert.Equal(12566, ((Task<long>)tasks[7]).Result);
+                Assert.Equal(12566, (double)((Task<ulong>)tasks[8]).Result);
+                Assert.Equal('r', ((Task<char>)tasks[9]).Result);
+                Assert.True(((Task<bool>)tasks[10]).Result);
+                Assert.Equal(12566, ((Task<float>)tasks[11]).Result);
+                Assert.Equal(12566.4565m, ((Task<decimal>)tasks[12]).Result);
+                Assert.Equal("Hello Seattle", ((Task<string>)tasks[13]).Result);
+                Assert.Equal(TestDateTime, ((Task<DateTime>)tasks[14]).Result);
+                Assert.Equal(2, ((Task<int[][]>)tasks[15]).Result.Length);
+                Assert.Equal(20, ((Task<float[]>)tasks[16]).Result.Length);
+                Assert.Equal(10, ((Task<byte[]>)tasks[17]).Result.Length);
+                Assert.Equal(100, ((Task<int?>)tasks[18]).Result);
+                Assert.Equal("00:00:05", ((Task<TimeSpan>)tasks[19]).Result.ToString());
+                Assert.Equal("7a1c7e9a-f4ce-4861-852c-c05ec59fad4d", ((Task<Guid>)tasks[20]).Result.ToString());
+                Assert.Equal(Color.Blue, ((Task<Color>)tasks[21]).Result);               
+            }            
+        }
+
+        internal class Startup
+        {
+            public void ConfigureServices(IServiceCollection services)
+            {
+                services.AddServiceModelServices();
+            }
+
+            public void Configure(IApplicationBuilder app, IHostingEnvironment env)
+            {
+                app.UseServiceModel(builder =>
+                {
+                    builder.AddService<Services.TestPrimitives>();
+                    builder.AddServiceEndpoint<Services.TestPrimitives, ServiceContract.ITestPrimitives>(new CoreWCF.BasicHttpBinding(), "/TaskPrimitives/basichttp.svc");
+                });
+            }
+        }
+    }
+}
diff --git a/src/CoreWCF.Http/tests/WebSocketsTests.cs b/src/CoreWCF.Http/tests/WebSocketsTests.cs
index e8269ba..f8e376f 100644
--- a/src/CoreWCF.Http/tests/WebSocketsTests.cs
+++ b/src/CoreWCF.Http/tests/WebSocketsTests.cs
@@ -14,7 +14,7 @@ namespace NetHttp
     public class WebSocketsTests
     {
         private const string NetHttpServiceBaseUri = "http://localhost:8080";
-        private const string NetHttpServiceUri = NetHttpServiceBaseUri + Startup.HttpPath;
+        private const string NetHttpBufferedServiceUri = NetHttpServiceBaseUri + Startup.BufferedPath;
         private ITestOutputHelper _output;
 
         public WebSocketsTests(ITestOutputHelper output)
@@ -23,7 +23,7 @@ namespace NetHttp
         }
 
         [Fact]
-        public void SimpleNetHttpWebSocketsClientConnection()
+        public void NetHttpWebSocketsBufferedTransferMode()
         {
             string testString = new string('a', 3000);
             var host = ServiceHelper.CreateWebHostBuilder<Startup>(_output).Build();
@@ -36,7 +36,7 @@ namespace NetHttp
                 {
                     var binding = ClientHelper.GetBufferedModeWebSocketBinding();
                     factory = new System.ServiceModel.ChannelFactory<ClientContract.IEchoService>(binding,
-                        new System.ServiceModel.EndpointAddress(new Uri(NetHttpServiceUri)));
+                        new System.ServiceModel.EndpointAddress(new Uri(NetHttpBufferedServiceUri)));
                     channel = factory.CreateChannel();
                     ((IChannel)channel).Open();
                     var result = channel.EchoString(testString);
@@ -51,9 +51,40 @@ namespace NetHttp
             }
         }
 
+        //[Fact]
+        //public void NetHttpWebSocketsStreamedTransferMode()
+        //{
+        //    string testString = new string('a', 3000);
+        //    var host = ServiceHelper.CreateWebHostBuilder<Startup>(_output).Build();
+        //    using (host)
+        //    {
+        //        System.ServiceModel.ChannelFactory<ClientContract.IEchoService> factory = null;
+        //        ClientContract.IEchoService channel = null;
+        //        host.Start();
+        //        try
+        //        {
+        //            var binding = ClientHelper.GetStreamedModeWebSocketBinding();
+        //            factory = new System.ServiceModel.ChannelFactory<ClientContract.IEchoService>(binding,
+        //                new System.ServiceModel.EndpointAddress(new Uri(NetHttpServiceUri)));
+        //            channel = factory.CreateChannel();
+        //            ((IChannel)channel).Open();
+        //            var result = channel.EchoString(testString);
+        //            Assert.Equal(testString, result);
+        //            ((IChannel)channel).Close();
+        //            factory.Close();
+        //        }
+        //        finally
+        //        {
+        //            ServiceHelper.CloseServiceModelObjects((IChannel)channel, factory);
+        //        }
+        //    }
+        //}
+
+
         public class Startup
         {
-            public const string HttpPath = "/nethttp.svc";
+            public const string BufferedPath = "/nethttp.svc/buffered";
+            public const string StreamedPath = "/nethttp.svc/streamed";
 
             public void ConfigureServices(IServiceCollection services)
             {
@@ -67,7 +98,7 @@ namespace NetHttp
                     builder.AddService<Services.EchoService>();
                     var binding = new NetHttpBinding();
                     binding.WebSocketSettings.TransportUsage = CoreWCF.Channels.WebSocketTransportUsage.Always;
-                    builder.AddServiceEndpoint<Services.EchoService, ServiceContract.IEchoService>(binding, HttpPath);
+                    builder.AddServiceEndpoint<Services.EchoService, ServiceContract.IEchoService>(binding, BufferedPath);
                 });
             }
         }
diff --git a/src/CoreWCF.NetTcp/src/CoreWCF/Channels/ConnectionOrientedTransportReplyChannel.cs b/src/CoreWCF.NetTcp/src/CoreWCF/Channels/ConnectionOrientedTransportReplyChannel.cs
index a8f6a44..c790999 100644
--- a/src/CoreWCF.NetTcp/src/CoreWCF/Channels/ConnectionOrientedTransportReplyChannel.cs
+++ b/src/CoreWCF.NetTcp/src/CoreWCF/Channels/ConnectionOrientedTransportReplyChannel.cs
@@ -1,4 +1,4 @@
-﻿using Microsoft.Extensions.DependencyInjection;
+using Microsoft.Extensions.DependencyInjection;
 using System;
 using System.Collections.Generic;
 using System.Text;
diff --git a/src/CoreWCF.NetTcp/src/CoreWCF/Channels/Framing/FramingConnection.cs b/src/CoreWCF.NetTcp/src/CoreWCF/Channels/Framing/FramingConnection.cs
index 74f924c..686fa97 100644
--- a/src/CoreWCF.NetTcp/src/CoreWCF/Channels/Framing/FramingConnection.cs
+++ b/src/CoreWCF.NetTcp/src/CoreWCF/Channels/Framing/FramingConnection.cs
@@ -36,7 +36,8 @@ namespace CoreWCF.Channels.Framing
         public Uri Via => FramingDecoder?.Via;
         internal FramingMode FramingMode { get; set; }
         public MessageEncoder MessageEncoder { get; internal set; }
-        public SecurityMessageProperty SecurityMessageProperty { get; internal set; }
+        public SecurityMessageProperty SecurityMessageProperty { get; 
+            internal set; }
         public bool EOF { get; internal set; }
         public Memory<byte> EnvelopeBuffer { get; internal set; }
         public int EnvelopeOffset { get; internal set; }
diff --git a/src/CoreWCF.NetTcp/src/CoreWCF/Configuration/NetTcpServiceTransportDispatcher.cs b/src/CoreWCF.NetTcp/src/CoreWCF/Configuration/NetTcpServiceTransportDispatcher.cs
new file mode 100644
index 0000000..e5574a4
--- /dev/null
+++ b/src/CoreWCF.NetTcp/src/CoreWCF/Configuration/NetTcpServiceTransportDispatcher.cs
@@ -0,0 +1,15 @@
+﻿using Microsoft.AspNetCore.Builder;
+using System;
+using System.Collections.Generic;
+using System.Text;
+
+namespace CoreWCF.Configuration
+{
+    internal class NetTcpTransportServiceBuilder : ITransportServiceBuilder
+    {
+        public void Configure(IApplicationBuilder app)
+        {
+
+        }
+    }
+}
diff --git a/src/CoreWCF.NetTcp/src/CoreWCF/Configuration/ServiceModelWebHostBuilderExtensions.cs b/src/CoreWCF.NetTcp/src/CoreWCF/Configuration/ServiceModelWebHostBuilderExtensions.cs
index d20eb97..f354267 100644
--- a/src/CoreWCF.NetTcp/src/CoreWCF/Configuration/ServiceModelWebHostBuilderExtensions.cs
+++ b/src/CoreWCF.NetTcp/src/CoreWCF/Configuration/ServiceModelWebHostBuilderExtensions.cs
@@ -23,6 +23,7 @@ namespace CoreWCF.Configuration
             // Using default port
             webHostBuilder.ConfigureServices(services =>
             {
+                services.TryAddEnumerable(ServiceDescriptor.Singleton<ITransportServiceBuilder, NetTcpTransportServiceBuilder>());
                 services.AddSingleton(NetMessageFramingConnectionHandler.BuildAddressTable);
                 services.AddNetTcpServices(new IPEndPoint(IPAddress.Any, port));
                 services.AddTransient<IFramingConnectionHandshakeBuilder, FramingConnectionHandshakeBuilder>();
diff --git a/src/CoreWCF.Primitives/src/CoreWCF.Primitives.csproj b/src/CoreWCF.Primitives/src/CoreWCF.Primitives.csproj
index 248d66b..7ea03c7 100644
--- a/src/CoreWCF.Primitives/src/CoreWCF.Primitives.csproj
+++ b/src/CoreWCF.Primitives/src/CoreWCF.Primitives.csproj
@@ -10,7 +10,10 @@
     <PackageReference Include="Microsoft.AspNetCore.Hosting.Server.Abstractions" Version="2.1.1" />
     <PackageReference Include="Microsoft.AspNetCore.Http.Abstractions" Version="2.1.1" />
     <PackageReference Include="Microsoft.Extensions.DependencyInjection.Abstractions" Version="2.1.1" />
+    <PackageReference Include="Microsoft.Extensions.Logging.Abstractions" Version="2.1.1" />
     <PackageReference Include="System.DirectoryServices" Version="4.5.0" />
+    <PackageReference Include="System.Security.Cryptography.ProtectedData" Version="4.5.0" />
+    <PackageReference Include="System.Security.Cryptography.Xml" Version="4.5.0" />
     <PackageReference Include="System.Security.Principal.Windows" Version="4.5.1" />
     <PackageReference Include="System.Reflection.DispatchProxy" Version="4.5.1" />
     <PackageReference Include="System.Threading.Tasks.Extensions" Version="4.5.3" />
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Channels/Binding.cs b/src/CoreWCF.Primitives/src/CoreWCF/Channels/Binding.cs
index 80d8b78..11e7390 100644
--- a/src/CoreWCF.Primitives/src/CoreWCF/Channels/Binding.cs
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Channels/Binding.cs
@@ -1,6 +1,7 @@
 using System;
 using CoreWCF.Runtime;
 using CoreWCF.Description;
+using CoreWCF.Configuration;
 
 namespace CoreWCF.Channels
 {
@@ -169,23 +170,42 @@ namespace CoreWCF.Channels
             }
         }
 
-        // TODO: Ensure any validation logic here is executed in new pipeline
-        //public virtual IChannelListener<TChannel> BuildChannelListener<TChannel>(Uri listenUriBaseAddress, string listenUriRelativeAddress, ListenUriMode listenUriMode, BindingParameterCollection parameters)
-        //    where TChannel : class, IChannel
-        //{
-        //    EnsureInvariants();
-        //    BindingContext context = new BindingContext(new CustomBinding(this), parameters, listenUriBaseAddress, listenUriRelativeAddress, listenUriMode);
-        //    IChannelListener<TChannel> channelListener = context.BuildInnerChannelListener<TChannel>();
-        //    context.ValidateBindingElementsConsumed();
-        //    ValidateSecurityCapabilities(channelListener.GetProperty<ISecurityCapabilities>(), parameters);
+        public virtual bool CanBuildServiceDispatcher<TChannel>(BindingParameterCollection parameters) where TChannel : class, IChannel
+        {
+            BindingContext context = new BindingContext(new CustomBinding(this), parameters);
+            return context.CanBuildNextServiceDispatcher<TChannel>();
+        }
 
-        //    return channelListener;
-        //}
+        public virtual IServiceDispatcher BuildServiceDispatcher<TChannel>(BindingParameterCollection parameters, IServiceDispatcher dispatcher)
+where TChannel : class, IChannel
+        {
+            UriBuilder listenUriBuilder = new UriBuilder(this.Scheme, DnsCache.MachineName);
+            return BuildServiceDispatcher<TChannel>(listenUriBuilder.Uri, string.Empty, parameters, dispatcher);
+        }
+
+        public virtual IServiceDispatcher BuildServiceDispatcher<TChannel>(Uri listenUriBaseAddress, BindingParameterCollection parameters, IServiceDispatcher dispatcher)
+where TChannel : class, IChannel
+        {
+            return BuildServiceDispatcher<TChannel>(listenUriBaseAddress, string.Empty, parameters, dispatcher);
+        }
+
+        public virtual IServiceDispatcher BuildServiceDispatcher<TChannel>(Uri listenUriBaseAddress, string listenUriRelativeAddress, BindingParameterCollection parameters, IServiceDispatcher dispatcher)
+            where TChannel : class, IChannel
+        {
+            EnsureInvariants();
+            BindingContext context = new BindingContext(new CustomBinding(this), parameters, listenUriBaseAddress, listenUriRelativeAddress);
+            IServiceDispatcher serviceDispatcher = context.BuildNextServiceDispatcher<TChannel>(dispatcher);
+            context.ValidateBindingElementsConsumed();
+
+            // TODO: Work out how to validate security capabilities
+            //this.ValidateSecurityCapabilities(serviceDispatcher.GetProperty<ISecurityCapabilities>(), parameters);
+
+            return serviceDispatcher;
+        }
 
         public abstract BindingElementCollection CreateBindingElements();
 
-        public T GetProperty<T>(BindingParameterCollection parameters)
-    where T : class
+        public T GetProperty<T>(BindingParameterCollection parameters) where T : class
         {
             BindingContext context = new BindingContext(new CustomBinding(this), parameters);
             return context.GetInnerProperty<T>();
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Channels/BindingContext.cs b/src/CoreWCF.Primitives/src/CoreWCF/Channels/BindingContext.cs
index bacc9e3..ae2671a 100644
--- a/src/CoreWCF.Primitives/src/CoreWCF/Channels/BindingContext.cs
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Channels/BindingContext.cs
@@ -1,25 +1,19 @@
 using System;
 using System.Globalization;
 using System.Text;
+using CoreWCF.Configuration;
 using CoreWCF.Description;
 
 namespace CoreWCF.Channels
 {
     public class BindingContext
     {
-        CustomBinding _binding;
-        BindingParameterCollection _bindingParameters;
-        Uri _listenUriBaseAddress;
-        ListenUriMode _listenUriMode;
-        string _listenUriRelativeAddress;
-        BindingElementCollection _remainingBindingElements;  // kept to ensure each BE builds itself once
-
         public BindingContext(CustomBinding binding, BindingParameterCollection parameters)
-            : this(binding, parameters, null, string.Empty, ListenUriMode.Explicit)
+            : this(binding, parameters, null, string.Empty)
         {
         }
 
-        public BindingContext(CustomBinding binding, BindingParameterCollection parameters, Uri listenUriBaseAddress, string listenUriRelativeAddress, ListenUriMode listenUriMode)
+        public BindingContext(CustomBinding binding, BindingParameterCollection parameters, Uri listenUriBaseAddress, string listenUriRelativeAddress)
         {
             if (binding == null)
             {
@@ -29,68 +23,60 @@ namespace CoreWCF.Channels
             {
                 listenUriRelativeAddress = string.Empty;
             }
-            if (!ListenUriModeHelper.IsDefined(listenUriMode))
-            {
-                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(listenUriMode)));
-            }
 
-            Initialize(binding, binding.Elements, parameters, listenUriBaseAddress, listenUriRelativeAddress, listenUriMode);
+            Initialize(binding, binding.Elements, parameters, listenUriBaseAddress, listenUriRelativeAddress);
         }
 
-        BindingContext(CustomBinding binding,
+        private BindingContext(CustomBinding binding,
                BindingElementCollection remainingBindingElements,
                BindingParameterCollection parameters,
                Uri listenUriBaseAddress,
-               string listenUriRelativeAddress,
-               ListenUriMode listenUriMode)
+               string listenUriRelativeAddress)
         {
-            Initialize(binding, remainingBindingElements, parameters, listenUriBaseAddress, listenUriRelativeAddress, listenUriMode);
+            Initialize(binding, remainingBindingElements, parameters, listenUriBaseAddress, listenUriRelativeAddress);
         }
 
         private void Initialize(CustomBinding binding,
                 BindingElementCollection remainingBindingElements,
                 BindingParameterCollection parameters,
                 Uri listenUriBaseAddress,
-                string listenUriRelativeAddress,
-                ListenUriMode listenUriMode)
+                string listenUriRelativeAddress)
         {
-            _binding = binding;
+            Binding = binding;
 
-            _remainingBindingElements = new BindingElementCollection(remainingBindingElements);
-            _bindingParameters = new BindingParameterCollection(parameters);
-            _listenUriBaseAddress = listenUriBaseAddress;
-            _listenUriRelativeAddress = listenUriRelativeAddress;
-            _listenUriMode = listenUriMode;
+            RemainingBindingElements = new BindingElementCollection(remainingBindingElements);
+            BindingParameters = new BindingParameterCollection(parameters);
+            ListenUriBaseAddress = listenUriBaseAddress;
+            ListenUriRelativeAddress = listenUriRelativeAddress;
         }
 
-        public CustomBinding Binding => _binding;
+        public CustomBinding Binding { get; private set; }
 
-        public BindingParameterCollection BindingParameters => _bindingParameters;
+        public BindingParameterCollection BindingParameters { get; private set; }
 
-        public Uri ListenUriBaseAddress
-        {
-            get { return _listenUriBaseAddress; }
-            set { _listenUriBaseAddress = value; }
-        }
+        public Uri ListenUriBaseAddress { get; set; }
+
+        public string ListenUriRelativeAddress { get; set; }
 
-        public ListenUriMode ListenUriMode
+        public BindingElementCollection RemainingBindingElements { get; private set; }
+
+        public IServiceDispatcher BuildNextServiceDispatcher<TChannel>(IServiceDispatcher innerDispatcher)
+    where TChannel : class, IChannel
         {
-            get { return _listenUriMode; }
-            set { _listenUriMode = value; }
+            return this.RemoveNextElement().BuildServiceDispatcher<TChannel>(this, innerDispatcher);
         }
 
-        public string ListenUriRelativeAddress
+        public bool CanBuildNextServiceDispatcher<TChannel>()
+    where TChannel : class, IChannel
         {
-            get { return _listenUriRelativeAddress; }
-            set { _listenUriRelativeAddress = value; }
+            BindingContext clone = this.Clone();
+            return clone.RemoveNextElement().CanBuildServiceDispatcher<TChannel>(clone);
         }
 
-        public BindingElementCollection RemainingBindingElements => _remainingBindingElements;
-
         public T GetInnerProperty<T>()
             where T : class
         {
-            if (_remainingBindingElements.Count == 0)
+            if (RemainingBindingElements.Count == 0)
             {
                 return null;
             }
@@ -102,17 +88,17 @@ namespace CoreWCF.Channels
         }
         public BindingContext Clone()
         {
-            return new BindingContext(_binding, _remainingBindingElements, _bindingParameters,
-                _listenUriBaseAddress, _listenUriRelativeAddress, _listenUriMode);
+            return new BindingContext(Binding, RemainingBindingElements, BindingParameters,
+                ListenUriBaseAddress, ListenUriRelativeAddress);
         }
 
-        BindingElement RemoveNextElement()
+        private BindingElement RemoveNextElement()
         {
-            BindingElement element = _remainingBindingElements.Remove<BindingElement>();
+            BindingElement element = RemainingBindingElements.Remove<BindingElement>();
             if (element != null)
                 return element;
             throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(
-                SR.NoChannelBuilderAvailable, _binding.Name, _binding.Namespace)));
+                SR.NoChannelBuilderAvailable, Binding.Name, Binding.Namespace)));
         }
 
         internal void ValidateBindingElementsConsumed()
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Channels/BindingElement.cs b/src/CoreWCF.Primitives/src/CoreWCF/Channels/BindingElement.cs
index 82f23cf..7d3fde7 100644
--- a/src/CoreWCF.Primitives/src/CoreWCF/Channels/BindingElement.cs
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Channels/BindingElement.cs
@@ -1,3 +1,4 @@
+using CoreWCF.Configuration;
 using CoreWCF.Runtime;
 
 namespace CoreWCF.Channels
@@ -21,11 +22,31 @@ namespace CoreWCF.Channels
             return GetProperty<T>(new BindingContext(new CustomBinding(), new BindingParameterCollection()));
         }
 
+
         //TODO: Move back to internal
         protected virtual bool IsMatch(BindingElement b)
         {
             Fx.Assert(true, "Should not be called unless this binding element is used in one of the standard bindings. In which case, please re-implement the IsMatch() method.");
             return false;
         }
+        public virtual IServiceDispatcher BuildServiceDispatcher<TChannel>(BindingContext context, IServiceDispatcher innerDispatcher) where TChannel : class, IChannel
+        {
+            if (context == null)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(context));
+
+            if (innerDispatcher == null)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(innerDispatcher));
+
+            return context.BuildNextServiceDispatcher<TChannel>(innerDispatcher);
+        }
+
+        public virtual bool CanBuildServiceDispatcher<TChannel>(BindingContext context) where TChannel : class, IChannel
+        {
+            if (context == null)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("context");
+
+            return context.CanBuildNextServiceDispatcher<TChannel>();
+        }
+
     }
 }
\ No newline at end of file
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Channels/BindingElementCollection.cs b/src/CoreWCF.Primitives/src/CoreWCF/Channels/BindingElementCollection.cs
index 93b3d72..4d11bb0 100644
--- a/src/CoreWCF.Primitives/src/CoreWCF/Channels/BindingElementCollection.cs
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Channels/BindingElementCollection.cs
@@ -141,5 +141,16 @@ namespace CoreWCF.Channels
 
             base.SetItem(index, item);
         }
+
+        internal BindingElementCollection Reverse()
+        {
+            var bec = new BindingElementCollection();
+            for(int i = Count - 1; i >= 0; i--)
+            {
+                bec.Add(this[i]);
+            }
+
+            return bec;
+        }
     }
 }
\ No newline at end of file
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Channels/ChannelBindingMessageProperty.cs b/src/CoreWCF.Primitives/src/CoreWCF/Channels/ChannelBindingMessageProperty.cs
index 199bbff..e832934 100644
--- a/src/CoreWCF.Primitives/src/CoreWCF/Channels/ChannelBindingMessageProperty.cs
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Channels/ChannelBindingMessageProperty.cs
@@ -39,6 +39,34 @@ namespace CoreWCF.Channels
             }
         }
 
+        public static bool TryGet(Message message, out ChannelBindingMessageProperty property)
+        {
+            if (message == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("message");
+            }
+
+            return TryGet(message.Properties, out property);
+        }
+
+        public static bool TryGet(MessageProperties properties, out ChannelBindingMessageProperty property)
+        {
+            if (properties == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("properties");
+            }
+
+            property = null;
+            object value;
+
+            if (properties.TryGetValue(ChannelBindingMessageProperty.Name, out value))
+            {
+                property = value as ChannelBindingMessageProperty;
+                return property != null;
+            }
+
+            return false;
+        }
         IMessageProperty IMessageProperty.CreateCopy()
         {
             lock (thisLock)
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Channels/ChannelBuilder.cs b/src/CoreWCF.Primitives/src/CoreWCF/Channels/ChannelBuilder.cs
new file mode 100644
index 0000000..d370136
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Channels/ChannelBuilder.cs
@@ -0,0 +1,142 @@
+using System;
+using System.Collections.Generic;
+using System.Runtime;
+using CoreWCF.Configuration;
+using CoreWCF.Dispatcher;
+namespace CoreWCF.Channels
+{ 
+    class ChannelBuilder
+    {
+        CustomBinding binding;
+        BindingContext context;
+        BindingParameterCollection bindingParameters;
+        Uri listenUri;
+
+        public ChannelBuilder(BindingContext context, bool addChannelDemuxerIfRequired)
+        {
+            this.context = context;
+            if (addChannelDemuxerIfRequired)
+            {
+                throw new NotImplementedException();
+                //TODO next phase
+                //this.AddDemuxerBindingElement(context.RemainingBindingElements);
+            }
+            this.binding = new CustomBinding(context.Binding, context.RemainingBindingElements);
+            this.bindingParameters = context.BindingParameters;
+        }
+
+        public ChannelBuilder(Binding binding, BindingParameterCollection bindingParameters, bool addChannelDemuxerIfRequired)
+        {
+            this.binding = new CustomBinding(binding);
+            this.bindingParameters = bindingParameters;
+            if (addChannelDemuxerIfRequired)
+            {
+                throw new NotImplementedException();
+                //  this.AddDemuxerBindingElement(this.binding.Elements);
+            }
+        }
+
+        public ChannelBuilder(ChannelBuilder channelBuilder)
+        {
+            this.binding = new CustomBinding(channelBuilder.Binding);
+            this.bindingParameters = channelBuilder.BindingParameters;
+            //if (this.binding.Elements.Find<ChannelDemuxerBindingElement>() == null)
+            //{
+            //    throw Fx.AssertAndThrow("ChannelBuilder.ctor (this.binding.Elements.Find<ChannelDemuxerBindingElement>() != null)");
+            //}
+        }
+
+        public CustomBinding Binding
+        {
+            get { return this.binding; }
+            set { this.binding = value; }
+        }
+
+        public BindingParameterCollection BindingParameters
+        {
+            get { return this.bindingParameters; }
+            set { this.bindingParameters = value; }
+        }
+        //TODOinject and modify when Demuxer implementation happens
+        public  IServiceDispatcher BuildServiceDispatcher<TChannel>(BindingContext context, IServiceDispatcher innerDispatcher) where TChannel : class, IChannel
+        {
+            if (this.context != null)
+            {
+                IServiceDispatcher listener = this.context.BuildNextServiceDispatcher<TChannel>(innerDispatcher);// .BuildInnerChannelListener<TChannel>();
+               // this.listenUri = listener.Uri;
+                this.context = null;
+                return listener;
+            }
+            else
+            {
+                return this.binding.BuildServiceDispatcher<TChannel>( this.bindingParameters, innerDispatcher);
+            }
+        }
+
+        /*
+        void AddDemuxerBindingElement(BindingElementCollection elements)
+        {
+            if (elements.Find<ChannelDemuxerBindingElement>() == null)
+            {
+                // add the channel demuxer binding element right above the transport
+                TransportBindingElement transport = elements.Find<TransportBindingElement>();
+                if (transport == null)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.GetString(SR.TransportBindingElementNotFound)));
+                }
+                // cache the context state in the demuxer so that the same context state can be provided to the transport
+                // when building auxilliary channels and listeners (for ex, for security negotiation)
+                elements.Insert(elements.IndexOf(transport), new ChannelDemuxerBindingElement(true));
+            }
+        }*/
+
+        /* public IChannelFactory<TChannel> BuildChannelFactory<TChannel>()
+         {
+             if (this.context != null)
+             {
+                 IChannelFactory<TChannel> factory = this.context.BuildInnerChannelFactory<TChannel>();
+                 this.context = null;
+                 return factory;
+             }
+             else
+             {
+                 return this.binding.BuildChannelFactory<TChannel>(this.bindingParameters);
+             }
+         }*/
+
+        /*
+         public IChannelListener<TChannel> BuildChannelListener<TChannel>() where TChannel : class, IChannel
+         {
+             if (this.context != null)
+             {
+                 IChannelListener<TChannel> listener = this.context.BuildInnerChannelListener<TChannel>();
+                 this.listenUri = listener.Uri;
+                 this.context = null;
+                 return listener;
+             }
+             else
+             {
+                 return this.binding.BuildChannelListener<TChannel>(this.listenUri, this.bindingParameters);
+             }
+         }
+
+         public IChannelListener<TChannel> BuildChannelListener<TChannel>(MessageFilter filter, int priority) where TChannel : class, IChannel
+         {
+             this.bindingParameters.Add(new ChannelDemuxerFilter(filter, priority));
+             IChannelListener<TChannel> listener = this.BuildChannelListener<TChannel>();
+             this.bindingParameters.Remove<ChannelDemuxerFilter>();
+
+             return listener;
+         }
+
+         public bool CanBuildChannelFactory<TChannel>()
+         {
+             return this.binding.CanBuildChannelFactory<TChannel>(this.bindingParameters);
+         }
+
+         public bool CanBuildChannelListener<TChannel>() where TChannel : class, IChannel
+         {
+             return this.binding.CanBuildChannelListener<TChannel>(this.bindingParameters);
+         }*/
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Channels/DelegatingMessage.cs b/src/CoreWCF.Primitives/src/CoreWCF/Channels/DelegatingMessage.cs
new file mode 100644
index 0000000..2491efd
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Channels/DelegatingMessage.cs
@@ -0,0 +1,90 @@
+using System.Xml;
+using CoreWCF.Channels;
+using CoreWCF;
+
+namespace CoreWCF.Channels
+{
+
+    abstract class DelegatingMessage : Message
+    {
+        Message innerMessage;
+
+        protected DelegatingMessage(Message innerMessage)
+        {
+            if (innerMessage == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("innerMessage");
+            }
+            this.innerMessage = innerMessage;
+        }
+
+        public override bool IsEmpty
+        {
+            get
+            {
+                return this.innerMessage.IsEmpty;
+            }
+        }
+
+        public override bool IsFault
+        {
+            get { return this.innerMessage.IsFault; }
+        }
+
+        public override MessageHeaders Headers
+        {
+            get { return this.innerMessage.Headers; }
+        }
+
+        public override MessageProperties Properties
+        {
+            get { return this.innerMessage.Properties; }
+        }
+
+        public override MessageVersion Version
+        {
+            get { return this.innerMessage.Version; }
+        }
+
+        protected Message InnerMessage
+        {
+            get { return this.innerMessage; }
+        }
+
+        protected override void OnClose()
+        {
+            base.OnClose();
+            this.innerMessage.Close();
+        }
+
+        protected override void OnWriteStartEnvelope(XmlDictionaryWriter writer)
+        {
+            this.innerMessage.WriteStartEnvelope(writer);
+        }
+
+        protected override void OnWriteStartHeaders(XmlDictionaryWriter writer)
+        {
+            this.innerMessage.WriteStartHeaders(writer);
+        }
+
+        protected override void OnWriteStartBody(XmlDictionaryWriter writer)
+        {
+            this.innerMessage.WriteStartBody(writer);
+        }
+
+        protected override void OnWriteBodyContents(XmlDictionaryWriter writer)
+        {
+            this.innerMessage.WriteBodyContents(writer);
+        }
+
+        protected override string OnGetBodyAttribute(string localName, string ns)
+        {
+            return this.innerMessage.GetBodyAttribute(localName, ns);
+        }
+
+        protected override void OnBodyToString(XmlDictionaryWriter writer)
+        {
+            this.innerMessage.BodyToString(writer);
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Channels/IReliableChannelBinder.cs b/src/CoreWCF.Primitives/src/CoreWCF/Channels/IReliableChannelBinder.cs
new file mode 100644
index 0000000..2d21dc9
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Channels/IReliableChannelBinder.cs
@@ -0,0 +1,47 @@
+﻿using System.Threading.Tasks;
+using System;
+
+namespace CoreWCF.Channels
+{
+    internal delegate void BinderExceptionHandler(IReliableChannelBinder sender, Exception exception);
+
+    internal interface IReliableChannelBinder
+    {
+        IChannel Channel { get; }
+        bool Connected { get; }
+        TimeSpan DefaultSendTimeout { get; }
+        bool HasSession { get; }
+        EndpointAddress LocalAddress { get; }
+        EndpointAddress RemoteAddress { get; }
+        CommunicationState State { get; }
+
+        event BinderExceptionHandler Faulted;
+        event BinderExceptionHandler OnException;
+
+        void Abort();
+
+        Task CloseAsync(TimeSpan timeout);
+        Task CloseAsync(TimeSpan timeout, MaskingMode maskingMode);
+        Task OpenAsync(TimeSpan timeout);
+        Task SendAsync(Message message, TimeSpan timeout);
+        Task SendAsync(Message message, TimeSpan timeout, MaskingMode maskingMode);
+
+        Task<(bool, RequestContext)> TryReceiveAsync(TimeSpan timeout);
+        Task<(bool, RequestContext)> TryReceiveAsync(TimeSpan timeout, MaskingMode maskingMode);
+
+        ISession GetInnerSession();
+        void HandleException(Exception e);
+        bool IsHandleable(Exception e);
+        void SetMaskingMode(RequestContext context, MaskingMode maskingMode);
+        RequestContext WrapRequestContext(RequestContext context);
+    }
+
+    interface IServerReliableChannelBinder : IReliableChannelBinder
+    {
+        bool AddressResponse(Message request, Message response);
+        bool UseNewChannel(IChannel channel);
+
+        Task<Message> RequestAsync(Message message, TimeSpan timeout);
+        Task<Message> RequestAsync(Message message, TimeSpan timeout, MaskingMode maskingMode);
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Channels/LocalServiceSecuritySettings.cs b/src/CoreWCF.Primitives/src/CoreWCF/Channels/LocalServiceSecuritySettings.cs
new file mode 100644
index 0000000..04581f6
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Channels/LocalServiceSecuritySettings.cs
@@ -0,0 +1,377 @@
+using System;
+using System.Runtime;
+using CoreWCF.Runtime;
+using CoreWCF;
+using CoreWCF.Security;
+using System.Runtime.CompilerServices;
+using System.Globalization;
+
+namespace CoreWCF.Channels
+{    public sealed class LocalServiceSecuritySettings
+    {
+        //Move these to NegotiationTokenAuthenticator
+        internal const string defaultServerMaxNegotiationLifetimeString = "00:01:00";
+        internal const string defaultServerIssuedTokenLifetimeString = "10:00:00";
+        internal const string defaultServerIssuedTransitionTokenLifetimeString = "00:15:00";
+        internal const int defaultServerMaxActiveNegotiations = 128;
+
+        bool detectReplays;
+        int replayCacheSize;
+        TimeSpan replayWindow;
+        TimeSpan maxClockSkew;
+        TimeSpan issuedCookieLifetime;
+        int maxStatefulNegotiations;
+        TimeSpan negotiationTimeout;
+        int maxCachedCookies;
+        int maxPendingSessions;
+        TimeSpan inactivityTimeout;
+        TimeSpan sessionKeyRenewalInterval;
+        TimeSpan sessionKeyRolloverInterval;
+        bool reconnectTransportOnFailure;
+        TimeSpan timestampValidityDuration;
+        NonceCache nonceCache = null;
+
+        LocalServiceSecuritySettings(LocalServiceSecuritySettings other)
+        {
+            this.detectReplays = other.detectReplays;
+            this.replayCacheSize = other.replayCacheSize;
+            this.replayWindow = other.replayWindow;
+            this.maxClockSkew = other.maxClockSkew;
+            this.issuedCookieLifetime = other.issuedCookieLifetime;
+            this.maxStatefulNegotiations = other.maxStatefulNegotiations;
+            this.negotiationTimeout = other.negotiationTimeout;
+            this.maxPendingSessions = other.maxPendingSessions;
+            this.inactivityTimeout = other.inactivityTimeout;
+            this.sessionKeyRenewalInterval = other.sessionKeyRenewalInterval;
+            this.sessionKeyRolloverInterval = other.sessionKeyRolloverInterval;
+            this.reconnectTransportOnFailure = other.reconnectTransportOnFailure;
+            this.timestampValidityDuration = other.timestampValidityDuration;
+            this.maxCachedCookies = other.maxCachedCookies;
+            this.nonceCache = other.nonceCache;
+        }
+
+        public bool DetectReplays
+        {
+            get
+            {
+                return this.detectReplays;
+            }
+            set
+            {
+                this.detectReplays = value;
+            }
+        }
+
+        public int ReplayCacheSize
+        {
+            get
+            {
+                return this.replayCacheSize;
+            }
+            set
+            {
+                if (value < 0)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("value", value,
+                                                    SR.Format(SR.ValueMustBeNonNegative)));
+                }
+                this.replayCacheSize = value;
+            }
+        }
+
+        public TimeSpan ReplayWindow
+        {
+            get
+            {
+                return this.replayWindow;
+            }
+            set
+            {
+                if (value < TimeSpan.Zero)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("value", value,
+                        SR.Format(SR.SFxTimeoutOutOfRange0)));
+                }
+
+                if (TimeoutHelper.IsTooLarge(value))
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("value", value,
+                        SR.Format(SR.SFxTimeoutOutOfRangeTooBig)));
+                }
+
+                this.replayWindow = value;
+            }
+        }
+
+        public TimeSpan MaxClockSkew
+        {
+            get
+            {
+                return this.maxClockSkew;
+            }
+            set
+            {
+                if (value < TimeSpan.Zero)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("value", value,
+                        SR.Format(SR.SFxTimeoutOutOfRange0)));
+                }
+
+                if (TimeoutHelper.IsTooLarge(value))
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("value", value,
+                        SR.Format(SR.SFxTimeoutOutOfRangeTooBig)));
+                }
+
+                this.maxClockSkew = value;
+            }
+        }
+
+
+        public NonceCache NonceCache
+        {
+            get
+            {
+                return this.nonceCache;
+            }
+            set
+            {
+                this.nonceCache = value;
+            }
+        }
+
+        public TimeSpan IssuedCookieLifetime
+        {
+            get
+            {
+                return this.issuedCookieLifetime;
+            }
+            set
+            {
+                if (value < TimeSpan.Zero)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("value", value,
+                        SR.Format(SR.SFxTimeoutOutOfRange0)));
+                }
+
+                if (TimeoutHelper.IsTooLarge(value))
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("value", value,
+                        SR.Format(SR.SFxTimeoutOutOfRangeTooBig)));
+                }
+
+                this.issuedCookieLifetime = value;
+            }
+        }
+
+        public int MaxStatefulNegotiations
+        {
+            get
+            {
+                return this.maxStatefulNegotiations;
+            }
+            set
+            {
+                if (value < 0)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("value", value,
+                                                    SR.Format(SR.ValueMustBeNonNegative)));
+                }
+                this.maxStatefulNegotiations = value;
+            }
+        }
+
+        public TimeSpan NegotiationTimeout
+        {
+            get
+            {
+                return this.negotiationTimeout;
+            }
+            set
+            {
+                if (value < TimeSpan.Zero)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("value", value,
+                        SR.Format(SR.SFxTimeoutOutOfRange0)));
+                }
+
+                if (TimeoutHelper.IsTooLarge(value))
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("value", value,
+                        SR.Format(SR.SFxTimeoutOutOfRangeTooBig)));
+                }
+
+                this.negotiationTimeout = value;
+            }
+        }
+
+        public int MaxPendingSessions
+        {
+            get
+            {
+                return this.maxPendingSessions;
+            }
+            set
+            {
+                if (value < 0)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("value", value,
+                                                    SR.Format(SR.ValueMustBeNonNegative)));
+                }
+                this.maxPendingSessions = value;
+            }
+        }
+
+        public TimeSpan InactivityTimeout
+        {
+            get
+            {
+                return this.inactivityTimeout;
+            }
+            set
+            {
+                if (value < TimeSpan.Zero)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("value", value,
+                        SR.Format(SR.SFxTimeoutOutOfRange0)));
+                }
+
+                if (TimeoutHelper.IsTooLarge(value))
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("value", value,
+                        SR.Format(SR.SFxTimeoutOutOfRangeTooBig)));
+                }
+
+                this.inactivityTimeout = value;
+            }
+        }
+
+        public TimeSpan SessionKeyRenewalInterval
+        {
+            get
+            {
+                return this.sessionKeyRenewalInterval;
+            }
+            set
+            {
+                if (value < TimeSpan.Zero)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("value", value,
+                        SR.Format(SR.SFxTimeoutOutOfRange0)));
+                }
+
+                if (TimeoutHelper.IsTooLarge(value))
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("value", value,
+                        SR.Format(SR.SFxTimeoutOutOfRangeTooBig)));
+                }
+
+                this.sessionKeyRenewalInterval = value;
+            }
+        }
+
+        public TimeSpan SessionKeyRolloverInterval
+        {
+            get
+            {
+                return this.sessionKeyRolloverInterval;
+            }
+            set
+            {
+                if (value < TimeSpan.Zero)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("value", value,
+                        SR.Format(SR.SFxTimeoutOutOfRange0)));
+                }
+
+                if (TimeoutHelper.IsTooLarge(value))
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("value", value,
+                        SR.Format(SR.SFxTimeoutOutOfRangeTooBig)));
+                }
+
+                this.sessionKeyRolloverInterval = value;
+            }
+        }
+
+        public bool ReconnectTransportOnFailure
+        {
+            get
+            {
+                return this.reconnectTransportOnFailure;
+            }
+            set
+            {
+                this.reconnectTransportOnFailure = value;
+            }
+        }
+
+        public TimeSpan TimestampValidityDuration
+        {
+            get
+            {
+                return this.timestampValidityDuration;
+            }
+            set
+            {
+                if (value < TimeSpan.Zero)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("value", value,
+                        SR.Format(SR.SFxTimeoutOutOfRange0)));
+                }
+
+                if (TimeoutHelper.IsTooLarge(value))
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("value", value,
+                        SR.Format(SR.SFxTimeoutOutOfRangeTooBig)));
+                }
+
+                this.timestampValidityDuration = value;
+            }
+        }
+
+        public int MaxCachedCookies
+        {
+            get
+            {
+                return this.maxCachedCookies;
+            }
+            set
+            {
+                if (value < 0)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("value", value,
+                                                    SR.Format(SR.ValueMustBeNonNegative)));
+                }
+                this.maxCachedCookies = value;
+            }
+        }
+
+        public LocalServiceSecuritySettings()
+        {
+            this.DetectReplays = SecurityProtocolFactory.defaultDetectReplays;
+            this.ReplayCacheSize = SecurityProtocolFactory.defaultMaxCachedNonces;
+            this.ReplayWindow = SecurityProtocolFactory.defaultReplayWindow;
+            this.MaxClockSkew = SecurityProtocolFactory.defaultMaxClockSkew;
+            this.NegotiationTimeout = TimeSpan.Parse(defaultServerMaxNegotiationLifetimeString, CultureInfo.InvariantCulture);
+           this.IssuedCookieLifetime  = TimeSpan.Parse(defaultServerIssuedTokenLifetimeString, CultureInfo.InvariantCulture);
+             
+            //this.IssuedCookieLifetime = NegotiationTokenAuthenticator<NegotiationTokenAuthenticatorState>.defaultServerIssuedTokenLifetime;
+            //this.MaxStatefulNegotiations = NegotiationTokenAuthenticator<NegotiationTokenAuthenticatorState>.defaultServerMaxActiveNegotiations;
+            //this.NegotiationTimeout = NegotiationTokenAuthenticator<NegotiationTokenAuthenticatorState>.defaultServerMaxNegotiationLifetime;
+            this.maxPendingSessions = SecuritySessionServerSettings.defaultMaximumPendingSessions;
+            this.inactivityTimeout = SecuritySessionServerSettings.defaultInactivityTimeout;
+            this.sessionKeyRenewalInterval = SecuritySessionServerSettings.defaultKeyRenewalInterval;
+            this.sessionKeyRolloverInterval = SecuritySessionServerSettings.defaultKeyRolloverInterval;
+            this.reconnectTransportOnFailure = SecuritySessionServerSettings.defaultTolerateTransportFailures;
+            this.TimestampValidityDuration = SecurityProtocolFactory.defaultTimestampValidityDuration;
+       //     this.maxCachedCookies = NegotiationTokenAuthenticator<NegotiationTokenAuthenticatorState>.defaultServerMaxCachedTokens;
+            this.nonceCache = null;
+        }
+
+        public LocalServiceSecuritySettings Clone()
+        {
+            return new LocalServiceSecuritySettings(this);
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Channels/Message.cs b/src/CoreWCF.Primitives/src/CoreWCF/Channels/Message.cs
index 56d38d0..f71b902 100644
--- a/src/CoreWCF.Primitives/src/CoreWCF/Channels/Message.cs
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Channels/Message.cs
@@ -338,13 +338,13 @@ namespace CoreWCF.Channels
         //    return this.messageNavigator;
         //}
 
-        //internal void InitializeReply(Message request)
-        //{
-        //    UniqueId requestMessageID = request.Headers.MessageId;
-        //    if (requestMessageID == null)
-        //        throw TraceUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.RequestMessageDoesNotHaveAMessageID)), request);
-        //    Headers.RelatesTo = requestMessageID;
-        //}
+        internal void InitializeReply(Message request)
+        {
+            UniqueId requestMessageID = request.Headers.MessageId;
+            if (requestMessageID == null)
+                throw TraceUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.RequestMessageDoesNotHaveAMessageID)), request);
+            Headers.RelatesTo = requestMessageID;
+        }
 
         static internal bool IsFaultStartElement(XmlDictionaryReader reader, EnvelopeVersion version)
         {
@@ -1914,7 +1914,7 @@ namespace CoreWCF.Channels
             }
         }
 
-        class HeaderInfo : MessageHeaderInfo
+     public   class HeaderInfo : MessageHeaderInfo
         {
             string name;
             string ns;
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Channels/ReliableChannelBinder.cs b/src/CoreWCF.Primitives/src/CoreWCF/Channels/ReliableChannelBinder.cs
new file mode 100644
index 0000000..87b1103
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Channels/ReliableChannelBinder.cs
@@ -0,0 +1,25 @@
+﻿using System.Collections.Generic;
+using CoreWCF.Runtime;
+using System.Threading.Tasks;
+using System;
+using System.Threading;
+
+namespace CoreWCF.Channels
+{
+    internal enum TolerateFaultsMode
+    {
+        Never,
+        IfNotSecuritySession,
+        Always
+    }
+
+    [Flags]
+    internal enum MaskingMode
+    {
+        None = 0x0,
+        Handled = 0x1,
+        Unhandled = 0x2,
+        All = Handled | Unhandled
+    }
+
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Channels/SecurityBindingElement.cs b/src/CoreWCF.Primitives/src/CoreWCF/Channels/SecurityBindingElement.cs
new file mode 100644
index 0000000..2ec1273
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Channels/SecurityBindingElement.cs
@@ -0,0 +1,995 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Text;
+using CoreWCF.Configuration;
+using CoreWCF.Security;
+using System.Collections.ObjectModel;
+using System.Globalization;
+using CoreWCF.IdentityModel.Selectors;
+using CoreWCF.IdentityModel.Tokens;
+using System.Net.Security;
+using System.Runtime;
+using System.Security.Authentication.ExtendedProtection;
+using CoreWCF.Description;
+using CoreWCF.Security;
+using CoreWCF.Security.Tokens;
+using System.Xml;
+namespace CoreWCF.Channels
+{
+    public abstract class SecurityBindingElement : BindingElement
+    {
+        internal const string defaultAlgorithmSuiteString = ConfigurationStrings.Default;
+        internal static readonly SecurityAlgorithmSuite defaultDefaultAlgorithmSuite = SecurityAlgorithmSuite.Default;
+        internal const bool defaultIncludeTimestamp = true;
+        internal const bool defaultAllowInsecureTransport = false;
+        internal const MessageProtectionOrder defaultMessageProtectionOrder = MessageProtectionOrder.SignBeforeEncryptAndEncryptSignature;
+        internal const bool defaultRequireSignatureConfirmation = false;
+        internal const bool defaultEnableUnsecuredResponse = false;
+        internal const bool defaultProtectTokens = false;
+
+        SecurityAlgorithmSuite defaultAlgorithmSuite;
+        SupportingTokenParameters endpointSupportingTokenParameters;
+        SupportingTokenParameters optionalEndpointSupportingTokenParameters;
+        bool includeTimestamp;
+        SecurityKeyEntropyMode keyEntropyMode;
+        Dictionary<string, SupportingTokenParameters> operationSupportingTokenParameters;
+        Dictionary<string, SupportingTokenParameters> optionalOperationSupportingTokenParameters;
+        // LocalClientSecuritySettings localClientSettings;
+        LocalServiceSecuritySettings localServiceSettings;
+        MessageSecurityVersion messageSecurityVersion;
+        SecurityHeaderLayout securityHeaderLayout;
+        // InternalDuplexBindingElement internalDuplexBindingElement;
+        long maxReceivedMessageSize = TransportDefaults.MaxReceivedMessageSize;
+        XmlDictionaryReaderQuotas readerQuotas;
+        bool doNotEmitTrust = false; // true if user create a basic http standard binding, the custombinding equivalent will not set this flag 
+        bool supportsExtendedProtectionPolicy;
+        bool allowInsecureTransport;
+        bool enableUnsecuredResponse;
+        bool protectTokens = defaultProtectTokens;
+
+        internal SecurityBindingElement()
+            : base()
+        {
+            this.messageSecurityVersion = MessageSecurityVersion.Default;
+            this.keyEntropyMode = SecurityKeyEntropyMode.CombinedEntropy; // AcceleratedTokenProvider.defaultKeyEntropyMode;
+            this.includeTimestamp = defaultIncludeTimestamp;
+            this.defaultAlgorithmSuite = defaultDefaultAlgorithmSuite;
+            // this.localClientSettings = new LocalClientSecuritySettings();
+            this.localServiceSettings = new LocalServiceSecuritySettings();
+            this.endpointSupportingTokenParameters = new SupportingTokenParameters();
+            this.optionalEndpointSupportingTokenParameters = new SupportingTokenParameters();
+            this.operationSupportingTokenParameters = new Dictionary<string, SupportingTokenParameters>();
+            this.optionalOperationSupportingTokenParameters = new Dictionary<string, SupportingTokenParameters>();
+            this.securityHeaderLayout = SecurityHeaderLayout.Strict; // SecurityProtocolFactory.defaultSecurityHeaderLayout;
+            this.allowInsecureTransport = defaultAllowInsecureTransport;
+            this.enableUnsecuredResponse = defaultEnableUnsecuredResponse;
+            this.protectTokens = defaultProtectTokens;
+        }
+
+        internal SecurityBindingElement(SecurityBindingElement elementToBeCloned)
+            : base(elementToBeCloned)
+        {
+            if (elementToBeCloned == null)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("elementToBeCloned");
+
+            this.defaultAlgorithmSuite = elementToBeCloned.defaultAlgorithmSuite;
+            this.includeTimestamp = elementToBeCloned.includeTimestamp;
+            this.keyEntropyMode = elementToBeCloned.keyEntropyMode;
+            this.messageSecurityVersion = elementToBeCloned.messageSecurityVersion;
+            this.securityHeaderLayout = elementToBeCloned.securityHeaderLayout;
+            this.endpointSupportingTokenParameters = (SupportingTokenParameters)elementToBeCloned.endpointSupportingTokenParameters.Clone();
+            this.optionalEndpointSupportingTokenParameters = (SupportingTokenParameters)elementToBeCloned.optionalEndpointSupportingTokenParameters.Clone();
+            this.operationSupportingTokenParameters = new Dictionary<string, SupportingTokenParameters>();
+            foreach (string key in elementToBeCloned.operationSupportingTokenParameters.Keys)
+            {
+                this.operationSupportingTokenParameters[key] = (SupportingTokenParameters)elementToBeCloned.operationSupportingTokenParameters[key].Clone();
+            }
+            this.optionalOperationSupportingTokenParameters = new Dictionary<string, SupportingTokenParameters>();
+            foreach (string key in elementToBeCloned.optionalOperationSupportingTokenParameters.Keys)
+            {
+                this.optionalOperationSupportingTokenParameters[key] = (SupportingTokenParameters)elementToBeCloned.optionalOperationSupportingTokenParameters[key].Clone();
+            }
+            // this.localClientSettings = (LocalClientSecuritySettings)elementToBeCloned.localClientSettings.Clone();
+            this.localServiceSettings = (LocalServiceSecuritySettings)elementToBeCloned.localServiceSettings.Clone();
+            // this.internalDuplexBindingElement = elementToBeCloned.internalDuplexBindingElement;
+            this.maxReceivedMessageSize = elementToBeCloned.maxReceivedMessageSize;
+            this.readerQuotas = elementToBeCloned.readerQuotas;
+            this.doNotEmitTrust = elementToBeCloned.doNotEmitTrust;
+            this.allowInsecureTransport = elementToBeCloned.allowInsecureTransport;
+            this.enableUnsecuredResponse = elementToBeCloned.enableUnsecuredResponse;
+            this.supportsExtendedProtectionPolicy = elementToBeCloned.supportsExtendedProtectionPolicy;
+            this.protectTokens = elementToBeCloned.protectTokens;
+        }
+
+        internal bool SupportsExtendedProtectionPolicy
+        {
+            get { return this.supportsExtendedProtectionPolicy; }
+            set { this.supportsExtendedProtectionPolicy = value; }
+        }
+
+        public SupportingTokenParameters EndpointSupportingTokenParameters
+        {
+            get
+            {
+                return this.endpointSupportingTokenParameters;
+            }
+        }
+
+        public SupportingTokenParameters OptionalEndpointSupportingTokenParameters
+        {
+            get
+            {
+                return this.optionalEndpointSupportingTokenParameters;
+            }
+        }
+
+
+        public IDictionary<string, SupportingTokenParameters> OperationSupportingTokenParameters
+        {
+            get
+            {
+                return this.operationSupportingTokenParameters;
+            }
+        }
+
+        public IDictionary<string, SupportingTokenParameters> OptionalOperationSupportingTokenParameters
+        {
+            get
+            {
+                return this.optionalOperationSupportingTokenParameters;
+            }
+        }
+
+        public SecurityHeaderLayout SecurityHeaderLayout
+        {
+            get
+            {
+                return this.securityHeaderLayout;
+            }
+            set
+            {
+                if (!SecurityHeaderLayoutHelper.IsDefined(value))
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("value"));
+
+                this.securityHeaderLayout = value;
+            }
+        }
+
+        public MessageSecurityVersion MessageSecurityVersion
+        {
+            get
+            {
+                return this.messageSecurityVersion;
+            }
+            set
+            {
+                if (value == null)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException("value"));
+                this.messageSecurityVersion = value;
+            }
+        }
+
+        public bool EnableUnsecuredResponse
+        {
+            get
+            {
+                return this.enableUnsecuredResponse;
+            }
+            set
+            {
+                this.enableUnsecuredResponse = value;
+            }
+        }
+
+        public bool IncludeTimestamp
+        {
+            get
+            {
+                return this.includeTimestamp;
+            }
+            set
+            {
+                this.includeTimestamp = value;
+            }
+        }
+
+        public bool AllowInsecureTransport
+        {
+            get
+            {
+                return this.allowInsecureTransport;
+            }
+            set
+            {
+                this.allowInsecureTransport = value;
+            }
+        }
+
+        public SecurityAlgorithmSuite DefaultAlgorithmSuite
+        {
+            get
+            {
+                return this.defaultAlgorithmSuite;
+            }
+            set
+            {
+                if (value == null)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException("value"));
+                this.defaultAlgorithmSuite = value;
+            }
+        }
+
+        public bool ProtectTokens
+        {
+            get
+            {
+                return this.protectTokens;
+            }
+            set
+            {
+                this.protectTokens = value;
+            }
+        }
+
+        /*
+        public LocalClientSecuritySettings LocalClientSettings
+        {
+            get
+            {
+                return this.localClientSettings;
+            }
+        } */
+
+        public LocalServiceSecuritySettings LocalServiceSettings
+        {
+            get
+            {
+                return this.localServiceSettings;
+            }
+        }
+
+        public SecurityKeyEntropyMode KeyEntropyMode
+        {
+            get
+            {
+                return this.keyEntropyMode;
+            }
+            set
+            {
+                if (!SecurityKeyEntropyModeHelper.IsDefined(value))
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("value"));
+                }
+                this.keyEntropyMode = value;
+            }
+        }
+
+        internal virtual bool SessionMode
+        {
+            get { return false; }
+        }
+
+        internal virtual bool SupportsDuplex
+        {
+            get { return false; }
+        }
+
+        internal virtual bool SupportsRequestReply
+        {
+            get { return false; }
+        }
+
+        internal long MaxReceivedMessageSize
+        {
+            get { return this.maxReceivedMessageSize; }
+            set { this.maxReceivedMessageSize = value; }
+        }
+
+        internal bool DoNotEmitTrust
+        {
+            get { return this.doNotEmitTrust; }
+            set { this.doNotEmitTrust = value; }
+        }
+
+        internal XmlDictionaryReaderQuotas ReaderQuotas
+        {
+            get { return this.readerQuotas; }
+            set { this.readerQuotas = value; }
+        }
+
+        void GetSupportingTokensCapabilities(ICollection<SecurityTokenParameters> parameters, out bool supportsClientAuth, out bool supportsWindowsIdentity)
+        {
+            supportsClientAuth = false;
+            supportsWindowsIdentity = false;
+            foreach (SecurityTokenParameters p in parameters)
+            {
+                if (p.SupportsClientAuthentication)
+                    supportsClientAuth = true;
+                if (p.SupportsClientWindowsIdentity)
+                    supportsWindowsIdentity = true;
+            }
+        }
+
+        void GetSupportingTokensCapabilities(SupportingTokenParameters requirements, out bool supportsClientAuth, out bool supportsWindowsIdentity)
+        {
+            supportsClientAuth = false;
+            supportsWindowsIdentity = false;
+            bool tmpSupportsClientAuth;
+            bool tmpSupportsWindowsIdentity;
+            this.GetSupportingTokensCapabilities(requirements.Endorsing, out tmpSupportsClientAuth, out tmpSupportsWindowsIdentity);
+            supportsClientAuth = supportsClientAuth || tmpSupportsClientAuth;
+            supportsWindowsIdentity = supportsWindowsIdentity || tmpSupportsWindowsIdentity;
+
+            this.GetSupportingTokensCapabilities(requirements.SignedEndorsing, out tmpSupportsClientAuth, out tmpSupportsWindowsIdentity);
+            supportsClientAuth = supportsClientAuth || tmpSupportsClientAuth;
+            supportsWindowsIdentity = supportsWindowsIdentity || tmpSupportsWindowsIdentity;
+
+            this.GetSupportingTokensCapabilities(requirements.SignedEncrypted, out tmpSupportsClientAuth, out tmpSupportsWindowsIdentity);
+            supportsClientAuth = supportsClientAuth || tmpSupportsClientAuth;
+            supportsWindowsIdentity = supportsWindowsIdentity || tmpSupportsWindowsIdentity;
+        }
+
+        internal bool IsUnderlyingListenerDuplex<TChannel>(BindingContext context)
+        {
+            return ((typeof(TChannel) == typeof(IDuplexSessionChannel)) && context.CanBuildNextServiceDispatcher<IDuplexChannel>()
+                && !context.CanBuildNextServiceDispatcher<IDuplexSessionChannel>());
+        }
+
+        internal void GetSupportingTokensCapabilities(out bool supportsClientAuth, out bool supportsWindowsIdentity)
+        {
+            this.GetSupportingTokensCapabilities(this.EndpointSupportingTokenParameters, out supportsClientAuth, out supportsWindowsIdentity);
+        }
+
+        // SecureConversation needs a demuxer below security to 1) demux between the security sessions and 2) demux the SCT issue and renewal messages
+        // to the authenticator
+        internal void AddDemuxerForSecureConversation(ChannelBuilder builder, BindingContext secureConversationBindingContext)
+        {
+            // add a demuxer element  right below security unless there's a demuxer already present below and the only 
+            // binding elements between security and the demuxer are "ancillary" binding elements like message encoding element and
+            // stream-security upgrade element. We could always add the channel demuxer below security but not doing so in the ancillary
+            // binding elements case improves perf
+            //int numChannelDemuxersBelowSecurity = 0;
+            //bool doesBindingHaveShapeChangingElements = false;
+            //for (int i = 0; i < builder.Binding.Elements.Count; ++i)
+            //{
+            //    if ((builder.Binding.Elements[i] is MessageEncodingBindingElement) || (builder.Binding.Elements[i] is StreamUpgradeBindingElement))
+            //    {
+            //        continue;
+            //    }
+            //    if (builder.Binding.Elements[i] is ChannelDemuxerBindingElement)
+            //    {
+            //        ++numChannelDemuxersBelowSecurity;
+            //    }
+            //    else if (builder.Binding.Elements[i] is TransportBindingElement)
+            //    {
+            //        break;
+            //    }
+            //    else
+            //    {
+            //        doesBindingHaveShapeChangingElements = true;
+            //    }
+            //}
+            //if (numChannelDemuxersBelowSecurity == 1 && !doesBindingHaveShapeChangingElements)
+            //{
+            //    return;
+            //}
+
+            //ChannelDemuxerBindingElement demuxer = new ChannelDemuxerBindingElement(false);
+            //demuxer.MaxPendingSessions = this.LocalServiceSettings.MaxPendingSessions;
+            //demuxer.PeekTimeout = this.LocalServiceSettings.NegotiationTimeout;
+
+            //builder.Binding.Elements.Insert(0, demuxer);
+            //secureConversationBindingContext.RemainingBindingElements.Insert(0, demuxer);
+        }
+
+        internal void ApplyPropertiesOnDemuxer(ChannelBuilder builder, BindingContext context)
+        {
+            /* TODO later
+             Collection<ChannelDemuxerBindingElement> demuxerElements = builder.Binding.Elements.FindAll<ChannelDemuxerBindingElement>();
+             foreach (ChannelDemuxerBindingElement element in demuxerElements)
+             {
+                 if (element != null)
+                 {
+                     element.MaxPendingSessions = this.LocalServiceSettings.MaxPendingSessions;
+                     element.PeekTimeout = this.LocalServiceSettings.NegotiationTimeout;
+                 }
+             }*/
+        }
+
+        /*
+        static BindingContext CreateIssuerBindingContextForNegotiation(BindingContext issuerBindingContext)
+        {
+            TransportBindingElement transport = issuerBindingContext.RemainingBindingElements.Find<TransportBindingElement>();
+            if (transport == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.GetString(SR.TransportBindingElementNotFound)));
+            }
+            ChannelDemuxerBindingElement demuxer = null;
+            // pick the demuxer above transport (i.e. the last demuxer in the array)
+            for (int i = 0; i < issuerBindingContext.RemainingBindingElements.Count; ++i)
+            {
+                if (issuerBindingContext.RemainingBindingElements[i] is ChannelDemuxerBindingElement)
+                {
+                    demuxer = (ChannelDemuxerBindingElement)issuerBindingContext.RemainingBindingElements[i];
+                }
+            }
+            if (demuxer == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.GetString(SR.ChannelDemuxerBindingElementNotFound)));
+            }
+            BindingElementCollection negotiationBindingElements = new BindingElementCollection();
+            negotiationBindingElements.Add(demuxer.Clone());
+            negotiationBindingElements.Add(transport.Clone());
+            CustomBinding binding = new CustomBinding(negotiationBindingElements);
+            binding.OpenTimeout = issuerBindingContext.Binding.OpenTimeout;
+            binding.CloseTimeout = issuerBindingContext.Binding.CloseTimeout;
+            binding.SendTimeout = issuerBindingContext.Binding.SendTimeout;
+            binding.ReceiveTimeout = issuerBindingContext.Binding.ReceiveTimeout;
+            if (issuerBindingContext.ListenUriBaseAddress != null)
+            {
+                return new BindingContext(binding, new BindingParameterCollection(issuerBindingContext.BindingParameters), issuerBindingContext.ListenUriBaseAddress,
+                    issuerBindingContext.ListenUriRelativeAddress, issuerBindingContext.ListenUriMode);
+            }
+            else
+            {
+                return new BindingContext(binding, new BindingParameterCollection(issuerBindingContext.BindingParameters));
+            }
+        }
+
+        protected static void SetIssuerBindingContextIfRequired(SecurityTokenParameters parameters, BindingContext issuerBindingContext)
+        {
+            if (parameters is SslSecurityTokenParameters)
+            {
+                ((SslSecurityTokenParameters)parameters).IssuerBindingContext = CreateIssuerBindingContextForNegotiation(issuerBindingContext);
+            }
+            else if (parameters is SspiSecurityTokenParameters)
+            {
+                ((SspiSecurityTokenParameters)parameters).IssuerBindingContext = CreateIssuerBindingContextForNegotiation(issuerBindingContext);
+            }
+        }
+
+        static void SetIssuerBindingContextIfRequired(SupportingTokenParameters supportingParameters, BindingContext issuerBindingContext)
+        {
+            for (int i = 0; i < supportingParameters.Endorsing.Count; ++i)
+            {
+                SetIssuerBindingContextIfRequired(supportingParameters.Endorsing[i], issuerBindingContext);
+            }
+            for (int i = 0; i < supportingParameters.SignedEndorsing.Count; ++i)
+            {
+                SetIssuerBindingContextIfRequired(supportingParameters.SignedEndorsing[i], issuerBindingContext);
+            }
+            for (int i = 0; i < supportingParameters.Signed.Count; ++i)
+            {
+                SetIssuerBindingContextIfRequired(supportingParameters.Signed[i], issuerBindingContext);
+            }
+            for (int i = 0; i < supportingParameters.SignedEncrypted.Count; ++i)
+            {
+                SetIssuerBindingContextIfRequired(supportingParameters.SignedEncrypted[i], issuerBindingContext);
+            }
+        }
+
+        void SetIssuerBindingContextIfRequired(BindingContext issuerBindingContext)
+        {
+            SetIssuerBindingContextIfRequired(this.EndpointSupportingTokenParameters, issuerBindingContext);
+            SetIssuerBindingContextIfRequired(this.OptionalEndpointSupportingTokenParameters, issuerBindingContext);
+            foreach (SupportingTokenParameters parameters in this.OperationSupportingTokenParameters.Values)
+            {
+                SetIssuerBindingContextIfRequired(parameters, issuerBindingContext);
+            }
+            foreach (SupportingTokenParameters parameters in this.OptionalOperationSupportingTokenParameters.Values)
+            {
+                SetIssuerBindingContextIfRequired(parameters, issuerBindingContext);
+            }
+        }
+
+        internal bool RequiresChannelDemuxer(SecurityTokenParameters parameters)
+        {
+            return ((parameters is SecureConversationSecurityTokenParameters)
+                    || (parameters is SslSecurityTokenParameters)
+                    || (parameters is SspiSecurityTokenParameters));
+        }
+
+        internal virtual bool RequiresChannelDemuxer()
+        {
+            foreach (SecurityTokenParameters parameters in EndpointSupportingTokenParameters.Endorsing)
+            {
+                if (RequiresChannelDemuxer(parameters))
+                {
+                    return true;
+                }
+            }
+            foreach (SecurityTokenParameters parameters in EndpointSupportingTokenParameters.SignedEndorsing)
+            {
+                if (RequiresChannelDemuxer(parameters))
+                {
+                    return true;
+                }
+            }
+            foreach (SecurityTokenParameters parameters in OptionalEndpointSupportingTokenParameters.Endorsing)
+            {
+                if (RequiresChannelDemuxer(parameters))
+                {
+                    return true;
+                }
+            }
+            foreach (SecurityTokenParameters parameters in OptionalEndpointSupportingTokenParameters.SignedEndorsing)
+            {
+                if (RequiresChannelDemuxer(parameters))
+                {
+                    return true;
+                }
+            }
+            foreach (SupportingTokenParameters supportingParameters in OperationSupportingTokenParameters.Values)
+            {
+                foreach (SecurityTokenParameters parameters in supportingParameters.Endorsing)
+                {
+                    if (RequiresChannelDemuxer(parameters))
+                    {
+                        return true;
+                    }
+                }
+                foreach (SecurityTokenParameters parameters in supportingParameters.SignedEndorsing)
+                {
+                    if (RequiresChannelDemuxer(parameters))
+                    {
+                        return true;
+                    }
+                }
+            }
+            foreach (SupportingTokenParameters supportingParameters in OptionalOperationSupportingTokenParameters.Values)
+            {
+                foreach (SecurityTokenParameters parameters in supportingParameters.Endorsing)
+                {
+                    if (RequiresChannelDemuxer(parameters))
+                    {
+                        return true;
+                    }
+                }
+                foreach (SecurityTokenParameters parameters in supportingParameters.SignedEndorsing)
+                {
+                    if (RequiresChannelDemuxer(parameters))
+                    {
+                        return true;
+                    }
+                }
+            }
+            return false;
+        }
+
+
+
+        void SetPrivacyNoticeUriIfRequired(SecurityProtocolFactory factory, Binding binding)
+        {
+            PrivacyNoticeBindingElement privacyElement = binding.CreateBindingElements().Find<PrivacyNoticeBindingElement>();
+            if (privacyElement != null)
+            {
+                factory.PrivacyNoticeUri = privacyElement.Url;
+                factory.PrivacyNoticeVersion = privacyElement.Version;
+            }
+        }
+        */
+        internal void ConfigureProtocolFactory(SecurityProtocolFactory factory, SecurityCredentialsManager credentialsManager, bool isForService, BindingContext issuerBindingContext, Binding binding)
+        {
+            if (factory == null)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException("factory"));
+            if (credentialsManager == null)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException("credentialsManager"));
+
+            factory.AddTimestamp = this.IncludeTimestamp;
+            factory.IncomingAlgorithmSuite = this.DefaultAlgorithmSuite;
+            factory.OutgoingAlgorithmSuite = this.DefaultAlgorithmSuite;
+            factory.SecurityHeaderLayout = this.SecurityHeaderLayout;
+
+            if (!isForService)
+            {
+                /* factory.TimestampValidityDuration = this.LocalClientSettings.TimestampValidityDuration;
+                 factory.DetectReplays = this.LocalClientSettings.DetectReplays;
+                 factory.MaxCachedNonces = this.LocalClientSettings.ReplayCacheSize;
+                 factory.MaxClockSkew = this.LocalClientSettings.MaxClockSkew;
+                 factory.ReplayWindow = this.LocalClientSettings.ReplayWindow;
+
+                 if (this.LocalClientSettings.DetectReplays)
+                 {
+                     factory.NonceCache = this.LocalClientSettings.NonceCache;
+                 }*/
+            }
+            else
+            {
+                factory.TimestampValidityDuration = this.LocalServiceSettings.TimestampValidityDuration;
+                factory.DetectReplays = this.LocalServiceSettings.DetectReplays;
+                factory.MaxCachedNonces = this.LocalServiceSettings.ReplayCacheSize;
+                factory.MaxClockSkew = this.LocalServiceSettings.MaxClockSkew;
+                factory.ReplayWindow = this.LocalServiceSettings.ReplayWindow;
+
+                if (this.LocalServiceSettings.DetectReplays)
+                {
+                    factory.NonceCache = this.LocalServiceSettings.NonceCache;
+                }
+            }
+
+            factory.SecurityBindingElement = (SecurityBindingElement)this.Clone();
+            factory.SecurityBindingElement.SetIssuerBindingContextIfRequired(issuerBindingContext);
+            factory.SecurityTokenManager = credentialsManager.CreateSecurityTokenManager();
+            SecurityTokenSerializer tokenSerializer = factory.SecurityTokenManager.CreateSecurityTokenSerializer(this.messageSecurityVersion.SecurityTokenVersion);
+            factory.StandardsManager = new SecurityStandardsManager(this.messageSecurityVersion, tokenSerializer);
+        }
+
+        internal abstract SecurityProtocolFactory CreateSecurityProtocolFactory<TChannel>(BindingContext context, SecurityCredentialsManager credentialsManager,
+        bool isForService, BindingContext issuanceBindingContext);
+
+        public override IServiceDispatcher BuildServiceDispatcher<TChannel>(BindingContext context, IServiceDispatcher innerDispatcher)
+        {
+            if (context == null)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("context");
+
+            if (!this.CanBuildServiceDispatcher<TChannel>(context))
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.ChannelTypeNotSupported, typeof(TChannel)), "TChannel"));
+            }
+
+            this.readerQuotas = context.GetInnerProperty<XmlDictionaryReaderQuotas>();
+            if (readerQuotas == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.EncodingBindingElementDoesNotHandleReaderQuotas)));
+            }
+
+            TransportBindingElement transportBindingElement = null;
+            if (context.RemainingBindingElements != null)
+                transportBindingElement = context.RemainingBindingElements.Find<TransportBindingElement>();
+
+            if (transportBindingElement != null)
+                this.maxReceivedMessageSize = transportBindingElement.MaxReceivedMessageSize;
+            return this.BuildServiceDispatcherCore<TChannel>(context, innerDispatcher);
+        }
+        protected abstract IServiceDispatcher BuildServiceDispatcherCore<TChannel>(BindingContext context, IServiceDispatcher serviceDispatcher)
+            where TChannel : class, IChannel;
+        public override bool CanBuildServiceDispatcher<TChannel>(BindingContext context)
+        {
+            if (context == null)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("context");
+
+            // InternalDuplexBindingElement.AddDuplexListenerSupport(context, ref this.internalDuplexBindingElement);
+
+            //  if (this.SessionMode)
+            //  {
+            //      return this.CanBuildSessionChannelListener<TChannel>(context);
+            //  }
+
+            if (!context.CanBuildNextServiceDispatcher<TChannel>())
+            {
+                return false;
+            }
+
+            return typeof(TChannel) == typeof(IInputChannel) || typeof(TChannel) == typeof(IInputSessionChannel) ||
+                (this.SupportsDuplex && (typeof(TChannel) == typeof(IDuplexChannel) || typeof(TChannel) == typeof(IDuplexSessionChannel))) ||
+                (this.SupportsRequestReply && (typeof(TChannel) == typeof(IReplyChannel) || typeof(TChannel) == typeof(IReplySessionChannel)));
+        }
+
+
+        public virtual void SetKeyDerivation(bool requireDerivedKeys)
+        {
+            this.EndpointSupportingTokenParameters.SetKeyDerivation(requireDerivedKeys);
+            this.OptionalEndpointSupportingTokenParameters.SetKeyDerivation(requireDerivedKeys);
+            foreach (SupportingTokenParameters t in this.OperationSupportingTokenParameters.Values)
+                t.SetKeyDerivation(requireDerivedKeys);
+            foreach (SupportingTokenParameters t in this.OptionalOperationSupportingTokenParameters.Values)
+            {
+                t.SetKeyDerivation(requireDerivedKeys);
+            }
+        }
+
+        internal virtual bool IsSetKeyDerivation(bool requireDerivedKeys)
+        {
+            if (!this.EndpointSupportingTokenParameters.IsSetKeyDerivation(requireDerivedKeys))
+                return false;
+
+            if (!this.OptionalEndpointSupportingTokenParameters.IsSetKeyDerivation(requireDerivedKeys))
+                return false;
+
+            foreach (SupportingTokenParameters t in this.OperationSupportingTokenParameters.Values)
+            {
+                if (!t.IsSetKeyDerivation(requireDerivedKeys))
+                    return false;
+            }
+            foreach (SupportingTokenParameters t in this.OptionalOperationSupportingTokenParameters.Values)
+            {
+                if (!t.IsSetKeyDerivation(requireDerivedKeys))
+                    return false;
+            }
+            return true;
+        }
+
+        internal ChannelProtectionRequirements GetProtectionRequirements(AddressingVersion addressing, ProtectionLevel defaultProtectionLevel)
+        {
+            if (addressing == null)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("addressing");
+
+            ChannelProtectionRequirements result = new ChannelProtectionRequirements();
+            ProtectionLevel supportedRequestProtectionLevel = this.GetIndividualProperty<ISecurityCapabilities>().SupportedRequestProtectionLevel;
+            ProtectionLevel supportedResponseProtectionLevel = this.GetIndividualProperty<ISecurityCapabilities>().SupportedResponseProtectionLevel;
+
+            bool canSupportMoreThanTheDefault =
+                (ProtectionLevelHelper.IsStrongerOrEqual(supportedRequestProtectionLevel, defaultProtectionLevel)
+                && ProtectionLevelHelper.IsStrongerOrEqual(supportedResponseProtectionLevel, defaultProtectionLevel));
+            if (canSupportMoreThanTheDefault)
+            {
+                MessagePartSpecification signedParts = new MessagePartSpecification();
+                MessagePartSpecification encryptedParts = new MessagePartSpecification();
+                if (defaultProtectionLevel != ProtectionLevel.None)
+                {
+                    signedParts.IsBodyIncluded = true;
+                    if (defaultProtectionLevel == ProtectionLevel.EncryptAndSign)
+                    {
+                        encryptedParts.IsBodyIncluded = true;
+                    }
+                }
+                signedParts.MakeReadOnly();
+                encryptedParts.MakeReadOnly();
+                if (addressing.FaultAction != null)
+                {
+                    // Addressing faults
+                    result.IncomingSignatureParts.AddParts(signedParts, addressing.FaultAction);
+                    result.OutgoingSignatureParts.AddParts(signedParts, addressing.FaultAction);
+                    result.IncomingEncryptionParts.AddParts(encryptedParts, addressing.FaultAction);
+                    result.OutgoingEncryptionParts.AddParts(encryptedParts, addressing.FaultAction);
+                }
+                if (addressing.DefaultFaultAction != null)
+                {
+                    // Faults that do not specify a particular action
+                    result.IncomingSignatureParts.AddParts(signedParts, addressing.DefaultFaultAction);
+                    result.OutgoingSignatureParts.AddParts(signedParts, addressing.DefaultFaultAction);
+                    result.IncomingEncryptionParts.AddParts(encryptedParts, addressing.DefaultFaultAction);
+                    result.OutgoingEncryptionParts.AddParts(encryptedParts, addressing.DefaultFaultAction);
+                }
+                // Infrastructure faults
+                result.IncomingSignatureParts.AddParts(signedParts, FaultCodeConstants.Actions.NetDispatcher);
+                result.OutgoingSignatureParts.AddParts(signedParts, FaultCodeConstants.Actions.NetDispatcher);
+                result.IncomingEncryptionParts.AddParts(encryptedParts, FaultCodeConstants.Actions.NetDispatcher);
+                result.OutgoingEncryptionParts.AddParts(encryptedParts, FaultCodeConstants.Actions.NetDispatcher);
+            }
+
+            return result;
+        }
+
+        public override T GetProperty<T>(BindingContext context)
+        {
+            if (context == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("context");
+            }
+            if (typeof(T) == typeof(ISecurityCapabilities))
+            {
+                return (T)(object)GetSecurityCapabilities(context);
+            }
+            else if (typeof(T) == typeof(IdentityVerifier))
+            {
+                throw new NotImplementedException();
+               // return (T)(object)this.localClientSettings.IdentityVerifier;
+            }
+            else
+            {
+                return context.GetInnerProperty<T>();
+            }
+        }
+
+        internal abstract ISecurityCapabilities GetIndividualISecurityCapabilities();
+
+        ISecurityCapabilities GetSecurityCapabilities(BindingContext context)
+        {
+            ISecurityCapabilities thisSecurityCapability = this.GetIndividualISecurityCapabilities();
+            ISecurityCapabilities lowerSecurityCapability = context.GetInnerProperty<ISecurityCapabilities>();
+            if (lowerSecurityCapability == null)
+            {
+                return thisSecurityCapability;
+            }
+            else
+            {
+                bool supportsClientAuth = thisSecurityCapability.SupportsClientAuthentication;
+                bool supportsClientWindowsIdentity = thisSecurityCapability.SupportsClientWindowsIdentity;
+                bool supportsServerAuth = thisSecurityCapability.SupportsServerAuthentication || lowerSecurityCapability.SupportsServerAuthentication;
+                ProtectionLevel requestProtectionLevel = ProtectionLevelHelper.Max(thisSecurityCapability.SupportedRequestProtectionLevel, lowerSecurityCapability.SupportedRequestProtectionLevel);
+                ProtectionLevel responseProtectionLevel = ProtectionLevelHelper.Max(thisSecurityCapability.SupportedResponseProtectionLevel, lowerSecurityCapability.SupportedResponseProtectionLevel);
+                return new SecurityCapabilities(supportsClientAuth, supportsServerAuth, supportsClientWindowsIdentity, requestProtectionLevel, responseProtectionLevel);
+            }
+        }
+        void SetIssuerBindingContextIfRequired(BindingContext issuerBindingContext)
+        {
+            SetIssuerBindingContextIfRequired(this.EndpointSupportingTokenParameters, issuerBindingContext);
+            SetIssuerBindingContextIfRequired(this.OptionalEndpointSupportingTokenParameters, issuerBindingContext);
+            foreach (SupportingTokenParameters parameters in this.OperationSupportingTokenParameters.Values)
+            {
+                SetIssuerBindingContextIfRequired(parameters, issuerBindingContext);
+            }
+            foreach (SupportingTokenParameters parameters in this.OptionalOperationSupportingTokenParameters.Values)
+            {
+                SetIssuerBindingContextIfRequired(parameters, issuerBindingContext);
+            }
+        }
+       
+
+        protected static void SetIssuerBindingContextIfRequired(SecurityTokenParameters parameters, BindingContext issuerBindingContext)
+        {
+            Type typ = parameters.GetType();
+            if (!(parameters is UserNameSecurityTokenParameters))
+                throw new NotImplementedException(); //TODO implement rest later
+            //if (parameters is SslSecurityTokenParameters)
+            //{
+            //    ((SslSecurityTokenParameters)parameters).IssuerBindingContext = CreateIssuerBindingContextForNegotiation(issuerBindingContext);
+            //}
+            //else if (parameters is SspiSecurityTokenParameters)
+            //{
+            //    ((SspiSecurityTokenParameters)parameters).IssuerBindingContext = CreateIssuerBindingContextForNegotiation(issuerBindingContext);
+            //}
+        }
+
+        static void SetIssuerBindingContextIfRequired(SupportingTokenParameters supportingParameters, BindingContext issuerBindingContext)
+        {
+            for (int i = 0; i < supportingParameters.Endorsing.Count; ++i)
+            {
+                SetIssuerBindingContextIfRequired(supportingParameters.Endorsing[i], issuerBindingContext);
+            }
+            for (int i = 0; i < supportingParameters.SignedEndorsing.Count; ++i)
+            {
+                SetIssuerBindingContextIfRequired(supportingParameters.SignedEndorsing[i], issuerBindingContext);
+            }
+            for (int i = 0; i < supportingParameters.Signed.Count; ++i)
+            {
+                SetIssuerBindingContextIfRequired(supportingParameters.Signed[i], issuerBindingContext);
+            }
+            for (int i = 0; i < supportingParameters.SignedEncrypted.Count; ++i)
+            {
+                SetIssuerBindingContextIfRequired(supportingParameters.SignedEncrypted[i], issuerBindingContext);
+            }
+        }
+
+
+       
+
+        // If any changes are made to this method, please make sure that they are
+        // reflected in the corresponding IsUserNameOverTransportBinding() method.
+        static public TransportSecurityBindingElement CreateUserNameOverTransportBindingElement()
+        {
+            TransportSecurityBindingElement result = new TransportSecurityBindingElement();
+            result.EndpointSupportingTokenParameters.SignedEncrypted.Add(
+                new UserNameSecurityTokenParameters());
+            result.IncludeTimestamp = true;
+            //result.LocalClientSettings.DetectReplays = false;
+            result.LocalServiceSettings.DetectReplays = false;
+            return result;
+        }
+
+        // this method reverses CreateMutualCertificateBindingElement() logic
+        internal static bool IsUserNameOverTransportBinding(SecurityBindingElement sbe)
+        {
+            // do not check local settings: sbe.LocalServiceSettings and sbe.LocalClientSettings
+            if (!sbe.IncludeTimestamp)
+                return false;
+
+            if (!(sbe is TransportSecurityBindingElement))
+                return false;
+
+            SupportingTokenParameters parameters = sbe.EndpointSupportingTokenParameters;
+            if (parameters.Signed.Count != 0 || parameters.SignedEncrypted.Count != 1 || parameters.Endorsing.Count != 0 || parameters.SignedEndorsing.Count != 0)
+                return false;
+
+            UserNameSecurityTokenParameters userNameParameters = parameters.SignedEncrypted[0] as UserNameSecurityTokenParameters;
+            if (userNameParameters == null)
+                return false;
+
+            return true;
+        }
+
+        // If any changes are made to this method, please make sure that they are
+        // reflected in the corresponding IsSecureConversationBinding() method.
+        static public SecurityBindingElement CreateSecureConversationBindingElement(SecurityBindingElement bootstrapSecurity)
+        {
+            return CreateSecureConversationBindingElement(bootstrapSecurity, SecureConversationSecurityTokenParameters.defaultRequireCancellation, null);
+        }
+
+        // this method reverses CreateSecureConversationBindingElement() logic
+        internal static bool IsSecureConversationBinding(SecurityBindingElement sbe, out SecurityBindingElement bootstrapSecurity)
+        {
+            return IsSecureConversationBinding(sbe, SecureConversationSecurityTokenParameters.defaultRequireCancellation, out bootstrapSecurity);
+        }
+
+        static public SecurityBindingElement CreateSecureConversationBindingElement(SecurityBindingElement bootstrapSecurity, bool requireCancellation)
+        {
+            return CreateSecureConversationBindingElement(bootstrapSecurity, requireCancellation, null);
+        }
+
+        // If any changes are made to this method, please make sure that they are
+        // reflected in the corresponding IsSecureConversationBinding() method.
+        static public SecurityBindingElement CreateSecureConversationBindingElement(SecurityBindingElement bootstrapSecurity, bool requireCancellation, ChannelProtectionRequirements bootstrapProtectionRequirements)
+        {
+            if (bootstrapSecurity == null)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("bootstrapBinding");
+
+            SecurityBindingElement result;
+
+            if (bootstrapSecurity is TransportSecurityBindingElement)
+            {
+                // there is no need to do replay detection or key derivation for transport bindings
+                TransportSecurityBindingElement primary = new TransportSecurityBindingElement();
+                SecureConversationSecurityTokenParameters scParameters = new SecureConversationSecurityTokenParameters(
+                        bootstrapSecurity,
+                        requireCancellation,
+                        bootstrapProtectionRequirements);
+                scParameters.RequireDerivedKeys = false;
+                primary.EndpointSupportingTokenParameters.Endorsing.Add(
+                    scParameters);
+               // primary.LocalClientSettings.DetectReplays = false;
+                primary.LocalServiceSettings.DetectReplays = false;
+                primary.IncludeTimestamp = true;
+                result = primary;
+            }
+            else // Symmetric- or AsymmetricSecurityBindingElement
+            {
+                SymmetricSecurityBindingElement primary = new SymmetricSecurityBindingElement(
+                    new SecureConversationSecurityTokenParameters(
+                        bootstrapSecurity,
+                        requireCancellation,
+                        bootstrapProtectionRequirements));
+                // there is no need for signature confirmation on the steady state binding
+                primary.RequireSignatureConfirmation = false;
+                result = primary;
+            }
+
+            return result;
+        }
+
+        // this method reverses CreateSecureConversationBindingElement() logic
+        internal static bool IsSecureConversationBinding(SecurityBindingElement sbe, bool requireCancellation, out SecurityBindingElement bootstrapSecurity)
+        {
+            bootstrapSecurity = null;
+            SymmetricSecurityBindingElement ssbe = sbe as SymmetricSecurityBindingElement;
+            if (ssbe != null)
+            {
+                if (ssbe.RequireSignatureConfirmation)
+                    return false;
+
+                SecureConversationSecurityTokenParameters parameters = ssbe.ProtectionTokenParameters as SecureConversationSecurityTokenParameters;
+                if (parameters == null)
+                    return false;
+                if (parameters.RequireCancellation != requireCancellation)
+                    return false;
+                bootstrapSecurity = parameters.BootstrapSecurityBindingElement;
+            }
+            else
+            {
+                if (!sbe.IncludeTimestamp)
+                    return false;
+
+                // do not check local settings: sbe.LocalServiceSettings and sbe.LocalClientSettings
+
+                if (!(sbe is TransportSecurityBindingElement))
+                    return false;
+
+                SupportingTokenParameters parameters = sbe.EndpointSupportingTokenParameters;
+                if (parameters.Signed.Count != 0 || parameters.SignedEncrypted.Count != 0 || parameters.Endorsing.Count != 1 || parameters.SignedEndorsing.Count != 0)
+                    return false;
+                SecureConversationSecurityTokenParameters scParameters = parameters.Endorsing[0] as SecureConversationSecurityTokenParameters;
+                if (scParameters == null)
+                    return false;
+
+                if (scParameters.RequireCancellation != requireCancellation)
+                    return false;
+
+                bootstrapSecurity = scParameters.BootstrapSecurityBindingElement;
+
+            }
+
+            if (bootstrapSecurity != null && bootstrapSecurity.SecurityHeaderLayout != SecurityProtocolFactory.defaultSecurityHeaderLayout)
+                return false;
+
+            return bootstrapSecurity != null;
+        }
+
+        //TODO other security mode
+
+
+
+
+
+
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Channels/SecurityHeaderLayout.cs b/src/CoreWCF.Primitives/src/CoreWCF/Channels/SecurityHeaderLayout.cs
new file mode 100644
index 0000000..6ef3a83
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Channels/SecurityHeaderLayout.cs
@@ -0,0 +1,32 @@
+namespace CoreWCF.Channels
+{
+    using System.ComponentModel;
+
+    public enum SecurityHeaderLayout
+    {
+        Strict = 0,
+        Lax = 1,
+        LaxTimestampFirst = 2,
+        LaxTimestampLast = 3
+    }
+
+    static class SecurityHeaderLayoutHelper
+    {
+        public static bool IsDefined(SecurityHeaderLayout value)
+        {
+            return (value == SecurityHeaderLayout.Lax
+            || value == SecurityHeaderLayout.LaxTimestampFirst
+            || value == SecurityHeaderLayout.LaxTimestampLast
+            || value == SecurityHeaderLayout.Strict);
+        }
+
+        public static void Validate(SecurityHeaderLayout value)
+        {
+            if (!IsDefined(value))
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidEnumArgumentException("value", (int)value,
+                    typeof(SecurityHeaderLayout)));
+            }
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Channels/SymmetricSecurityBindingElement.cs b/src/CoreWCF.Primitives/src/CoreWCF/Channels/SymmetricSecurityBindingElement.cs
new file mode 100644
index 0000000..616e7c6
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Channels/SymmetricSecurityBindingElement.cs
@@ -0,0 +1,214 @@
+using System;
+using CoreWCF.Description;
+using System.Xml;
+using System.Collections.Generic;
+using System.Globalization;
+using System.Runtime.Serialization;
+using CoreWCF;
+using CoreWCF.Security;
+using CoreWCF.Security.Tokens;
+using CoreWCF.Dispatcher;
+using System.Net.Security;
+using System.Text;
+using CoreWCF.Configuration;
+
+namespace CoreWCF.Channels
+{
+    public sealed class SymmetricSecurityBindingElement : SecurityBindingElement //, IPolicyExportExtension
+    {
+        private MessageProtectionOrder _messageProtectionOrder;
+        private SecurityTokenParameters _protectionTokenParameters;
+        private bool _requireSignatureConfirmation;
+
+        private SymmetricSecurityBindingElement(SymmetricSecurityBindingElement elementToBeCloned)
+            : base(elementToBeCloned)
+        {
+            _messageProtectionOrder = elementToBeCloned._messageProtectionOrder;
+            if (elementToBeCloned._protectionTokenParameters != null)
+                _protectionTokenParameters = (SecurityTokenParameters)elementToBeCloned._protectionTokenParameters.Clone();
+            _requireSignatureConfirmation = elementToBeCloned._requireSignatureConfirmation;
+        }
+
+        public SymmetricSecurityBindingElement()
+            : this((SecurityTokenParameters)null)
+        {
+            // empty
+        }
+
+        public SymmetricSecurityBindingElement(SecurityTokenParameters protectionTokenParameters)
+            : base()
+        {
+            _messageProtectionOrder = SecurityBindingElement.defaultMessageProtectionOrder;
+            _requireSignatureConfirmation = SecurityBindingElement.defaultRequireSignatureConfirmation;
+            _protectionTokenParameters = protectionTokenParameters;
+        }
+
+        public bool RequireSignatureConfirmation
+        {
+            get
+            {
+                return _requireSignatureConfirmation;
+            }
+            set
+            {
+                _requireSignatureConfirmation = value;
+            }
+        }
+
+        public MessageProtectionOrder MessageProtectionOrder
+        {
+            get
+            {
+                return _messageProtectionOrder;
+            }
+            set
+            {
+                if (!MessageProtectionOrderHelper.IsDefined(value))
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("value"));
+                _messageProtectionOrder = value;
+            }
+        }
+
+        public SecurityTokenParameters ProtectionTokenParameters
+        {
+            get
+            {
+                return _protectionTokenParameters;
+            }
+            set
+            {
+                _protectionTokenParameters = value;
+            }
+        }
+
+        internal override ISecurityCapabilities GetIndividualISecurityCapabilities()
+        {
+            bool supportsServerAuthentication = false;
+            bool supportsClientAuthentication;
+            bool supportsClientWindowsIdentity;
+            GetSupportingTokensCapabilities(out supportsClientAuthentication, out supportsClientWindowsIdentity);
+            if (ProtectionTokenParameters != null)
+            {
+                supportsClientAuthentication = supportsClientAuthentication || ProtectionTokenParameters.SupportsClientAuthentication;
+                supportsClientWindowsIdentity = supportsClientWindowsIdentity || ProtectionTokenParameters.SupportsClientWindowsIdentity;
+
+                if (ProtectionTokenParameters.HasAsymmetricKey)
+                {
+                    supportsServerAuthentication = ProtectionTokenParameters.SupportsClientAuthentication;
+                }
+                else
+                {
+                    supportsServerAuthentication = ProtectionTokenParameters.SupportsServerAuthentication;
+                }
+            }
+
+            return new SecurityCapabilities(supportsClientAuthentication, supportsServerAuthentication, supportsClientWindowsIdentity,
+                ProtectionLevel.EncryptAndSign, ProtectionLevel.EncryptAndSign);
+        }
+
+        internal override bool SessionMode
+        {
+            get
+            {
+                SecureConversationSecurityTokenParameters secureConversationTokenParameters = this.ProtectionTokenParameters as SecureConversationSecurityTokenParameters;
+                if (secureConversationTokenParameters != null)
+                    return secureConversationTokenParameters.RequireCancellation;
+                else
+                    return false;
+            }
+        }
+
+        internal override bool SupportsDuplex
+        {
+            get { return this.SessionMode; }
+        }
+
+        internal override bool SupportsRequestReply
+        {
+            get { return true; }
+        }
+
+        public override void SetKeyDerivation(bool requireDerivedKeys)
+        {
+            base.SetKeyDerivation(requireDerivedKeys);
+            if (_protectionTokenParameters != null)
+                _protectionTokenParameters.RequireDerivedKeys = requireDerivedKeys;
+        }
+
+        internal override bool IsSetKeyDerivation(bool requireDerivedKeys)
+        {
+            if (!base.IsSetKeyDerivation(requireDerivedKeys))
+                return false;
+
+            if (_protectionTokenParameters != null && _protectionTokenParameters.RequireDerivedKeys != requireDerivedKeys)
+                return false;
+
+            return true;
+        }
+
+       
+
+        public override T GetProperty<T>(BindingContext context)
+        {
+            if (context == null)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("context");
+
+            if (typeof(T) == typeof(ChannelProtectionRequirements))
+            {
+                AddressingVersion addressing = MessageVersion.Default.Addressing;
+#pragma warning disable 56506
+                MessageEncodingBindingElement encoding = context.Binding.Elements.Find<MessageEncodingBindingElement>();
+                if (encoding != null)
+                {
+                    addressing = encoding.MessageVersion.Addressing;
+                }
+                ChannelProtectionRequirements myRequirements = base.GetProtectionRequirements(addressing, ProtectionLevel.EncryptAndSign);
+                myRequirements.Add(context.GetInnerProperty<ChannelProtectionRequirements>() ?? new ChannelProtectionRequirements());
+                return (T)(object)myRequirements;
+            }
+            else
+            {
+                return base.GetProperty<T>(context);
+            }
+        }
+
+        public override string ToString()
+        {
+            StringBuilder sb = new StringBuilder();
+            sb.AppendLine(base.ToString());
+
+            sb.AppendLine(String.Format(CultureInfo.InvariantCulture, "MessageProtectionOrder: {0}", _messageProtectionOrder.ToString()));
+            sb.AppendLine(String.Format(CultureInfo.InvariantCulture, "RequireSignatureConfirmation: {0}", _requireSignatureConfirmation.ToString()));
+            sb.Append("ProtectionTokenParameters: ");
+            if (_protectionTokenParameters != null)
+                sb.AppendLine(_protectionTokenParameters.ToString().Trim().Replace("\n", "\n  "));
+            else
+                sb.AppendLine("null");
+
+            return sb.ToString().Trim();
+        }
+
+        public override BindingElement Clone()
+        {
+            return new SymmetricSecurityBindingElement(this);
+        }
+
+       // void IPolicyExportExtension.ExportPolicy(MetadataExporter exporter, PolicyConversionContext context)
+      //  {
+      //      //SecurityBindingElement.ExportPolicy(exporter, context);
+     //       throw new NotImplementedException();
+       // }
+
+        internal override SecurityProtocolFactory CreateSecurityProtocolFactory<TChannel>(BindingContext context, SecurityCredentialsManager credentialsManager, bool isForService, BindingContext issuanceBindingContext)
+        {
+            throw new NotImplementedException();
+        }
+
+
+
+        protected override IServiceDispatcher BuildServiceDispatcherCore<TChannel>(BindingContext context, IServiceDispatcher serviceDispatcher)
+        {
+            throw new NotImplementedException();
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Channels/TransportBindingElement.cs b/src/CoreWCF.Primitives/src/CoreWCF/Channels/TransportBindingElement.cs
index 384d1a8..eb268e5 100644
--- a/src/CoreWCF.Primitives/src/CoreWCF/Channels/TransportBindingElement.cs
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Channels/TransportBindingElement.cs
@@ -74,6 +74,7 @@ namespace CoreWCF.Channels
         }
 
         public abstract string Scheme { get; }
+
         public override T GetProperty<T>(BindingContext context)
         {
             if (context == null)
@@ -137,7 +138,5 @@ namespace CoreWCF.Channels
             }
             return true;
         }
-
-        public virtual Type MiddlewareType { get; } = null;
     }
 }
\ No newline at end of file
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Channels/TransportSecurityBindingElement.cs b/src/CoreWCF.Primitives/src/CoreWCF/Channels/TransportSecurityBindingElement.cs
new file mode 100644
index 0000000..4e7ef45
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Channels/TransportSecurityBindingElement.cs
@@ -0,0 +1,216 @@
+using System;
+using CoreWCF.Description;
+using System.Xml;
+using System.Collections.Generic;
+using System.Runtime.Serialization;
+using CoreWCF;
+using CoreWCF.Security;
+using CoreWCF.Security.Tokens;
+
+using System.Net.Security;
+using CoreWCF.Channels;
+using CoreWCF.Configuration;
+using CoreWCF.Dispatcher;
+using Microsoft.AspNetCore.Builder;
+
+namespace CoreWCF.Channels
+{
+    public sealed class TransportSecurityBindingElement : SecurityBindingElement //, IPolicyExportExtension
+    {
+        public TransportSecurityBindingElement()
+            : base()
+        {
+            //  this.LocalClientSettings.DetectReplays = this.LocalServiceSettings.DetectReplays = false;
+        }
+
+        TransportSecurityBindingElement(TransportSecurityBindingElement elementToBeCloned)
+            : base(elementToBeCloned)
+        {
+            // empty
+        }
+
+        internal override ISecurityCapabilities GetIndividualISecurityCapabilities()
+        {
+            bool supportsClientAuthentication;
+            bool supportsClientWindowsIdentity;
+            GetSupportingTokensCapabilities(out supportsClientAuthentication, out supportsClientWindowsIdentity);
+            return new SecurityCapabilities(supportsClientAuthentication, false, supportsClientWindowsIdentity,
+                ProtectionLevel.None, ProtectionLevel.None);
+        }
+
+        internal override bool SessionMode
+        {
+            get
+            {
+                SecureConversationSecurityTokenParameters scParameters = null;
+                if (this.EndpointSupportingTokenParameters.Endorsing.Count > 0)
+                    scParameters = this.EndpointSupportingTokenParameters.Endorsing[0] as SecureConversationSecurityTokenParameters;
+                if (scParameters != null)
+                    return scParameters.RequireCancellation;
+                else
+                    return false;
+            }
+        }
+
+        internal override bool SupportsDuplex
+        {
+            get { return true; }
+        }
+
+        internal override bool SupportsRequestReply
+        {
+            get { return true; }
+        }
+
+
+        internal override SecurityProtocolFactory CreateSecurityProtocolFactory<TChannel>(BindingContext context, SecurityCredentialsManager credentialsManager, bool isForService, BindingContext issuerBindingContext)
+        {
+            if (context == null)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("context");
+            if (credentialsManager == null)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("credentialsManager");
+
+            TransportSecurityProtocolFactory protocolFactory = new TransportSecurityProtocolFactory();
+            // if (isForService)
+            //     base.ApplyAuditBehaviorSettings(context, protocolFactory);
+            base.ConfigureProtocolFactory(protocolFactory, credentialsManager, isForService, issuerBindingContext, context.Binding);
+            protocolFactory.DetectReplays = false;
+
+            return protocolFactory;
+        }
+
+        protected override IServiceDispatcher BuildServiceDispatcherCore<TChannel>(BindingContext context, IServiceDispatcher serviceDispatcher)
+        {
+            SecurityServiceDispatcher securityServiceDispatcher = new SecurityServiceDispatcher(this, context, serviceDispatcher);
+            SecurityCredentialsManager credentialsManager = serviceDispatcher.Host.Description.Behaviors.Find<SecurityCredentialsManager>();
+            if (credentialsManager == null)
+                credentialsManager = ServiceCredentials.CreateDefaultCredentials();
+            
+            SecureConversationSecurityTokenParameters scParameters;
+            if (this.EndpointSupportingTokenParameters.Endorsing.Count > 0)
+                scParameters = this.EndpointSupportingTokenParameters.Endorsing[0] as SecureConversationSecurityTokenParameters;
+            else
+                scParameters = null;
+
+            bool requireDemuxer = false; // TODO later  RequiresChannelDemuxer();
+            ChannelBuilder channelBuilder = new ChannelBuilder(context, requireDemuxer);
+
+            if (requireDemuxer)
+            {
+                ApplyPropertiesOnDemuxer(channelBuilder, context);
+            }
+
+            BindingContext issuerBindingContext = context.Clone();
+            issuerBindingContext.BindingParameters.Add(credentialsManager);
+            if (scParameters != null)
+            {
+                if (scParameters.BootstrapSecurityBindingElement == null)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.SecureConversationSecurityTokenParametersRequireBootstrapBinding)));
+
+                AddDemuxerForSecureConversation(channelBuilder, issuerBindingContext);
+
+                if (scParameters.RequireCancellation)
+                {
+                    SessionSymmetricTransportSecurityProtocolFactory sessionFactory = new SessionSymmetricTransportSecurityProtocolFactory();
+                    // base.ApplyAuditBehaviorSettings(context, sessionFactory);
+                    sessionFactory.SecurityTokenParameters = scParameters.Clone();
+                    ((SecureConversationSecurityTokenParameters)sessionFactory.SecurityTokenParameters).IssuerBindingContext = issuerBindingContext;
+                    this.EndpointSupportingTokenParameters.Endorsing.RemoveAt(0);
+                    try
+                    {
+                        base.ConfigureProtocolFactory(sessionFactory, credentialsManager, true, issuerBindingContext, context.Binding);
+                    }
+                    finally
+                    {
+                        this.EndpointSupportingTokenParameters.Endorsing.Insert(0, scParameters);
+                    }
+
+                    securityServiceDispatcher.SessionMode = true;
+                    securityServiceDispatcher.SessionServerSettings.InactivityTimeout = this.LocalServiceSettings.InactivityTimeout;
+                    securityServiceDispatcher.SessionServerSettings.KeyRolloverInterval = this.LocalServiceSettings.SessionKeyRolloverInterval;
+                    securityServiceDispatcher.SessionServerSettings.MaximumPendingSessions = this.LocalServiceSettings.MaxPendingSessions;
+                    securityServiceDispatcher.SessionServerSettings.MaximumKeyRenewalInterval = this.LocalServiceSettings.SessionKeyRenewalInterval;
+                    securityServiceDispatcher.SessionServerSettings.TolerateTransportFailures = this.LocalServiceSettings.ReconnectTransportOnFailure;
+                    securityServiceDispatcher.SessionServerSettings.CanRenewSession = scParameters.CanRenewSession;
+                    securityServiceDispatcher.SessionServerSettings.IssuedSecurityTokenParameters = scParameters.Clone();
+                    ((SecureConversationSecurityTokenParameters)securityServiceDispatcher.SessionServerSettings.IssuedSecurityTokenParameters).IssuerBindingContext = issuerBindingContext;
+                    securityServiceDispatcher.SessionServerSettings.SecurityStandardsManager = sessionFactory.StandardsManager;
+                    securityServiceDispatcher.SessionServerSettings.SessionProtocolFactory = sessionFactory;
+                    securityServiceDispatcher.SecurityProtocolFactory = (SecurityProtocolFactory)sessionFactory;
+
+                    // pass in the error handler for handling unknown security sessions - dont do this if the underlying channel is duplex since sending 
+                    // back faults in response to badly secured requests over duplex can result in DoS.
+                    //if (context.BindingParameters != null && context.BindingParameters.Find<IChannelDemuxFailureHandler>() == null
+                    //    && !IsUnderlyingListenerDuplex<TChannel>(context))
+                    //{
+                    //    context.BindingParameters.Add(new SecuritySessionServerSettings.SecuritySessionDemuxFailureHandler(sessionFactory.StandardsManager));
+                    //}
+                }
+                else
+                {
+                    //TODO later 
+                    //TransportSecurityProtocolFactory protocolFactory = new TransportSecurityProtocolFactory();
+                    //base.ApplyAuditBehaviorSettings(context, protocolFactory);
+                    //this.EndpointSupportingTokenParameters.Endorsing.RemoveAt(0);
+                    //try
+                    //{
+                    //    base.ConfigureProtocolFactory(protocolFactory, credentialsManager, true, issuerBindingContext, context.Binding);
+                    //    SecureConversationSecurityTokenParameters acceleratedTokenParameters = (SecureConversationSecurityTokenParameters)scParameters.Clone();
+                    //    acceleratedTokenParameters.IssuerBindingContext = issuerBindingContext;
+                    //    protocolFactory.SecurityBindingElement.EndpointSupportingTokenParameters.Endorsing.Insert(0, acceleratedTokenParameters);
+                    //}
+                    //finally
+                    //{
+                    //    this.EndpointSupportingTokenParameters.Endorsing.Insert(0, scParameters);
+                    //}
+
+                    //channelListener.SecurityProtocolFactory = protocolFactory;
+                }
+
+            }
+            //else
+            //{
+            //    SecurityProtocolFactory protocolFactory = this.CreateSecurityProtocolFactory<TChannel>(context, credentialsManager, true, issuerBindingContext);
+            //    channelListener.SecurityProtocolFactory = protocolFactory;
+            //}
+
+            //channelListener.InitializeListener(channelBuilder);
+
+            //return channelListener;
+            channelBuilder.BuildServiceDispatcher<TChannel>(context, securityServiceDispatcher);
+            return securityServiceDispatcher;
+        }
+
+        public override T GetProperty<T>(BindingContext context)
+        {
+            if (context == null)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("context");
+
+            if (typeof(T) == typeof(ChannelProtectionRequirements))
+            {
+                AddressingVersion addressing = MessageVersion.Default.Addressing;
+#pragma warning suppress 56506
+                MessageEncodingBindingElement encoding = context.Binding.Elements.Find<MessageEncodingBindingElement>();
+                if (encoding != null)
+                {
+                    addressing = encoding.MessageVersion.Addressing;
+                }
+
+                ChannelProtectionRequirements myRequirements = base.GetProtectionRequirements(addressing, ProtectionLevel.EncryptAndSign);
+                myRequirements.Add(context.GetInnerProperty<ChannelProtectionRequirements>() ?? new ChannelProtectionRequirements());
+                return (T)(object)myRequirements;
+            }
+            else
+            {
+                return base.GetProperty<T>(context);
+            }
+        }
+
+        public override BindingElement Clone()
+        {
+            return new TransportSecurityBindingElement(this);
+        }
+
+
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Configuration/ConfigurationStrings.cs b/src/CoreWCF.Primitives/src/CoreWCF/Configuration/ConfigurationStrings.cs
new file mode 100644
index 0000000..c31249b
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Configuration/ConfigurationStrings.cs
@@ -0,0 +1,551 @@
+
+namespace CoreWCF.Configuration
+{
+    static class ConfigurationStrings
+    {
+        internal const string AcknowledgementInterval = "acknowledgementInterval";
+        internal const string ActivityTracing = "activityTracing";
+        internal const string Add = "add";
+        internal const string AdditionalRequestParameters = "additionalRequestParameters";
+        internal const string Address = "address";
+        internal const string AlgorithmSuite = "algorithmSuite";
+        internal const string AllowAnonymousLogons = "allowAnonymousLogons";
+        internal const string AllowCookies = "allowCookies";
+        internal const string AllowedAudienceUris = "allowedAudienceUris";
+        internal const string AllowedAudienceUri = "allowedAudienceUri";
+        internal const string AllowedImpersonationLevel = "allowedImpersonationLevel";
+        internal const string AllowInsecureTransport = "allowInsecureTransport";
+        internal const string AllowNtlm = "allowNtlm";
+        internal const string AllowSerializedSigningTokenOnReply = "allowSerializedSigningTokenOnReply";
+        internal const string AllowUntrustedRsaIssuers = "allowUntrustedRsaIssuers";
+        internal const string AlternativeIssuedTokenParameters = "alternativeIssuedTokenParameters";
+        internal const string ApplicationContainerSettings = "applicationContainerSettings";
+        internal const string AspNetCompatibilityEnabled = "aspNetCompatibilityEnabled";
+        internal const string AsynchronousSendEnabled = "asynchronousSendEnabled";
+        internal const string AudienceUriMode = "audienceUriMode";
+        internal const string AuditLogLocation = "auditLogLocation";
+        internal const string Authentication = "authentication";
+        internal const string AuthenticationMode = "authenticationMode";
+        internal const string AuthenticationScheme = "authenticationScheme";
+        internal const string AuthenticationSchemes = "authenticationSchemes";
+        internal const string AuthorizationPolicies = "authorizationPolicies";
+        internal const string BaseAddress = "baseAddress";
+        internal const string BaseAddresses = "baseAddresses";
+        internal const string BaseAddressPrefixFilters = "baseAddressPrefixFilters";
+        internal const string Basic128 = "Basic128";
+        internal const string Basic192 = "Basic192";
+        internal const string Basic256 = "Basic256";
+        internal const string Basic128Rsa15 = "Basic128Rsa15";
+        internal const string Basic192Rsa15 = "Basic192Rsa15";
+        internal const string Basic256Rsa15 = "Basic256Rsa15";
+        internal const string Basic128Sha256 = "Basic128Sha256";
+        internal const string Basic192Sha256 = "Basic192Sha256";
+        internal const string Basic256Sha256 = "Basic256Sha256";
+        internal const string Basic128Sha256Rsa15 = "Basic128Sha256Rsa15";
+        internal const string Basic192Sha256Rsa15 = "Basic192Sha256Rsa15";
+        internal const string Basic256Sha256Rsa15 = "Basic256Sha256Rsa15";
+        internal const string BasicHttpBindingCollectionElementName = "basicHttpBinding";
+        internal const string BasicHttpsBindingCollectionElementName = "basicHttpsBinding";
+        internal const string Behavior = "behavior";
+        internal const string BehaviorConfiguration = "behaviorConfiguration";
+        internal const string BehaviorExtensions = "behaviorExtensions";
+        internal const string BehaviorsSectionName = "behaviors";
+        internal const string BinaryMessageEncodingSectionName = "binaryMessageEncoding";
+        internal const string Binding = "binding";
+        internal const string BindingConfiguration = "bindingConfiguration";
+        internal const string BindingElementExtensions = "bindingElementExtensions";
+        internal const string BindingExtensions = "bindingExtensions";
+        internal const string BindingName = "bindingName";
+        internal const string BindingNamespace = "bindingNamespace";
+        internal const string BindingsSectionGroupName = "bindings";
+        internal const string BypassProxyOnLocal = "bypassProxyOnLocal";
+        internal const string CacheCookies = "cacheCookies";
+        internal const string CachedLogonTokenLifetime = "cachedLogonTokenLifetime";
+        internal const string CacheIssuedTokens = "cacheIssuedTokens";
+        internal const string CacheLogonTokens = "cacheLogonTokens";
+        internal const string CallbackDebugSectionName = "callbackDebug";
+        internal const string CallbackTimeouts = "callbackTimeouts";
+        internal const string CanRenewSecurityContextToken = "canRenewSecurityContextToken";
+        internal const string Certificate = "certificate";
+        internal const string CertificateReference = "certificateReference";
+        internal const string CertificateValidationMode = "certificateValidationMode";
+        internal const string Channel = "channel";
+        internal const string ChannelInitializationTimeout = "channelInitializationTimeout";
+        internal const string ChannelPoolSettings = "channelPoolSettings";
+        internal const string ClaimType = "claimType";
+        internal const string ClaimTypeRequirements = "claimTypeRequirements";
+        internal const string Clear = "clear";
+        internal const string ClientBaseAddress = "clientBaseAddress";
+        internal const string ClientCallbackAddressName = "clientCallbackAddress";
+        internal const string ClientCertificate = "clientCertificate";
+        internal const string ClientCredentials = "clientCredentials";
+        internal const string ClientCredentialType = "clientCredentialType";
+        internal const string ClientSectionName = "client";
+        internal const string ClientViaSectionName = "clientVia";
+        internal const string CloseIdleServicesAtLowMemory = "closeIdleServicesAtLowMemory";
+        internal const string CloseTimeout = "closeTimeout";
+        internal const string ComContract = "comContract";
+        internal const string ComContractName = "name";
+        internal const string ComContractNamespace = "namespace";
+        internal const string ComContractsSectionName = "comContracts";
+        internal const string ComMethod = "exposedMethod";
+        internal const string ComMethodCollection = "exposedMethods";
+        internal const string CommonBehaviorsSectionName = "commonBehaviors";
+        internal const string ComPersistableTypes = "persistableTypes";
+        internal const string CompositeDuplexSectionName = "compositeDuplex";
+        internal const string CompressionFormat = "compressionFormat";
+        internal const string ComSessionRequired = "requiresSession";
+        internal const string ComUdt = "userDefinedType";
+        internal const string ComUdtCollection = "userDefinedTypes";
+        internal const string ConnectionBufferSize = "connectionBufferSize";
+        internal const string ConnectionPoolSettings = "connectionPoolSettings";
+        internal const string Contract = "contract";
+        internal const string Cookie = "Cookie";
+        internal const string CookieRenewalThresholdPercentage = "cookieRenewalThresholdPercentage";
+        internal const string CreateNotificationOnConnection = "createNotificationOnConnection";
+        internal const string Custom = "custom";
+        internal const string CustomBindingCollectionElementName = "customBinding";
+        internal const string CustomCertificateValidatorType = "customCertificateValidatorType";
+        internal const string CustomDeadLetterQueue = "customDeadLetterQueue";
+        internal const string CustomUserNamePasswordValidatorType = "customUserNamePasswordValidatorType";
+        internal const string DataContractSerializerSectionName = "dataContractSerializer";
+        internal const string DeadLetterQueue = "deadLetterQueue";
+        internal const string DecompressionEnabled = "decompressionEnabled";
+        internal const string Default = "Default";
+        internal const string DefaultAlgorithmSuite = "defaultAlgorithmSuite";
+        internal const string DefaultCertificate = "defaultCertificate";
+        internal const string DefaultCollectionName = ""; // String.Empty
+        internal const string DefaultKeyEntropyMode = "defaultKeyEntropyMode";
+        internal const string DefaultMessageSecurityVersion = "defaultMessageSecurityVersion";
+        internal const string DefaultName = "";
+        internal const string DefaultPorts = "defaultPorts";
+        internal const string DetectReplays = "detectReplays";
+        internal const string DiagnosticSectionName = "diagnostics";
+        internal const string DisablePayloadMasking = "disablePayloadMasking";
+        internal const string Dns = "dns";
+        internal const string Durable = "durable";
+        internal const string Enabled = "enabled";
+        internal const string EnableUnsecuredResponse = "enableUnsecuredResponse";
+        internal const string EncodedValue = "encodedValue";
+        internal const string Endpoint = "endpoint";
+        internal const string EndpointBehaviors = "endpointBehaviors";
+        internal const string EndpointConfiguration = "endpointConfiguration";
+        internal const string EndpointExtensions = "endpointExtensions";
+        internal const string EndToEndTracing = "endToEndTracing";
+        internal const string EstablishSecurityContext = "establishSecurityContext";
+        internal const string EtwProviderId = "etwProviderId";
+        internal const string ExactlyOnce = "exactlyOnce";
+        internal const string ExposedMethod = "exposedMethod";
+        internal const string ExtendedProtectionPolicy = "extendedProtectionPolicy";
+        internal const string Extension = "extension";
+        internal const string Extensions = "extensions";
+        internal const string ExternalMetadataLocation = "externalMetadataLocation";
+        internal const string Factory = "factory";
+        internal const string Filter = "filter";
+        internal const string Filters = "filters";
+        internal const string FindValue = "findValue";
+        internal const string FlowControlEnabled = "flowControlEnabled";
+        internal const string GroupName = "groupName";
+        internal const string Handler = "handler";
+        internal const string Handlers = "handlers";
+        internal const string Header = "header";
+        internal const string Headers = "headers";
+        internal const string Host = "host";
+        internal const string HostNameComparisonMode = "hostNameComparisonMode";
+        internal const string HttpDigest = "httpDigest";
+        internal const string HttpGetEnabled = "httpGetEnabled";
+        internal const string HttpGetUrl = "httpGetUrl";
+        internal const string HttpsGetEnabled = "httpsGetEnabled";
+        internal const string HttpsGetUrl = "httpsGetUrl";
+        internal const string HealthDetailsEnabled = "healthDetailsEnabled";        
+        internal const string HttpHelpPageEnabled = "httpHelpPageEnabled";
+        internal const string HttpHelpPageUrl = "httpHelpPageUrl";
+        internal const string HttpsHelpPageEnabled = "httpsHelpPageEnabled";
+        internal const string HttpsHelpPageUrl = "httpsHelpPageUrl";
+        internal const string HttpHelpPageBinding = "httpHelpPageBinding";
+        internal const string HttpHelpPageBindingConfiguration = "httpHelpPageBindingConfiguration";
+        internal const string HttpsHelpPageBinding = "httpsHelpPageBinding";
+        internal const string HttpsHelpPageBindingConfiguration = "httpsHelpPageBindingConfiguration";
+        internal const string HttpGetBinding = "httpGetBinding";
+        internal const string HttpGetBindingConfiguration = "httpGetBindingConfiguration";
+        internal const string HttpsGetBinding = "httpsGetBinding";
+        internal const string HttpsGetBindingConfiguration = "httpsGetBindingConfiguration";
+        internal const string MexHttpBindingCollectionElementName = "mexHttpBinding";
+        internal const string HttpsTransportSectionName = "httpsTransport";
+        internal const string HttpTransportSectionName = "httpTransport";
+        internal const string MexHttpsBindingCollectionElementName = "mexHttpsBinding";
+        internal const string ID = "ID";
+        internal const string Identity = "identity";
+        internal const string IdentityConfiguration = "identityConfiguration";        
+        internal const string IdleTimeout = "idleTimeout";
+        internal const string IgnoreExtensionDataObject = "ignoreExtensionDataObject";
+        internal const string ImpersonateCallerForAllOperations = "impersonateCallerForAllOperations";
+        internal const string ImpersonateOnSerializingReply = "impersonateOnSerializingReply";
+        internal const string ImpersonationLevel = "impersonationLevel";
+        internal const string InactivityTimeout = "inactivityTimeout";
+        internal const string IncludeExceptionDetailInFaults = "includeExceptionDetailInFaults";
+        internal const string IncludeTimestamp = "includeTimestamp";
+        internal const string IncludeWindowsGroups = "includeWindowsGroups";
+        internal const string IsChainIncluded = "isChainIncluded";
+        internal const string IsOptional = "isOptional";
+        internal const string IssuedCookieLifetime = "issuedCookieLifetime";
+        internal const string IssuedKeyType = "issuedKeyType";
+        internal const string IssuedToken = "issuedToken";
+        internal const string IssuedTokenAuthentication = "issuedTokenAuthentication";
+        internal const string IssuedTokenParameters = "issuedTokenParameters";
+        internal const string IssuedTokenRenewalThresholdPercentage = "issuedTokenRenewalThresholdPercentage";
+        internal const string IssuedTokenType = "issuedTokenType";
+        internal const string Issuer = "issuer";
+        internal const string IssuerAddress = "issuerAddress";
+        internal const string IssuerChannelBehaviors = "issuerChannelBehaviors";
+        internal const string IssuerMetadata = "issuerMetadata";
+        internal const string IsSystemEndpoint = "isSystemEndpoint";
+        internal const string KeepAliveEnabled = "keepAliveEnabled";
+        internal const string KeepAliveInterval = "keepAliveInterval";
+        internal const string KeyEntropyMode = "keyEntropyMode";
+        internal const string KeySize = "keySize";
+        internal const string KeyType = "keyType";
+        internal const string Kind = "kind";
+        internal const string KnownCertificates = "knownCertificates";
+        internal const string LeaseTimeout = "leaseTimeout";
+        internal const string ListenBacklog = "listenBacklog";
+        internal const string ListenIPAddress = "listenIPAddress";
+        internal const string ListenUri = "listenUri";
+        internal const string ListenUriMode = "listenUriMode";
+        internal const string LocalClientSettings = "localClientSettings";
+        internal const string LocalIssuer = "localIssuer";
+        internal const string LocalIssuerChannelBehaviors = "localIssuerChannelBehaviors";
+        internal const string LocalServiceSettings = "localServiceSettings";
+        internal const string LogEntireMessage = "logEntireMessage";
+        internal const string LogKnownPii = "logKnownPii";
+        internal const string LogMalformedMessages = "logMalformedMessages";
+        internal const string LogMessagesAtServiceLevel = "logMessagesAtServiceLevel";
+        internal const string LogMessagesAtTransportLevel = "logMessagesAtTransportLevel";
+        internal const string ManualAddressing = "manualAddressing";
+        internal const string MapClientCertificateToWindowsAccount = "mapClientCertificateToWindowsAccount";
+        internal const string MaxAcceptedChannels = "maxAcceptedChannels";
+        internal const string MaxArrayLength = "maxArrayLength";
+        internal const string MaxBatchSize = "maxBatchSize";
+        internal const string MaxBufferPoolSize = "maxBufferPoolSize";
+        internal const string MaxBufferSize = "maxBufferSize";
+        internal const string MaxBytesPerRead = "maxBytesPerRead";
+        internal const string MaxCachedCookies = "maxCachedCookies";
+        internal const string MaxCachedLogonTokens = "maxCachedLogonTokens";
+        internal const string MaxClockSkew = "maxClockSkew";
+        internal const string MaxConcurrentCalls = "maxConcurrentCalls";
+        internal const string MaxConcurrentInstances = "maxConcurrentInstances";
+        internal const string MaxConcurrentSessions = "maxConcurrentSessions";
+        internal const string MaxConnections = "maxConnections";
+        internal const string MaxCookieCachingTime = "maxCookieCachingTime";
+        internal const string MaxDepth = "maxDepth";
+        internal const string MaxIssuedTokenCachingTime = "maxIssuedTokenCachingTime";
+        internal const string MaxItemsInObjectGraph = "maxItemsInObjectGraph";
+        internal const string MaxMessagesToLog = "maxMessagesToLog";
+        internal const string MaxNameTableCharCount = "maxNameTableCharCount";
+        internal const string MaxOutboundChannelsPerEndpoint = "maxOutboundChannelsPerEndpoint";
+        internal const string MaxOutboundConnectionsPerEndpoint = "maxOutboundConnectionsPerEndpoint";
+        internal const string MaxOutputDelay = "maxOutputDelay";
+        internal const string MaxPendingAccepts = "maxPendingAccepts";
+        internal const string MaxPendingChannels = "maxPendingChannels";
+        internal const string MaxPendingConnections = "maxPendingConnections";
+        internal const string MaxPendingReceives = "maxPendingReceives";
+        internal const string MaxPendingSessions = "maxPendingSessions";
+        internal const string MaxPoolSize = "maxPoolSize";
+        internal const string MaxReadPoolSize = "maxReadPoolSize";
+        internal const string MaxReceivedMessageSize = "maxReceivedMessageSize";
+        internal const string MaxRetryCount = "maxRetryCount";
+        internal const string MaxRetryCycles = "maxRetryCycles";
+        internal const string MaxSessionSize = "maxSessionSize";
+        internal const string MaxSizeOfMessageToLog = "maxSizeOfMessageToLog";
+        internal const string MaxStatefulNegotiations = "maxStatefulNegotiations";
+        internal const string MaxStringContentLength = "maxStringContentLength";
+        internal const string MaxTransferWindowSize = "maxTransferWindowSize";
+        internal const string MaxWritePoolSize = "maxWritePoolSize";
+        internal const string MembershipProviderName = "membershipProviderName";
+        internal const string Message = "message";
+        internal const string MessageAuthenticationAuditLevel = "messageAuthenticationAuditLevel";
+        internal const string MessageEncoding = "messageEncoding";
+        internal const string MessageFlowTracing = "messageFlowTracing";
+        internal const string MessageHandlerFactory = "messageHandlerFactory";
+        internal const string MessageLogging = "messageLogging";
+        internal const string MessageProtectionOrder = "messageProtectionOrder";
+        internal const string MessageSecurityVersion = "messageSecurityVersion";
+        internal const string MessageSenderAuthentication = "messageSenderAuthentication";
+        internal const string MessageVersion = "messageVersion";
+        internal const string Metadata = "metadata";
+        internal const string MinFreeMemoryPercentageToActivateService = "minFreeMemoryPercentageToActivateService";
+        internal const string Mode = "mode";
+        internal const string MsmqAuthenticationMode = "msmqAuthenticationMode";
+        internal const string MsmqEncryptionAlgorithm = "msmqEncryptionAlgorithm";
+        internal const string MsmqIntegrationBindingCollectionElementName = "msmqIntegrationBinding";
+        internal const string MsmqIntegrationSectionName = "msmqIntegration";
+        internal const string MsmqProtectionLevel = "msmqProtectionLevel";
+        internal const string MsmqSecureHashAlgorithm = "msmqSecureHashAlgorithm";
+        internal const string MsmqTransportSectionName = "msmqTransport";
+        internal const string MsmqTransportSecurity = "msmqTransportSecurity";
+        internal const string MtomMessageEncodingSectionName = "mtomMessageEncoding";
+        internal const string MultipleSiteBindingsEnabled = "multipleSiteBindingsEnabled";
+        internal const string Name = "name";
+        internal const string NamedPipeTransportSectionName = "namedPipeTransport";
+        internal const string NegotiateServiceCredential = "negotiateServiceCredential";
+        internal const string NegotiationTimeout = "negotiationTimeout";
+        internal const string NetMsmqBindingCollectionElementName = "netMsmqBinding";
+        internal const string NetNamedPipeBindingCollectionElementName = "netNamedPipeBinding";
+        internal const string MexNamedPipeBindingCollectionElementName = "mexNamedPipeBinding";
+        internal const string NetPeerTcpBindingCollectionElementName = "netPeerTcpBinding";
+        internal const string NetTcpBindingCollectionElementName = "netTcpBinding";
+        internal const string NetHttpBindingCollectionElementName = "netHttpBinding";
+        internal const string NetHttpsBindingCollectionElementName = "netHttpsBinding";
+        internal const string NodeQuota = "nodeQuota";
+        internal const string None = "None";
+        internal const string OleTransactions = "OleTransactions";
+        internal const string OneWaySectionName = "oneWay";
+        internal const string MexTcpBindingCollectionElementName = "mexTcpBinding";
+        internal const string MexStandardEndpointCollectionElementName = "mexEndpoint";
+        internal const string OpenTimeout = "openTimeout";
+        internal const string Ordered = "ordered";
+        internal const string PackageFullName = "packageFullName";
+        internal const string PacketRoutable = "packetRoutable";
+        internal const string Peer = "peer";
+        internal const string PeerAuthentication = "peerAuthentication";
+        internal const string PeerResolver = "resolver";
+        internal const string PeerResolverType = "resolverType";
+        internal const string PeerTransportCredentialType = "credentialType";
+        internal const string PeerTransportSectionName = "peerTransport";
+        internal const string PerformanceCounters = "performanceCounters";
+        internal const string PipeSettings = "pipeSettings";
+        internal const string PnrpPeerResolverSectionName = "pnrpPeerResolver";
+        internal const string Policy12 = "Policy12";
+        internal const string Policy15 = "Policy15";
+        internal const string PolicyImporters = "policyImporters";
+        internal const string PolicyType = "policyType";
+        internal const string PolicyVersion = "policyVersion";
+        internal const string Port = "port";
+        internal const string PortSharingEnabled = "portSharingEnabled";
+        internal const string Prefix = "prefix";
+        internal const string PrincipalPermissionMode = "principalPermissionMode";
+        internal const string PrivacyNoticeAt = "privacyNoticeAt";
+        internal const string PrivacyNoticeSectionName = "privacyNoticeAt";
+        internal const string PrivacyNoticeVersion = "privacyNoticeVersion";
+        internal const string PropagateActivity = "propagateActivity";
+        internal const string ProtectionLevel = "protectionLevel";
+        internal const string ProtectTokens = "protectTokens";
+        internal const string ProtocolMappingSectionName = "protocolMapping";        
+        internal const string ProxyAddress = "proxyAddress";
+        internal const string ProxyAuthenticationScheme = "proxyAuthenticationScheme";
+        internal const string ProxyCredentialType = "proxyCredentialType";
+        internal const string QueueTransferProtocol = "queueTransferProtocol";
+        internal const string ReaderQuotas = "readerQuotas";
+        internal const string Realm = "realm";
+        internal const string ReceiveContextEnabled = "receiveContextEnabled";
+        internal const string ReceiveErrorHandling = "receiveErrorHandling";
+        internal const string ReceiveRetryCount = "receiveRetryCount";
+        internal const string ReceiveTimeout = "receiveTimeout";
+        internal const string ReconnectTransportOnFailure = "reconnectTransportOnFailure";
+        internal const string ReferralPolicy = "referralPolicy";
+        internal const string ReliableMessagingVersion = "reliableMessagingVersion";
+        internal const string RelativeAddress = "relativeAddress";
+        internal const string ReliableSession = "reliableSession";
+        internal const string ReliableSessionSectionName = "reliableSession";
+        internal const string Remove = "remove";
+        internal const string ReplayCacheSize = "replayCacheSize";
+        internal const string ReplayWindow = "replayWindow";
+        internal const string RequestInitializationTimeout = "requestInitializationTimeout";
+        internal const string RequireClientCertificate = "requireClientCertificate";
+        internal const string RequireDerivedKeys = "requireDerivedKeys";
+        internal const string RequireSecurityContextCancellation = "requireSecurityContextCancellation";
+        internal const string RequireSignatureConfirmation = "requireSignatureConfirmation";
+        internal const string RetryCycleDelay = "retryCycleDelay";
+        internal const string RevocationMode = "revocationMode";
+        internal const string RoleProviderName = "roleProviderName";
+        internal const string Rsa = "rsa";
+        internal const string SamlSerializerType = "samlSerializerType";
+        internal const string Scheme = "scheme";
+        internal const string ScopedCertificates = "scopedCertificates";
+        internal const string SectionGroupName = "system.serviceModel";
+        internal const string SecureConversationAuthentication = "secureConversationAuthentication";
+        internal const string SecureConversationBootstrap = "secureConversationBootstrap";
+        internal const string Security = "security";
+        internal const string SecurityHeaderLayout = "securityHeaderLayout";
+        internal const string SecuritySectionName = "security";
+        internal const string SecurityStateEncoderType = "securityStateEncoderType";
+        internal const string SendTimeout = "sendTimeout";
+        internal const string SerializationFormat = "serializationFormat";
+        internal const string Service = "service";
+        internal const string ServiceActivations = "serviceActivations";
+        internal const string ServiceAuthenticationManagerSectionName = "serviceAuthenticationManager";        
+        internal const string ServiceAuthenticationManagerType = "serviceAuthenticationManagerType";        
+        internal const string ServiceAuthorizationAuditLevel = "serviceAuthorizationAuditLevel";
+        internal const string ServiceAuthorizationManagerType = "serviceAuthorizationManagerType";
+        internal const string ServiceAuthorizationSectionName = "serviceAuthorization";
+        internal const string ServiceBehaviors = "serviceBehaviors";
+        internal const string ServiceCertificate = "serviceCertificate";
+        internal const string ServiceCredentials = "serviceCredentials";
+        internal const string ServiceDebugSectionName = "serviceDebug";
+        internal const string ServiceHealthSectionName = "serviceHealth";
+        internal const string ServiceHostingEnvironmentSectionName = "serviceHostingEnvironment";
+        internal const string ServiceMetadataPublishingSectionName = "serviceMetadata";
+        internal const string ServicePrincipalName = "servicePrincipalName";
+        internal const string ServiceSecurityAuditSectionName = "serviceSecurityAudit";
+        internal const string ServicesSectionName = "services";
+        internal const string ServiceThrottlingSectionName = "serviceThrottling";
+        internal const string ServiceTimeouts = "serviceTimeouts";
+        internal const string Session = "Session";
+        internal const string SessionIdAttribute = "sessionId";
+        internal const string SessionKeyRenewalInterval = "sessionKeyRenewalInterval";
+        internal const string SessionKeyRolloverInterval = "sessionKeyRolloverInterval";
+        internal const string Soap11 = "Soap11";
+        internal const string Soap11WSAddressing10 = "Soap11WSAddressing10";
+        internal const string Soap11WSAddressingAugust2004 = "Soap11WSAddressingAugust2004";
+        internal const string Soap12 = "Soap12";
+        internal const string Soap12WSAddressing10 = "Soap12WSAddressing10";
+        internal const string Soap12WSAddressingAugust2004 = "Soap12WSAddressingAugust2004";
+        internal const string SslCertificateAuthentication = "sslCertificateAuthentication";
+        internal const string SslProtocols = "sslProtocols";
+        internal const string SslStreamSecuritySectionName = "sslStreamSecurity";
+        internal const string StandardEndpoint = "standardEndpoint";
+        internal const string StandardEndpointsSectionName = "standardEndpoints";        
+        internal const string StoreLocation = "storeLocation";
+        internal const string StoreName = "storeName";
+        internal const string SubProtocol = "subProtocol";
+        internal const string SupportInteractive = "supportInteractive";
+        internal const string SuppressAuditFailure = "suppressAuditFailure";
+        internal const string SynchronousReceiveSectionName = "synchronousReceive";
+        internal const string DispatcherSynchronizationSectionName = "dispatcherSynchronization";
+        internal const string TargetUri = "targetUri";
+        internal const string TcpTransportSectionName = "tcpTransport";
+        internal const string TeredoEnabled = "teredoEnabled";
+        internal const string TextEncoding = "textEncoding";
+        internal const string TextMessageEncodingSectionName = "textMessageEncoding";
+        internal const string Timeouts = "timeouts";
+        internal const string TimeSpanInfinite = "-00:00:00.001";
+        internal const string TimeSpanOneTick = "00:00:00.0000001";
+        internal const string TimeSpanZero = "00:00:00";
+        internal const string TimestampValidityDuration = "timestampValidityDuration";
+        internal const string TimeToLive = "timeToLive";
+        internal const string TokenRequestParameters = "tokenRequestParameters";
+        internal const string TokenType = "tokenType";
+        internal const string TransactedBatchingSectionName = "transactedBatching";
+        internal const string TransactionFlow = "transactionFlow";
+        internal const string TransactionFlowSectionName = "transactionFlow";
+        internal const string TransactionProtocol = "transactionProtocol";
+        internal const string TransactionTimeout = "transactionTimeout";
+        internal const string TransactionAllowWildcardAction = "allowWildcardAction";
+        internal const string TransferMode = "transferMode";
+        internal const string Transport = "transport";
+        internal const string TransportConfigurationType = "transportConfigurationType";
+        internal const string TransportUsage = "transportUsage";
+        internal const string TripleDes = "TripleDes";
+        internal const string TripleDesRsa15 = "TripleDesRsa15";
+        internal const string TripleDesSha256 = "TripleDesSha256";
+        internal const string TripleDesSha256Rsa15 = "TripleDesSha256Rsa15";
+        internal const string TrustedStoreLocation = "trustedStoreLocation";
+        internal const string Type = "type";
+        internal const string TypeDefID = "typeDefID";
+        internal const string TypeLibID = "typeLibID";
+        internal const string TypeLibVersion = "typeLibVersion";
+        internal const string UdpBindingCollectionElementName = "udpBinding";
+        internal const string UdpBindingCollectionElementType = "System.ServiceModel.Configuration.UdpBindingCollectionElement, System.ServiceModel.Channels, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35"; 
+        internal const string UdpTransportElementType = "System.ServiceModel.Configuration.UdpTransportElement, System.ServiceModel.Channels, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35";
+        internal const string UdpTransportImporterType = "System.ServiceModel.Channels.UdpTransportImporter, System.ServiceModel.Channels, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35";
+        internal const string UdpTransportSectionName = "udpTransport";
+        internal const string UnrecognizedPolicyAssertionSectionName = "unrecognizedPolicyAssertions";
+        internal const string UnsafeConnectionNtlmAuthentication = "unsafeConnectionNtlmAuthentication";
+        internal const string Url = "url";
+        internal const string UseActiveDirectory = "useActiveDirectory";
+        internal const string UseDefaultWebProxy = "useDefaultWebProxy";
+        internal const string UseIdentityConfiguration = "useIdentityConfiguration";
+        internal const string UseManagedPresentationSectionName = "useManagedPresentation";
+        internal const string UseMsmqTracing = "useMsmqTracing";
+        internal const string UserNameAuthentication = "userNameAuthentication";
+        internal const string UserNamePasswordValidationMode = "userNamePasswordValidationMode";
+        internal const string UserPrincipalName = "userPrincipalName";
+        internal const string UseRequestHeadersForMetadataAddress = "useRequestHeadersForMetadataAddress";
+        internal const string UseSourceJournal = "useSourceJournal";
+        internal const string UseStrTransform = "useStrTransform";
+        internal const string ValidityDuration = "validityDuration";
+        internal const string Value = "value";
+        internal const string Version = "version";
+        internal const string ViaUri = "viaUri";
+        internal const string WebSocketSettingsSectionName = "webSocketSettings";
+        internal const string Windows = "windows";
+        internal const string WindowsAuthentication = "windowsAuthentication";
+        internal const string WindowsStreamSecuritySectionName = "windowsStreamSecurity";
+        internal const string WmiProviderEnabled = "wmiProviderEnabled";
+        internal const string WriteEncoding = "writeEncoding";
+        internal const string WSAtomicTransactionOctober2004 = "WSAtomicTransactionOctober2004";
+        internal const string WSAtomicTransaction11 = "WSAtomicTransaction11";        
+        internal const string WsdlImporters = "wsdlImporters";
+        internal const string WSDualHttpBindingCollectionElementName = "wsDualHttpBinding";
+        internal const string WSFederationHttpBindingCollectionElementName = "wsFederationHttpBinding";
+        internal const string WS2007FederationHttpBindingCollectionElementName = "ws2007FederationHttpBinding";
+        internal const string WS2007HttpBindingCollectionElementName = "ws2007HttpBinding";
+        internal const string WSHttpBindingCollectionElementName = "wsHttpBinding";
+        internal const string WSReliableMessaging11 = "WSReliableMessaging11";
+        internal const string WSReliableMessagingFebruary2005 = "WSReliableMessagingFebruary2005";
+        internal const string WSSecurity10WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11BasicSecurityProfile10 = "WSSecurity10WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11BasicSecurityProfile10";
+        internal const string WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11 = "WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11";
+        internal const string WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11BasicSecurityProfile10 = "WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11BasicSecurityProfile10";
+        internal const string WSSecurity10WSTrust13WSSecureConversation13WSSecurityPolicy12BasicSecurityProfile10 = "WSSecurity10WSTrust13WSSecureConversation13WSSecurityPolicy12BasicSecurityProfile10";
+        internal const string WSSecurity11WSTrust13WSSecureConversation13WSSecurityPolicy12 = "WSSecurity11WSTrust13WSSecureConversation13WSSecurityPolicy12";
+        internal const string WSSecurity11WSTrust13WSSecureConversation13WSSecurityPolicy12BasicSecurityProfile10 = "WSSecurity11WSTrust13WSSecureConversation13WSSecurityPolicy12BasicSecurityProfile10";
+        internal const string X509FindType = "x509FindType";
+        internal const string XmlElement = "xmlElement";
+
+        
+        //internal static string BehaviorsSectionPath
+        //{
+        //    get { return ConfigurationHelpers.GetSectionPath(ConfigurationStrings.BehaviorsSectionName); }
+        //}
+
+        //internal static string BindingsSectionGroupPath
+        //{
+        //    get { return ConfigurationHelpers.GetSectionPath(ConfigurationStrings.BindingsSectionGroupName); }
+        //}
+
+        //internal static string ClientSectionPath
+        //{
+        //    get { return ConfigurationHelpers.GetSectionPath(ConfigurationStrings.ClientSectionName); }
+        //}
+
+        //internal static string ComContractsSectionPath
+        //{
+        //    get { return ConfigurationHelpers.GetSectionPath(ConfigurationStrings.ComContractsSectionName); }
+        //}
+
+        //internal static string CommonBehaviorsSectionPath
+        //{
+        //    get { return ConfigurationHelpers.GetSectionPath(ConfigurationStrings.CommonBehaviorsSectionName); }
+        //}
+
+        //internal static string DiagnosticSectionPath
+        //{
+        //    get { return ConfigurationHelpers.GetSectionPath(ConfigurationStrings.DiagnosticSectionName); }
+        //}
+
+        //internal static string ExtensionsSectionPath
+        //{
+        //    get { return ConfigurationHelpers.GetSectionPath(ConfigurationStrings.Extensions); }
+        //}
+
+        //internal static string ProtocolMappingSectionPath
+        //{
+        //    get { return ConfigurationHelpers.GetSectionPath(ConfigurationStrings.ProtocolMappingSectionName); }
+        //}
+
+        //internal static string ServiceHostingEnvironmentSectionPath
+        //{
+        //    get { return ConfigurationHelpers.GetSectionPath(ConfigurationStrings.ServiceHostingEnvironmentSectionName); }
+        //}
+
+        //internal static string ServicesSectionPath
+        //{
+        //    get { return ConfigurationHelpers.GetSectionPath(ConfigurationStrings.ServicesSectionName); }
+        //}
+
+        //internal static string StandardEndpointsSectionPath
+        //{
+        //    get { return ConfigurationHelpers.GetSectionPath(ConfigurationStrings.StandardEndpointsSectionName); }
+        //}
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Configuration/IServiceDispatcher.cs b/src/CoreWCF.Primitives/src/CoreWCF/Configuration/IServiceDispatcher.cs
index 62302de..7c5b548 100644
--- a/src/CoreWCF.Primitives/src/CoreWCF/Configuration/IServiceDispatcher.cs
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Configuration/IServiceDispatcher.cs
@@ -11,7 +11,8 @@ namespace CoreWCF.Configuration
     {
         Uri BaseAddress { get; }
         Binding Binding { get; }
-        ICollection<Type> SupportedChannelTypes { get; }
+        ServiceHostBase Host { get; }
+        IList<Type> SupportedChannelTypes { get; }
         Task<IServiceChannelDispatcher> CreateServiceChannelDispatcherAsync(IChannel channel);
     }
 }
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Configuration/ITransportServiceBuilder.cs b/src/CoreWCF.Primitives/src/CoreWCF/Configuration/ITransportServiceBuilder.cs
new file mode 100644
index 0000000..91bd8cb
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Configuration/ITransportServiceBuilder.cs
@@ -0,0 +1,12 @@
+﻿using Microsoft.AspNetCore.Builder;
+using System;
+using System.Collections.Generic;
+using System.Text;
+
+namespace CoreWCF.Configuration
+{
+    public interface ITransportServiceBuilder
+    {
+        void Configure(IApplicationBuilder app);
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Configuration/ServiceBuilder.cs b/src/CoreWCF.Primitives/src/CoreWCF/Configuration/ServiceBuilder.cs
index 1bc36dd..dda892d 100644
--- a/src/CoreWCF.Primitives/src/CoreWCF/Configuration/ServiceBuilder.cs
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Configuration/ServiceBuilder.cs
@@ -27,6 +27,7 @@ namespace CoreWCF.Configuration
             var serviceConfig = _serviceProvider.GetRequiredService<IServiceConfiguration<TService>>();
             _services[serviceConfig.ServiceType] = serviceConfig;
         }
+        public IServiceProvider ServiceProvider { get{ return _serviceProvider; } }
 
         public void AddServiceEndpoint<TService, TContract>(Binding binding, string address)
         {
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Configuration/ServiceBuilderExtensions.cs b/src/CoreWCF.Primitives/src/CoreWCF/Configuration/ServiceBuilderExtensions.cs
new file mode 100644
index 0000000..7dcd4c4
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Configuration/ServiceBuilderExtensions.cs
@@ -0,0 +1,19 @@
+﻿using Microsoft.Extensions.DependencyInjection;
+using System;
+using System.Collections.Generic;
+using System.Text;
+
+namespace CoreWCF.Configuration
+{
+   public static class ServiceBuilderExtensions
+    {
+        public static void ConfigureService<TService>(this IServiceBuilder builder, Action<ServiceHostBase> func) where TService : class
+        {
+            var serviceBuilder = builder as ServiceBuilder;
+            var holder = serviceBuilder.ServiceProvider
+                .GetRequiredService<ServiceConfigurationDelegateHolder<TService>>();
+            holder.AddConfigDelegate(func);
+
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Configuration/ServiceConfigurationDelegateHolder.cs b/src/CoreWCF.Primitives/src/CoreWCF/Configuration/ServiceConfigurationDelegateHolder.cs
new file mode 100644
index 0000000..74cdac6
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Configuration/ServiceConfigurationDelegateHolder.cs
@@ -0,0 +1,30 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Text;
+
+namespace CoreWCF.Configuration
+{
+   public class ServiceConfigurationDelegateHolder<TService> where TService : class
+
+    {
+        private List<Action<ServiceHostBase>> configDelegates = new List<Action<ServiceHostBase>>();
+
+        public void AddConfigDelegate(Action<ServiceHostBase> func)
+
+        {
+            configDelegates.Add(func);
+        }
+
+        public void Configure(ServiceHostBase host)
+
+        {
+            foreach (var del in configDelegates)
+
+            {
+                del(host);
+            }
+
+        }
+
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Configuration/ServiceModelApplicationBuilderExtensions.cs b/src/CoreWCF.Primitives/src/CoreWCF/Configuration/ServiceModelApplicationBuilderExtensions.cs
index ba4c803..781e28a 100644
--- a/src/CoreWCF.Primitives/src/CoreWCF/Configuration/ServiceModelApplicationBuilderExtensions.cs
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Configuration/ServiceModelApplicationBuilderExtensions.cs
@@ -4,6 +4,9 @@ using CoreWCF.Channels;
 using System;
 using System.Collections.Generic;
 using System.Text;
+using System.Net;
+using Microsoft.Extensions.Logging;
+using System.Linq;
 
 namespace CoreWCF.Configuration
 {
@@ -21,33 +24,36 @@ namespace CoreWCF.Configuration
                 throw new ArgumentNullException(nameof(configureServices));
             }
 
+            var loggerFactory = app.ApplicationServices.GetRequiredService<ILoggerFactory>();
+            var logger = loggerFactory.CreateLogger(nameof(ServiceModelApplicationBuilderExtensions));
             var serviceBuilder = app.ApplicationServices.GetRequiredService<ServiceBuilder>();
             configureServices(serviceBuilder);
 
-            var transportMiddlewareTypes = new HashSet<Type>();
+            var transportServiceBuilders = app.ApplicationServices.GetServices<ITransportServiceBuilder>();
+            var transportServiceBuilderSeenTypes = new HashSet<Type>();
+            foreach (var transportServiceBuilder in transportServiceBuilders)
+            {
+                if (!transportServiceBuilderSeenTypes.Contains(transportServiceBuilder.GetType()))
+                {
+                    logger.LogDebug($"Calling {transportServiceBuilder.GetType().FullName}.Configure");
+                    transportServiceBuilder.Configure(app);
+                    transportServiceBuilderSeenTypes.Add(transportServiceBuilder.GetType());
+                }
+            }
+
             foreach (var serviceConfig in serviceBuilder.ServiceConfigurations)
             {
                 foreach (var serviceEndpoint in serviceConfig.Endpoints)
                 {
-                    var be = serviceEndpoint.Binding.CreateBindingElements();
-                    var tbe = be.Find<TransportBindingElement>();
-                    // TODO : Error handling if TBE doesn't exist
-                    var transportMiddlewareType = tbe.MiddlewareType;
-                    if (transportMiddlewareTypes.Contains(transportMiddlewareType))
-                        continue;
-                    transportMiddlewareTypes.Add(transportMiddlewareType);
-                    string scheme = tbe.Scheme;
-                    if ("http".Equals(scheme, StringComparison.OrdinalIgnoreCase) ||
-                        "https".Equals(scheme, StringComparison.OrdinalIgnoreCase))
-                    {
-                        app.UseMiddleware(transportMiddlewareType, app);
-                    }
-                    else
+                    var transportServiceBuilder = serviceEndpoint.Binding.GetProperty<ITransportServiceBuilder>(new BindingParameterCollection());
+                    // Check if this transport service builder type has already been used in this app
+                    if (transportServiceBuilder != null && !transportServiceBuilderSeenTypes.Contains(transportServiceBuilder.GetType()))
                     {
-                        // Not implemented yet. Commented code is for how things will work in the future.
-                        //svc.UseMiddleware(transportMiddlewareType);
+                        //Console.WriteLine($"Found ITransportServiceBuilder of type {transportServiceBuilder.GetType().FullName}");
+                        logger.LogDebug($"Calling {transportServiceBuilder.GetType().FullName}.Configure");
+                        transportServiceBuilder.Configure(app);
+                        transportServiceBuilderSeenTypes.Add(transportServiceBuilder.GetType());
                     }
-
                 }
             }
 
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Configuration/ServiceModelServiceCollectionExtensions.cs b/src/CoreWCF.Primitives/src/CoreWCF/Configuration/ServiceModelServiceCollectionExtensions.cs
index e46b36c..df818e4 100644
--- a/src/CoreWCF.Primitives/src/CoreWCF/Configuration/ServiceModelServiceCollectionExtensions.cs
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Configuration/ServiceModelServiceCollectionExtensions.cs
@@ -33,9 +33,11 @@ namespace CoreWCF.Configuration
             services.TryAddSingleton(typeof(IServiceConfiguration<>), typeof(ServiceConfiguration<>));
             services.TryAddSingleton<IDispatcherBuilder, DispatcherBuilderImpl>();
             services.AddScoped<ReplyChannelBinder>();
+            services.AddScoped<SecurityReplyChannelBinder>();
             services.AddScoped<DuplexChannelBinder>();
             services.AddScoped<InputChannelBinder>();
             services.AddScoped<ServiceChannel.SessionIdleManager>();
+            services.AddSingleton(typeof(ServiceHostObjectModel<>));
 
             return services;
         }
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/DXD.cs b/src/CoreWCF.Primitives/src/CoreWCF/DXD.cs
new file mode 100644
index 0000000..35db661
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/DXD.cs
@@ -0,0 +1,652 @@
+namespace CoreWCF
+{
+    using System.Xml;
+    using System.Collections.Generic;
+
+    // NOTE: This is a dynamic dictionary of XmlDictionaryStrings for the Binary Encoder to dynamically encode should
+    // the string not exist in the static cache.
+    // When adding or removing memebers please keep the capacity of the XmlDictionary field current.
+    static class DXD
+    {
+        static AtomicTransactionExternal11Dictionary atomicTransactionExternal11Dictionary;
+        static CoordinationExternal11Dictionary coordinationExternal11Dictionary;
+        static SecureConversationDec2005Dictionary secureConversationDec2005Dictionary;
+        static SecurityAlgorithmDec2005Dictionary securityAlgorithmDec2005Dictionary;
+        static TrustDec2005Dictionary trustDec2005Dictionary;
+        static Wsrm11Dictionary wsrm11Dictionary;
+
+        static DXD()
+        {
+            // Each string added to the XmlDictionary will keep a reference to the XmlDictionary so this class does
+            // not need to keep a reference.
+            XmlDictionary dictionary = new XmlDictionary(137);
+
+            // Each dictionaries' constructor should add strings to the XmlDictionary.
+            atomicTransactionExternal11Dictionary = new AtomicTransactionExternal11Dictionary(dictionary);
+            coordinationExternal11Dictionary = new CoordinationExternal11Dictionary(dictionary);
+            secureConversationDec2005Dictionary = new SecureConversationDec2005Dictionary(dictionary);
+            secureConversationDec2005Dictionary.PopulateSecureConversationDec2005();
+            securityAlgorithmDec2005Dictionary = new SecurityAlgorithmDec2005Dictionary(dictionary);
+            securityAlgorithmDec2005Dictionary.PopulateSecurityAlgorithmDictionaryString();
+            trustDec2005Dictionary = new TrustDec2005Dictionary(dictionary);
+            trustDec2005Dictionary.PopulateDec2005DictionaryStrings();
+            trustDec2005Dictionary.PopulateFeb2005DictionaryString();
+            wsrm11Dictionary = new Wsrm11Dictionary(dictionary);
+        }
+
+        static public AtomicTransactionExternal11Dictionary AtomicTransactionExternal11Dictionary
+        {
+            get { return atomicTransactionExternal11Dictionary; }
+        }
+
+        static public CoordinationExternal11Dictionary CoordinationExternal11Dictionary
+        {
+            get { return coordinationExternal11Dictionary; }
+        }
+
+        static public SecureConversationDec2005Dictionary SecureConversationDec2005Dictionary
+        {
+            get { return secureConversationDec2005Dictionary; }
+        }
+
+        static public SecurityAlgorithmDec2005Dictionary SecurityAlgorithmDec2005Dictionary
+        {
+            get { return securityAlgorithmDec2005Dictionary; }
+        }
+
+        static public TrustDec2005Dictionary TrustDec2005Dictionary
+        {
+            get { return trustDec2005Dictionary; }
+        }
+
+        static public Wsrm11Dictionary Wsrm11Dictionary
+        {
+            get { return wsrm11Dictionary; }
+        }
+    }
+
+    class AtomicTransactionExternal11Dictionary
+    {
+        public XmlDictionaryString Namespace;
+        public XmlDictionaryString CompletionUri;
+        public XmlDictionaryString Durable2PCUri;
+        public XmlDictionaryString Volatile2PCUri;
+        public XmlDictionaryString CommitAction;
+        public XmlDictionaryString RollbackAction;
+        public XmlDictionaryString CommittedAction;
+        public XmlDictionaryString AbortedAction;
+        public XmlDictionaryString PrepareAction;
+        public XmlDictionaryString PreparedAction;
+        public XmlDictionaryString ReadOnlyAction;
+        public XmlDictionaryString ReplayAction;
+        public XmlDictionaryString FaultAction;
+        public XmlDictionaryString UnknownTransaction;
+
+        public AtomicTransactionExternal11Dictionary(XmlDictionary dictionary)
+        {
+            this.Namespace = dictionary.Add(AtomicTransactionExternal11Strings.Namespace);
+            this.CompletionUri = dictionary.Add(AtomicTransactionExternal11Strings.CompletionUri);
+            this.Durable2PCUri = dictionary.Add(AtomicTransactionExternal11Strings.Durable2PCUri);
+            this.Volatile2PCUri = dictionary.Add(AtomicTransactionExternal11Strings.Volatile2PCUri);
+            this.CommitAction = dictionary.Add(AtomicTransactionExternal11Strings.CommitAction);
+            this.RollbackAction = dictionary.Add(AtomicTransactionExternal11Strings.RollbackAction);
+            this.CommittedAction = dictionary.Add(AtomicTransactionExternal11Strings.CommittedAction);
+            this.AbortedAction = dictionary.Add(AtomicTransactionExternal11Strings.AbortedAction);
+            this.PrepareAction = dictionary.Add(AtomicTransactionExternal11Strings.PrepareAction);
+            this.PreparedAction = dictionary.Add(AtomicTransactionExternal11Strings.PreparedAction);
+            this.ReadOnlyAction = dictionary.Add(AtomicTransactionExternal11Strings.ReadOnlyAction);
+            this.ReplayAction = dictionary.Add(AtomicTransactionExternal11Strings.ReplayAction);
+            this.FaultAction = dictionary.Add(AtomicTransactionExternal11Strings.FaultAction);
+            this.UnknownTransaction = dictionary.Add(AtomicTransactionExternal11Strings.UnknownTransaction);
+        }
+    }
+
+    class CoordinationExternal11Dictionary
+    {
+        public XmlDictionaryString Namespace;
+        public XmlDictionaryString CreateCoordinationContextAction;
+        public XmlDictionaryString CreateCoordinationContextResponseAction;
+        public XmlDictionaryString RegisterAction;
+        public XmlDictionaryString RegisterResponseAction;
+        public XmlDictionaryString FaultAction;
+        public XmlDictionaryString CannotCreateContext;
+        public XmlDictionaryString CannotRegisterParticipant;
+
+        public CoordinationExternal11Dictionary(XmlDictionary dictionary)
+        {
+            this.Namespace = dictionary.Add(CoordinationExternal11Strings.Namespace);
+            this.CreateCoordinationContextAction = dictionary.Add(CoordinationExternal11Strings.CreateCoordinationContextAction);
+            this.CreateCoordinationContextResponseAction = dictionary.Add(CoordinationExternal11Strings.CreateCoordinationContextResponseAction);
+            this.RegisterAction = dictionary.Add(CoordinationExternal11Strings.RegisterAction);
+            this.RegisterResponseAction = dictionary.Add(CoordinationExternal11Strings.RegisterResponseAction);
+            this.FaultAction = dictionary.Add(CoordinationExternal11Strings.FaultAction);
+            this.CannotCreateContext = dictionary.Add(CoordinationExternal11Strings.CannotCreateContext);
+            this.CannotRegisterParticipant = dictionary.Add(CoordinationExternal11Strings.CannotRegisterParticipant);
+        }
+    }
+
+   public class SecureConversationDec2005Dictionary : SecureConversationDictionary
+    {
+        public XmlDictionaryString RequestSecurityContextRenew;
+        public XmlDictionaryString RequestSecurityContextRenewResponse;
+        public XmlDictionaryString RequestSecurityContextClose;
+        public XmlDictionaryString RequestSecurityContextCloseResponse;
+        public XmlDictionaryString Instance;
+
+        public List<XmlDictionaryString> SecureConversationDictionaryStrings = new List<XmlDictionaryString>();  
+
+        public SecureConversationDec2005Dictionary(XmlDictionary dictionary)
+        {
+            this.SecurityContextToken = dictionary.Add(SecureConversationDec2005Strings.SecurityContextToken);
+            this.AlgorithmAttribute = dictionary.Add(SecureConversationDec2005Strings.AlgorithmAttribute);
+            this.Generation = dictionary.Add(SecureConversationDec2005Strings.Generation);
+            this.Label = dictionary.Add(SecureConversationDec2005Strings.Label);
+            this.Offset = dictionary.Add(SecureConversationDec2005Strings.Offset);
+            this.Properties = dictionary.Add(SecureConversationDec2005Strings.Properties);
+            this.Identifier = dictionary.Add(SecureConversationDec2005Strings.Identifier);
+            this.Cookie = dictionary.Add(SecureConversationDec2005Strings.Cookie);
+            this.RenewNeededFaultCode = dictionary.Add(SecureConversationDec2005Strings.RenewNeededFaultCode);
+            this.BadContextTokenFaultCode = dictionary.Add(SecureConversationDec2005Strings.BadContextTokenFaultCode);
+            this.Prefix = dictionary.Add(SecureConversationDec2005Strings.Prefix);
+            this.DerivedKeyTokenType = dictionary.Add(SecureConversationDec2005Strings.DerivedKeyTokenType);
+            this.SecurityContextTokenType = dictionary.Add(SecureConversationDec2005Strings.SecurityContextTokenType);
+            this.SecurityContextTokenReferenceValueType = dictionary.Add(SecureConversationDec2005Strings.SecurityContextTokenReferenceValueType);
+            this.RequestSecurityContextIssuance = dictionary.Add(SecureConversationDec2005Strings.RequestSecurityContextIssuance);
+            this.RequestSecurityContextIssuanceResponse = dictionary.Add(SecureConversationDec2005Strings.RequestSecurityContextIssuanceResponse);
+            this.RequestSecurityContextRenew = dictionary.Add(SecureConversationDec2005Strings.RequestSecurityContextRenew);
+            this.RequestSecurityContextRenewResponse = dictionary.Add(SecureConversationDec2005Strings.RequestSecurityContextRenewResponse);
+            this.RequestSecurityContextClose = dictionary.Add(SecureConversationDec2005Strings.RequestSecurityContextClose);
+            this.RequestSecurityContextCloseResponse = dictionary.Add(SecureConversationDec2005Strings.RequestSecurityContextCloseResponse);
+            this.Namespace = dictionary.Add(SecureConversationDec2005Strings.Namespace);
+            this.DerivedKeyToken = dictionary.Add(SecureConversationDec2005Strings.DerivedKeyToken);
+            this.Nonce = dictionary.Add(SecureConversationDec2005Strings.Nonce);
+            this.Length = dictionary.Add(SecureConversationDec2005Strings.Length);
+            this.Instance = dictionary.Add(SecureConversationDec2005Strings.Instance);
+        }
+
+        public void PopulateSecureConversationDec2005()
+        {
+            SecureConversationDictionaryStrings.Add(DXD.SecureConversationDec2005Dictionary.SecurityContextToken);
+            SecureConversationDictionaryStrings.Add(DXD.SecureConversationDec2005Dictionary.AlgorithmAttribute);
+            SecureConversationDictionaryStrings.Add(DXD.SecureConversationDec2005Dictionary.Generation);
+            SecureConversationDictionaryStrings.Add(DXD.SecureConversationDec2005Dictionary.Label);
+            SecureConversationDictionaryStrings.Add(DXD.SecureConversationDec2005Dictionary.Offset);
+            SecureConversationDictionaryStrings.Add(DXD.SecureConversationDec2005Dictionary.Properties);
+            SecureConversationDictionaryStrings.Add(DXD.SecureConversationDec2005Dictionary.Identifier);
+            SecureConversationDictionaryStrings.Add(DXD.SecureConversationDec2005Dictionary.Cookie);
+            SecureConversationDictionaryStrings.Add(DXD.SecureConversationDec2005Dictionary.RenewNeededFaultCode);
+            SecureConversationDictionaryStrings.Add(DXD.SecureConversationDec2005Dictionary.BadContextTokenFaultCode);
+            SecureConversationDictionaryStrings.Add(DXD.SecureConversationDec2005Dictionary.Prefix);
+            SecureConversationDictionaryStrings.Add(DXD.SecureConversationDec2005Dictionary.DerivedKeyTokenType);
+            SecureConversationDictionaryStrings.Add(DXD.SecureConversationDec2005Dictionary.SecurityContextTokenType);
+            SecureConversationDictionaryStrings.Add(DXD.SecureConversationDec2005Dictionary.SecurityContextTokenReferenceValueType);
+            SecureConversationDictionaryStrings.Add(DXD.SecureConversationDec2005Dictionary.RequestSecurityContextIssuance);
+            SecureConversationDictionaryStrings.Add(DXD.SecureConversationDec2005Dictionary.RequestSecurityContextIssuanceResponse);
+            SecureConversationDictionaryStrings.Add(DXD.SecureConversationDec2005Dictionary.RequestSecurityContextRenew);
+            SecureConversationDictionaryStrings.Add(DXD.SecureConversationDec2005Dictionary.RequestSecurityContextRenewResponse);
+            SecureConversationDictionaryStrings.Add(DXD.SecureConversationDec2005Dictionary.RequestSecurityContextClose);
+            SecureConversationDictionaryStrings.Add(DXD.SecureConversationDec2005Dictionary.RequestSecurityContextCloseResponse);
+            SecureConversationDictionaryStrings.Add(DXD.SecureConversationDec2005Dictionary.Namespace);
+            SecureConversationDictionaryStrings.Add(DXD.SecureConversationDec2005Dictionary.DerivedKeyToken);
+            SecureConversationDictionaryStrings.Add(DXD.SecureConversationDec2005Dictionary.Nonce);
+            SecureConversationDictionaryStrings.Add(DXD.SecureConversationDec2005Dictionary.Length);
+            SecureConversationDictionaryStrings.Add(DXD.SecureConversationDec2005Dictionary.Instance);
+        }
+
+    }
+
+    class SecurityAlgorithmDec2005Dictionary
+    {
+        public XmlDictionaryString Psha1KeyDerivationDec2005;
+
+        public List<XmlDictionaryString> SecurityAlgorithmDictionaryStrings = new List<XmlDictionaryString>();
+
+        public SecurityAlgorithmDec2005Dictionary(XmlDictionary dictionary)
+        {
+            this.Psha1KeyDerivationDec2005 = dictionary.Add(SecurityAlgorithmDec2005Strings.Psha1KeyDerivationDec2005);
+        }
+
+        public void PopulateSecurityAlgorithmDictionaryString()
+        {
+            SecurityAlgorithmDictionaryStrings.Add(DXD.SecurityAlgorithmDec2005Dictionary.Psha1KeyDerivationDec2005);
+        }
+    }
+
+    class TrustDec2005Dictionary : TrustDictionary
+    {
+        public XmlDictionaryString AsymmetricKeyBinarySecret;
+        public XmlDictionaryString RequestSecurityTokenCollectionIssuanceFinalResponse;
+        public XmlDictionaryString RequestSecurityTokenRenewal;
+        public XmlDictionaryString RequestSecurityTokenRenewalResponse;
+        public XmlDictionaryString RequestSecurityTokenCollectionRenewalFinalResponse;
+        public XmlDictionaryString RequestSecurityTokenCancellation;
+        public XmlDictionaryString RequestSecurityTokenCancellationResponse;
+        public XmlDictionaryString RequestSecurityTokenCollectionCancellationFinalResponse;
+        public XmlDictionaryString KeyWrapAlgorithm;
+        public XmlDictionaryString BearerKeyType;
+        public XmlDictionaryString SecondaryParameters;
+        public XmlDictionaryString Dialect;
+        public XmlDictionaryString DialectType;
+
+        public List<XmlDictionaryString> Feb2005DictionaryStrings = new List<XmlDictionaryString>();
+        public List<XmlDictionaryString> Dec2005DictionaryString = new List<XmlDictionaryString>();
+
+        public TrustDec2005Dictionary(XmlDictionary dictionary)
+        {
+            this.CombinedHashLabel = dictionary.Add(TrustDec2005Strings.CombinedHashLabel);
+            this.RequestSecurityTokenResponse = dictionary.Add(TrustDec2005Strings.RequestSecurityTokenResponse);
+            this.TokenType = dictionary.Add(TrustDec2005Strings.TokenType);
+            this.KeySize = dictionary.Add(TrustDec2005Strings.KeySize);
+            this.RequestedTokenReference = dictionary.Add(TrustDec2005Strings.RequestedTokenReference);
+            this.AppliesTo = dictionary.Add(TrustDec2005Strings.AppliesTo);
+            this.Authenticator = dictionary.Add(TrustDec2005Strings.Authenticator);
+            this.CombinedHash = dictionary.Add(TrustDec2005Strings.CombinedHash);
+            this.BinaryExchange = dictionary.Add(TrustDec2005Strings.BinaryExchange);
+            this.Lifetime = dictionary.Add(TrustDec2005Strings.Lifetime);
+            this.RequestedSecurityToken = dictionary.Add(TrustDec2005Strings.RequestedSecurityToken);
+            this.Entropy = dictionary.Add(TrustDec2005Strings.Entropy);
+            this.RequestedProofToken = dictionary.Add(TrustDec2005Strings.RequestedProofToken);
+            this.ComputedKey = dictionary.Add(TrustDec2005Strings.ComputedKey);
+            this.RequestSecurityToken = dictionary.Add(TrustDec2005Strings.RequestSecurityToken);
+            this.RequestType = dictionary.Add(TrustDec2005Strings.RequestType);
+            this.Context = dictionary.Add(TrustDec2005Strings.Context);
+            this.BinarySecret = dictionary.Add(TrustDec2005Strings.BinarySecret);
+            this.Type = dictionary.Add(TrustDec2005Strings.Type);
+            this.SpnegoValueTypeUri = dictionary.Add(TrustDec2005Strings.SpnegoValueTypeUri);
+            this.TlsnegoValueTypeUri = dictionary.Add(TrustDec2005Strings.TlsnegoValueTypeUri);
+            this.Prefix = dictionary.Add(TrustDec2005Strings.Prefix);
+            this.RequestSecurityTokenIssuance = dictionary.Add(TrustDec2005Strings.RequestSecurityTokenIssuance);
+            this.RequestSecurityTokenIssuanceResponse = dictionary.Add(TrustDec2005Strings.RequestSecurityTokenIssuanceResponse);
+            this.RequestTypeIssue = dictionary.Add(TrustDec2005Strings.RequestTypeIssue);
+            this.AsymmetricKeyBinarySecret = dictionary.Add(TrustDec2005Strings.AsymmetricKeyBinarySecret);
+            this.SymmetricKeyBinarySecret = dictionary.Add(TrustDec2005Strings.SymmetricKeyBinarySecret);
+            this.NonceBinarySecret = dictionary.Add(TrustDec2005Strings.NonceBinarySecret);
+            this.Psha1ComputedKeyUri = dictionary.Add(TrustDec2005Strings.Psha1ComputedKeyUri);
+            this.KeyType = dictionary.Add(TrustDec2005Strings.KeyType);
+            this.SymmetricKeyType = dictionary.Add(TrustDec2005Strings.SymmetricKeyType);
+            this.PublicKeyType = dictionary.Add(TrustDec2005Strings.PublicKeyType);
+            this.Claims = dictionary.Add(TrustDec2005Strings.Claims);
+            this.InvalidRequestFaultCode = dictionary.Add(TrustDec2005Strings.InvalidRequestFaultCode);
+            this.FailedAuthenticationFaultCode = dictionary.Add(TrustDec2005Strings.FailedAuthenticationFaultCode);
+            this.UseKey = dictionary.Add(TrustDec2005Strings.UseKey);
+            this.SignWith = dictionary.Add(TrustDec2005Strings.SignWith);
+            this.EncryptWith = dictionary.Add(TrustDec2005Strings.EncryptWith);
+            this.EncryptionAlgorithm = dictionary.Add(TrustDec2005Strings.EncryptionAlgorithm);
+            this.CanonicalizationAlgorithm = dictionary.Add(TrustDec2005Strings.CanonicalizationAlgorithm);
+            this.ComputedKeyAlgorithm = dictionary.Add(TrustDec2005Strings.ComputedKeyAlgorithm);
+            this.RequestSecurityTokenResponseCollection = dictionary.Add(TrustDec2005Strings.RequestSecurityTokenResponseCollection);
+            this.Namespace = dictionary.Add(TrustDec2005Strings.Namespace);
+            this.BinarySecretClauseType = dictionary.Add(TrustDec2005Strings.BinarySecretClauseType);
+            this.RequestSecurityTokenCollectionIssuanceFinalResponse = dictionary.Add(TrustDec2005Strings.RequestSecurityTokenCollectionIssuanceFinalResponse);
+            this.RequestSecurityTokenRenewal = dictionary.Add(TrustDec2005Strings.RequestSecurityTokenRenewal);
+            this.RequestSecurityTokenRenewalResponse = dictionary.Add(TrustDec2005Strings.RequestSecurityTokenRenewalResponse);
+            this.RequestSecurityTokenCollectionRenewalFinalResponse = dictionary.Add(TrustDec2005Strings.RequestSecurityTokenCollectionRenewalFinalResponse);
+            this.RequestSecurityTokenCancellation = dictionary.Add(TrustDec2005Strings.RequestSecurityTokenCancellation);
+            this.RequestSecurityTokenCancellationResponse = dictionary.Add(TrustDec2005Strings.RequestSecurityTokenCancellationResponse);
+            this.RequestSecurityTokenCollectionCancellationFinalResponse = dictionary.Add(TrustDec2005Strings.RequestSecurityTokenCollectionCancellationFinalResponse);
+            this.RequestTypeRenew = dictionary.Add(TrustDec2005Strings.RequestTypeRenew);
+            this.RequestTypeClose = dictionary.Add(TrustDec2005Strings.RequestTypeClose);
+            this.RenewTarget = dictionary.Add(TrustDec2005Strings.RenewTarget);
+            this.CloseTarget = dictionary.Add(TrustDec2005Strings.CloseTarget);
+            this.RequestedTokenClosed = dictionary.Add(TrustDec2005Strings.RequestedTokenClosed);
+            this.RequestedAttachedReference = dictionary.Add(TrustDec2005Strings.RequestedAttachedReference);
+            this.RequestedUnattachedReference = dictionary.Add(TrustDec2005Strings.RequestedUnattachedReference);
+            this.IssuedTokensHeader = dictionary.Add(TrustDec2005Strings.IssuedTokensHeader);
+            this.KeyWrapAlgorithm = dictionary.Add(TrustDec2005Strings.KeyWrapAlgorithm);
+            this.BearerKeyType = dictionary.Add(TrustDec2005Strings.BearerKeyType);
+            this.SecondaryParameters = dictionary.Add(TrustDec2005Strings.SecondaryParameters);
+            this.Dialect = dictionary.Add(TrustDec2005Strings.Dialect);
+            this.DialectType = dictionary.Add(TrustDec2005Strings.DialectType);
+        }
+
+        public void PopulateFeb2005DictionaryString()
+        {
+            Feb2005DictionaryStrings.Add(XD.TrustFeb2005Dictionary.RequestSecurityTokenResponseCollection);
+            Feb2005DictionaryStrings.Add(XD.TrustFeb2005Dictionary.Namespace);
+            Feb2005DictionaryStrings.Add(XD.TrustFeb2005Dictionary.BinarySecretClauseType);
+            Feb2005DictionaryStrings.Add(XD.TrustFeb2005Dictionary.CombinedHashLabel);
+            Feb2005DictionaryStrings.Add(XD.TrustFeb2005Dictionary.RequestSecurityTokenResponse);
+            Feb2005DictionaryStrings.Add(XD.TrustFeb2005Dictionary.TokenType);
+            Feb2005DictionaryStrings.Add(XD.TrustFeb2005Dictionary.KeySize);
+            Feb2005DictionaryStrings.Add(XD.TrustFeb2005Dictionary.RequestedTokenReference);
+            Feb2005DictionaryStrings.Add(XD.TrustFeb2005Dictionary.AppliesTo);
+            Feb2005DictionaryStrings.Add(XD.TrustFeb2005Dictionary.Authenticator);
+            Feb2005DictionaryStrings.Add(XD.TrustFeb2005Dictionary.CombinedHash);
+            Feb2005DictionaryStrings.Add(XD.TrustFeb2005Dictionary.BinaryExchange);
+            Feb2005DictionaryStrings.Add(XD.TrustFeb2005Dictionary.Lifetime);
+            Feb2005DictionaryStrings.Add(XD.TrustFeb2005Dictionary.RequestedSecurityToken);
+            Feb2005DictionaryStrings.Add(XD.TrustFeb2005Dictionary.Entropy);
+            Feb2005DictionaryStrings.Add(XD.TrustFeb2005Dictionary.RequestedProofToken);
+            Feb2005DictionaryStrings.Add(XD.TrustFeb2005Dictionary.ComputedKey);
+            Feb2005DictionaryStrings.Add(XD.TrustFeb2005Dictionary.RequestSecurityToken);
+            Feb2005DictionaryStrings.Add(XD.TrustFeb2005Dictionary.RequestType);
+            Feb2005DictionaryStrings.Add(XD.TrustFeb2005Dictionary.Context);
+            Feb2005DictionaryStrings.Add(XD.TrustFeb2005Dictionary.BinarySecret);
+            Feb2005DictionaryStrings.Add(XD.TrustFeb2005Dictionary.Type);
+            Feb2005DictionaryStrings.Add(XD.TrustFeb2005Dictionary.SpnegoValueTypeUri);
+            Feb2005DictionaryStrings.Add(XD.TrustFeb2005Dictionary.TlsnegoValueTypeUri);
+            Feb2005DictionaryStrings.Add(XD.TrustFeb2005Dictionary.Prefix);
+            Feb2005DictionaryStrings.Add(XD.TrustFeb2005Dictionary.RequestSecurityTokenIssuance);
+            Feb2005DictionaryStrings.Add(XD.TrustFeb2005Dictionary.RequestSecurityTokenIssuanceResponse);
+            Feb2005DictionaryStrings.Add(XD.TrustFeb2005Dictionary.RequestTypeIssue);
+            Feb2005DictionaryStrings.Add(XD.TrustFeb2005Dictionary.SymmetricKeyBinarySecret);
+            Feb2005DictionaryStrings.Add(XD.TrustFeb2005Dictionary.Psha1ComputedKeyUri);
+            Feb2005DictionaryStrings.Add(XD.TrustFeb2005Dictionary.NonceBinarySecret);
+            Feb2005DictionaryStrings.Add(XD.TrustFeb2005Dictionary.RenewTarget);
+            Feb2005DictionaryStrings.Add(XD.TrustFeb2005Dictionary.CloseTarget);
+            Feb2005DictionaryStrings.Add(XD.TrustFeb2005Dictionary.RequestedTokenClosed);
+            Feb2005DictionaryStrings.Add(XD.TrustFeb2005Dictionary.RequestedAttachedReference);
+            Feb2005DictionaryStrings.Add(XD.TrustFeb2005Dictionary.RequestedUnattachedReference);
+            Feb2005DictionaryStrings.Add(XD.TrustFeb2005Dictionary.IssuedTokensHeader);
+            Feb2005DictionaryStrings.Add(XD.TrustFeb2005Dictionary.RequestTypeRenew);
+            Feb2005DictionaryStrings.Add(XD.TrustFeb2005Dictionary.RequestTypeClose);
+            Feb2005DictionaryStrings.Add(XD.TrustFeb2005Dictionary.KeyType);
+            Feb2005DictionaryStrings.Add(XD.TrustFeb2005Dictionary.SymmetricKeyType);
+            Feb2005DictionaryStrings.Add(XD.TrustFeb2005Dictionary.PublicKeyType);
+            Feb2005DictionaryStrings.Add(XD.TrustFeb2005Dictionary.Claims);
+            Feb2005DictionaryStrings.Add(XD.TrustFeb2005Dictionary.InvalidRequestFaultCode);
+            Feb2005DictionaryStrings.Add(XD.TrustFeb2005Dictionary.FailedAuthenticationFaultCode);
+            Feb2005DictionaryStrings.Add(XD.TrustFeb2005Dictionary.UseKey);
+            Feb2005DictionaryStrings.Add(XD.TrustFeb2005Dictionary.SignWith);
+            Feb2005DictionaryStrings.Add(XD.TrustFeb2005Dictionary.EncryptWith);
+            Feb2005DictionaryStrings.Add(XD.TrustFeb2005Dictionary.EncryptionAlgorithm);
+            Feb2005DictionaryStrings.Add(XD.TrustFeb2005Dictionary.CanonicalizationAlgorithm);
+            Feb2005DictionaryStrings.Add(XD.TrustFeb2005Dictionary.ComputedKeyAlgorithm);
+        }
+
+        public void PopulateDec2005DictionaryStrings()
+        {
+            Dec2005DictionaryString.Add(DXD.TrustDec2005Dictionary.CombinedHashLabel);
+            Dec2005DictionaryString.Add(DXD.TrustDec2005Dictionary.RequestSecurityTokenResponse);
+            Dec2005DictionaryString.Add(DXD.TrustDec2005Dictionary.TokenType);
+            Dec2005DictionaryString.Add(DXD.TrustDec2005Dictionary.KeySize);
+            Dec2005DictionaryString.Add(DXD.TrustDec2005Dictionary.RequestedTokenReference);
+            Dec2005DictionaryString.Add(DXD.TrustDec2005Dictionary.AppliesTo);
+            Dec2005DictionaryString.Add(DXD.TrustDec2005Dictionary.Authenticator);
+            Dec2005DictionaryString.Add(DXD.TrustDec2005Dictionary.CombinedHash);
+            Dec2005DictionaryString.Add(DXD.TrustDec2005Dictionary.BinaryExchange);
+            Dec2005DictionaryString.Add(DXD.TrustDec2005Dictionary.Lifetime);
+            Dec2005DictionaryString.Add(DXD.TrustDec2005Dictionary.RequestedSecurityToken);
+            Dec2005DictionaryString.Add(DXD.TrustDec2005Dictionary.Entropy);
+            Dec2005DictionaryString.Add(DXD.TrustDec2005Dictionary.RequestedProofToken);
+            Dec2005DictionaryString.Add(DXD.TrustDec2005Dictionary.ComputedKey);
+            Dec2005DictionaryString.Add(DXD.TrustDec2005Dictionary.RequestSecurityToken);
+            Dec2005DictionaryString.Add(DXD.TrustDec2005Dictionary.RequestType);
+            Dec2005DictionaryString.Add(DXD.TrustDec2005Dictionary.Context);
+            Dec2005DictionaryString.Add(DXD.TrustDec2005Dictionary.BinarySecret);
+            Dec2005DictionaryString.Add(DXD.TrustDec2005Dictionary.Type);
+            Dec2005DictionaryString.Add(DXD.TrustDec2005Dictionary.SpnegoValueTypeUri);
+            Dec2005DictionaryString.Add(DXD.TrustDec2005Dictionary.TlsnegoValueTypeUri);
+            Dec2005DictionaryString.Add(DXD.TrustDec2005Dictionary.Prefix);
+            Dec2005DictionaryString.Add(DXD.TrustDec2005Dictionary.RequestSecurityTokenIssuance);
+            Dec2005DictionaryString.Add(DXD.TrustDec2005Dictionary.RequestSecurityTokenIssuanceResponse);
+            Dec2005DictionaryString.Add(DXD.TrustDec2005Dictionary.RequestTypeIssue);
+            Dec2005DictionaryString.Add(DXD.TrustDec2005Dictionary.AsymmetricKeyBinarySecret);
+            Dec2005DictionaryString.Add(DXD.TrustDec2005Dictionary.SymmetricKeyBinarySecret);
+            Dec2005DictionaryString.Add(DXD.TrustDec2005Dictionary.NonceBinarySecret);
+            Dec2005DictionaryString.Add(DXD.TrustDec2005Dictionary.Psha1ComputedKeyUri);
+            Dec2005DictionaryString.Add(DXD.TrustDec2005Dictionary.KeyType);
+            Dec2005DictionaryString.Add(DXD.TrustDec2005Dictionary.SymmetricKeyType);
+            Dec2005DictionaryString.Add(DXD.TrustDec2005Dictionary.PublicKeyType);
+            Dec2005DictionaryString.Add(DXD.TrustDec2005Dictionary.Claims);
+            Dec2005DictionaryString.Add(DXD.TrustDec2005Dictionary.InvalidRequestFaultCode);
+            Dec2005DictionaryString.Add(DXD.TrustDec2005Dictionary.FailedAuthenticationFaultCode);
+            Dec2005DictionaryString.Add(DXD.TrustDec2005Dictionary.UseKey);
+            Dec2005DictionaryString.Add(DXD.TrustDec2005Dictionary.SignWith);
+            Dec2005DictionaryString.Add(DXD.TrustDec2005Dictionary.EncryptWith);
+            Dec2005DictionaryString.Add(DXD.TrustDec2005Dictionary.EncryptionAlgorithm);
+            Dec2005DictionaryString.Add(DXD.TrustDec2005Dictionary.CanonicalizationAlgorithm);
+            Dec2005DictionaryString.Add(DXD.TrustDec2005Dictionary.ComputedKeyAlgorithm);
+            Dec2005DictionaryString.Add(DXD.TrustDec2005Dictionary.RequestSecurityTokenResponseCollection);
+            Dec2005DictionaryString.Add(DXD.TrustDec2005Dictionary.Namespace);
+            Dec2005DictionaryString.Add(DXD.TrustDec2005Dictionary.BinarySecretClauseType);
+            Dec2005DictionaryString.Add(DXD.TrustDec2005Dictionary.RequestSecurityTokenCollectionIssuanceFinalResponse);
+            Dec2005DictionaryString.Add(DXD.TrustDec2005Dictionary.RequestSecurityTokenRenewal);
+            Dec2005DictionaryString.Add(DXD.TrustDec2005Dictionary.RequestSecurityTokenRenewalResponse);
+            Dec2005DictionaryString.Add(DXD.TrustDec2005Dictionary.RequestSecurityTokenCollectionRenewalFinalResponse);
+            Dec2005DictionaryString.Add(DXD.TrustDec2005Dictionary.RequestSecurityTokenCancellation);
+            Dec2005DictionaryString.Add(DXD.TrustDec2005Dictionary.RequestSecurityTokenCancellationResponse);
+            Dec2005DictionaryString.Add(DXD.TrustDec2005Dictionary.RequestSecurityTokenCollectionCancellationFinalResponse);
+            Dec2005DictionaryString.Add(DXD.TrustDec2005Dictionary.RequestTypeRenew);
+            Dec2005DictionaryString.Add(DXD.TrustDec2005Dictionary.RequestTypeClose);
+            Dec2005DictionaryString.Add(DXD.TrustDec2005Dictionary.RenewTarget);
+            Dec2005DictionaryString.Add(DXD.TrustDec2005Dictionary.CloseTarget);
+            Dec2005DictionaryString.Add(DXD.TrustDec2005Dictionary.RequestedTokenClosed);
+            Dec2005DictionaryString.Add(DXD.TrustDec2005Dictionary.RequestedAttachedReference);
+            Dec2005DictionaryString.Add(DXD.TrustDec2005Dictionary.RequestedUnattachedReference);
+            Dec2005DictionaryString.Add(DXD.TrustDec2005Dictionary.IssuedTokensHeader);
+            Dec2005DictionaryString.Add(DXD.TrustDec2005Dictionary.KeyWrapAlgorithm);
+            Dec2005DictionaryString.Add(DXD.TrustDec2005Dictionary.BearerKeyType);
+            Dec2005DictionaryString.Add(DXD.TrustDec2005Dictionary.SecondaryParameters);
+            Dec2005DictionaryString.Add(DXD.TrustDec2005Dictionary.Dialect);
+            Dec2005DictionaryString.Add(DXD.TrustDec2005Dictionary.DialectType);
+        }
+    }
+
+    class Wsrm11Dictionary
+    {
+        public XmlDictionaryString AckRequestedAction;
+        public XmlDictionaryString CloseSequence;
+        public XmlDictionaryString CloseSequenceAction;
+        public XmlDictionaryString CloseSequenceResponse;
+        public XmlDictionaryString CloseSequenceResponseAction;
+        public XmlDictionaryString CreateSequenceAction;
+        public XmlDictionaryString CreateSequenceResponseAction;
+        public XmlDictionaryString DiscardFollowingFirstGap;
+        public XmlDictionaryString Endpoint;
+        public XmlDictionaryString FaultAction;
+        public XmlDictionaryString Final;
+        public XmlDictionaryString IncompleteSequenceBehavior;
+        public XmlDictionaryString LastMsgNumber;
+        public XmlDictionaryString MaxMessageNumber;
+        public XmlDictionaryString Namespace;
+        public XmlDictionaryString NoDiscard;
+        public XmlDictionaryString None;
+        public XmlDictionaryString SequenceAcknowledgementAction;
+        public XmlDictionaryString SequenceClosed;
+        public XmlDictionaryString TerminateSequenceAction;
+        public XmlDictionaryString TerminateSequenceResponse;
+        public XmlDictionaryString TerminateSequenceResponseAction;
+        public XmlDictionaryString UsesSequenceSSL;
+        public XmlDictionaryString UsesSequenceSTR;
+        public XmlDictionaryString WsrmRequired;
+
+        public Wsrm11Dictionary(XmlDictionary dictionary)
+        {
+            this.AckRequestedAction = dictionary.Add(Wsrm11Strings.AckRequestedAction);
+            this.CloseSequence = dictionary.Add(Wsrm11Strings.CloseSequence);
+            this.CloseSequenceAction = dictionary.Add(Wsrm11Strings.CloseSequenceAction);
+            this.CloseSequenceResponse = dictionary.Add(Wsrm11Strings.CloseSequenceResponse);
+            this.CloseSequenceResponseAction = dictionary.Add(Wsrm11Strings.CloseSequenceResponseAction);
+            this.CreateSequenceAction = dictionary.Add(Wsrm11Strings.CreateSequenceAction);
+            this.CreateSequenceResponseAction = dictionary.Add(Wsrm11Strings.CreateSequenceResponseAction);
+            this.DiscardFollowingFirstGap = dictionary.Add(Wsrm11Strings.DiscardFollowingFirstGap);
+            this.Endpoint = dictionary.Add(Wsrm11Strings.Endpoint);
+            this.FaultAction = dictionary.Add(Wsrm11Strings.FaultAction);
+            this.Final = dictionary.Add(Wsrm11Strings.Final);
+            this.IncompleteSequenceBehavior = dictionary.Add(Wsrm11Strings.IncompleteSequenceBehavior);
+            this.LastMsgNumber = dictionary.Add(Wsrm11Strings.LastMsgNumber);
+            this.MaxMessageNumber = dictionary.Add(Wsrm11Strings.MaxMessageNumber);
+            this.Namespace = dictionary.Add(Wsrm11Strings.Namespace);
+            this.NoDiscard = dictionary.Add(Wsrm11Strings.NoDiscard);
+            this.None = dictionary.Add(Wsrm11Strings.None);
+            this.SequenceAcknowledgementAction = dictionary.Add(Wsrm11Strings.SequenceAcknowledgementAction);
+            this.SequenceClosed = dictionary.Add(Wsrm11Strings.SequenceClosed);
+            this.TerminateSequenceAction = dictionary.Add(Wsrm11Strings.TerminateSequenceAction);
+            this.TerminateSequenceResponse = dictionary.Add(Wsrm11Strings.TerminateSequenceResponse);
+            this.TerminateSequenceResponseAction = dictionary.Add(Wsrm11Strings.TerminateSequenceResponseAction);
+            this.UsesSequenceSSL = dictionary.Add(Wsrm11Strings.UsesSequenceSSL);
+            this.UsesSequenceSTR = dictionary.Add(Wsrm11Strings.UsesSequenceSTR);
+            this.WsrmRequired = dictionary.Add(Wsrm11Strings.WsrmRequired);
+        }
+    }
+
+    static class AtomicTransactionExternal11Strings
+    {
+        // dictionary strings
+        public const string Namespace = "http://docs.oasis-open.org/ws-tx/wsat/2006/06";
+        public const string CompletionUri = "http://docs.oasis-open.org/ws-tx/wsat/2006/06/Completion";
+        public const string Durable2PCUri = "http://docs.oasis-open.org/ws-tx/wsat/2006/06/Durable2PC";
+        public const string Volatile2PCUri = "http://docs.oasis-open.org/ws-tx/wsat/2006/06/Volatile2PC";
+        public const string CommitAction = "http://docs.oasis-open.org/ws-tx/wsat/2006/06/Commit";
+        public const string RollbackAction = "http://docs.oasis-open.org/ws-tx/wsat/2006/06/Rollback";
+        public const string CommittedAction = "http://docs.oasis-open.org/ws-tx/wsat/2006/06/Committed";
+        public const string AbortedAction = "http://docs.oasis-open.org/ws-tx/wsat/2006/06/Aborted";
+        public const string PrepareAction = "http://docs.oasis-open.org/ws-tx/wsat/2006/06/Prepare";
+        public const string PreparedAction = "http://docs.oasis-open.org/ws-tx/wsat/2006/06/Prepared";
+        public const string ReadOnlyAction = "http://docs.oasis-open.org/ws-tx/wsat/2006/06/ReadOnly";
+        public const string ReplayAction = "http://docs.oasis-open.org/ws-tx/wsat/2006/06/Replay";
+        public const string FaultAction = "http://docs.oasis-open.org/ws-tx/wsat/2006/06/fault";
+        public const string UnknownTransaction = "UnknownTransaction";
+    }
+
+    static class CoordinationExternal11Strings
+    {
+        // dictionary strings
+        public const string Namespace = "http://docs.oasis-open.org/ws-tx/wscoor/2006/06";
+        public const string CreateCoordinationContextAction = "http://docs.oasis-open.org/ws-tx/wscoor/2006/06/CreateCoordinationContext";
+        public const string CreateCoordinationContextResponseAction = "http://docs.oasis-open.org/ws-tx/wscoor/2006/06/CreateCoordinationContextResponse";
+        public const string RegisterAction = "http://docs.oasis-open.org/ws-tx/wscoor/2006/06/Register";
+        public const string RegisterResponseAction = "http://docs.oasis-open.org/ws-tx/wscoor/2006/06/RegisterResponse";
+        public const string FaultAction = "http://docs.oasis-open.org/ws-tx/wscoor/2006/06/fault";
+        public const string CannotCreateContext = "CannotCreateContext";
+        public const string CannotRegisterParticipant = "CannotRegisterParticipant";
+    }
+
+    static class SecureConversationDec2005Strings
+    {
+        // dictionary strings
+        public const string SecurityContextToken = "SecurityContextToken";
+        public const string AlgorithmAttribute = "Algorithm";
+        public const string Generation = "Generation";
+        public const string Label = "Label";
+        public const string Offset = "Offset";
+        public const string Properties = "Properties";
+        public const string Identifier = "Identifier";
+        public const string Cookie = "Cookie";
+        public const string RenewNeededFaultCode = "RenewNeeded";
+        public const string BadContextTokenFaultCode = "BadContextToken";
+        public const string Prefix = "sc";
+        public const string DerivedKeyTokenType = "http://docs.oasis-open.org/ws-sx/ws-secureconversation/200512/dk";
+        public const string SecurityContextTokenType = "http://docs.oasis-open.org/ws-sx/ws-secureconversation/200512/sct";
+        public const string SecurityContextTokenReferenceValueType = "http://docs.oasis-open.org/ws-sx/ws-secureconversation/200512/sct";
+        public const string RequestSecurityContextIssuance = "http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/SCT";
+        public const string RequestSecurityContextIssuanceResponse = "http://docs.oasis-open.org/ws-sx/ws-trust/200512/RSTR/SCT";
+        public const string RequestSecurityContextRenew = "http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/SCT/Renew";
+        public const string RequestSecurityContextRenewResponse = "http://docs.oasis-open.org/ws-sx/ws-trust/200512/RSTR/SCT/Renew";
+        public const string RequestSecurityContextClose = "http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/SCT/Cancel";
+        public const string RequestSecurityContextCloseResponse = "http://docs.oasis-open.org/ws-sx/ws-trust/200512/RSTR/SCT/Cancel";
+        public const string Namespace = "http://docs.oasis-open.org/ws-sx/ws-secureconversation/200512";
+        public const string DerivedKeyToken = "DerivedKeyToken";
+        public const string Nonce = "Nonce";
+        public const string Length = "Length";
+        public const string Instance = "Instance";
+    }
+
+    static class SecurityAlgorithmDec2005Strings
+    {
+        // dictionary strings
+        public const string Psha1KeyDerivationDec2005 = "http://docs.oasis-open.org/ws-sx/ws-secureconversation/200512/dk/p_sha1";
+    }
+
+    static class TrustDec2005Strings
+    {
+        // dictionary strings
+        public const string CombinedHashLabel = "AUTH-HASH";
+        public const string RequestSecurityTokenResponse = "RequestSecurityTokenResponse";
+        public const string TokenType = "TokenType";
+        public const string KeySize = "KeySize";
+        public const string RequestedTokenReference = "RequestedTokenReference";
+        public const string AppliesTo = "AppliesTo";
+        public const string Authenticator = "Authenticator";
+        public const string CombinedHash = "CombinedHash";
+        public const string BinaryExchange = "BinaryExchange";
+        public const string Lifetime = "Lifetime";
+        public const string RequestedSecurityToken = "RequestedSecurityToken";
+        public const string Entropy = "Entropy";
+        public const string RequestedProofToken = "RequestedProofToken";
+        public const string ComputedKey = "ComputedKey";
+        public const string RequestSecurityToken = "RequestSecurityToken";
+        public const string RequestType = "RequestType";
+        public const string Context = "Context";
+        public const string BinarySecret = "BinarySecret";
+        public const string Type = "Type";
+        public const string SpnegoValueTypeUri = "http://schemas.xmlsoap.org/ws/2005/02/trust/spnego";
+        public const string TlsnegoValueTypeUri = "http://schemas.xmlsoap.org/ws/2005/02/trust/tlsnego";
+        public const string Prefix = "trust";
+        public const string RequestSecurityTokenIssuance = "http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Issue";
+        public const string RequestSecurityTokenIssuanceResponse = "http://docs.oasis-open.org/ws-sx/ws-trust/200512/RSTR/Issue";
+        public const string RequestTypeIssue = "http://docs.oasis-open.org/ws-sx/ws-trust/200512/Issue";
+        public const string AsymmetricKeyBinarySecret = "http://docs.oasis-open.org/ws-sx/ws-trust/200512/AsymmetricKey";
+        public const string SymmetricKeyBinarySecret = "http://docs.oasis-open.org/ws-sx/ws-trust/200512/SymmetricKey";
+        public const string NonceBinarySecret = "http://docs.oasis-open.org/ws-sx/ws-trust/200512/Nonce";
+        public const string Psha1ComputedKeyUri = "http://docs.oasis-open.org/ws-sx/ws-trust/200512/CK/PSHA1";
+        public const string KeyType = "KeyType";
+        public const string SymmetricKeyType = "http://docs.oasis-open.org/ws-sx/ws-trust/200512/SymmetricKey";
+        public const string PublicKeyType = "http://docs.oasis-open.org/ws-sx/ws-trust/200512/PublicKey";
+        public const string Claims = "Claims";
+        public const string InvalidRequestFaultCode = "InvalidRequest";
+        public const string FailedAuthenticationFaultCode = "FailedAuthentication";
+        public const string UseKey = "UseKey";
+        public const string SignWith = "SignWith";
+        public const string EncryptWith = "EncryptWith";
+        public const string EncryptionAlgorithm = "EncryptionAlgorithm";
+        public const string CanonicalizationAlgorithm = "CanonicalizationAlgorithm";
+        public const string ComputedKeyAlgorithm = "ComputedKeyAlgorithm";
+        public const string RequestSecurityTokenResponseCollection = "RequestSecurityTokenResponseCollection";
+        public const string Namespace = "http://docs.oasis-open.org/ws-sx/ws-trust/200512";
+        public const string BinarySecretClauseType = "http://docs.oasis-open.org/ws-sx/ws-trust/200512#BinarySecret";
+        public const string RequestSecurityTokenCollectionIssuanceFinalResponse = "http://docs.oasis-open.org/ws-sx/ws-trust/200512/RSTRC/IssueFinal";
+        public const string RequestSecurityTokenRenewal = "http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Renew";
+        public const string RequestSecurityTokenRenewalResponse = "http://docs.oasis-open.org/ws-sx/ws-trust/200512/RSTR/Renew";
+        public const string RequestSecurityTokenCollectionRenewalFinalResponse = "http://docs.oasis-open.org/ws-sx/ws-trust/200512/RSTR/RenewFinal";
+        public const string RequestSecurityTokenCancellation = "http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Cancel";
+        public const string RequestSecurityTokenCancellationResponse = "http://docs.oasis-open.org/ws-sx/ws-trust/200512/RSTR/Cancel";
+        public const string RequestSecurityTokenCollectionCancellationFinalResponse = "http://docs.oasis-open.org/ws-sx/ws-trust/200512/RSTR/CancelFinal";
+        public const string RequestTypeRenew = "http://docs.oasis-open.org/ws-sx/ws-trust/200512/Renew";
+        public const string RequestTypeClose = "http://docs.oasis-open.org/ws-sx/ws-trust/200512/Cancel";
+        public const string RenewTarget = "RenewTarget";
+        public const string CloseTarget = "CancelTarget";
+        public const string RequestedTokenClosed = "RequestedTokenCancelled";
+        public const string RequestedAttachedReference = "RequestedAttachedReference";
+        public const string RequestedUnattachedReference = "RequestedUnattachedReference";
+        public const string IssuedTokensHeader = "IssuedTokens";
+        public const string KeyWrapAlgorithm = "KeyWrapAlgorithm";
+        public const string BearerKeyType = "http://docs.oasis-open.org/ws-sx/ws-trust/200512/Bearer";
+        public const string SecondaryParameters = "SecondaryParameters";
+        public const string Dialect = "Dialect";
+        public const string DialectType = "http://schemas.xmlsoap.org/ws/2005/05/identity";
+    }
+
+    static class Wsrm11Strings
+    {
+        // dictionary strings
+        public const string AckRequestedAction = "http://docs.oasis-open.org/ws-rx/wsrm/200702/AckRequested";
+        public const string CloseSequence = "CloseSequence";
+        public const string CloseSequenceAction = "http://docs.oasis-open.org/ws-rx/wsrm/200702/CloseSequence";
+        public const string CloseSequenceResponse = "CloseSequenceResponse";
+        public const string CloseSequenceResponseAction = "http://docs.oasis-open.org/ws-rx/wsrm/200702/CloseSequenceResponse";
+        public const string CreateSequenceAction = "http://docs.oasis-open.org/ws-rx/wsrm/200702/CreateSequence";
+        public const string CreateSequenceResponseAction = "http://docs.oasis-open.org/ws-rx/wsrm/200702/CreateSequenceResponse";
+        public const string DiscardFollowingFirstGap = "DiscardFollowingFirstGap";
+        public const string Endpoint = "Endpoint";
+        public const string FaultAction = "http://docs.oasis-open.org/ws-rx/wsrm/200702/fault";
+        public const string Final = "Final";
+        public const string IncompleteSequenceBehavior = "IncompleteSequenceBehavior";
+        public const string LastMsgNumber = "LastMsgNumber";
+        public const string MaxMessageNumber = "MaxMessageNumber";
+        public const string Namespace = "http://docs.oasis-open.org/ws-rx/wsrm/200702";
+        public const string NoDiscard = "NoDiscard";
+        public const string None = "None";
+        public const string SequenceAcknowledgementAction = "http://docs.oasis-open.org/ws-rx/wsrm/200702/SequenceAcknowledgement";
+        public const string SequenceClosed = "SequenceClosed";
+        public const string TerminateSequenceAction = "http://docs.oasis-open.org/ws-rx/wsrm/200702/TerminateSequence";
+        public const string TerminateSequenceResponse = "TerminateSequenceResponse";
+        public const string TerminateSequenceResponseAction = "http://docs.oasis-open.org/ws-rx/wsrm/200702/TerminateSequenceResponse";
+        public const string UsesSequenceSSL = "UsesSequenceSSL";
+        public const string UsesSequenceSTR = "UsesSequenceSTR";
+        public const string WsrmRequired = "WsrmRequired";
+        // string constants
+        public const string DiscardEntireSequence = "DiscardEntireSequence";
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Description/DispatcherBuilder.cs b/src/CoreWCF.Primitives/src/CoreWCF/Description/DispatcherBuilder.cs
index d6f62bc..d74d980 100644
--- a/src/CoreWCF.Primitives/src/CoreWCF/Description/DispatcherBuilder.cs
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Description/DispatcherBuilder.cs
@@ -668,8 +668,8 @@ namespace CoreWCF.Description
         {
             var serviceBuilder = services.GetRequiredService<IServiceBuilder>();
             var serverUriAddresses = serviceBuilder.BaseAddresses.ToArray();
-            ServiceHostObjectModel < TService > serviceHost;
-            serviceHost = new ServiceHostObjectModel<TService>(services, serverUriAddresses);
+            ServiceHostObjectModel<TService> serviceHost;
+            serviceHost = services.GetRequiredService<ServiceHostObjectModel<TService>>();
 
             // TODO: Create internal behavior which configures any extensibilities which exist in serviceProvider, eg IMessageInspector
             foreach (var endpointConfig in serviceConfig.Endpoints)
@@ -680,6 +680,7 @@ namespace CoreWCF.Description
                 }
 
                 ContractDescription contract = serviceHost.ReflectedContracts[endpointConfig.Contract];
+
                 var uri = serviceHost.MakeAbsoluteUri(endpointConfig.Address, endpointConfig.Binding);
                 var serviceEndpoint = new ServiceEndpoint(
                     contract,
@@ -688,8 +689,13 @@ namespace CoreWCF.Description
 
                 serviceHost.Description.Endpoints.Add(serviceEndpoint);
             }
+            //services.GetService<ServiceConfigurationDelegateHolder<TService>();
+
 
             InitializeServiceHost(serviceHost);
+            ServiceConfigurationDelegateHolder<TService> configDelegate = services.GetService<ServiceConfigurationDelegateHolder<TService>>();
+            if(configDelegate !=null)
+                configDelegate.Configure(serviceHost);
 
             // TODO: Add error checking to make sure property chain is correctly populated with objects
             var dispatchers = new List<IServiceDispatcher>(serviceHost.ChannelDispatchers.Count);
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Description/MessagePartDescription.cs b/src/CoreWCF.Primitives/src/CoreWCF/Description/MessagePartDescription.cs
index 11fcc38..51dd7a1 100644
--- a/src/CoreWCF.Primitives/src/CoreWCF/Description/MessagePartDescription.cs
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Description/MessagePartDescription.cs
@@ -1,4 +1,5 @@
 using System;
+using System.Net.Security;
 using System.Reflection;
 
 namespace CoreWCF.Description
@@ -10,8 +11,8 @@ namespace CoreWCF.Description
         int index;
         Type type;
         int serializationPosition;
-        //ProtectionLevel protectionLevel;
-        //bool hasProtectionLevel;
+        ProtectionLevel protectionLevel;
+        bool hasProtectionLevel;
         MemberInfo memberInfo;
         // TODO: Was ICustomAttributeProvider
         CustomAttributeProvider additionalAttributesProvider;
@@ -44,8 +45,8 @@ namespace CoreWCF.Description
             index = other.index;
             type = other.type;
             serializationPosition = other.serializationPosition;
-            //this.hasProtectionLevel = other.hasProtectionLevel;
-            //this.protectionLevel = other.protectionLevel;
+            this.hasProtectionLevel = other.hasProtectionLevel;
+            this.protectionLevel = other.protectionLevel;
             memberInfo = other.memberInfo;
             multiple = other.multiple;
             additionalAttributesProvider = other.additionalAttributesProvider;
@@ -90,7 +91,17 @@ namespace CoreWCF.Description
             get { return multiple; }
             set { multiple = value; }
         }
-
+        public ProtectionLevel ProtectionLevel
+        {
+            get { return this.protectionLevel; }
+            set
+            {
+              //  if (!ProtectionLevelHelper.IsDefined(value))
+              //      throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("value"));
+                this.protectionLevel = value;
+                this.hasProtectionLevel = true;
+            }
+        }
         public MemberInfo MemberInfo
         {
             get { return memberInfo; }
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Description/MetadataStrings.cs b/src/CoreWCF.Primitives/src/CoreWCF/Description/MetadataStrings.cs
new file mode 100644
index 0000000..770e4cc
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Description/MetadataStrings.cs
@@ -0,0 +1,144 @@
+namespace CoreWCF.Description
+{
+    internal static class MetadataStrings
+    {
+        public static class MetadataExchangeStrings
+        {
+            /*
+             * This file has a counterpart XmlStrings.cs in the svcutil codebase. 
+             * When making chnages here, please consider whether they should be made there as well
+             */
+            public const string Prefix = "wsx";
+            public const string Name = "WS-MetadataExchange";
+            public const string Namespace = "http://schemas.xmlsoap.org/ws/2004/09/mex";
+            public const string HttpBindingName = "MetadataExchangeHttpBinding";
+            public const string HttpsBindingName = "MetadataExchangeHttpsBinding";
+            public const string TcpBindingName = "MetadataExchangeTcpBinding";
+            public const string NamedPipeBindingName = "MetadataExchangeNamedPipeBinding";
+            public const string BindingNamespace = "http://schemas.microsoft.com/ws/2005/02/mex/bindings";
+    
+            public const string Metadata = "Metadata";
+            public const string MetadataSection = "MetadataSection";
+            public const string Dialect = "Dialect";
+            public const string Identifier = "Identifier";
+            public const string MetadataReference = "MetadataReference";
+            public const string Location = "Location";
+
+        }
+
+        public static class WSTransfer
+        {
+            public const string Prefix = "wxf";
+            public const string Name = "WS-Transfer";
+            public const string Namespace = "http://schemas.xmlsoap.org/ws/2004/09/transfer";
+
+            public const string GetAction = Namespace + "/Get";
+            public const string GetResponseAction = Namespace + "/GetResponse";
+        }
+
+        public static class ServiceDescription
+        {
+            public const string Definitions = "definitions";
+            public const string ArrayType = "arrayType";
+        }
+        
+        public static class XmlSchema
+        {
+            public const string Schema = "schema";
+        }
+
+        public static class Xml
+        {
+            public const string Prefix = "xml";
+            public const string NamespaceUri = "http://www.w3.org/XML/1998/namespace";
+
+            public static class Attributes
+            {
+                public const string Id = "id";
+            }
+                
+        }
+
+        public static class Addressing200408
+        {
+            public const string Prefix = "wsa";
+            public const string NamespaceUri = Addressing200408Strings.Namespace;
+
+            public static class Policy
+            {
+                public const string Prefix = "wsap";
+                public const string NamespaceUri = Addressing200408Strings.Namespace + "/policy";
+                public const string UsingAddressing = "UsingAddressing";
+            }
+        }
+
+        public static class Addressing10
+        {
+            public const string Prefix = "wsa10";
+            public const string NamespaceUri = Addressing10Strings.Namespace;
+
+            public static class WsdlBindingPolicy
+            {
+                public const string Prefix = "wsaw";
+                public const string NamespaceUri = "http://www.w3.org/2006/05/addressing/wsdl";
+                public const string UsingAddressing = "UsingAddressing";
+            }
+
+            public static class MetadataPolicy
+            {
+                public const string Prefix = "wsam";
+                public const string NamespaceUri = "http://www.w3.org/2007/05/addressing/metadata";
+                public const string Addressing = "Addressing";
+                public const string AnonymousResponses = "AnonymousResponses";
+                public const string NonAnonymousResponses = "NonAnonymousResponses";
+            }
+        }
+
+        public static class AddressingWsdl
+        {
+            public const string Prefix = "wsaw";
+            public const string NamespaceUri = "http://www.w3.org/2006/05/addressing/wsdl";
+            public const string Action = "Action";
+        }
+
+        public static class AddressingMetadata
+        {
+            public const string Prefix = "wsam";
+            public const string NamespaceUri = "http://www.w3.org/2007/05/addressing/metadata";
+            public const string Action = "Action";
+        }
+
+        public static class Wsu
+        {
+            public const string Prefix = "wsu";
+            public const string NamespaceUri = "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd";
+            public static class Attributes
+            {    
+                public const string Id = "Id";
+            }
+        }
+
+        public static class WSPolicy
+        {
+            public const string Prefix = "wsp";
+            public const string NamespaceUri = "http://schemas.xmlsoap.org/ws/2004/09/policy";
+            public const string NamespaceUri15 = "http://www.w3.org/ns/ws-policy";
+
+            public static class Attributes
+            {
+                public const string Optional = "Optional";
+                public const string PolicyURIs = "PolicyURIs";
+                public const string URI = "URI";
+                public const string TargetNamespace = "TargetNamespace";
+            }
+            public static class Elements
+            {
+                public const string PolicyReference = "PolicyReference";
+                public const string All = "All";
+                public const string ExactlyOne = "ExactlyOne";
+                public const string Policy = "Policy";
+            }
+        }
+
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Description/ServiceCredentials.cs b/src/CoreWCF.Primitives/src/CoreWCF/Description/ServiceCredentials.cs
index fbe79c0..d6da08f 100644
--- a/src/CoreWCF.Primitives/src/CoreWCF/Description/ServiceCredentials.cs
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Description/ServiceCredentials.cs
@@ -16,9 +16,9 @@ namespace CoreWCF.Description
         X509CertificateInitiatorServiceCredential clientCertificate;
         X509CertificateRecipientServiceCredential serviceCertificate;
         WindowsServiceCredential windows;
-        //IssuedTokenServiceCredential issuedToken;
-        //SecureConversationServiceCredential secureConversation;
-        //bool useIdentityConfiguration = false;
+        IssuedTokenServiceCredential issuedToken;
+        SecureConversationServiceCredential secureConversation;
+        bool useIdentityConfiguration = false;
 
         bool isReadOnly = false;
         bool saveBootstrapTokenInSession = true;
@@ -31,8 +31,8 @@ namespace CoreWCF.Description
             clientCertificate = new X509CertificateInitiatorServiceCredential();
             serviceCertificate = new X509CertificateRecipientServiceCredential();
             windows = new WindowsServiceCredential();
-            //this.issuedToken = new IssuedTokenServiceCredential();
-            //this.secureConversation = new SecureConversationServiceCredential();
+            this.issuedToken = new IssuedTokenServiceCredential();
+            this.secureConversation = new SecureConversationServiceCredential();
             exceptionMapper = new ExceptionMapper();
         }
 
@@ -46,8 +46,8 @@ namespace CoreWCF.Description
             clientCertificate = new X509CertificateInitiatorServiceCredential(other.clientCertificate);
             serviceCertificate = new X509CertificateRecipientServiceCredential(other.serviceCertificate);
             windows = new WindowsServiceCredential(other.windows);
-            //this.issuedToken = new IssuedTokenServiceCredential(other.issuedToken);
-            //this.secureConversation = new SecureConversationServiceCredential(other.secureConversation);
+            this.issuedToken = new IssuedTokenServiceCredential(other.issuedToken);
+            this.secureConversation = new SecureConversationServiceCredential(other.secureConversation);
             saveBootstrapTokenInSession = other.saveBootstrapTokenInSession;
             exceptionMapper = other.exceptionMapper;
         }
@@ -84,21 +84,21 @@ namespace CoreWCF.Description
             }
         }
 
-        //public IssuedTokenServiceCredential IssuedTokenAuthentication
-        //{
-        //    get
-        //    {
-        //        return this.issuedToken;
-        //    }
-        //}
+        public IssuedTokenServiceCredential IssuedTokenAuthentication
+        {
+            get
+            {
+                return this.issuedToken;
+            }
+        }
 
-        //public SecureConversationServiceCredential SecureConversationAuthentication
-        //{
-        //    get
-        //    {
-        //        return this.secureConversation;
-        //    }
-        //}
+        public SecureConversationServiceCredential SecureConversationAuthentication
+        {
+            get
+            {
+                return this.secureConversation;
+            }
+        }
 
         /// <summary>
         /// Gets or sets the ExceptionMapper to be used when throwing exceptions.
@@ -185,8 +185,8 @@ namespace CoreWCF.Description
         {
             isReadOnly = true;
             ClientCertificate.MakeReadOnly();
-            //this.IssuedTokenAuthentication.MakeReadOnly();
-            //this.SecureConversationAuthentication.MakeReadOnly();
+            this.IssuedTokenAuthentication.MakeReadOnly();
+            this.SecureConversationAuthentication.MakeReadOnly();
             ServiceCertificate.MakeReadOnly();
             UserNameAuthentication.MakeReadOnly();
             WindowsAuthentication.MakeReadOnly();
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Diagnostics/TraceUtility.cs b/src/CoreWCF.Primitives/src/CoreWCF/Diagnostics/TraceUtility.cs
index 7579f72..e48c474 100644
--- a/src/CoreWCF.Primitives/src/CoreWCF/Diagnostics/TraceUtility.cs
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Diagnostics/TraceUtility.cs
@@ -3,6 +3,7 @@ using System.Reflection;
 using CoreWCF.Runtime;
 using CoreWCF.Channels;
 using CoreWCF.Dispatcher;
+using CoreWCF.Security;
 
 namespace CoreWCF.Diagnostics
 {
@@ -58,5 +59,15 @@ namespace CoreWCF.Diagnostics
             //        SR.Format(SR.TraceCodeDroppedAMessage), new MessageDroppedTraceRecord(message, endpointAddress));
             //}
         }
+
+        internal static Exception ThrowHelperArgumentNull(string v, Message message)
+        {
+            return new Exception(v);
+        }
+
+        internal static Exception ThrowHelperWarning(Exception exception, Message request)
+        {
+            return exception;
+        }
     }
 }
\ No newline at end of file
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Dispatcher/ChannelDispatcher.cs b/src/CoreWCF.Primitives/src/CoreWCF/Dispatcher/ChannelDispatcher.cs
index 5b6d478..c53c311 100644
--- a/src/CoreWCF.Primitives/src/CoreWCF/Dispatcher/ChannelDispatcher.cs
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Dispatcher/ChannelDispatcher.cs
@@ -238,7 +238,7 @@ namespace CoreWCF.Dispatcher
         internal Uri ListenUri { get; }
 
         internal List<Type> SupportedChannelTypes { get; }
-        
+
         internal Binding Binding { get; }
 
         internal bool HandleError(Exception error)
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Dispatcher/DispatchOperationRuntime.cs b/src/CoreWCF.Primitives/src/CoreWCF/Dispatcher/DispatchOperationRuntime.cs
index 95618c5..9fcb477 100644
--- a/src/CoreWCF.Primitives/src/CoreWCF/Dispatcher/DispatchOperationRuntime.cs
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Dispatcher/DispatchOperationRuntime.cs
@@ -407,7 +407,7 @@ namespace CoreWCF.Dispatcher
                     {
                         await parent.SecurityImpersonation.RunImpersonated(rpc, async () =>
                         {
-                            (rpc.ReturnParameter, rpc.OutputParameters) = await Invoker.InvokeAsync(target, rpc.InputParameters);
+                        (rpc.ReturnParameter, rpc.OutputParameters) = await Invoker.InvokeAsync(target, rpc.InputParameters);
                         });
                     }
                     else
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Dispatcher/HeaderFilter.cs b/src/CoreWCF.Primitives/src/CoreWCF/Dispatcher/HeaderFilter.cs
new file mode 100644
index 0000000..714e9fa
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Dispatcher/HeaderFilter.cs
@@ -0,0 +1,37 @@
+namespace CoreWCF.Dispatcher
+{
+    using System;
+    using CoreWCF.Channels;
+    using System.Collections;
+    using System.Collections.Generic;
+    using System.Collections.ObjectModel;
+    using System.Diagnostics;
+    using System.Runtime.Serialization;
+    using CoreWCF.Diagnostics;
+
+    abstract class HeaderFilter : MessageFilter
+    {
+        protected HeaderFilter()
+            : base()
+        {
+        }
+
+        public override bool Match(MessageBuffer buffer)
+        {
+            if (buffer == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("buffer");
+            }
+
+            Message message = buffer.CreateMessage();
+            try
+            {
+                return Match(message);
+            }
+            finally
+            {
+                message.Close();
+            }
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Dispatcher/InputChannelBinder.cs b/src/CoreWCF.Primitives/src/CoreWCF/Dispatcher/InputChannelBinder.cs
index a1b870f..e200df5 100644
--- a/src/CoreWCF.Primitives/src/CoreWCF/Dispatcher/InputChannelBinder.cs
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Dispatcher/InputChannelBinder.cs
@@ -133,5 +133,4 @@ namespace CoreWCF.Dispatcher
             }
         }
     }
-
 }
\ No newline at end of file
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Dispatcher/SecurityReplyChannelBinder.cs b/src/CoreWCF.Primitives/src/CoreWCF/Dispatcher/SecurityReplyChannelBinder.cs
new file mode 100644
index 0000000..d38e78c
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Dispatcher/SecurityReplyChannelBinder.cs
@@ -0,0 +1,201 @@
+﻿using CoreWCF.Channels;
+using CoreWCF.Configuration;
+using CoreWCF.Description;
+using CoreWCF.Diagnostics;
+using CoreWCF.Runtime;
+using CoreWCF.Security;
+using CoreWCF.Security.Tokens;
+using System;
+using System.Collections.Generic;
+using System.Text;
+using System.Threading;
+using System.Threading.Tasks;
+using System.Xml;
+
+namespace CoreWCF.Dispatcher
+{
+    //For Security over SOAP, creating a separte Binder
+    class SecurityReplyChannelBinder : IChannelBinder
+    {
+        private IReplyChannel _channel;
+        private bool _initialized = false;
+        private IServiceChannelDispatcher _next;
+        private SecurityServiceDispatcher _securityDispatcher;
+
+        public SecurityReplyChannelBinder() { }
+
+        internal void Init(IReplyChannel channel, Uri listenUri)
+        {
+            if (_initialized)
+            {
+                Fx.Assert(_channel == channel, "Wrong channel when calling Init");
+                Fx.Assert(ListenUri == listenUri, "Wrong listenUri when calling Init");
+                return;
+            }
+
+            if (channel == null)
+            {
+                Fx.Assert("ReplyChannelBinder.ReplyChannelBinder: (channel != null)");
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(channel));
+            }
+            _channel = channel;
+            ListenUri = listenUri;
+            _initialized = true;
+            if(_channel is SecurityReplyChannel)
+            {
+                this._securityDispatcher = ((SecurityReplyChannel)_channel).SecurityServiceDispatcher;
+            }
+        }
+
+        public IChannel Channel
+        {
+            get { return _channel; }
+        }
+
+        public bool HasSession
+        {
+            get { return _channel is SecurityReplyChannel; }
+        }
+
+        public Uri ListenUri { get; private set; }
+
+        public EndpointAddress LocalAddress
+        {
+            get { return _channel.LocalAddress; }
+        }
+
+        public EndpointAddress RemoteAddress
+        {
+            get
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new NotImplementedException());
+            }
+        }
+
+        public void Abort()
+        {
+            _channel.Abort();
+        }
+
+        public void CloseAfterFault(TimeSpan timeout)
+        {
+            var helper = new TimeoutHelper(timeout);
+            _channel.CloseAsync(helper.GetCancellationToken()).GetAwaiter().GetResult();
+        }
+
+        public RequestContext CreateRequestContext(Message message)
+        {
+            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new NotImplementedException());
+        }
+
+        public Task SendAsync(Message message, CancellationToken token)
+        {
+            throw TraceUtility.ThrowHelperError(new NotImplementedException(), message);
+        }
+
+        public Task<Message> RequestAsync(Message message, CancellationToken token)
+        {
+            throw TraceUtility.ThrowHelperError(new NotImplementedException(), message);
+        }
+
+        public void SetNextDispatcher(IServiceChannelDispatcher dispatcher)
+        {
+            _next = dispatcher;
+        }
+
+        public Task DispatchAsync(RequestContext context)
+        {
+            Fx.Assert(_next != null, "SetNextDispatcher wasn't called");
+            if (IdentityModel.SecurityUtils.
+                IsRequestSecurityContextIssuance(context.RequestMessage.Headers.Action))
+            {
+                context = HandleHandshake(context);
+                //Add logic to separate flow for handshake or actual call
+                return _next.DispatchAsync(context);
+            }
+            else
+            {
+                return ProcessRequest(context);
+
+            }
+
+        }
+
+        public Task DispatchAsync(Message message)
+        {
+            throw new NotImplementedException();
+        }
+
+
+
+
+
+        private Task ProcessRequest(RequestContext context)
+        {
+            String sessionKey = GetIdentifier(context.RequestMessage.Headers);
+            if (String.IsNullOrEmpty(sessionKey))
+                throw new Exception("Session Key is mising");
+            if (this._securityDispatcher.SessionServerSettings != null)
+            {
+                UniqueId sessionId = new UniqueId(sessionKey);
+                SecuritySessionServerSettings settings = this._securityDispatcher.SessionServerSettings;
+                SecurityContextSecurityToken cacheToken =
+                    settings.GetSecurityContextSecurityToken(sessionId);
+                SecurityContextSecurityToken securityToken = cacheToken.Clone();
+                settings.RemovePendingSession(sessionId);
+                ServerSecuritySimplexSessionChannel.SecurityReplySessionChannel
+                    sessionReplyChannel = new ServerSecuritySimplexSessionChannel.
+                    SecurityReplySessionChannel(settings, securityToken, null
+                    , settings.SettingsLifetimeManager);
+                RequestContext securityRequestContext = sessionReplyChannel.ReceiveRequest(context);
+                ServiceDispatcher serviceDispatcher = (ServiceDispatcher)this._securityDispatcher.InnerServiceDispatcher;
+                Task<IServiceChannelDispatcher> serviceChannelDispatcherTask = serviceDispatcher.CreateServiceChannelDispatcherAsync(this._securityDispatcher.OuterChannel);
+                IServiceChannelDispatcher serviceChannelDispatcher = serviceChannelDispatcherTask.GetAwaiter().GetResult();
+                return serviceChannelDispatcher.DispatchAsync(securityRequestContext);
+            }
+            else
+            {
+                throw new Exception("Session in server missing");
+            }
+
+        }
+
+        private SecurityRequestContext HandleHandshake(RequestContext context)
+        {
+            SecurityReplyChannel securityReplyChannel = (SecurityReplyChannel)_channel;
+            SecurityRequestContext securedMessage = (SecurityRequestContext)securityReplyChannel.ProcessReceivedRequest(context);
+            return securedMessage;
+        }
+
+
+        private String GetIdentifier(MessageHeaders headers)
+        {
+            int headerIndex = headers.FindHeader(XD.SecurityJan2004Dictionary.Security.Value, XD.SecurityJan2004Dictionary.Namespace.Value);
+            if(headerIndex >0)
+            {
+                XmlReader reader = headers.GetReaderAtHeader(headerIndex).ReadSubtree();
+                while (!reader.EOF)
+                {
+                    reader.MoveToElement();
+                    if (String.Compare(reader.LocalName, SecureConversationApr2004Strings.SecurityContextToken, true) == 0)
+                    {
+                        reader.MoveToElement();
+                        while (!reader.EOF)
+                        {
+                            if(String.Compare(reader.LocalName, SecureConversationApr2004Strings.Identifier, true) == 0)
+                            {
+                                reader.Read();
+                                return reader.Value;
+                            }
+                            reader.Read();
+                        }
+                    }
+                    reader.Read();
+                 }
+            }
+
+            return String.Empty;
+        }
+
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Dispatcher/SecurityServiceDispatcher.cs b/src/CoreWCF.Primitives/src/CoreWCF/Dispatcher/SecurityServiceDispatcher.cs
new file mode 100644
index 0000000..900ae47
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Dispatcher/SecurityServiceDispatcher.cs
@@ -0,0 +1,593 @@
+﻿using CoreWCF.Channels;
+using CoreWCF.Configuration;
+using CoreWCF.Description;
+using CoreWCF.Runtime;
+using CoreWCF.Security;
+using CoreWCF.Security.Tokens;
+using System;
+using System.Collections.Generic;
+using System.Security;
+using System.Text;
+using System.Threading;
+using System.Threading.Tasks;
+using System.Xml;
+using System.Xml.Schema;
+
+namespace CoreWCF.Dispatcher
+{
+    public class SecurityServiceDispatcher : IServiceDispatcher
+    {
+        private IRequestReplyCorrelator _requestReplyCorrelator;
+        private BindingContext bindingContext;
+        TransportSecurityBindingElement transportSecurityBinding;
+        private SecurityProtocolFactory securityProtocolFactory;
+        private SecuritySessionServerSettings sessionServerSettings;
+        // Do we need it ?
+        SecurityListenerSettingsLifetimeManager settingsLifetimeManager;
+        private bool sessionMode;
+        private bool sendUnsecuredFaults;
+        private ChannelDispatcher securityAuthChannelDispatcher;
+        IChannel outerChannel;
+
+        public SecurityServiceDispatcher(TransportSecurityBindingElement transportSecurityBindingElement, BindingContext context, IServiceDispatcher serviceDispatcher)
+        {
+            this.InnerServiceDispatcher = serviceDispatcher;
+            this.bindingContext = context;
+            this.transportSecurityBinding = transportSecurityBindingElement;
+            _requestReplyCorrelator = new RequestReplyCorrelator();
+            // this.securityProtocolFactory =  securityProtocolFactory; // we set it later from TransportSecurityBindingElement
+            //  this.settingsLifetimeManager = new SecurityListenerSettingsLifetimeManager(this.securityProtocolFactory, this.sessionServerSettings, this.sessionMode, this.InnerChannelListener);
+        }
+
+        public Uri BaseAddress => InnerServiceDispatcher.BaseAddress;
+
+        public Binding Binding => bindingContext.Binding;
+
+        public IServiceDispatcher InnerServiceDispatcher { get; }
+
+        public ChannelDispatcher SecurityAuthChannelDispatcher
+        {
+            get
+            {
+                return this.securityAuthChannelDispatcher;
+            }
+            set
+            {
+                this.securityAuthChannelDispatcher = value;
+            }
+        }
+
+        // public EndpointDispatcherTable Endpoints => ChannelDispatcher.EndpointDispatcherTable;
+
+        public ICollection<Type> SupportedChannelTypes => InnerServiceDispatcher.SupportedChannelTypes;
+
+        public object ThisLock { get; } = new object();
+
+        public SecurityProtocolFactory SecurityProtocolFactory
+        {
+            get
+            {
+
+                //  ThrowIfDisposed();
+                return this.securityProtocolFactory;
+            }
+            set
+            {
+                if (value == null)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("value");
+                }
+                //   ThrowIfDisposedOrImmutable();
+                this.securityProtocolFactory = value;
+            }
+        }
+
+        public bool SessionMode
+        {
+            get
+            {
+                return this.sessionMode;
+            }
+            set
+            {
+                this.sessionMode = value;
+            }
+        }
+
+        public SecuritySessionServerSettings SessionServerSettings
+        {
+            get
+            {
+                if (this.sessionServerSettings == null)
+                {
+                    lock (ThisLock)
+                    {
+                        if (this.sessionServerSettings == null)
+                        {
+                            SecuritySessionServerSettings tmp = new SecuritySessionServerSettings();
+                            System.Threading.Thread.MemoryBarrier();
+                            tmp.SecurityServiceDispatcher = this;
+                            this.sessionServerSettings = tmp;
+                        }
+                    }
+                }
+                return this.sessionServerSettings;
+            }
+        }
+
+        bool SupportsDuplex
+        {
+            get
+            {
+                ThrowIfProtocolFactoryNotSet();
+                return this.securityProtocolFactory.SupportsDuplex;
+            }
+        }
+
+        bool SupportsRequestReply
+        {
+            get
+            {
+                ThrowIfProtocolFactoryNotSet();
+                return this.securityProtocolFactory.SupportsRequestReply;
+            }
+        }
+
+        public bool SendUnsecuredFaults
+        {
+            get
+            {
+                return this.sendUnsecuredFaults;
+            }
+            set
+            {
+                this.sendUnsecuredFaults = value;
+            }
+        }
+
+        public IChannel OuterChannel
+        {
+            get { return this.outerChannel; }
+            set { this.outerChannel = value; }
+        }
+
+        IList<Type> IServiceDispatcher.SupportedChannelTypes => throw new NotImplementedException();
+
+        public ServiceHostBase Host =>  InnerServiceDispatcher.Host;
+
+        //private 
+
+        // This method should only be called at Open time, since it looks up the identity based on the 
+        // thread token
+        //void ComputeEndpointIdentity()
+        //{
+        //    EndpointIdentity result = null;
+        //    if (this.State == CommunicationState.Opened)
+        //    {
+        //        if (this.SecurityProtocolFactory != null)
+        //        {
+        //            result = this.SecurityProtocolFactory.GetIdentityOfSelf();
+        //        }
+        //        else if (this.SessionServerSettings != null && this.SessionServerSettings.SessionProtocolFactory != null)
+        //        {
+        //            result = this.SessionServerSettings.SessionProtocolFactory.GetIdentityOfSelf();
+        //        }
+        //    }
+        //    if (result == null)
+        //    {
+        //        result = base.GetProperty<EndpointIdentity>();
+        //    }
+        //    this.identity = result;
+        //}
+
+
+
+        void ThrowIfProtocolFactoryNotSet()
+        {
+            if (this.securityProtocolFactory == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.SecurityProtocolFactoryShouldBeSetBeforeThisOperation)));
+            }
+        }
+        public async Task<IServiceChannelDispatcher> CreateServiceChannelDispatcherAsync(IChannel outerChannel)
+        {
+            this.outerChannel = outerChannel;
+            IChannel securityChannel = GetInnerChannel(outerChannel);
+            var sessionIdleManager = securityChannel.GetProperty<ServiceChannel.SessionIdleManager>();
+            IChannelBinder binder = null;
+            if (securityChannel is IReplyChannel)
+            {
+                var rcbinder = securityChannel.GetProperty<SecurityReplyChannelBinder>();
+                rcbinder.Init(securityChannel as IReplyChannel, BaseAddress);
+                binder = rcbinder;
+            }
+            else
+            {
+                throw new NotImplementedException();
+            }
+            //Open the session server 
+            await this.SessionServerSettings.OnOpenAsync(ServiceDefaults.OpenTimeout);
+
+            // TODO: MUST add the proper messsage
+            if (this.SecurityAuthChannelDispatcher == null)
+                throw new Exception("SecurityAuthChannelDispatcher can't be null");
+
+            ServiceDispatcher securitySessionAuthDispatcher = new ServiceDispatcher(this.SecurityAuthChannelDispatcher);
+            var channelHandler = new ChannelHandler(Binding.MessageVersion, binder, securityChannel.GetProperty<ServiceThrottle>(),
+            securitySessionAuthDispatcher, /*wasChannelThrottled*/ false, sessionIdleManager);
+            var channelDispatcher = channelHandler.GetDispatcher();
+            outerChannel.ChannelDispatcher = securityChannel.ChannelDispatcher = channelDispatcher;
+            await channelHandler.OpenAsync();
+            return channelDispatcher;
+        }
+
+        private IChannel GetInnerChannel(IChannel outerChannel)
+        {
+            IChannel securityChannel = null;
+            /* TODO once we add more features
+            if (outerChannel is IInputChannel)
+            {
+                securityChannel = new SecurityInputChannel(listener, (IInputChannel)innerChannel, securityProtocol, listener.settingsLifetimeManager);
+            }
+            else if (outerChannel is IInputSessionChannel))
+            {
+                securityChannel = new SecurityInputSessionChannel(listener, (IInputSessionChannel)innerChannel, securityProtocol, listener.settingsLifetimeManager);
+            }
+            else if (outerChannel is IDuplexChannel))
+            {
+                securityChannel = new SecurityDuplexChannel(listener, (IDuplexChannel)innerChannel, securityProtocol, listener.settingsLifetimeManager);
+            }
+            else if (outerChannel is IDuplexSessionChannel))
+            {
+                securityChannel = new SecurityDuplexSessionChannel(listener, (IDuplexSessionChannel)innerChannel, securityProtocol, listener.settingsLifetimeManager);
+            }
+            else*/
+            if (outerChannel is IReplyChannel)
+            {
+                securityChannel = new SecurityReplyChannel(this, (IReplyChannel)outerChannel);
+            }
+            /* else if (listener.SupportsRequestReply && typeof(TChannel) == typeof(IReplySessionChannel))
+             {
+                 securityChannel = new SecurityReplySessionChannel(listener, (IReplySessionChannel)innerChannel, securityProtocol, listener.settingsLifetimeManager);
+             }
+             else
+             {
+                 throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new NotSupportedException(SR.GetString(SR.UnsupportedChannelInterfaceType, typeof(TChannel))));
+             }*/
+
+             return (IChannel)securityChannel;
+        }
+
+    }
+
+   abstract class ServerSecurityChannel<UChannel>  where UChannel : class, IChannel
+    {
+        static MessageFault secureConversationCloseNotSupportedFault;
+        string secureConversationCloseAction;
+        SecurityListenerSettingsLifetimeManager settingsLifetimeManager;
+        bool hasSecurityStateReference;
+
+        internal SecurityProtocol SecurityProtocol { get;  set; }
+        public IReplyChannel OuterChannel { get; private set; }
+
+        protected ServerSecurityChannel( IReplyChannel outerChannel)
+            //: base(channelManager, innerChannel, securityProtocol) // not sure use of channel manager at this time
+        {
+            this.OuterChannel = outerChannel;
+        }
+
+
+        static MessageFault GetSecureConversationCloseNotSupportedFault()
+        {
+            if (secureConversationCloseNotSupportedFault == null)
+            {
+                FaultCode faultCode = FaultCode.CreateSenderFaultCode(DotNetSecurityStrings.SecureConversationCancelNotAllowedFault, DotNetSecurityStrings.Namespace);
+                FaultReason faultReason = new FaultReason(SR.Format(SR.SecureConversationCancelNotAllowedFaultReason), System.Globalization.CultureInfo.InvariantCulture);
+                secureConversationCloseNotSupportedFault = MessageFault.CreateFault(faultCode, faultReason);
+            }
+            return secureConversationCloseNotSupportedFault;
+        }
+
+        void ThrowIfSecureConversationCloseMessage(Message message)
+        {
+            if (message.Headers.Action == this.secureConversationCloseAction)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new MessageSecurityException(SR.Format(SR.SecureConversationCancelNotAllowedFaultReason), null, GetSecureConversationCloseNotSupportedFault()));
+            }
+        }
+       
+        [SecuritySafeCritical]
+        internal SecurityProtocolCorrelationState VerifyIncomingMessage(ref Message message, TimeSpan timeout, params SecurityProtocolCorrelationState[] correlationState)
+        {
+            if (message == null)
+            {
+                return null;
+            }
+            if (this.SecurityProtocol == null)
+                throw new Exception("SecurityProtocol is null");
+            ThrowIfSecureConversationCloseMessage(message);
+           // using (this.ApplyHostingIntegrationContext(message))
+           // {
+                return this.SecurityProtocol.VerifyIncomingMessage(ref message, timeout, correlationState);
+           // }
+        }
+
+
+        [SecuritySafeCritical]
+        internal void VerifyIncomingMessage(ref Message message, TimeSpan timeout)
+        {
+            if (message == null)
+            {
+                return;
+            }
+            ThrowIfSecureConversationCloseMessage(message);
+           // using (this.ApplyHostingIntegrationContext(message))
+           // {
+                this.SecurityProtocol.VerifyIncomingMessage(ref message, timeout);
+           // }
+        }
+    }
+    class SecurityReplyChannel : ServerSecurityChannel<IReplyChannel>, IReplyChannel
+    {
+        bool sendUnsecuredFaults;
+        internal static readonly SecurityStandardsManager defaultStandardsManager = SecurityStandardsManager.DefaultInstance;
+
+        public SecurityReplyChannel(SecurityServiceDispatcher securityDispatcher, IReplyChannel outerChannel)
+            : base(outerChannel)
+        {
+            this.SecurityServiceDispatcher = securityDispatcher;
+        }
+
+        public EndpointAddress LocalAddress => throw new NotImplementedException();
+
+        public IServiceChannelDispatcher ChannelDispatcher { get; set; }
+
+        public SecurityServiceDispatcher SecurityServiceDispatcher { get; }
+        public CommunicationState State => this.OuterChannel.State;
+       
+        public virtual XmlDictionaryString RenewAction
+        {
+            get
+            {
+                return defaultStandardsManager.SecureConversationDriver.RenewAction;
+            }
+        }
+
+        public virtual XmlDictionaryString IssueAction
+        {
+            get
+            {
+                return defaultStandardsManager.SecureConversationDriver.IssueAction;
+            }
+        }
+
+        public event EventHandler Closed;
+        public event EventHandler Closing;
+        public event EventHandler Faulted;
+        public event EventHandler Opened;
+        public event EventHandler Opening;
+
+        public void Abort()
+        {
+            
+        }
+
+        public Task CloseAsync()
+        {
+           return Task.CompletedTask;
+        }
+
+        public Task CloseAsync(CancellationToken token)
+        {
+            return Task.CompletedTask;
+        }
+
+        public T GetProperty<T>() where T : class
+        {
+            return this.OuterChannel.GetProperty<T>();
+        }
+
+        public Task OpenAsync()
+        {
+            BuildResponderSecurityProtocol<SecurityReplyChannel>();
+            return Task.CompletedTask;
+        }
+
+       // internal IChannelListener<TChannel> BuildResponderChannelListener<TChannel>(BindingContext context)
+        //   where TChannel : class, IChannel
+        //Keeping above signature for future reference. Flattening out the Listner and sticking to push model
+        internal void BuildResponderSecurityProtocol<TChannel>() 
+        {
+            SecuritySessionSecurityTokenAuthenticator authenticator = 
+                (SecuritySessionSecurityTokenAuthenticator) this.SecurityServiceDispatcher
+                .SessionServerSettings.SessionTokenAuthenticator;
+             BindingContext issuerBindingContext = authenticator.IssuerBindingContext; 
+            SecurityBindingElement bootStrapSecurity = authenticator.BootstrapSecurityBindingElement;
+
+            SecurityCredentialsManager securityCredentials = issuerBindingContext.BindingParameters.Find<SecurityCredentialsManager>();
+            if (securityCredentials == null)
+            {
+                securityCredentials = ServiceCredentials.CreateDefaultCredentials();
+            }
+            bootStrapSecurity.ReaderQuotas 
+                = issuerBindingContext.GetInnerProperty<XmlDictionaryReaderQuotas>();
+            if (bootStrapSecurity.ReaderQuotas == null)
+            {
+                bootStrapSecurity.ReaderQuotas = XmlDictionaryReaderQuotas.Max;
+                //throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.EncodingBindingElementDoesNotHandleReaderQuotas)));
+            }
+
+            TransportBindingElement transportBindingElement = issuerBindingContext.RemainingBindingElements.Find<TransportBindingElement>();
+            if (transportBindingElement != null)
+                bootStrapSecurity.MaxReceivedMessageSize 
+                    = transportBindingElement.MaxReceivedMessageSize;
+
+            SecurityProtocolFactory bootstrapSecurityProtocolFactory = bootStrapSecurity.
+                CreateSecurityProtocolFactory<TChannel>(issuerBindingContext.Clone(), 
+                securityCredentials, true, issuerBindingContext.Clone());
+            //TODO : Message security
+            //if (bootstrapSecurityProtocolFactory is MessageSecurityProtocolFactory)
+            //{
+            //    MessageSecurityProtocolFactory soapBindingFactory = (MessageSecurityProtocolFactory)bootstrapSecurityProtocolFactory;
+            //    soapBindingFactory.ApplyConfidentiality = soapBindingFactory.ApplyIntegrity
+            //    = soapBindingFactory.RequireConfidentiality = soapBindingFactory.RequireIntegrity = true;
+
+            //    soapBindingFactory.ProtectionRequirements.IncomingSignatureParts.ChannelParts.IsBodyIncluded = true;
+            //    soapBindingFactory.ProtectionRequirements.OutgoingSignatureParts.ChannelParts.IsBodyIncluded = true;
+
+            //    MessagePartSpecification bodyPart = new MessagePartSpecification(true);
+            //    soapBindingFactory.ProtectionRequirements.OutgoingSignatureParts.AddParts(bodyPart, this.IssueResponseAction);
+            //    soapBindingFactory.ProtectionRequirements.OutgoingEncryptionParts.AddParts(bodyPart, this.IssueResponseAction);
+            //    soapBindingFactory.ProtectionRequirements.OutgoingSignatureParts.AddParts(bodyPart, this.RenewResponseAction);
+            //    soapBindingFactory.ProtectionRequirements.OutgoingEncryptionParts.AddParts(bodyPart, this.RenewResponseAction);
+
+            //    soapBindingFactory.ProtectionRequirements.IncomingSignatureParts.AddParts(bodyPart, this.IssueAction);
+            //    soapBindingFactory.ProtectionRequirements.IncomingEncryptionParts.AddParts(bodyPart, this.IssueAction);
+            //    soapBindingFactory.ProtectionRequirements.IncomingSignatureParts.AddParts(bodyPart, this.RenewAction);
+            //    soapBindingFactory.ProtectionRequirements.IncomingEncryptionParts.AddParts(bodyPart, this.RenewAction);
+            //}
+
+            //TODO renew part
+            //SupportingTokenParameters renewSupportingTokenParameters = new SupportingTokenParameters();
+            //SecurityContextSecurityTokenParameters sctParameters = new SecurityContextSecurityTokenParameters();
+            //if (bootStrapSecurity.EndpointSupportingTokenParameters.Endorsing.Count > 0)
+            //{
+            //    SecureConversationSecurityTokenParameters scParametersTemp = bootStrapSecurity.EndpointSupportingTokenParameters.Endorsing[0] as SecureConversationSecurityTokenParameters;
+            //    sctParameters.RequireDerivedKeys = scParametersTemp.RequireDerivedKeys;
+            //}
+            //renewSupportingTokenParameters.Endorsing.Add(sctParameters);
+           // bootstrapSecurityProtocolFactory.SecurityBindingElement.OperationSupportingTokenParameters.Add(this.RenewAction.Value, renewSupportingTokenParameters);
+            // bootstrapSecurityProtocolFactory.SecurityTokenManager = new SessionRenewSecurityTokenManager(bootstrapSecurityProtocolFactory.SecurityTokenManager, this.sessionTokenAuthenticator, (SecurityTokenResolver)this.IssuedTokenCache);
+            //SecurityChannelListener<TChannel> securityChannelListener = new SecurityChannelListener<TChannel>(
+            //    this.bootstrapSecurityBindingElement, this.IssuerBindingContext);
+            //securityChannelListener.SecurityProtocolFactory = bootstrapSecurityProtocolFactory;
+            //securityChannelListener.SendUnsecuredFaults = !SecurityUtils.IsCompositeDuplexBinding(context);
+
+            //ChannelBuilder channelBuilder = new ChannelBuilder(context, true);
+            //securityChannelListener.InitializeListener(channelBuilder);
+            //this.shouldMatchRstWithEndpointFilter = SecurityUtils.ShouldMatchRstWithEndpointFilter(this.bootstrapSecurityBindingElement);
+            //return securityChannelListener;
+            bootstrapSecurityProtocolFactory.OpenAsync(TimeSpan.Zero);
+            base.SecurityProtocol = bootstrapSecurityProtocolFactory.CreateSecurityProtocol(
+                    null,
+                    null,null,
+                    true, TimeSpan.Zero);
+
+        }
+
+        public Task OpenAsync(CancellationToken token)
+        {
+            return Task.CompletedTask;
+        }
+
+        internal RequestContext ProcessReceivedRequest(RequestContext requestContext)
+        {
+            if (requestContext == null)
+            {
+                return null;
+            }
+            Exception securityException = null;
+            TimeSpan timeout = ServiceDefaults.ReceiveTimeout;
+            Message message = requestContext.RequestMessage;
+            TimeoutHelper timeoutHelper = new TimeoutHelper(timeout);
+            if (message == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new CommunicationException(SR.Format(SR.ReceivedMessageInRequestContextNull)));
+            }
+            try
+            {
+                SecurityProtocolCorrelationState correlationState = this.VerifyIncomingMessage(ref message, timeoutHelper.RemainingTime(), null);
+               //TODO check with MS
+                if(message.Headers.RelatesTo == null && message.Headers.MessageId !=null)
+                {
+                    message.Headers.RelatesTo = message.Headers.MessageId;
+                }
+                return new SecurityRequestContext(message, requestContext, this.SecurityProtocol, correlationState, ServiceDefaults.SendTimeout, ServiceDefaults.CloseTimeout);
+            }
+            catch (Exception e)
+            {
+                securityException = e;
+                SendFaultIfRequired(securityException, requestContext, timeoutHelper.RemainingTime());
+                throw securityException;
+            }
+
+        }
+
+        void SendFaultIfRequired(Exception e, RequestContext innerContext, TimeSpan timeout)
+        {
+            if (!sendUnsecuredFaults)
+            {
+                return;
+            }
+            MessageFault fault = SecurityUtils.CreateSecurityMessageFault(e, this.SecurityProtocol.SecurityProtocolFactory.StandardsManager);
+            if (fault == null)
+            {
+                return;
+            }
+            Message requestMessage = innerContext.RequestMessage;
+            Message faultMessage = Message.CreateMessage(requestMessage.Version, fault, requestMessage.Version.Addressing.DefaultFaultAction);
+            try
+            {
+                TimeoutHelper timeoutHelper = new TimeoutHelper(timeout);
+                innerContext.ReplyAsync(faultMessage);
+                innerContext.CloseAsync(timeoutHelper.GetCancellationToken());
+            }
+#pragma warning suppress 56500 // covered by FxCOP
+            catch (Exception ex)
+            {
+                if (Fx.IsFatal(ex))
+                {
+                    throw;
+                }
+
+                // eat up exceptions
+            }
+            finally
+            {
+                faultMessage.Close();
+                innerContext.Abort();
+            }
+        }
+    }
+
+    sealed class SecurityRequestContext : RequestContextBase
+    {
+        readonly RequestContext innerContext;
+        readonly SecurityProtocol securityProtocol;
+        readonly SecurityProtocolCorrelationState correlationState;
+
+        public SecurityRequestContext(Message requestMessage, RequestContext innerContext,
+            SecurityProtocol securityProtocol, SecurityProtocolCorrelationState correlationState,
+            TimeSpan defaultSendTimeout, TimeSpan defaultCloseTimeout)
+            : base(requestMessage, defaultCloseTimeout, defaultSendTimeout)
+        {
+            this.innerContext = innerContext;
+            this.securityProtocol = securityProtocol;
+            this.correlationState = correlationState;
+        }
+
+        protected override void OnAbort()
+        {
+            this.innerContext.Abort();
+        }
+
+        protected override Task OnCloseAsync(CancellationToken token)
+        {
+            return this.innerContext.CloseAsync(token);
+        }
+
+        protected override Task OnReplyAsync(Message message, CancellationToken token)
+        {
+            if (message != null)
+            {
+             Task<Message> appLiedMessage =  this.securityProtocol.SecureOutgoingMessageAsync(message, token);
+                return this.innerContext.ReplyAsync(appLiedMessage.GetAwaiter().GetResult(),token);
+            }else
+            {
+              return  Task.CompletedTask;
+            }
+        }
+
+        
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Dispatcher/ServiceDispatcher.cs b/src/CoreWCF.Primitives/src/CoreWCF/Dispatcher/ServiceDispatcher.cs
index dd2c259..b5dc5c1 100644
--- a/src/CoreWCF.Primitives/src/CoreWCF/Dispatcher/ServiceDispatcher.cs
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Dispatcher/ServiceDispatcher.cs
@@ -26,10 +26,11 @@ namespace CoreWCF.Dispatcher
         public Binding Binding => ChannelDispatcher.Binding;
 
         public ChannelDispatcher ChannelDispatcher { get; }
+        public ServiceHostBase Host { get { return ChannelDispatcher.Host; } }
 
         public EndpointDispatcherTable Endpoints => ChannelDispatcher.EndpointDispatcherTable;
 
-        public ICollection<Type> SupportedChannelTypes => ChannelDispatcher.SupportedChannelTypes;
+        public IList<Type> SupportedChannelTypes => ChannelDispatcher.SupportedChannelTypes;
 
         public object ThisLock { get; } = new object();
 
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/CanonicalizationDriver.cs b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/CanonicalizationDriver.cs
new file mode 100644
index 0000000..c6cd0d9
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/CanonicalizationDriver.cs
@@ -0,0 +1,141 @@
+﻿using System.Collections;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.IO;
+using System.Security.Cryptography;
+using System.Text;
+using System.Xml;
+using System;
+
+namespace CoreWCF.IdentityModel
+{
+    sealed class CanonicalizationDriver
+    {
+        bool closeReadersAfterProcessing;
+        XmlReader reader;
+        string[] inclusivePrefixes;
+        bool includeComments;
+
+        public bool CloseReadersAfterProcessing
+        {
+            get { return this.closeReadersAfterProcessing; }
+            set { this.closeReadersAfterProcessing = value; }
+        }
+
+        public bool IncludeComments
+        {
+            get { return this.includeComments; }
+            set { this.includeComments = value; }
+        }
+
+        public string[] GetInclusivePrefixes()
+        {
+            return this.inclusivePrefixes;
+        }
+
+        public void Reset()
+        {
+            this.reader = null;
+        }
+
+        public void SetInclusivePrefixes(string[] inclusivePrefixes)
+        {
+            this.inclusivePrefixes = inclusivePrefixes;
+        }
+
+        public void SetInput(Stream stream)
+        {
+            if (stream == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("stream");
+            }
+            this.reader = XmlReader.Create(stream);
+        }
+
+        public void SetInput(XmlReader reader)
+        {
+            if (reader == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("reader");
+            }
+            this.reader = reader;
+        }
+
+        public byte[] GetBytes()
+        {
+            return GetMemoryStream().ToArray();
+        }
+
+        public MemoryStream GetMemoryStream()
+        {
+            MemoryStream stream = new MemoryStream();
+            WriteTo(stream);
+            stream.Seek(0, SeekOrigin.Begin);
+            return stream;
+        }
+
+        public void WriteTo(HashAlgorithm hashAlgorithm)
+        {
+            WriteTo(new HashStream(hashAlgorithm));
+        }
+
+        public void WriteTo(Stream canonicalStream)
+        {
+            if (this.reader != null)
+            {
+                XmlDictionaryReader dicReader = this.reader as XmlDictionaryReader;
+                if ((dicReader != null) && (dicReader.CanCanonicalize))
+                {
+                    dicReader.MoveToContent();
+                    dicReader.StartCanonicalization(canonicalStream, this.includeComments, this.inclusivePrefixes);
+                    dicReader.Skip();
+                    dicReader.EndCanonicalization();
+                }
+                else
+                {
+                    XmlDictionaryWriter writer = XmlDictionaryWriter.CreateTextWriter(Stream.Null);
+                    if (this.inclusivePrefixes != null)
+                    {
+                        // Add a dummy element at the top and populate the namespace 
+                        // declaration of all the inclusive prefixes.
+                        writer.WriteStartElement("a", reader.LookupNamespace(String.Empty));
+                        for (int i = 0; i < this.inclusivePrefixes.Length; ++i)
+                        {
+                            string ns = reader.LookupNamespace(this.inclusivePrefixes[i]);
+                            if (ns != null)
+                            {
+                                writer.WriteXmlnsAttribute(this.inclusivePrefixes[i], ns);
+                            }
+                        }
+                    }
+                    writer.StartCanonicalization(canonicalStream, this.includeComments, this.inclusivePrefixes);
+                    //if (reader is WrappedReader)
+                    //{
+                    //    ((WrappedReader)reader).XmlTokens.GetWriter().WriteTo(writer, new DictionaryManager());
+                    //}
+                    //else
+                    //{
+
+                        writer.WriteNode(reader, false);
+                  //  }
+                    writer.Flush();
+                    writer.EndCanonicalization();
+
+                    if (this.inclusivePrefixes != null)
+                        writer.WriteEndElement();
+
+                    writer.Close();
+                }
+                if (this.closeReadersAfterProcessing)
+                {
+                    this.reader.Close();
+                }
+                this.reader = null;
+            }
+            else
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format("NoInputIsSetForCanonicalization")));
+            }
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/CryptoHelper.cs b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/CryptoHelper.cs
new file mode 100644
index 0000000..d78f2bf
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/CryptoHelper.cs
@@ -0,0 +1,443 @@
+using System.Collections.Generic;
+using CoreWCF.IdentityModel.Tokens;
+using System.Reflection;
+using System.Security.Cryptography;
+using CoreWCF;
+using System;
+using Linq = System.Linq;
+
+
+namespace CoreWCF.IdentityModel
+{
+    internal static class CryptoHelper
+    {
+        private static RandomNumberGenerator s_random;
+        private const string SHAString = "SHA";
+        private const string SHA1String = "SHA1";
+        private const string SHA256String = "SHA256";
+        private const string SystemSecurityCryptographySha1String = "System.Security.Cryptography.SHA1";
+        static byte[] emptyBuffer;
+
+        private static Dictionary<string, Func<object>> s_algorithmDelegateDictionary = new Dictionary<string, Func<object>>();
+        private static object s_algorithmDictionaryLock = new object();
+
+        internal static byte[] EmptyBuffer
+        {
+            get
+            {
+                if (emptyBuffer == null)
+                {
+                    byte[] tmp = new byte[0];
+                    emptyBuffer = tmp;
+                }
+                return emptyBuffer;
+            }
+        }
+        public static bool FixedTimeEquals(byte[] a, byte[] b)
+        {
+            if (a == null && b == null)
+            {
+                return true;
+            }
+            else if (a == null || b == null)
+            {
+                return false;
+            }
+            else if (a.Length != b.Length)
+            {
+                return false;
+            }
+
+            var result = 0;
+            var length = a.Length;
+
+            for (int i = 0; i < length; i++)
+            {
+                result |= a[i] ^ b[i];
+            }
+
+            return result == 0;
+        }
+
+        internal static bool IsSymmetricAlgorithm(string algorithm)
+        {
+            throw new PlatformNotSupportedException();
+        }
+
+        internal static byte[] UnwrapKey(byte[] wrappingKey, byte[] wrappedKey, string algorithm)
+        {
+            throw new PlatformNotSupportedException();
+        }
+
+        internal static byte[] WrapKey(byte[] wrappingKey, byte[] keyToBeWrapped, string algorithm)
+        {
+            throw new PlatformNotSupportedException();
+        }
+
+        internal static byte[] GenerateDerivedKey(byte[] key, string algorithm, byte[] label, byte[] nonce, int derivedKeySize, int position)
+        {
+            throw new PlatformNotSupportedException();
+        }
+
+        internal static int GetIVSize(string algorithm)
+        {
+            throw new PlatformNotSupportedException();
+        }
+
+        internal static ICryptoTransform CreateDecryptor(byte[] key, byte[] iv, string algorithm)
+        {
+            throw new PlatformNotSupportedException();
+        }
+
+        internal static ICryptoTransform CreateEncryptor(byte[] key, byte[] iv, string algorithm)
+        {
+            throw new PlatformNotSupportedException();
+        }
+
+        internal static KeyedHashAlgorithm CreateKeyedHashAlgorithm(byte[] key, string algorithm)
+        {
+            object algorithmObject = GetAlgorithmFromConfig(algorithm);
+
+            if (algorithmObject != null)
+            {
+                KeyedHashAlgorithm keyedHashAlgorithm = algorithmObject as KeyedHashAlgorithm;
+                if (keyedHashAlgorithm != null)
+                {
+                    keyedHashAlgorithm.Key = key;
+                    return keyedHashAlgorithm;
+                }
+
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new InvalidOperationException(SR.Format("CustomCryptoAlgorithmIsNotValidKeyedHashAlgorithm", algorithm)));
+            }
+
+            switch (algorithm)
+            {
+                case SecurityAlgorithms.HmacSha1Signature:
+#pragma warning disable CA5350 // Do not use insecure cryptographic algorithm SHA1.
+                    return new HMACSHA1(key);
+#pragma warning restore CA5350 // Do not use insecure cryptographic algorithm SHA1.
+                case SecurityAlgorithms.HmacSha256Signature:
+                    return new HMACSHA256(key);
+                default:
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new InvalidOperationException(SR.Format(SR.UnsupportedCryptoAlgorithm, algorithm)));
+            }
+        }
+
+        internal static SymmetricAlgorithm GetSymmetricAlgorithm(byte[] key, string algorithm)
+        {
+            throw new PlatformNotSupportedException();
+        }
+
+        internal static bool IsAsymmetricAlgorithm(string algorithm)
+        {
+            throw new PlatformNotSupportedException();
+        }
+
+        internal static bool IsSymmetricSupportedAlgorithm(string algorithm, int keySize)
+        {
+            bool found = false;
+            object algorithmObject = null;
+
+            try
+            {
+                algorithmObject = GetAlgorithmFromConfig(algorithm);
+            }
+            catch (InvalidOperationException)
+            {
+                // We swallow the exception and continue.
+            }
+            if (algorithmObject != null)
+            {
+                SymmetricAlgorithm symmetricAlgorithm = algorithmObject as SymmetricAlgorithm;
+                KeyedHashAlgorithm keyedHashAlgorithm = algorithmObject as KeyedHashAlgorithm;
+
+                if (symmetricAlgorithm != null || keyedHashAlgorithm != null)
+                {
+                    found = true;
+                }
+                // The reason we do not return here even when the user has provided a custom algorithm to CryptoConfig 
+                // is because we need to check if the user has overwritten an existing standard URI.
+            }
+
+            switch (algorithm)
+            {
+                case SecurityAlgorithms.DsaSha1Signature:
+                case SecurityAlgorithms.RsaSha1Signature:
+                case SecurityAlgorithms.RsaSha256Signature:
+                case SecurityAlgorithms.RsaOaepKeyWrap:
+                case SecurityAlgorithms.RsaV15KeyWrap:
+                    return false;
+                case SecurityAlgorithms.HmacSha1Signature:
+                case SecurityAlgorithms.HmacSha256Signature:
+                case SecurityAlgorithms.Psha1KeyDerivation:
+                case SecurityAlgorithms.Psha1KeyDerivationDec2005:
+                    return true;
+                case SecurityAlgorithms.Aes128Encryption:
+                case SecurityAlgorithms.Aes128KeyWrap:
+                    return keySize >= 128 && keySize <= 256;
+                case SecurityAlgorithms.Aes192Encryption:
+                case SecurityAlgorithms.Aes192KeyWrap:
+                    return keySize >= 192 && keySize <= 256;
+                case SecurityAlgorithms.Aes256Encryption:
+                case SecurityAlgorithms.Aes256KeyWrap:
+                    return keySize == 256;
+                case SecurityAlgorithms.TripleDesEncryption:
+                case SecurityAlgorithms.TripleDesKeyWrap:
+                    return keySize == 128 || keySize == 192;
+                default:
+                    if (found)
+                    {
+                        return true;
+                    }
+
+                    return false;
+                    // We do not expect the user to map the uri of an existing standrad algorithm with say key size 128 bit 
+                    // to a custom algorithm with keySize 192 bits. If he does that, we anyways make sure that we return false.
+            }
+        }
+
+        internal static void FillRandomBytes(byte[] buffer)
+        {
+            RandomNumberGenerator.GetBytes(buffer);
+        }
+
+        /// <summary>
+        /// This generates the entropy using random number. This is usually used on the sending 
+        /// side to generate the requestor's entropy.
+        /// </summary>
+        /// <param name="data">The array to fill with cryptographically strong random nonzero bytes.</param>
+        public static void GenerateRandomBytes(byte[] data)
+        {
+            RandomNumberGenerator.GetNonZeroBytes(data);
+        }
+
+        /// <summary>
+        /// This method generates a random byte array used as entropy with the given size. 
+        /// </summary>
+        /// <param name="sizeInBits"></param>
+        /// <returns></returns>
+        public static byte[] GenerateRandomBytes(int sizeInBits)
+        {
+            int sizeInBytes = sizeInBits / 8;
+            if (sizeInBits <= 0)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(sizeInBits), SR.Format("ID6033", sizeInBits)));
+            }
+            else if (sizeInBytes * 8 != sizeInBits)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format("ID6002", sizeInBits), nameof(sizeInBits)));
+            }
+
+            byte[] data = new byte[sizeInBytes];
+            GenerateRandomBytes(data);
+
+            return data;
+        }
+
+        internal static RandomNumberGenerator RandomNumberGenerator
+        {
+            get
+            {
+                if (s_random == null)
+                {
+                    s_random = RandomNumberGenerator.Create();
+                }
+                return s_random;
+            }
+        }
+
+        internal static HashAlgorithm CreateHashAlgorithm(string algorithm)
+        {
+            object algorithmObject = GetAlgorithmFromConfig(algorithm);
+
+            if (algorithmObject != null)
+            {
+                HashAlgorithm hashAlgorithm = algorithmObject as HashAlgorithm;
+                if (hashAlgorithm != null)
+                {
+                    return hashAlgorithm;
+                }
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new InvalidOperationException(SR.Format(SR.CustomCryptoAlgorithmIsNotValidHashAlgorithm, algorithm)));
+            }
+
+            switch (algorithm)
+            {
+                case SHAString:
+                case SHA1String:
+                case SystemSecurityCryptographySha1String:
+                case SecurityAlgorithms.Sha1Digest:
+#pragma warning disable CA5350 // Do not use insecure cryptographic algorithm SHA1.
+                    return SHA1.Create();
+#pragma warning restore CA5350 // Do not use insecure cryptographic algorithm SHA1.
+                case SHA256String:
+                case SecurityAlgorithms.Sha256Digest:
+                    return SHA256.Create();
+                default:
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new InvalidOperationException(SR.Format(SR.UnsupportedCryptoAlgorithm, algorithm)));
+            }
+        }
+
+        private static object GetDefaultAlgorithm(string algorithm)
+        {
+            if (string.IsNullOrEmpty(algorithm))
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException(nameof(algorithm)));
+            }
+
+            switch (algorithm)
+            {
+                //case SecurityAlgorithms.RsaSha1Signature:
+                //case SecurityAlgorithms.DsaSha1Signature:
+                // For these algorithms above, crypto config returns internal objects.
+                // As we cannot create those internal objects, we are returning null.
+                // If no custom algorithm is plugged-in, at least these two algorithms
+                // will be inside the delegate dictionary.
+                case SecurityAlgorithms.Sha1Digest:
+#pragma warning disable CA5350 // Do not use insecure cryptographic algorithm SHA1.
+                    return SHA1.Create();
+#pragma warning restore CA5350 // Do not use insecure cryptographic algorithm SHA1.
+                case SecurityAlgorithms.ExclusiveC14n:
+                    throw new PlatformNotSupportedException();
+                case SHA256String:
+                case SecurityAlgorithms.Sha256Digest:
+                    return SHA256.Create();
+                case SecurityAlgorithms.Sha512Digest:
+                    return SHA512.Create();
+                case SecurityAlgorithms.Aes128Encryption:
+                case SecurityAlgorithms.Aes192Encryption:
+                case SecurityAlgorithms.Aes256Encryption:
+                case SecurityAlgorithms.Aes128KeyWrap:
+                case SecurityAlgorithms.Aes192KeyWrap:
+                case SecurityAlgorithms.Aes256KeyWrap:
+                    return Aes.Create();
+                case SecurityAlgorithms.TripleDesEncryption:
+                case SecurityAlgorithms.TripleDesKeyWrap:
+#pragma warning disable CA5350 // Do Not Use Weak Cryptographic Algorithms
+                    return TripleDES.Create();
+#pragma warning restore CA5350 // Do Not Use Weak Cryptographic Algorithms
+                case SecurityAlgorithms.HmacSha1Signature:
+#pragma warning disable CA5350 // Do not use insecure cryptographic algorithm SHA1.
+                    return new HMACSHA1();
+#pragma warning restore CA5350 // Do not use insecure cryptographic algorithm SHA1.
+                case SecurityAlgorithms.HmacSha256Signature:
+                    return new HMACSHA256();
+                case SecurityAlgorithms.ExclusiveC14nWithComments:
+                    throw new PlatformNotSupportedException();
+                case SecurityAlgorithms.Ripemd160Digest:
+                    return null;
+                case SecurityAlgorithms.DesEncryption:
+#pragma warning disable CA5351 // Do Not Use Broken Cryptographic Algorithms
+                    return DES.Create();
+#pragma warning restore CA5351 // Do Not Use Broken Cryptographic Algorithms
+                default:
+                    return null;
+            }
+        }
+
+
+        internal static object GetAlgorithmFromConfig(string algorithm)
+        {
+            if (string.IsNullOrEmpty(algorithm))
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException(nameof(algorithm)));
+            }
+
+            object algorithmObject = null;
+            object defaultObject = null;
+            Func<object> delegateFunction = null;
+
+            if (!s_algorithmDelegateDictionary.TryGetValue(algorithm, out delegateFunction))
+            {
+                lock (s_algorithmDictionaryLock)
+                {
+                    if (!s_algorithmDelegateDictionary.ContainsKey(algorithm))
+                    {
+                        try
+                        {
+                            algorithmObject = CryptoConfig.CreateFromName(algorithm);
+                        }
+                        catch (TargetInvocationException)
+                        {
+                            s_algorithmDelegateDictionary[algorithm] = null;
+                        }
+
+                        if (algorithmObject == null)
+                        {
+                            s_algorithmDelegateDictionary[algorithm] = null;
+                        }
+                        else
+                        {
+                            defaultObject = GetDefaultAlgorithm(algorithm);
+                            if (defaultObject != null && defaultObject.GetType() == algorithmObject.GetType())
+                            {
+                                s_algorithmDelegateDictionary[algorithm] = null;
+                            }
+                            else
+                            {
+                                // Create a factory delegate which returns new instances of the algorithm type for later calls.
+                                Type algorithmType = algorithmObject.GetType();
+                                System.Linq.Expressions.NewExpression algorithmCreationExpression = Linq.Expressions.Expression.New(algorithmType);
+                                Linq.Expressions.LambdaExpression creationFunction = Linq.Expressions.Expression.Lambda<Func<object>>(algorithmCreationExpression);
+                                delegateFunction = creationFunction.Compile() as Func<object>;
+
+                                if (delegateFunction != null)
+                                {
+                                    s_algorithmDelegateDictionary[algorithm] = delegateFunction;
+                                }
+                                return algorithmObject;
+                            }
+                        }
+                    }
+                }
+            }
+            else
+            {
+                if (delegateFunction != null)
+                {
+                    return delegateFunction.Invoke();
+                }
+            }
+
+            //
+            // This is a fallback in case CryptoConfig fails to return a valid
+            // algorithm object. CrytoConfig does not understand all the uri's and
+            // can return a null in that case, in which case it is our responsibility
+            // to fallback and create the right algorithm if it is a uri we understand
+            //
+            switch (algorithm)
+            {
+                case SHA256String:
+                case SecurityAlgorithms.Sha256Digest:
+                    return SHA256.Create();
+                case SecurityAlgorithms.Sha1Digest:
+#pragma warning disable CA5350 // Do not use insecure cryptographic algorithm SHA1.
+                    return SHA1.Create();
+#pragma warning restore CA5350 // Do not use insecure cryptographic algorithm SHA1.
+                case SecurityAlgorithms.HmacSha1Signature:
+#pragma warning disable CA5350 // Do not use insecure cryptographic algorithm SHA1.
+                    return new HMACSHA1();
+#pragma warning restore CA5350 // Do not use insecure cryptographic algorithm SHA1.
+                default:
+                    break;
+            }
+
+            return null;
+        }
+
+        internal static HashAlgorithm NewSha1HashAlgorithm()
+        {
+            return CreateHashAlgorithm(SecurityAlgorithms.Sha1Digest);
+        }
+
+        internal static HashAlgorithm NewSha256HashAlgorithm()
+        {
+            return CreateHashAlgorithm(SecurityAlgorithms.Sha256Digest);
+        }
+
+        internal static KeyedHashAlgorithm NewHmacSha1KeyedHashAlgorithm(byte[] key)
+        {
+            return CryptoHelper.CreateKeyedHashAlgorithm(key, SecurityAlgorithms.HmacSha1Signature);
+        }
+    }
+}
+
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/DictionaryManager.cs b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/DictionaryManager.cs
new file mode 100644
index 0000000..08b9d96
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/DictionaryManager.cs
@@ -0,0 +1,149 @@
+using System.Xml;
+using System;
+
+namespace CoreWCF.IdentityModel
+{
+    internal class DictionaryManager
+    {
+        private SamlDictionary _samlDictionary;
+        private XmlSignatureDictionary _sigantureDictionary;
+        private UtilityDictionary _utilityDictionary;
+        private ExclusiveC14NDictionary _exclusiveC14NDictionary;
+        private SecurityAlgorithmDec2005Dictionary _securityAlgorithmDec2005Dictionary;
+        private SecurityAlgorithmDictionary _securityAlgorithmDictionary;
+        private SecurityJan2004Dictionary _securityJan2004Dictionary;
+        private SecurityXXX2005Dictionary _securityJanXXX2005Dictionary;
+        private SecureConversationDec2005Dictionary _secureConversationDec2005Dictionary;
+        private SecureConversationFeb2005Dictionary _secureConversationFeb2005Dictionary;
+        private TrustFeb2005Dictionary _trustFeb2005Dictionary;
+        private TrustDec2005Dictionary _trustDec2005Dictionary;
+        private XmlEncryptionDictionary _xmlEncryptionDictionary;
+        private IXmlDictionary _parentDictionary;
+
+        public DictionaryManager()
+        {
+            _samlDictionary = CoreWCF.XD.SamlDictionary;
+            _sigantureDictionary = CoreWCF.XD.XmlSignatureDictionary;
+            _utilityDictionary = CoreWCF.XD.UtilityDictionary;
+            _exclusiveC14NDictionary = CoreWCF.XD.ExclusiveC14NDictionary;
+            _securityAlgorithmDictionary = CoreWCF.XD.SecurityAlgorithmDictionary;
+            _parentDictionary = CoreWCF.XD.Dictionary;
+            _securityJan2004Dictionary = CoreWCF.XD.SecurityJan2004Dictionary;
+            _securityJanXXX2005Dictionary = CoreWCF.XD.SecurityXXX2005Dictionary;
+            _secureConversationFeb2005Dictionary = CoreWCF.XD.SecureConversationFeb2005Dictionary;
+            _trustFeb2005Dictionary = CoreWCF.XD.TrustFeb2005Dictionary;
+            _xmlEncryptionDictionary = CoreWCF.XD.XmlEncryptionDictionary;
+
+            // These 3 are factored into a seperate dictionary in ServiceModel under DXD. 
+            _secureConversationDec2005Dictionary = DXD.SecureConversationDec2005Dictionary;
+            _securityAlgorithmDec2005Dictionary = DXD.SecurityAlgorithmDec2005Dictionary;
+            _trustDec2005Dictionary = DXD.TrustDec2005Dictionary;
+        }
+
+        
+        public DictionaryManager(ServiceModelDictionary parentDictionary)
+        {
+            _samlDictionary = new SamlDictionary(parentDictionary);
+            _sigantureDictionary = new XmlSignatureDictionary(parentDictionary);
+            _utilityDictionary = new UtilityDictionary(parentDictionary);
+            _exclusiveC14NDictionary = new ExclusiveC14NDictionary(parentDictionary);
+            _securityAlgorithmDictionary = new SecurityAlgorithmDictionary(parentDictionary);
+            _securityJan2004Dictionary = new SecurityJan2004Dictionary(parentDictionary);
+            _securityJanXXX2005Dictionary = new SecurityXXX2005Dictionary(parentDictionary);
+            _secureConversationFeb2005Dictionary = new SecureConversationFeb2005Dictionary(parentDictionary);
+            _trustFeb2005Dictionary = new TrustFeb2005Dictionary(parentDictionary);
+            _xmlEncryptionDictionary = new XmlEncryptionDictionary(parentDictionary);
+            _parentDictionary = parentDictionary;
+
+            // These 3 are factored into a seperate dictionary in ServiceModel under DXD. 
+            // ServiceModel should set these seperately using the property setters.
+            _secureConversationDec2005Dictionary = DXD.SecureConversationDec2005Dictionary;
+            _securityAlgorithmDec2005Dictionary = DXD.SecurityAlgorithmDec2005Dictionary;
+            _trustDec2005Dictionary = DXD.TrustDec2005Dictionary;
+        }
+
+        public SamlDictionary SamlDictionary
+        {
+            get { return _samlDictionary; }
+            set { _samlDictionary = value; }
+        }
+
+        public XmlSignatureDictionary XmlSignatureDictionary
+        {
+            get { return _sigantureDictionary; }
+            set { _sigantureDictionary = value; }
+        }
+
+        public UtilityDictionary UtilityDictionary
+        {
+            get { return _utilityDictionary; }
+            set { _utilityDictionary = value; }
+        }
+
+        public ExclusiveC14NDictionary ExclusiveC14NDictionary
+        {
+            get { return _exclusiveC14NDictionary; }
+            set { _exclusiveC14NDictionary = value; }
+        }
+
+        public SecurityAlgorithmDec2005Dictionary SecurityAlgorithmDec2005Dictionary
+        {
+            get { return _securityAlgorithmDec2005Dictionary; }
+            set { _securityAlgorithmDec2005Dictionary = value; }
+        }
+
+        public SecurityAlgorithmDictionary SecurityAlgorithmDictionary
+        {
+            get { return _securityAlgorithmDictionary; }
+            set { _securityAlgorithmDictionary = value; }
+        }
+
+        public SecurityJan2004Dictionary SecurityJan2004Dictionary
+        {
+            get { return _securityJan2004Dictionary; }
+            set { _securityJan2004Dictionary = value; }
+        }
+
+        public SecurityXXX2005Dictionary SecurityJanXXX2005Dictionary
+        {
+            get { return _securityJanXXX2005Dictionary; }
+            set { _securityJanXXX2005Dictionary = value; }
+        }
+
+        public SecureConversationDec2005Dictionary SecureConversationDec2005Dictionary
+        {
+            get { return _secureConversationDec2005Dictionary; }
+            set { _secureConversationDec2005Dictionary = value; }
+        }
+
+        public SecureConversationFeb2005Dictionary SecureConversationFeb2005Dictionary
+        {
+            get { return _secureConversationFeb2005Dictionary; }
+            set { _secureConversationFeb2005Dictionary = value; }
+        }
+
+        public TrustDec2005Dictionary TrustDec2005Dictionary
+        {
+            get { return _trustDec2005Dictionary; }
+            set { _trustDec2005Dictionary = value; }
+        }
+
+        public TrustFeb2005Dictionary TrustFeb2005Dictionary
+        {
+            get { return _trustFeb2005Dictionary; }
+            set { _trustFeb2005Dictionary = value; }
+        }
+
+        public XmlEncryptionDictionary XmlEncryptionDictionary
+        {
+            get { return _xmlEncryptionDictionary; }
+            set { _xmlEncryptionDictionary = value; }
+        }
+
+        public IXmlDictionary ParentDictionary
+        {
+            get { return _parentDictionary; }
+            set { _parentDictionary = value; }
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/EncryptedKeyIdentifierClause.cs b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/EncryptedKeyIdentifierClause.cs
new file mode 100644
index 0000000..acb11eb
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/EncryptedKeyIdentifierClause.cs
@@ -0,0 +1,71 @@
+
+using System;
+using System.Globalization;
+using CoreWCF;
+
+namespace CoreWCF.IdentityModel.Tokens
+{
+    sealed public class EncryptedKeyIdentifierClause : BinaryKeyIdentifierClause
+    {
+        private readonly string _encryptionMethod;
+
+        public EncryptedKeyIdentifierClause(byte[] encryptedKey, string encryptionMethod)
+            : this(encryptedKey, encryptionMethod, null)
+        {
+        }
+
+        public EncryptedKeyIdentifierClause(byte[] encryptedKey, string encryptionMethod, SecurityKeyIdentifier encryptingKeyIdentifier)
+            : this(encryptedKey, encryptionMethod, encryptingKeyIdentifier, null)
+        {
+        }
+
+        public EncryptedKeyIdentifierClause(byte[] encryptedKey, string encryptionMethod, SecurityKeyIdentifier encryptingKeyIdentifier, string carriedKeyName)
+            : this(encryptedKey, encryptionMethod, encryptingKeyIdentifier, carriedKeyName, true, null, 0)
+        {
+        }
+
+        public EncryptedKeyIdentifierClause(byte[] encryptedKey, string encryptionMethod, SecurityKeyIdentifier encryptingKeyIdentifier, string carriedKeyName, byte[] derivationNonce, int derivationLength)
+            : this(encryptedKey, encryptionMethod, encryptingKeyIdentifier, carriedKeyName, true, derivationNonce, derivationLength)
+        {
+        }
+
+        internal EncryptedKeyIdentifierClause(byte[] encryptedKey, string encryptionMethod, SecurityKeyIdentifier encryptingKeyIdentifier, string carriedKeyName, bool cloneBuffer, byte[] derivationNonce, int derivationLength)
+            : base("http://www.w3.org/2001/04/xmlenc#EncryptedKey", encryptedKey, cloneBuffer, derivationNonce, derivationLength)
+        {
+            CarriedKeyName = carriedKeyName;
+            _encryptionMethod = encryptionMethod ?? throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(encryptionMethod));
+            EncryptingKeyIdentifier = encryptingKeyIdentifier;
+        }
+
+        public string CarriedKeyName { get; }
+
+        public SecurityKeyIdentifier EncryptingKeyIdentifier { get; }
+
+        public string EncryptionMethod
+        {
+            get { return _encryptionMethod; }
+        }
+
+        public override bool Matches(SecurityKeyIdentifierClause keyIdentifierClause)
+        {
+            EncryptedKeyIdentifierClause that = keyIdentifierClause as EncryptedKeyIdentifierClause;
+            return ReferenceEquals(this, that) || (that != null && that.Matches(GetRawBuffer(), _encryptionMethod, CarriedKeyName));
+        }
+
+        public bool Matches(byte[] encryptedKey, string encryptionMethod, string carriedKeyName)
+        {
+            return Matches(encryptedKey) && _encryptionMethod == encryptionMethod && CarriedKeyName == carriedKeyName;
+        }
+
+        public byte[] GetEncryptedKey()
+        {
+            return GetBuffer();
+        }
+
+        public override string ToString()
+        {
+            return string.Format(CultureInfo.InvariantCulture, "EncryptedKeyIdentifierClause(EncryptedKey = {0}, Method '{1}')",
+                Convert.ToBase64String(GetRawBuffer()), EncryptionMethod);
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/ExclusiveCanonicalizationTransform.cs b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/ExclusiveCanonicalizationTransform.cs
new file mode 100644
index 0000000..53d872b
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/ExclusiveCanonicalizationTransform.cs
@@ -0,0 +1,265 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Text;
+using System.IO;
+using System.Security.Cryptography;
+using CoreWCF.IdentityModel.Selectors;
+using CoreWCF.IdentityModel.Tokens;
+using System.Text;
+using System.Xml;
+
+namespace CoreWCF.IdentityModel
+{
+    class ExclusiveCanonicalizationTransform : Transform
+    {
+        bool includeComments;
+        string algorithm;
+        string inclusiveNamespacesPrefixList;
+        string[] inclusivePrefixes;
+        string inclusiveListElementPrefix = ExclusiveC14NStrings.Prefix;
+        string prefix = XmlSignatureStrings.Prefix;
+        readonly bool isCanonicalizationMethod;
+
+        public ExclusiveCanonicalizationTransform()
+            : this(false)
+        {
+        }
+
+        public ExclusiveCanonicalizationTransform(bool isCanonicalizationMethod)
+            : this(isCanonicalizationMethod, false)
+        {
+        }
+
+        public ExclusiveCanonicalizationTransform(bool isCanonicalizationMethod, bool includeComments)
+        {
+            this.isCanonicalizationMethod = isCanonicalizationMethod;
+            this.includeComments = includeComments;
+            this.algorithm = includeComments ? CoreWCF.XD.SecurityAlgorithmDictionary.ExclusiveC14nWithComments.Value : CoreWCF.XD.SecurityAlgorithmDictionary.ExclusiveC14n.Value;
+        }
+
+        public override string Algorithm
+        {
+            get
+            {
+                return algorithm;
+            }
+        }
+
+        public bool IncludeComments
+        {
+            get
+            {
+                return this.includeComments;
+            }
+        }
+
+        public string InclusiveNamespacesPrefixList
+        {
+            get
+            {
+                return this.inclusiveNamespacesPrefixList;
+            }
+            set
+            {
+                this.inclusiveNamespacesPrefixList = value;
+                this.inclusivePrefixes = TokenizeInclusivePrefixList(value);
+            }
+        }
+
+        public override bool NeedsInclusiveContext
+        {
+            get { return GetInclusivePrefixes() != null; }
+        }
+
+        public string[] GetInclusivePrefixes()
+        {
+            return this.inclusivePrefixes;
+        }
+
+        CanonicalizationDriver GetConfiguredDriver(SignatureResourcePool resourcePool)
+        {
+            CanonicalizationDriver driver = resourcePool.TakeCanonicalizationDriver();
+            driver.IncludeComments = this.IncludeComments;
+            driver.SetInclusivePrefixes(this.inclusivePrefixes);
+            return driver;
+        }
+
+        // multi-transform case, inefficient path
+        public override object Process(object input, SignatureResourcePool resourcePool, DictionaryManager dictionaryManager)
+        {
+            if (input is XmlReader)
+            {
+                CanonicalizationDriver driver = GetConfiguredDriver(resourcePool);
+                driver.SetInput(input as XmlReader);
+                return driver.GetMemoryStream();
+            }
+            else if (input is ISecurityElement)
+            {
+                MemoryStream stream = new MemoryStream();
+                XmlDictionaryWriter utf8Writer = resourcePool.TakeUtf8Writer();
+                utf8Writer.StartCanonicalization(stream, false, null);
+                (input as ISecurityElement).WriteTo(utf8Writer, dictionaryManager);
+                utf8Writer.EndCanonicalization();
+                stream.Seek(0, SeekOrigin.Begin);
+                return stream;
+            }
+            else
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new NotSupportedException(SR.Format("UnsupportedInputTypeForTransform", input.GetType())));
+            }
+        }
+
+        // common single-transform case; fold directly into a digest
+        public override byte[] ProcessAndDigest(object input, SignatureResourcePool resourcePool, string digestAlgorithm, DictionaryManager dictionaryManager)
+        {
+            HashAlgorithm hash = resourcePool.TakeHashAlgorithm(digestAlgorithm);
+            ProcessAndDigest(input, resourcePool, hash, dictionaryManager);
+            return hash.Hash;
+        }
+
+        public void ProcessAndDigest(object input, SignatureResourcePool resourcePool, HashAlgorithm hash, DictionaryManager dictionaryManger)
+        {
+            HashStream hashStream = resourcePool.TakeHashStream(hash);
+
+            XmlReader reader = input as XmlReader;
+            if (reader != null)
+            {
+                ProcessReaderInput(reader, resourcePool, hashStream);
+            }
+            else if (input is ISecurityElement)
+            {
+                XmlDictionaryWriter utf8Writer = resourcePool.TakeUtf8Writer();
+                utf8Writer.StartCanonicalization(hashStream, this.IncludeComments, GetInclusivePrefixes());
+                (input as ISecurityElement).WriteTo(utf8Writer, dictionaryManger);
+                utf8Writer.EndCanonicalization();
+            }
+            else
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new NotSupportedException(SR.Format("UnsupportedInputTypeForTransform", input.GetType())));
+            }
+
+            hashStream.FlushHash();
+        }
+
+        void ProcessReaderInput(XmlReader reader, SignatureResourcePool resourcePool, HashStream hashStream)
+        {
+            reader.MoveToContent();
+            XmlDictionaryReader dictionaryReader = reader as XmlDictionaryReader;
+            if (dictionaryReader != null && dictionaryReader.CanCanonicalize)
+            {
+                dictionaryReader.StartCanonicalization(hashStream, this.IncludeComments, GetInclusivePrefixes());
+                dictionaryReader.Skip();
+                dictionaryReader.EndCanonicalization();
+            }
+            else
+            {
+                CanonicalizationDriver driver = GetConfiguredDriver(resourcePool);
+                driver.SetInput(reader);
+                driver.WriteTo(hashStream);
+            }
+        }
+
+        public override void ReadFrom(XmlDictionaryReader reader, DictionaryManager dictionaryManager, bool preserveComments)
+        {
+            XmlDictionaryString elementName = this.isCanonicalizationMethod ?
+                dictionaryManager.XmlSignatureDictionary.CanonicalizationMethod : dictionaryManager.XmlSignatureDictionary.Transform;
+            reader.MoveToStartElement(elementName, dictionaryManager.XmlSignatureDictionary.Namespace);
+            this.prefix = reader.Prefix;
+            bool isEmptyElement = reader.IsEmptyElement;
+            algorithm = reader.GetAttribute(dictionaryManager.XmlSignatureDictionary.Algorithm, null);
+            if (string.IsNullOrEmpty(algorithm))
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new CryptographicException(SR.Format("ID0001", dictionaryManager.XmlSignatureDictionary.Algorithm, reader.LocalName)));
+            }
+
+            if (algorithm == dictionaryManager.SecurityAlgorithmDictionary.ExclusiveC14nWithComments.Value)
+            {
+                // to include comments in canonicalization, two conditions need to be met
+                // 1. the Reference must be an xpointer.
+                // 2. the transform must be #withComments
+                includeComments = preserveComments && true;
+            }
+            else if (algorithm == dictionaryManager.SecurityAlgorithmDictionary.ExclusiveC14n.Value)
+            {
+                includeComments = false;
+            }
+            else
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new CryptographicException(SR.Format("ID6005", algorithm)));
+            }
+
+            reader.Read();
+            reader.MoveToContent();
+
+            if (!isEmptyElement)
+            {
+                if (reader.IsStartElement(dictionaryManager.ExclusiveC14NDictionary.InclusiveNamespaces, dictionaryManager.ExclusiveC14NDictionary.Namespace))
+                {
+                    reader.MoveToStartElement(dictionaryManager.ExclusiveC14NDictionary.InclusiveNamespaces, dictionaryManager.ExclusiveC14NDictionary.Namespace);
+                    this.inclusiveListElementPrefix = reader.Prefix;
+                    bool emptyElement = reader.IsEmptyElement;
+                    // We treat PrefixList as optional Attribute.
+                    this.InclusiveNamespacesPrefixList = reader.GetAttribute(dictionaryManager.ExclusiveC14NDictionary.PrefixList, null);
+                    reader.Read();
+                    if (!emptyElement)
+                        reader.ReadEndElement();
+                }
+                reader.MoveToContent();
+                reader.ReadEndElement(); // Transform
+            }
+        }
+
+        public override void WriteTo(XmlDictionaryWriter writer, DictionaryManager dictionaryManager)
+        {
+            XmlDictionaryString elementName = this.isCanonicalizationMethod ?
+                dictionaryManager.XmlSignatureDictionary.CanonicalizationMethod : dictionaryManager.XmlSignatureDictionary.Transform;
+            writer.WriteStartElement(this.prefix, elementName, dictionaryManager.XmlSignatureDictionary.Namespace);
+            writer.WriteAttributeString(dictionaryManager.XmlSignatureDictionary.Algorithm, null, algorithm);
+
+            if (this.InclusiveNamespacesPrefixList != null)
+            {
+                writer.WriteStartElement(this.inclusiveListElementPrefix, dictionaryManager.ExclusiveC14NDictionary.InclusiveNamespaces, dictionaryManager.ExclusiveC14NDictionary.Namespace);
+                writer.WriteAttributeString(dictionaryManager.ExclusiveC14NDictionary.PrefixList, null, this.InclusiveNamespacesPrefixList);
+                writer.WriteEndElement(); // InclusiveNamespaces
+            }
+
+            writer.WriteEndElement(); // Transform
+        }
+
+        static string[] TokenizeInclusivePrefixList(string prefixList)
+        {
+            if (prefixList == null)
+            {
+                return null;
+            }
+            string[] prefixes = prefixList.Split(null);
+            int count = 0;
+            for (int i = 0; i < prefixes.Length; i++)
+            {
+                string prefix = prefixes[i];
+                if (prefix == "#default")
+                {
+                    prefixes[count++] = string.Empty;
+                }
+                else if (prefix.Length > 0)
+                {
+                    prefixes[count++] = prefix;
+                }
+            }
+            if (count == 0)
+            {
+                return null;
+            }
+            else if (count == prefixes.Length)
+            {
+                return prefixes;
+            }
+            else
+            {
+                string[] result = new string[count];
+                Array.Copy(prefixes, result, count);
+                return result;
+            }
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/HashStream.cs b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/HashStream.cs
new file mode 100644
index 0000000..c33c254
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/HashStream.cs
@@ -0,0 +1,172 @@
+using System.IO;
+using System.Security.Cryptography;
+using CoreWCF;
+using System;
+
+namespace CoreWCF.IdentityModel
+{
+    sealed class HashStream : Stream
+    {
+        HashAlgorithm hash;
+        long length;
+        bool disposed;
+        bool hashNeedsReset;
+        MemoryStream logStream;
+
+        /// <summary>
+        /// Constructor for HashStream. The HashAlgorithm instance is owned by the caller.
+        /// </summary>
+        public HashStream(HashAlgorithm hash)
+        {
+            if (hash == null)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("hash");
+
+            Reset(hash);
+        }
+
+        public override bool CanRead
+        {
+            get { return false; }
+        }
+
+        public override bool CanWrite
+        {
+            get { return true; }
+        }
+
+        public override bool CanSeek
+        {
+            get { return false; }
+        }
+
+        public HashAlgorithm Hash
+        {
+            get { return this.hash; }
+        }
+
+        public override long Length
+        {
+            get { return this.length; }
+        }
+
+        public override long Position
+        {
+            get { return this.length; }
+            set
+            {
+                // PreSharp Bug: Property get methods should not throw exceptions.
+#pragma warning suppress 56503
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new NotSupportedException());
+            }
+        }
+
+        public override void Flush()
+        {
+        }
+
+        public void FlushHash()
+        {
+            FlushHash(null);
+        }
+
+        public void FlushHash(MemoryStream preCanonicalBytes)
+        {
+
+            this.hash.TransformFinalBlock(CryptoHelper.EmptyBuffer, 0, 0);
+
+            //if (DigestTraceRecordHelper.ShouldTraceDigest)
+            //    DigestTraceRecordHelper.TraceDigest(this.logStream, this.hash);
+        }
+
+        public byte[] FlushHashAndGetValue()
+        {
+            return FlushHashAndGetValue(null);
+        }
+
+        public byte[] FlushHashAndGetValue(MemoryStream preCanonicalBytes)
+        {
+            FlushHash(preCanonicalBytes);
+            return this.hash.Hash;
+        }
+
+        public override int Read(byte[] buffer, int offset, int count)
+        {
+            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new NotSupportedException());
+        }
+
+        public void Reset()
+        {
+            if (this.hashNeedsReset)
+            {
+                this.hash.Initialize();
+                this.hashNeedsReset = false;
+            }
+            this.length = 0;
+
+           // if (DigestTraceRecordHelper.ShouldTraceDigest)
+           //     this.logStream = new MemoryStream();
+
+        }
+
+        public void Reset(HashAlgorithm hash)
+        {
+            this.hash = hash;
+            this.hashNeedsReset = false;
+            this.length = 0;
+
+          //  if (DigestTraceRecordHelper.ShouldTraceDigest)
+           //     this.logStream = new MemoryStream();
+        }
+
+        public override void Write(byte[] buffer, int offset, int count)
+        {
+            this.hash.TransformBlock(buffer, offset, count, buffer, offset);
+            this.length += count;
+            this.hashNeedsReset = true;
+
+           // if (DigestTraceRecordHelper.ShouldTraceDigest)
+            //    this.logStream.Write(buffer, offset, count);
+        }
+
+        public override long Seek(long offset, SeekOrigin origin)
+        {
+            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new NotSupportedException());
+        }
+
+        public override void SetLength(long length)
+        {
+            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new NotSupportedException());
+        }
+
+        #region IDisposable members
+
+        protected override void Dispose(bool disposing)
+        {
+            base.Dispose(disposing);
+
+            if (this.disposed)
+            {
+                return;
+            }
+
+            if (disposing)
+            {
+                //
+                // Free all of our managed resources
+                //
+
+                if (this.logStream != null)
+                {
+                    this.logStream.Dispose();
+                    this.logStream = null;
+                }
+            }
+
+            // Free native resources, if any.
+
+            this.disposed = true;
+        }
+
+        #endregion
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/IPrefixGenerator.cs b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/IPrefixGenerator.cs
new file mode 100644
index 0000000..9da0e37
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/IPrefixGenerator.cs
@@ -0,0 +1,8 @@
+
+namespace CoreWCF.IdentityModel
+{
+    interface IPrefixGenerator
+    {
+        string GetPrefix(string namespaceUri, int depth, bool isForAttribute);
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/ISecurityElement.cs b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/ISecurityElement.cs
new file mode 100644
index 0000000..06a97e5
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/ISecurityElement.cs
@@ -0,0 +1,15 @@
+
+
+using System.Xml;
+
+namespace CoreWCF.IdentityModel
+{
+    internal interface ISecurityElement
+    {
+        bool HasId { get; }
+
+        string Id { get; }
+
+        void WriteTo(XmlDictionaryWriter writer, DictionaryManager dictionaryManager);
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/ISignatureValueSecurityElement.cs b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/ISignatureValueSecurityElement.cs
new file mode 100644
index 0000000..0ff22fd
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/ISignatureValueSecurityElement.cs
@@ -0,0 +1,9 @@
+using System.Xml;
+
+namespace CoreWCF.IdentityModel
+{
+    internal interface ISignatureValueSecurityElement : ISecurityElement
+    {
+        byte[] GetSignatureValue();
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/IdentityModelDictionary.cs b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/IdentityModelDictionary.cs
new file mode 100644
index 0000000..d5fe711
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/IdentityModelDictionary.cs
@@ -0,0 +1,105 @@
+
+
+using System.Collections.Generic;
+using CoreWCF;
+using System.Xml;
+using System;
+
+namespace CoreWCF.IdentityModel
+{
+    internal class IdentityModelDictionary : IXmlDictionary
+    {
+        static public readonly IdentityModelDictionary Version1 = new IdentityModelDictionary(new IdentityModelStringsVersion1());
+        private IdentityModelStrings _strings;
+        private int _count;
+        private XmlDictionaryString[] _dictionaryStrings;
+        private Dictionary<string, int> _dictionary;
+        private XmlDictionaryString[] _versionedDictionaryStrings;
+
+        public IdentityModelDictionary(IdentityModelStrings strings)
+        {
+            _strings = strings;
+            _count = strings.Count;
+        }
+
+        static public IdentityModelDictionary CurrentVersion
+        {
+            get
+            {
+                return Version1;
+            }
+        }
+
+        public XmlDictionaryString CreateString(string value, int key)
+        {
+            return new XmlDictionaryString(this, value, key);
+        }
+
+        public bool TryLookup(string key, out XmlDictionaryString value)
+        {
+            if (key == null)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException("key"));
+            if (_dictionary == null)
+            {
+                Dictionary<string, int> dictionary = new Dictionary<string, int>(_count);
+                for (int i = 0; i < _count; i++)
+                    dictionary.Add(_strings[i], i);
+                _dictionary = dictionary;
+            }
+            int id;
+            if (_dictionary.TryGetValue(key, out id))
+                return TryLookup(id, out value);
+            value = null;
+            return false;
+        }
+
+        public bool TryLookup(int key, out XmlDictionaryString value)
+        {
+            if (key < 0 || key >= _count)
+            {
+                value = null;
+                return false;
+            }
+            if (_dictionaryStrings == null)
+                _dictionaryStrings = new XmlDictionaryString[_count];
+            XmlDictionaryString s = _dictionaryStrings[key];
+            if (s == null)
+            {
+                s = CreateString(_strings[key], key);
+                _dictionaryStrings[key] = s;
+            }
+            value = s;
+            return true;
+        }
+
+        public bool TryLookup(XmlDictionaryString key, out XmlDictionaryString value)
+        {
+            if (key == null)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException("key"));
+            if (key.Dictionary == this)
+            {
+                value = key;
+                return true;
+            }
+            if (key.Dictionary == CurrentVersion)
+            {
+                if (_versionedDictionaryStrings == null)
+                    _versionedDictionaryStrings = new XmlDictionaryString[CurrentVersion._count];
+                XmlDictionaryString s = _versionedDictionaryStrings[key.Key];
+                if (s == null)
+                {
+                    if (!TryLookup(key.Value, out s))
+                    {
+                        value = null;
+                        return false;
+                    }
+                    _versionedDictionaryStrings[key.Key] = s;
+                }
+                value = s;
+                return true;
+            }
+            value = null;
+            return false;
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/KeyInfoSerializer.cs b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/KeyInfoSerializer.cs
new file mode 100644
index 0000000..c0e84c4
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/KeyInfoSerializer.cs
@@ -0,0 +1,367 @@
+﻿using CoreWCF.IdentityModel.Selectors;
+using System.Collections.Generic;
+using CoreWCF.IdentityModel.Selectors;
+using CoreWCF.Runtime;
+using System.Xml;
+using CoreWCF;
+using System;
+
+namespace CoreWCF.IdentityModel.Tokens
+{
+    /// <summary>
+    /// Abstract class for SecurityKeyIdentifierClause Serializer.
+    /// </summary>
+    internal class KeyInfoSerializer : SecurityTokenSerializer
+    {
+        private readonly List<KeyIdentifierEntry> _keyIdentifierEntries;
+        private readonly List<KeyIdentifierClauseEntry> _keyIdentifierClauseEntries;
+        private readonly List<SerializerEntries> _serializerEntries;
+        private readonly List<TokenEntry> _tokenEntries;
+        private SecurityTokenSerializer _innerSecurityTokenSerializer;
+
+        /// <summary>
+        /// Creates an instance of <see cref="SecurityKeyIdentifierClauseSerializer"/>
+        /// </summary>
+        public KeyInfoSerializer(bool emitBspRequiredAttributes)
+            : this(emitBspRequiredAttributes, new DictionaryManager(), DXD.TrustDec2005Dictionary, null)
+        {
+        }
+
+        public KeyInfoSerializer(
+            bool emitBspRequiredAttributes,
+            DictionaryManager dictionaryManager,
+            TrustDictionary trustDictionary,
+            SecurityTokenSerializer innerSecurityTokenSerializer) :
+            this(emitBspRequiredAttributes, dictionaryManager, trustDictionary, innerSecurityTokenSerializer, null)
+        {
+        }
+
+        public KeyInfoSerializer(
+            bool emitBspRequiredAttributes,
+            DictionaryManager dictionaryManager,
+            TrustDictionary trustDictionary,
+            SecurityTokenSerializer innerSecurityTokenSerializer,
+            Func<KeyInfoSerializer, IEnumerable<SerializerEntries>> additionalEntries)
+        {
+            DictionaryManager = dictionaryManager;
+            EmitBspRequiredAttributes = emitBspRequiredAttributes;
+            _innerSecurityTokenSerializer = innerSecurityTokenSerializer;
+
+            _serializerEntries = new List<SerializerEntries>();
+
+            _serializerEntries.Add(new XmlDsigSep2000(this));
+            _serializerEntries.Add(new Security.WSTrust(this, trustDictionary));
+            if (additionalEntries != null)
+            {
+                foreach (SerializerEntries entries in additionalEntries(this))
+                {
+                    _serializerEntries.Add(entries);
+                }
+            }
+
+            bool wsSecuritySerializerFound = false;
+            foreach (SerializerEntries entry in _serializerEntries)
+            {
+                if ((entry is WSSecurityXXX2005) || (entry is WSSecurityJan2004))
+                {
+                    wsSecuritySerializerFound = true;
+                    break;
+                }
+            }
+
+            if (!wsSecuritySerializerFound)
+            {
+                _serializerEntries.Add(new WSSecurityXXX2005(this));
+            }
+
+            _tokenEntries = new List<TokenEntry>();
+            _keyIdentifierEntries = new List<KeyIdentifierEntry>();
+            _keyIdentifierClauseEntries = new List<KeyIdentifierClauseEntry>();
+
+            for (int i = 0; i < _serializerEntries.Count; ++i)
+            {
+                SerializerEntries serializerEntry = _serializerEntries[i];
+                serializerEntry.PopulateTokenEntries(_tokenEntries);
+                serializerEntry.PopulateKeyIdentifierEntries(_keyIdentifierEntries);
+                serializerEntry.PopulateKeyIdentifierClauseEntries(_keyIdentifierClauseEntries);
+            }
+        }
+
+        public DictionaryManager DictionaryManager { get; }
+
+        /// <summary>
+        /// Gets or sets a value indicating if BSP required attributes should be written out.
+        /// </summary>
+        public bool EmitBspRequiredAttributes { get; }
+
+        public SecurityTokenSerializer InnerSecurityTokenSerializer
+        {
+            get
+            {
+                return _innerSecurityTokenSerializer == null ? this : _innerSecurityTokenSerializer;
+            }
+            set
+            {
+                _innerSecurityTokenSerializer = value;
+            }
+        }
+
+        protected override bool CanReadTokenCore(XmlReader reader)
+        {
+            return false;
+        }
+
+        protected override SecurityToken ReadTokenCore(XmlReader reader, SecurityTokenResolver tokenResolver)
+        {
+            XmlDictionaryReader localReader = XmlDictionaryReader.CreateDictionaryReader(reader);
+            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new XmlException(SR.Format(SR.CannotReadToken, reader.LocalName, reader.NamespaceURI, localReader.GetAttribute(CoreWCF.XD.SecurityJan2004Dictionary.ValueType, null))));
+        }
+
+        protected override bool CanWriteTokenCore(SecurityToken token)
+        {
+            return false;
+        }
+
+        protected override void WriteTokenCore(XmlWriter writer, SecurityToken token)
+        {
+            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.StandardsManagerCannotWriteObject, token.GetType())));
+        }
+
+        protected override bool CanReadKeyIdentifierCore(XmlReader reader)
+        {
+            XmlDictionaryReader localReader = XmlDictionaryReader.CreateDictionaryReader(reader);
+            for (int i = 0; i < _keyIdentifierEntries.Count; i++)
+            {
+                KeyIdentifierEntry keyIdentifierEntry = _keyIdentifierEntries[i];
+                if (keyIdentifierEntry.CanReadKeyIdentifierCore(localReader))
+                {
+                    return true;
+                }
+            }
+            return false;
+        }
+
+        protected override SecurityKeyIdentifier ReadKeyIdentifierCore(XmlReader reader)
+        {
+            XmlDictionaryReader localReader = XmlDictionaryReader.CreateDictionaryReader(reader);
+            localReader.ReadStartElement(CoreWCF.XD.XmlSignatureDictionary.KeyInfo, CoreWCF.XD.XmlSignatureDictionary.Namespace);
+            SecurityKeyIdentifier keyIdentifier = new SecurityKeyIdentifier();
+            while (localReader.IsStartElement())
+            {
+                SecurityKeyIdentifierClause clause = InnerSecurityTokenSerializer.ReadKeyIdentifierClause(localReader);
+                if (clause == null)
+                {
+                    localReader.Skip();
+                }
+                else
+                {
+                    keyIdentifier.Add(clause);
+                }
+            }
+            if (keyIdentifier.Count == 0)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new XmlException(SR.Format("ErrorDeserializingKeyIdentifierClause")));
+            }
+            localReader.ReadEndElement();
+
+            return keyIdentifier;
+        }
+
+        protected override bool CanWriteKeyIdentifierCore(SecurityKeyIdentifier keyIdentifier)
+        {
+            for (int i = 0; i < _keyIdentifierEntries.Count; ++i)
+            {
+                KeyIdentifierEntry keyIdentifierEntry = _keyIdentifierEntries[i];
+                if (keyIdentifierEntry.SupportsCore(keyIdentifier))
+                {
+                    return true;
+                }
+            }
+            return false;
+        }
+
+        protected override void WriteKeyIdentifierCore(XmlWriter writer, SecurityKeyIdentifier keyIdentifier)
+        {
+            bool wroteKeyIdentifier = false;
+            XmlDictionaryWriter localWriter = XmlDictionaryWriter.CreateDictionaryWriter(writer);
+            for (int i = 0; i < _keyIdentifierEntries.Count; ++i)
+            {
+                KeyIdentifierEntry keyIdentifierEntry = _keyIdentifierEntries[i];
+                if (keyIdentifierEntry.SupportsCore(keyIdentifier))
+                {
+                    try
+                    {
+                        keyIdentifierEntry.WriteKeyIdentifierCore(localWriter, keyIdentifier);
+                    }
+                    catch (Exception e)
+                    {
+                        if (Fx.IsFatal(e))
+                        {
+                            throw;
+                        }
+
+                        if (!ShouldWrapException(e))
+                        {
+                            throw;
+                        }
+
+                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new XmlException(SR.Format("ErrorSerializingKeyIdentifier"), e));
+                    }
+                    wroteKeyIdentifier = true;
+                    break;
+                }
+            }
+
+            if (!wroteKeyIdentifier)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.StandardsManagerCannotWriteObject, keyIdentifier.GetType())));
+            }
+
+            localWriter.Flush();
+        }
+
+        protected override bool CanReadKeyIdentifierClauseCore(XmlReader reader)
+        {
+            XmlDictionaryReader localReader = XmlDictionaryReader.CreateDictionaryReader(reader);
+            for (int i = 0; i < _keyIdentifierClauseEntries.Count; i++)
+            {
+                KeyIdentifierClauseEntry keyIdentifierClauseEntry = _keyIdentifierClauseEntries[i];
+                if (keyIdentifierClauseEntry.CanReadKeyIdentifierClauseCore(localReader))
+                {
+                    return true;
+                }
+            }
+            return false;
+        }
+
+        protected override SecurityKeyIdentifierClause ReadKeyIdentifierClauseCore(XmlReader reader)
+        {
+            XmlDictionaryReader localReader = XmlDictionaryReader.CreateDictionaryReader(reader);
+            for (int i = 0; i < _keyIdentifierClauseEntries.Count; i++)
+            {
+                KeyIdentifierClauseEntry keyIdentifierClauseEntry = _keyIdentifierClauseEntries[i];
+                if (keyIdentifierClauseEntry.CanReadKeyIdentifierClauseCore(localReader))
+                {
+                    try
+                    {
+                        return keyIdentifierClauseEntry.ReadKeyIdentifierClauseCore(localReader);
+                    }
+                    catch (Exception e)
+                    {
+                        if (Fx.IsFatal(e))
+                        {
+                            throw;
+                        }
+
+                        if (!ShouldWrapException(e))
+                        {
+                            throw;
+                        }
+                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new XmlException(SR.Format("ErrorDeserializingKeyIdentifierClause"), e));
+                    }
+                }
+            }
+            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new XmlException(SR.Format("CannotReadKeyIdentifierClause", reader.LocalName, reader.NamespaceURI)));
+        }
+
+        protected override bool CanWriteKeyIdentifierClauseCore(SecurityKeyIdentifierClause keyIdentifierClause)
+        {
+            for (int i = 0; i < _keyIdentifierClauseEntries.Count; ++i)
+            {
+                KeyIdentifierClauseEntry keyIdentifierClauseEntry = _keyIdentifierClauseEntries[i];
+                if (keyIdentifierClauseEntry.SupportsCore(keyIdentifierClause))
+                {
+                    return true;
+                }
+            }
+            return false;
+        }
+
+        protected override void WriteKeyIdentifierClauseCore(XmlWriter writer, SecurityKeyIdentifierClause keyIdentifierClause)
+        {
+            bool wroteKeyIdentifierClause = false;
+            XmlDictionaryWriter localWriter = XmlDictionaryWriter.CreateDictionaryWriter(writer);
+            for (int i = 0; i < _keyIdentifierClauseEntries.Count; ++i)
+            {
+                KeyIdentifierClauseEntry keyIdentifierClauseEntry = _keyIdentifierClauseEntries[i];
+                if (keyIdentifierClauseEntry.SupportsCore(keyIdentifierClause))
+                {
+                    try
+                    {
+                        keyIdentifierClauseEntry.WriteKeyIdentifierClauseCore(localWriter, keyIdentifierClause);
+                    }
+                    catch (Exception e)
+                    {
+                        if (Fx.IsFatal(e))
+                        {
+                            throw;
+                        }
+
+                        if (!ShouldWrapException(e))
+                        {
+                            throw;
+                        }
+
+                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new XmlException("ErrorSerializingKeyIdentifierClause", e));
+                    }
+                    wroteKeyIdentifierClause = true;
+                    break;
+                }
+            }
+
+            if (!wroteKeyIdentifierClause)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.StandardsManagerCannotWriteObject, keyIdentifierClause.GetType())));
+            }
+
+            localWriter.Flush();
+        }
+
+        internal void PopulateStrEntries(IList<StrEntry> strEntries)
+        {
+            foreach (SerializerEntries serializerEntry in _serializerEntries)
+            {
+                serializerEntry.PopulateStrEntries(strEntries);
+            }
+        }
+
+        private bool ShouldWrapException(Exception e)
+        {
+            return ((e is ArgumentException) || (e is FormatException) || (e is InvalidOperationException));
+        }
+
+        internal Type[] GetTokenTypes(string tokenTypeUri)
+        {
+            if (tokenTypeUri != null)
+            {
+                for (int i = 0; i < _tokenEntries.Count; i++)
+                {
+                    TokenEntry tokenEntry = _tokenEntries[i];
+
+                    if (tokenEntry.SupportsTokenTypeUri(tokenTypeUri))
+                    {
+                        return tokenEntry.GetTokenTypes();
+                    }
+                }
+            }
+            return null;
+        }
+
+        protected internal virtual string GetTokenTypeUri(Type tokenType)
+        {
+            if (tokenType != null)
+            {
+                for (int i = 0; i < _tokenEntries.Count; i++)
+                {
+                    TokenEntry tokenEntry = _tokenEntries[i];
+
+                    if (tokenEntry.SupportsCore(tokenType))
+                    {
+                        return tokenEntry.TokenTypeUri;
+                    }
+                }
+            }
+            return null;
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/MostlySingletonList.cs b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/MostlySingletonList.cs
new file mode 100644
index 0000000..907edd4
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/MostlySingletonList.cs
@@ -0,0 +1,134 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Text;
+
+namespace CoreWCF.IdentityModel
+{
+    struct MostlySingletonList<T> where T : class
+    {
+        int count;
+        T singleton;
+        List<T> list;
+
+        public T this[int index]
+        {
+            get
+            {
+                if (this.list == null)
+                {
+                    EnsureValidSingletonIndex(index);
+                    return this.singleton;
+                }
+                else
+                {
+                    return this.list[index];
+                }
+            }
+        }
+
+        public int Count
+        {
+            get { return this.count; }
+        }
+
+        public void Add(T item)
+        {
+            if (this.list == null)
+            {
+                if (this.count == 0)
+                {
+                    this.singleton = item;
+                    this.count = 1;
+                    return;
+                }
+                this.list = new List<T>();
+                this.list.Add(this.singleton);
+                this.singleton = null;
+            }
+            this.list.Add(item);
+            this.count++;
+        }
+
+        static bool Compare(T x, T y)
+        {
+            return x == null ? y == null : x.Equals(y);
+        }
+
+        public bool Contains(T item)
+        {
+            return IndexOf(item) >= 0;
+        }
+
+        void EnsureValidSingletonIndex(int index)
+        {
+            if (this.count != 1)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("count", SR.Format("ValueMustBeOne")));
+            }
+
+            if (index != 0)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("index", SR.Format("ValueMustBeZero")));
+            }
+
+        }
+
+        bool MatchesSingleton(T item)
+        {
+            return this.count == 1 && Compare(this.singleton, item);
+        }
+
+        public int IndexOf(T item)
+        {
+            if (this.list == null)
+            {
+                return MatchesSingleton(item) ? 0 : -1;
+            }
+            else
+            {
+                return this.list.IndexOf(item);
+            }
+        }
+
+        public bool Remove(T item)
+        {
+            if (this.list == null)
+            {
+                if (MatchesSingleton(item))
+                {
+                    this.singleton = null;
+                    this.count = 0;
+                    return true;
+                }
+                else
+                {
+                    return false;
+                }
+            }
+            else
+            {
+                bool result = this.list.Remove(item);
+                if (result)
+                {
+                    this.count--;
+                }
+                return result;
+            }
+        }
+
+        public void RemoveAt(int index)
+        {
+            if (this.list == null)
+            {
+                EnsureValidSingletonIndex(index);
+                this.singleton = null;
+                this.count = 0;
+            }
+            else
+            {
+                this.list.RemoveAt(index);
+                this.count--;
+            }
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Psha1DerivedKeyGenerator.cs b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Psha1DerivedKeyGenerator.cs
new file mode 100644
index 0000000..5576098
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Psha1DerivedKeyGenerator.cs
@@ -0,0 +1,107 @@
+﻿
+using System.Runtime;
+using System.Security.Cryptography;
+using CoreWCF;
+using System;
+using CoreWCF.Runtime;
+
+namespace CoreWCF.IdentityModel
+{
+    internal sealed class Psha1DerivedKeyGenerator
+    {
+        private byte[] _key;
+
+        public Psha1DerivedKeyGenerator(byte[] key)
+        {
+            _key = key ?? throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(key));
+        }
+
+        public byte[] GenerateDerivedKey(byte[] label, byte[] nonce, int derivedKeySize, int position)
+        {
+            if (label == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(label));
+            }
+            if (nonce == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(nonce));
+            }
+            ManagedPsha1 dkcp = new ManagedPsha1(_key, label, nonce);
+            return dkcp.GetDerivedKey(derivedKeySize, position);
+        }
+
+        // private class to do the real work
+        // Note: Though named ManagedPsha1, this works for both fips and non-fips compliance
+        private sealed class ManagedPsha1
+        {
+            private byte[] _aValue;
+            private byte[] _buffer;
+            private byte[] _chunk;
+            private KeyedHashAlgorithm _hmac;
+            private int _index;
+            private int _position;
+            private byte[] _secret;
+            private byte[] _seed;
+
+            // assume arguments are already validated
+            public ManagedPsha1(byte[] secret, byte[] label, byte[] seed)
+            {
+                _secret = secret;
+                _seed = Fx.AllocateByteArray(checked(label.Length + seed.Length));
+                label.CopyTo(_seed, 0);
+                seed.CopyTo(_seed, label.Length);
+
+                _aValue = _seed;
+                _chunk = new byte[0];
+                _index = 0;
+                _position = 0;
+                _hmac = CryptoHelper.NewHmacSha1KeyedHashAlgorithm(secret);
+
+                _buffer =  Fx.AllocateByteArray(checked(_hmac.HashSize / 8 + _seed.Length));
+            }
+
+            public byte[] GetDerivedKey(int derivedKeySize, int position)
+            {
+                if (derivedKeySize < 0)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(derivedKeySize), SR.ValueMustBeNonNegative));
+                }
+                if (_position > position)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(position), SR.Format(SR.ValueMustBeInRange, 0, _position)));
+                }
+
+                // Seek to the desired position in the pseudo-random stream.
+                while (_position < position)
+                {
+                    GetByte();
+                }
+                int sizeInBytes = derivedKeySize / 8;
+                byte[] derivedKey = new byte[sizeInBytes];
+                for (int i = 0; i < sizeInBytes; i++)
+                {
+                    derivedKey[i] = GetByte();
+                }
+                return derivedKey;
+            }
+
+            private byte GetByte()
+            {
+                if (_index >= _chunk.Length)
+                {
+                    // Calculate A(i) = HMAC_SHA1(secret, A(i-1)).
+                    _hmac.Initialize();
+                    _aValue = _hmac.ComputeHash(_aValue);
+                    // Calculate P_SHA1(secret, seed)[j] = HMAC_SHA1(secret, A(j+1) || seed).
+                    _aValue.CopyTo(_buffer, 0);
+                    _seed.CopyTo(_buffer, _aValue.Length);
+                    _hmac.Initialize();
+                    _chunk = _hmac.ComputeHash(_buffer);
+                    _index = 0;
+                }
+                _position++;
+                return _chunk[_index++];
+            }
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/ReferenceList.cs b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/ReferenceList.cs
new file mode 100644
index 0000000..b201771
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/ReferenceList.cs
@@ -0,0 +1,140 @@
+using System.Collections.Generic;
+using CoreWCF.IdentityModel;
+using System.Runtime.CompilerServices;
+using System.Xml;
+using DictionaryManager = CoreWCF.IdentityModel.DictionaryManager;
+using ISecurityElement = CoreWCF.IdentityModel.ISecurityElement;
+using CoreWCF;
+using XD = CoreWCF.IdentityModel.XD;
+using System;
+
+namespace CoreWCF.Security
+{
+   sealed class ReferenceList : ISecurityElement
+    {
+        internal static readonly XmlDictionaryString ElementName = XD.XmlEncryptionDictionary.ReferenceList;
+        const string NamespacePrefix = XmlEncryptionStrings.Prefix;
+        internal static readonly XmlDictionaryString NamespaceUri = XD.XmlEncryptionDictionary.Namespace;// EncryptedType.NamespaceUri;
+        internal static readonly XmlDictionaryString UriAttribute = XD.XmlEncryptionDictionary.URI;
+        List<string> referredIds = new List<string>();
+
+        public ReferenceList()
+        {
+        }
+
+        public int DataReferenceCount
+        {
+            get { return this.referredIds.Count; }
+        }
+
+        public bool HasId
+        {
+            get { return false; }
+        }
+
+        public string Id
+        {
+            get
+            {
+                // PreSharp Bug: Property get methods should not throw exceptions.
+                #pragma warning suppress 56503
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new NotSupportedException());
+            }
+        }
+
+        public void AddReferredId(string id)
+        {
+            if (id == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException("id"));
+            }
+            this.referredIds.Add(id);
+        }
+
+        public bool ContainsReferredId(string id)
+        {
+            if (id == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException("id"));
+            }
+            return this.referredIds.Contains(id);
+        }
+
+        public string GetReferredId(int index)
+        {
+            return this.referredIds[index];
+        }
+
+        public void ReadFrom(XmlDictionaryReader reader)
+        {
+            reader.ReadStartElement(ElementName, NamespaceUri);
+            while (reader.IsStartElement())
+            {
+                string id = DataReference.ReadFrom(reader);
+                if (this.referredIds.Contains(id))
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(
+                        new Exception(SR.Format("InvalidDataReferenceInReferenceList", "#" + id)));
+                }
+                this.referredIds.Add(id);
+            }
+            reader.ReadEndElement(); // ReferenceList
+            if (this.DataReferenceCount == 0)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new Exception(SR.Format("ReferenceListCannotBeEmpty")));
+            }
+        }
+
+        public bool TryRemoveReferredId(string id)
+        {
+            if (id == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException("id"));
+            }
+            return this.referredIds.Remove(id);
+        }
+
+        public void WriteTo(XmlDictionaryWriter writer, DictionaryManager dictionaryManager)
+        {
+            if (this.DataReferenceCount == 0)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format("ReferenceListCannotBeEmpty")));
+            }
+            writer.WriteStartElement(NamespacePrefix, ElementName, NamespaceUri);
+            for (int i = 0; i < this.DataReferenceCount; i++)
+            {
+                DataReference.WriteTo(writer, this.referredIds[i]);
+            }
+            writer.WriteEndElement(); // ReferenceList
+        }
+
+        static class DataReference
+        {
+            internal static readonly XmlDictionaryString ElementName = XD.XmlEncryptionDictionary.DataReference;
+            internal static readonly XmlDictionaryString NamespaceUri = XD.XmlEncryptionDictionary.Namespace;
+
+            public static string ReadFrom(XmlDictionaryReader reader)
+            {
+                throw new NotImplementedException();
+                //string prefix;
+                //string uri = XmlHelper.ReadEmptyElementAndRequiredAttribute(reader, ElementName, NamespaceUri, ReferenceList.UriAttribute, out prefix);
+                //if (uri.Length < 2 || uri[0] != '#')
+                //{
+                //    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(
+                //        new SecurityMessageSerializationException(SR.GetString(SR.InvalidDataReferenceInReferenceList, uri)));
+                //}
+                //return uri.Substring(1);
+            }
+
+            public static void WriteTo(XmlDictionaryWriter writer, string referredId)
+            {
+                writer.WriteStartElement(XD.XmlEncryptionDictionary.Prefix.Value, ElementName, NamespaceUri);
+                writer.WriteStartAttribute(ReferenceList.UriAttribute, null);
+                writer.WriteString("#");
+                writer.WriteString(referredId);
+                writer.WriteEndAttribute();
+                writer.WriteEndElement();
+            }
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/SamlAssertionKeyIdentifierClause.cs b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/SamlAssertionKeyIdentifierClause.cs
new file mode 100644
index 0000000..21b157f
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/SamlAssertionKeyIdentifierClause.cs
@@ -0,0 +1,92 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Text;
+
+namespace CoreWCF.IdentityModel
+{
+    using System.Globalization;
+
+    public class SamlAssertionKeyIdentifierClause : SecurityKeyIdentifierClause
+    {
+        readonly string assertionId;
+        readonly string valueType;
+        readonly string tokenTypeUri;
+        readonly string binding;
+        readonly string location;
+        readonly string authorityKind;
+
+        public SamlAssertionKeyIdentifierClause(string assertionId)
+            : this(assertionId, null, 0)
+        {
+        }
+
+        public SamlAssertionKeyIdentifierClause(string assertionId, byte[] derivationNonce, int derivationLength)
+            : this(assertionId, derivationNonce, derivationLength, null, null, null, null, null)
+        {
+        }
+
+        internal SamlAssertionKeyIdentifierClause(string assertionId, byte[] derivationNonce, int derivationLength, string valueType, string tokenTypeUri, string binding, string location, string authorityKind)
+            : base(null, derivationNonce, derivationLength)
+        {
+            if (assertionId == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("assertionId");
+            }
+            this.assertionId = assertionId;
+            this.valueType = valueType;
+            this.tokenTypeUri = tokenTypeUri;
+            this.binding = binding;
+            this.location = location;
+            this.authorityKind = authorityKind;
+        }
+
+        public string AssertionId
+        {
+            get { return this.assertionId; }
+        }
+
+        internal string TokenTypeUri
+        {
+            get { return this.tokenTypeUri; }
+        }
+
+        internal string ValueType
+        {
+            get { return this.valueType; }
+        }
+
+        internal string Binding
+        {
+            get { return this.binding; }
+        }
+
+        internal string Location
+        {
+            get { return this.location; }
+        }
+
+        internal string AuthorityKind
+        {
+            get { return this.authorityKind; }
+        }
+
+        public override bool Matches(SecurityKeyIdentifierClause keyIdentifierClause)
+        {
+            SamlAssertionKeyIdentifierClause that = keyIdentifierClause as SamlAssertionKeyIdentifierClause;
+
+            // PreSharp Bug: Parameter 'that' to this public method must be validated: A null-dereference can occur here.
+#pragma warning suppress 56506
+            return ReferenceEquals(this, that) || (that != null && that.Matches(this.assertionId));
+        }
+
+        public bool Matches(string assertionId)
+        {
+            return this.assertionId == assertionId;
+        }
+
+        public override string ToString()
+        {
+            return string.Format(CultureInfo.InvariantCulture, "SamlAssertionKeyIdentifierClause(AssertionId = '{0}')", this.AssertionId);
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/SecurityKeyIdentifierClause.cs b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/SecurityKeyIdentifierClause.cs
index 50f2b02..6cf2593 100644
--- a/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/SecurityKeyIdentifierClause.cs
+++ b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/SecurityKeyIdentifierClause.cs
@@ -12,7 +12,7 @@ namespace CoreWCF.IdentityModel
     // override CanCreateKey and return true, and implement
     // CreateKey()
 
-    internal abstract class SecurityKeyIdentifierClause
+    public abstract class SecurityKeyIdentifierClause
     {
         readonly string clauseType;
         byte[] derivationNonce;
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/SecurityUtils.cs b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/SecurityUtils.cs
index 9320fed..4e85f3b 100644
--- a/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/SecurityUtils.cs
+++ b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/SecurityUtils.cs
@@ -46,6 +46,8 @@ namespace CoreWCF.IdentityModel
             }
         }
 
+        public static bool RequiresFipsCompliance { get; internal set; }
+
         internal static IIdentity CreateIdentity(string name, string authenticationType)
         {
             return new GenericIdentity(name, authenticationType);
@@ -80,6 +82,35 @@ namespace CoreWCF.IdentityModel
             return certificateId;
         }
 
+        internal static bool MatchesBuffer(byte[] src, byte[] dst)
+        {
+            return MatchesBuffer(src, 0, dst, 0);
+        }
+
+        internal static bool MatchesBuffer(byte[] src, int srcOffset, byte[] dst, int dstOffset)
+        {
+            DiagnosticUtility.DebugAssert(dstOffset >= 0, "Negative dstOffset passed to MatchesBuffer.");
+            DiagnosticUtility.DebugAssert(srcOffset >= 0, "Negative srcOffset passed to MatchesBuffer.");
+
+            // defensive programming
+            if ((dstOffset < 0) || (srcOffset < 0))
+                return false;
+
+            if (src == null || srcOffset >= src.Length)
+                return false;
+            if (dst == null || dstOffset >= dst.Length)
+                return false;
+            if ((src.Length - srcOffset) != (dst.Length - dstOffset))
+                return false;
+
+            for (int i = srcOffset, j = dstOffset; i < src.Length; i++, j++)
+            {
+                if (src[i] != dst[j])
+                    return false;
+            }
+            return true;
+        }
+
         internal static void ResetCertificate(X509Certificate2 certificate)
         {
             // Check that Dispose() and Reset() do the same thing
@@ -123,6 +154,11 @@ namespace CoreWCF.IdentityModel
             }
         }
 
+        internal static bool TryCreateX509CertificateFromRawData(byte[] v, out X509Certificate2 certificate)
+        {
+            throw new NotImplementedException();
+        }
+
         internal static ReadOnlyCollection<IAuthorizationPolicy> CreateAuthorizationPolicies(ClaimSet claimSet)
         {
             return CreateAuthorizationPolicies(claimSet, SecurityUtils.MaxUtcDateTime);
@@ -340,6 +376,16 @@ namespace CoreWCF.IdentityModel
 
             return authorizationContext;
         }
+        public static bool IsRequestSecurityContextIssuance(String actionString)
+        {
+            if (String.CompareOrdinal(actionString, CoreWCF.XD.SecureConversationFeb2005Dictionary
+                .RequestSecurityContextIssuance.Value) == 0 ||
+                String.CompareOrdinal(actionString, CoreWCF.XD.SecureConversationApr2004Dictionary
+                .RequestSecurityContextIssuance.Value) == 0)
+                return true;
+            return false;
+        }
+
     }
 
     static class EmptyReadOnlyCollection<T>
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Selectors/GenericSecurityTokenAuthenticator.cs b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Selectors/GenericSecurityTokenAuthenticator.cs
index cddb109..16878f1 100644
--- a/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Selectors/GenericSecurityTokenAuthenticator.cs
+++ b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Selectors/GenericSecurityTokenAuthenticator.cs
@@ -21,7 +21,7 @@ namespace CoreWCF.IdentityModel.Selectors
         protected override ReadOnlyCollection<IAuthorizationPolicy> ValidateTokenCore(SecurityToken token)
         {
             var genericToken = (GenericSecurityToken)token;
-            return Security.SecurityUtils.CreatePrincipalNameAuthorizationPolicies(genericToken.Name);
+            return CoreWCF.Security.SecurityUtils.CreatePrincipalNameAuthorizationPolicies(genericToken.Name);
         }
     }
 }
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Selectors/SecurityTokenManager.cs b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Selectors/SecurityTokenManager.cs
index d148a4d..a5a40e1 100644
--- a/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Selectors/SecurityTokenManager.cs
+++ b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Selectors/SecurityTokenManager.cs
@@ -4,7 +4,7 @@ using System.Text;
 
 namespace CoreWCF.IdentityModel.Selectors
 {
-    internal abstract class SecurityTokenManager
+    public abstract class SecurityTokenManager
     {
         public abstract SecurityTokenProvider CreateSecurityTokenProvider(SecurityTokenRequirement tokenRequirement);
         internal abstract SecurityTokenSerializer CreateSecurityTokenSerializer(SecurityTokenVersion version);
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Selectors/SecurityTokenRequirement.cs b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Selectors/SecurityTokenRequirement.cs
index 49bc064..77a1ddb 100644
--- a/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Selectors/SecurityTokenRequirement.cs
+++ b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Selectors/SecurityTokenRequirement.cs
@@ -6,7 +6,7 @@ using System.Text;
 
 namespace CoreWCF.IdentityModel.Selectors
 {
-    internal class SecurityTokenRequirement
+    public class SecurityTokenRequirement
     {
         const string Namespace = "http://schemas.microsoft.com/ws/2006/05/identitymodel/securitytokenrequirement";
         const string tokenTypeProperty = Namespace + "/TokenType";
@@ -78,7 +78,7 @@ namespace CoreWCF.IdentityModel.Selectors
             }
         }
 
-        public SecurityKeyUsage KeyUsage
+        internal SecurityKeyUsage KeyUsage
         {
             get
             {
@@ -92,7 +92,7 @@ namespace CoreWCF.IdentityModel.Selectors
             }
         }
 
-        public SecurityKeyType KeyType
+        internal SecurityKeyType KeyType
         {
             get
             {
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Selectors/SecurityTokenResolver.cs b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Selectors/SecurityTokenResolver.cs
index 1ba4f68..9d615b8 100644
--- a/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Selectors/SecurityTokenResolver.cs
+++ b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Selectors/SecurityTokenResolver.cs
@@ -8,20 +8,192 @@ using System.Text;
 namespace CoreWCF.IdentityModel.Selectors
 {
     // TODO: Evaluate removing this class and all usages as the full framework implementation has a lot more functionality.
-    internal abstract class SecurityTokenResolver
+    public abstract class SecurityTokenResolver
     {
+        public SecurityToken ResolveToken(SecurityKeyIdentifier keyIdentifier)
+        {
+            if (keyIdentifier == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("keyIdentifier");
+            }
+            SecurityToken token;
+            if (!this.TryResolveTokenCore(keyIdentifier, out token))
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new InvalidOperationException(SR.Format("UnableToResolveTokenReference", keyIdentifier)));
+            }
+            return token;
+        }
+
+        public bool TryResolveToken(SecurityKeyIdentifier keyIdentifier, out SecurityToken token)
+        {
+            if (keyIdentifier == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("keyIdentifier");
+            }
+            return TryResolveTokenCore(keyIdentifier, out token);
+        }
+
+        public SecurityToken ResolveToken(SecurityKeyIdentifierClause keyIdentifierClause)
+        {
+            if (keyIdentifierClause == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("keyIdentifierClause");
+            }
+            SecurityToken token;
+            if (!this.TryResolveTokenCore(keyIdentifierClause, out token))
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new InvalidOperationException(SR.Format("UnableToResolveTokenReference", keyIdentifierClause)));
+            }
+            return token;
+        }
+
+        public bool TryResolveToken(SecurityKeyIdentifierClause keyIdentifierClause, out SecurityToken token)
+        {
+            if (keyIdentifierClause == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("keyIdentifierClause");
+            }
+            return this.TryResolveTokenCore(keyIdentifierClause, out token);
+        }
+
+        public SecurityKey ResolveSecurityKey(SecurityKeyIdentifierClause keyIdentifierClause)
+        {
+            if (keyIdentifierClause == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("keyIdentifierClause");
+            }
+            SecurityKey key;
+            if (!this.TryResolveSecurityKeyCore(keyIdentifierClause, out key))
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new InvalidOperationException(SR.Format("UnableToResolveKeyReference", keyIdentifierClause)));
+            }
+            return key;
+        }
+
+        public bool TryResolveSecurityKey(SecurityKeyIdentifierClause keyIdentifierClause, out SecurityKey key)
+        {
+            if (keyIdentifierClause == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("keyIdentifierClause");
+            }
+            return this.TryResolveSecurityKeyCore(keyIdentifierClause, out key);
+        }
+
+       
+
+        // protected methods
+        protected abstract bool TryResolveTokenCore(SecurityKeyIdentifier keyIdentifier, out SecurityToken token);
+        protected abstract bool TryResolveTokenCore(SecurityKeyIdentifierClause keyIdentifierClause, out SecurityToken token);
+        protected abstract bool TryResolveSecurityKeyCore(SecurityKeyIdentifierClause keyIdentifierClause, out SecurityKey key);
+
+
+        public static SecurityTokenResolver CreateDefaultSecurityTokenResolver(ReadOnlyCollection<SecurityToken> tokens, bool canMatchLocalId)
+        {
+            return new SimpleTokenResolver(tokens, canMatchLocalId);
+        }
         private class SimpleTokenResolver : SecurityTokenResolver
         {
-            private ReadOnlyCollection<SecurityToken> _tokens;
-            private bool _canMatchLocalId;
+            ReadOnlyCollection<SecurityToken> tokens;
+            bool canMatchLocalId;
 
             public SimpleTokenResolver(ReadOnlyCollection<SecurityToken> tokens, bool canMatchLocalId)
             {
                 if (tokens == null)
-                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(tokens));
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("tokens");
+
+                this.tokens = tokens;
+                this.canMatchLocalId = canMatchLocalId;
+            }
+
+            protected override bool TryResolveSecurityKeyCore(SecurityKeyIdentifierClause keyIdentifierClause, out SecurityKey key)
+            {
+                if (keyIdentifierClause == null)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("keyIdentifierClause");
+
+                key = null;
+                for (int i = 0; i < this.tokens.Count; ++i)
+                {
+                    SecurityKey securityKey = this.tokens[i].ResolveKeyIdentifierClause(keyIdentifierClause);
+                    if (securityKey != null)
+                    {
+                        key = securityKey;
+                        return true;
+                    }
+                }
+
+                if (keyIdentifierClause is EncryptedKeyIdentifierClause)
+                {
+                    EncryptedKeyIdentifierClause keyClause = (EncryptedKeyIdentifierClause)keyIdentifierClause;
+                    SecurityKeyIdentifier keyIdentifier = keyClause.EncryptingKeyIdentifier;
+                    if (keyIdentifier != null && keyIdentifier.Count > 0)
+                    {
+                        for (int i = 0; i < keyIdentifier.Count; i++)
+                        {
+                            SecurityKey unwrappingSecurityKey = null;
+                            if (TryResolveSecurityKey(keyIdentifier[i], out unwrappingSecurityKey))
+                            {
+                                byte[] wrappedKey = keyClause.GetEncryptedKey();
+                                string wrappingAlgorithm = keyClause.EncryptionMethod;
+                                byte[] unwrappedKey = unwrappingSecurityKey.DecryptKey(wrappingAlgorithm, wrappedKey);
+                                key = new InMemorySymmetricSecurityKey(unwrappedKey, false);
+                                return true;
+                            }
+                        }
+                    }
+                }
+
+                return key != null;
+            }
+
+            protected override bool TryResolveTokenCore(SecurityKeyIdentifier keyIdentifier, out SecurityToken token)
+            {
+                if (keyIdentifier == null)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("keyIdentifier");
+
+                token = null;
+                for (int i = 0; i < keyIdentifier.Count; ++i)
+                {
+
+                    SecurityToken securityToken = ResolveSecurityToken(keyIdentifier[i]);
+                    if (securityToken != null)
+                    {
+                        token = securityToken;
+                        break;
+                    }
+                }
+
+                return (token != null);
+            }
+
+            protected override bool TryResolveTokenCore(SecurityKeyIdentifierClause keyIdentifierClause, out SecurityToken token)
+            {
+                if (keyIdentifierClause == null)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("keyIdentifierClause");
+
+                token = null;
+
+                SecurityToken securityToken = ResolveSecurityToken(keyIdentifierClause);
+                if (securityToken != null)
+                    token = securityToken;
+
+                return (token != null);
+            }
+
+            SecurityToken ResolveSecurityToken(SecurityKeyIdentifierClause keyIdentifierClause)
+            {
+                if (keyIdentifierClause == null)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("keyIdentifierClause");
+
+                if (!this.canMatchLocalId && keyIdentifierClause is LocalIdKeyIdentifierClause)
+                    return null;
+
+                for (int i = 0; i < this.tokens.Count; ++i)
+                {
+                    if (this.tokens[i].MatchesKeyIdentifierClause(keyIdentifierClause))
+                        return this.tokens[i];
+                }
 
-                _tokens = tokens;
-                _canMatchLocalId = canMatchLocalId;
+                return null;
             }
         }
     }
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Selectors/SecurityTokenSerializer.cs b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Selectors/SecurityTokenSerializer.cs
index 7e10afa..857bbd2 100644
--- a/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Selectors/SecurityTokenSerializer.cs
+++ b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Selectors/SecurityTokenSerializer.cs
@@ -13,7 +13,7 @@ namespace CoreWCF.IdentityModel.Selectors
     /// The SecurityTokenSerializer is stateless
     /// Exceptions: XmlException, SecurityTokenException, NotSupportedException, InvalidOperationException, ArgumentException
     /// </summary>
-    internal abstract class SecurityTokenSerializer
+    public abstract class SecurityTokenSerializer
     {
         // public methods
         public bool CanReadToken(XmlReader reader)
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/SignatureResourcePool.cs b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/SignatureResourcePool.cs
new file mode 100644
index 0000000..2952bb7
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/SignatureResourcePool.cs
@@ -0,0 +1,123 @@
+using System.IO;
+using System.Security.Cryptography;
+using CoreWCF.IdentityModel.Tokens;
+using System.Xml;
+using System.Text;
+
+namespace CoreWCF.IdentityModel
+{
+    // for sequential use by one thread
+    sealed class SignatureResourcePool
+    {
+        const int BufferSize = 64;
+        CanonicalizationDriver canonicalizationDriver;
+        HashStream hashStream;
+        HashAlgorithm hashAlgorithm;
+#if NO
+        XmlC14NWriter integratedWriter;
+#endif
+        XmlDictionaryWriter utf8Writer;
+        byte[] encodingBuffer;
+        char[] base64Buffer;
+
+        public char[] TakeBase64Buffer()
+        {
+            if (this.base64Buffer == null)
+            {
+                this.base64Buffer = new char[BufferSize];
+            }
+            return this.base64Buffer;
+        }
+
+        public CanonicalizationDriver TakeCanonicalizationDriver()
+        {
+            if (this.canonicalizationDriver == null)
+            {
+                this.canonicalizationDriver = new CanonicalizationDriver();
+            }
+            else
+            {
+                this.canonicalizationDriver.Reset();
+            }
+            return this.canonicalizationDriver;
+        }
+
+        public byte[] TakeEncodingBuffer()
+        {
+            if (this.encodingBuffer == null)
+            {
+                this.encodingBuffer = new byte[BufferSize];
+            }
+            return this.encodingBuffer;
+        }
+
+        public HashAlgorithm TakeHashAlgorithm(string algorithm)
+        {
+            if (this.hashAlgorithm == null)
+            {
+                if (string.IsNullOrEmpty(algorithm))
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgument(algorithm, SR.Format("EmptyOrNullArgumentString", "algorithm"));
+                }
+
+                this.hashAlgorithm = CryptoHelper.CreateHashAlgorithm(algorithm);
+            }
+            else
+            {
+                this.hashAlgorithm.Initialize();
+            }
+
+            return this.hashAlgorithm;
+        }
+
+        public HashStream TakeHashStream(HashAlgorithm hash)
+        {
+            if (this.hashStream == null)
+            {
+                this.hashStream = new HashStream(hash);
+            }
+            else
+            {
+                this.hashStream.Reset(hash);
+            }
+            return this.hashStream;
+        }
+
+        public HashStream TakeHashStream(string algorithm)
+        {
+            return TakeHashStream(TakeHashAlgorithm(algorithm));
+        }
+#if NO
+        public XmlC14NWriter TakeIntegratedWriter(Stream stream)
+        {
+            return TakeIntegratedWriter(stream, false, null);
+        }
+ 
+        public XmlC14NWriter TakeIntegratedWriter(Stream stream, bool includeComments, string[] inclusivePrefixes)
+        {
+            if (this.integratedWriter == null)
+            {
+                this.integratedWriter = new XmlC14NWriter(stream, includeComments, inclusivePrefixes);
+            }
+            else
+            {
+                this.integratedWriter.SetOutput(stream, includeComments, inclusivePrefixes);
+            }
+            return this.integratedWriter;
+        }
+#endif
+
+        public XmlDictionaryWriter TakeUtf8Writer()
+        {
+            if (this.utf8Writer == null)
+            {
+                this.utf8Writer = XmlDictionaryWriter.CreateTextWriter(Stream.Null, Encoding.UTF8, false);
+            }
+            else
+            {
+                ((IXmlTextWriterInitializer)this.utf8Writer).SetOutput(Stream.Null, Encoding.UTF8, false);
+            }
+            return this.utf8Writer;
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/SignedXMLInternal.cs b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/SignedXMLInternal.cs
new file mode 100644
index 0000000..789b693
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/SignedXMLInternal.cs
@@ -0,0 +1,74 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Security.Cryptography.Xml;
+using System.Text;
+using System.Xml;
+using System.Xml.Linq;
+
+namespace CoreWCF.IdentityModel
+{
+    /// <summary>
+    /// Internal class to override GetIdElement
+    /// </summary>
+    class SignedXMLInternal : SignedXml
+    {
+
+        public SignedXMLInternal(): base()
+        {
+
+        }
+        public SignedXMLInternal(XmlDocument document):base(document)
+        {
+
+        }
+        public SignedXMLInternal(XmlElement elem) : base(elem)
+        {
+
+        }
+        public override XmlElement GetIdElement(XmlDocument document, string idValue)
+        {
+            
+            XmlElement element =  base.GetIdElement(document, idValue);
+            if(element == null)
+            {
+                element = GetElementByIdInternal(document, idValue);
+            }
+            return element;
+        }
+
+        private XmlElement GetElementByIdInternal(XmlDocument document, String idValue)
+        {
+            XElement xElement = XDocument.Load(document.CreateNavigator().ReadSubtree()).Root;
+            xElement = FindXlement(xElement, idValue);
+            if (xElement == null)
+                return null;
+            var doc = new XmlDocument();
+            using (XmlReader reader = xElement.CreateReader())
+            {
+                doc.Load(reader);
+            }
+            return doc.DocumentElement;
+
+        }
+        private XElement FindXlement(XElement element, String idValue)
+        {
+            var attributes = element.Attributes();
+            foreach (var attr in attributes)
+            {
+                if (String.Compare(attr.Name.LocalName, "id", true) == 0 
+                    && String.Compare(attr.Value, idValue,true)==0 )
+                {
+                    return element;
+                }
+            };
+            XElement finalResult = null;
+            foreach (var child in element.Descendants())
+            {
+                finalResult = FindXlement(child, idValue);
+                if (finalResult != null)
+                    return finalResult;
+            }
+            return finalResult;
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/StandardTransformFactory.cs b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/StandardTransformFactory.cs
new file mode 100644
index 0000000..d3bd037
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/StandardTransformFactory.cs
@@ -0,0 +1,41 @@
+﻿using System;
+using CoreWCF.IdentityModel.Tokens;
+using System.Security.Cryptography;
+
+namespace CoreWCF.IdentityModel
+{
+    class StandardTransformFactory : TransformFactory
+    {
+        static StandardTransformFactory instance = new StandardTransformFactory();
+
+        protected StandardTransformFactory() { }
+
+        internal static StandardTransformFactory Instance
+        {
+            get { return instance; }
+        }
+
+        public override Transform CreateTransform(string transformAlgorithmUri)
+        {
+            if (transformAlgorithmUri == SecurityAlgorithms.ExclusiveC14n)
+            {
+                throw new NotImplementedException();
+              //  return new ExclusiveCanonicalizationTransform();
+            }
+            else if (transformAlgorithmUri == SecurityAlgorithms.ExclusiveC14nWithComments)
+            {
+                throw new NotImplementedException();
+
+                //  return new ExclusiveCanonicalizationTransform(false, true);
+            }
+            else if (transformAlgorithmUri == SecurityAlgorithms.StrTransform)
+            {
+                return new StrTransform();
+            }
+            else
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new CryptographicException(SR.Format("UnsupportedTransformAlgorithm")));
+            }
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/StrTransForm.cs b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/StrTransForm.cs
new file mode 100644
index 0000000..b2e6d46
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/StrTransForm.cs
@@ -0,0 +1,288 @@
+﻿using CoreWCF.IdentityModel.Tokens;
+using System;
+using System.Collections.Generic;
+using System.IO;
+using System.Security.Cryptography;
+using System.Text;
+using System.Xml;
+
+namespace CoreWCF.IdentityModel
+{
+    class StrTransform : Transform
+    {
+        readonly bool includeComments;
+        string inclusiveNamespacesPrefixList;
+        string[] inclusivePrefixes;
+        string prefix = XmlSignatureStrings.Prefix;
+        TranformationParameters transformationParameters;
+
+        public StrTransform()
+        {
+            this.transformationParameters = new TranformationParameters();
+            this.includeComments = false;
+        }
+
+        public override string Algorithm
+        {
+            get
+            {
+                return SecurityAlgorithms.StrTransform;
+            }
+        }
+
+        public bool IncludeComments
+        {
+            get
+            {
+                return this.includeComments;
+            }
+        }
+
+        public string InclusiveNamespacesPrefixList
+        {
+            get
+            {
+                return this.inclusiveNamespacesPrefixList;
+            }
+            set
+            {
+                this.inclusiveNamespacesPrefixList = value;
+                this.inclusivePrefixes = TokenizeInclusivePrefixList(value);
+            }
+        }
+
+        public override bool NeedsInclusiveContext
+        {
+            get { return GetInclusivePrefixes() != null; }
+        }
+
+        public string[] GetInclusivePrefixes()
+        {
+            return this.inclusivePrefixes;
+        }
+
+        CanonicalizationDriver GetConfiguredDriver(SignatureResourcePool resourcePool)
+        {
+            CanonicalizationDriver driver = resourcePool.TakeCanonicalizationDriver();
+            driver.IncludeComments = this.IncludeComments;
+            driver.SetInclusivePrefixes(this.inclusivePrefixes);
+            return driver;
+        }
+
+        public override object Process(object input, SignatureResourcePool resourcePool, DictionaryManager dictionaryManager)
+        {
+            if (input is XmlReader)
+            {
+                CanonicalizationDriver driver = GetConfiguredDriver(resourcePool);
+                driver.SetInput(input as XmlReader);
+                return driver.GetMemoryStream();
+            }
+            else if (input is ISecurityElement)
+            {
+                MemoryStream stream = new MemoryStream();
+                XmlDictionaryWriter utf8Writer = resourcePool.TakeUtf8Writer();
+                utf8Writer.StartCanonicalization(stream, false, null);
+                (input as ISecurityElement).WriteTo(utf8Writer, dictionaryManager);
+                utf8Writer.EndCanonicalization();
+                stream.Seek(0, SeekOrigin.Begin);
+                return stream;
+            }
+            else
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new NotSupportedException(SR.Format("UnsupportedInputTypeForTransform", input.GetType())));
+            }
+        }
+
+        public override byte[] ProcessAndDigest(object input, SignatureResourcePool resourcePool, string digestAlgorithm, DictionaryManager dictionaryManager)
+        {
+            HashAlgorithm hash = resourcePool.TakeHashAlgorithm(digestAlgorithm);
+            ProcessAndDigest(input, resourcePool, hash, dictionaryManager);
+            return hash.Hash;
+        }
+
+        public void ProcessAndDigest(object input, SignatureResourcePool resourcePool, HashAlgorithm hash, DictionaryManager dictionaryManger)
+        {
+            HashStream hashStream = resourcePool.TakeHashStream(hash);
+
+            XmlReader reader = input as XmlReader;
+            if (reader != null)
+            {
+                ProcessReaderInput(reader, resourcePool, hashStream);
+            }
+            else if (input is ISecurityElement)
+            {
+                XmlDictionaryWriter utf8Writer = resourcePool.TakeUtf8Writer();
+                utf8Writer.StartCanonicalization(hashStream, this.IncludeComments, GetInclusivePrefixes());
+                (input as ISecurityElement).WriteTo(utf8Writer, dictionaryManger);
+                utf8Writer.EndCanonicalization();
+            }
+            else
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new NotSupportedException(SR.Format("UnsupportedInputTypeForTransform", input.GetType())));
+            }
+
+            hashStream.FlushHash();
+        }
+
+        void ProcessReaderInput(XmlReader reader, SignatureResourcePool resourcePool, HashStream hashStream)
+        {
+            reader.MoveToContent();
+            XmlDictionaryReader dictionaryReader = reader as XmlDictionaryReader;
+            if (dictionaryReader != null && dictionaryReader.CanCanonicalize)
+            {
+                dictionaryReader.StartCanonicalization(hashStream, this.IncludeComments, GetInclusivePrefixes());
+                dictionaryReader.Skip();
+                dictionaryReader.EndCanonicalization();
+            }
+            else
+            {
+                CanonicalizationDriver driver = GetConfiguredDriver(resourcePool);
+                driver.SetInput(reader);
+                driver.WriteTo(hashStream);
+            }
+        }
+
+        public override void ReadFrom(XmlDictionaryReader reader, DictionaryManager dictionaryManager, bool preserveComments)
+        {
+            reader.MoveToStartElement(dictionaryManager.XmlSignatureDictionary.Transform, dictionaryManager.XmlSignatureDictionary.Namespace);
+            this.prefix = reader.Prefix;
+            bool isEmptyElement = reader.IsEmptyElement;
+            string algorithm = reader.GetAttribute(dictionaryManager.XmlSignatureDictionary.Algorithm, null);
+            if (algorithm != this.Algorithm)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new CryptographicException(SR.Format("AlgorithmMismatchForTransform")));
+            }
+
+            reader.MoveToContent();
+            reader.Read();
+
+            if (!isEmptyElement)
+            {
+                if (reader.IsStartElement(XmlSignatureStrings.TransformationParameters, XmlSignatureStrings.SecurityJan2004Namespace))
+                {
+                    this.transformationParameters.ReadFrom(reader, dictionaryManager);
+                }
+
+                reader.MoveToContent();
+                reader.ReadEndElement();
+            }
+        }
+
+        public override void WriteTo(XmlDictionaryWriter writer, DictionaryManager dictionaryManager)
+        {
+            writer.WriteStartElement(prefix, dictionaryManager.XmlSignatureDictionary.Transform, dictionaryManager.XmlSignatureDictionary.Namespace);
+            writer.WriteStartAttribute(dictionaryManager.XmlSignatureDictionary.Algorithm, null);
+            writer.WriteString(this.Algorithm);
+            writer.WriteEndAttribute();
+            this.transformationParameters.WriteTo(writer, dictionaryManager);
+            writer.WriteEndElement(); // Transform
+        }
+
+        static string[] TokenizeInclusivePrefixList(string prefixList)
+        {
+            if (prefixList == null)
+            {
+                return null;
+            }
+            string[] prefixes = prefixList.Split(null);
+            int count = 0;
+            for (int i = 0; i < prefixes.Length; i++)
+            {
+                string prefix = prefixes[i];
+                if (prefix == "#default")
+                {
+                    prefixes[count++] = string.Empty;
+                }
+                else if (prefix.Length > 0)
+                {
+                    prefixes[count++] = prefix;
+                }
+            }
+            if (count == 0)
+            {
+                return null;
+            }
+            else if (count == prefixes.Length)
+            {
+                return prefixes;
+            }
+            else
+            {
+                string[] result = new string[count];
+                Array.Copy(prefixes, result, count);
+                return result;
+            }
+        }
+    }
+
+    class TranformationParameters
+    {
+        public TranformationParameters()
+        {
+        }
+
+        public string CanonicalizationAlgorithm
+        {
+            get { return CoreWCF.XD.SecurityAlgorithmDictionary.ExclusiveC14n.Value; }
+        }
+
+        public void ReadFrom(XmlDictionaryReader reader, DictionaryManager dictionaryManager)
+        {
+            reader.MoveToContent();
+            reader.MoveToStartElement(XmlSignatureStrings.TransformationParameters, XmlSignatureStrings.SecurityJan2004Namespace);
+            string prefix = reader.Prefix;
+
+            bool skipReadingTransformEnd = reader.IsEmptyElement;
+            reader.ReadStartElement();
+
+            if (reader.IsStartElement(dictionaryManager.XmlSignatureDictionary.CanonicalizationMethod, dictionaryManager.XmlSignatureDictionary.Namespace))
+            {
+
+                string algorithm = reader.GetAttribute(dictionaryManager.XmlSignatureDictionary.Algorithm, null);
+                // Canonicalization Method can be empty.
+                // <elementNOTempty></elementNOTempty>
+                // <elementEmpty/>
+                bool skipReadingC14End = reader.IsEmptyElement;
+
+                reader.ReadStartElement();
+
+                if (algorithm == null)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new CryptographicException(
+                        SR.Format(SR.RequiredAttributeMissing, dictionaryManager.XmlSignatureDictionary.Algorithm, dictionaryManager.XmlSignatureDictionary.CanonicalizationMethod)));
+                }
+
+                if (algorithm != this.CanonicalizationAlgorithm)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new CryptographicException(SR.Format("AlgorithmMismatchForTransform")));
+                }
+
+
+                // ReadEndElement() called only if element was not empty
+                if (!skipReadingC14End)
+                {
+                    reader.MoveToContent();
+                    reader.ReadEndElement();
+                }
+            }
+
+            // If it was empty, don't read endElement as it was read in ReadStartElement
+            if (!skipReadingTransformEnd)
+            {
+                reader.MoveToContent();
+                reader.ReadEndElement();
+            }
+        }
+
+        public void WriteTo(XmlDictionaryWriter writer, DictionaryManager dictionaryManager)
+        {
+            writer.WriteStartElement(XmlSignatureStrings.SecurityJan2004Prefix, XmlSignatureStrings.TransformationParameters, XmlSignatureStrings.SecurityJan2004Namespace);  //<wsse:TransformationParameters>
+            writer.WriteStartElement(dictionaryManager.XmlSignatureDictionary.Prefix.Value, dictionaryManager.XmlSignatureDictionary.CanonicalizationMethod, dictionaryManager.XmlSignatureDictionary.Namespace);
+            writer.WriteStartAttribute(dictionaryManager.XmlSignatureDictionary.Algorithm, null);
+            writer.WriteString(dictionaryManager.SecurityAlgorithmDictionary.ExclusiveC14n);
+            writer.WriteEndAttribute();
+            writer.WriteEndElement(); // CanonicalizationMethod 
+            writer.WriteEndElement(); // TransformationParameters
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Tokens/AggregateTokenResolver.cs b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Tokens/AggregateTokenResolver.cs
new file mode 100644
index 0000000..0be02e3
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Tokens/AggregateTokenResolver.cs
@@ -0,0 +1,137 @@
+﻿
+using System.Collections.Generic;
+using System.Collections.ObjectModel;
+using CoreWCF.IdentityModel.Selectors;
+using CoreWCF;
+
+namespace CoreWCF.IdentityModel.Tokens
+{
+    /// <summary>
+    /// This class defines a TokenResolver that can wrap multiple Token Resolvers 
+    /// and resolve tokens across all the wrapped token resolvers.
+    /// </summary>
+    internal class AggregateTokenResolver : SecurityTokenResolver
+    {
+        private List<SecurityTokenResolver> _tokenResolvers = new List<SecurityTokenResolver>();
+
+        /// <summary>
+        /// Initializes an instance of <see cref="AggregateTokenResolver"/>
+        /// </summary>
+        /// <param name="tokenResolvers">IEnumerable list of TokenResolvers to be wrapped.</param>
+        /// <exception cref="ArgumentNullException">The input argument 'tokenResolvers' is null.</exception>
+        /// <exception cref="ArgumentException">The input 'tokenResolver' list does not contain a valid
+        /// SecurityTokenResolver. At least one SecurityTokenResolver should be specified.</exception>
+        public AggregateTokenResolver(IEnumerable<SecurityTokenResolver> tokenResolvers)
+        {
+            if (tokenResolvers == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(tokenResolvers));
+            }
+
+            AddNonEmptyResolvers(tokenResolvers);
+        }
+
+        /// <summary>
+        /// Gets a read-only collection of TokenResolvers.
+        /// </summary>
+        public ReadOnlyCollection<SecurityTokenResolver> TokenResolvers
+        {
+            get
+            {
+                return _tokenResolvers.AsReadOnly();
+            }
+        }
+
+        /// <summary>
+        /// Override of the base class. Resolves the given SecurityKeyIdentifierClause to a 
+        /// SecurityKey.
+        /// </summary>
+        /// <param name="keyIdentifierClause">The Clause to be resolved.</param>
+        /// <param name="key">The resolved SecurityKey</param>
+        /// <returns>True if successfully resolved.</returns>
+        /// <exception cref="ArgumentNullException">Input argument 'keyIdentifierClause' is null.</exception>
+        protected override bool TryResolveSecurityKeyCore(SecurityKeyIdentifierClause keyIdentifierClause, out SecurityKey key)
+        {
+            if (keyIdentifierClause == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(keyIdentifierClause));
+            }
+
+            key = null;
+            foreach (SecurityTokenResolver tokenResolver in _tokenResolvers)
+            {
+                if (tokenResolver.TryResolveSecurityKey(keyIdentifierClause, out key))
+                {
+                    return true;
+                }
+            }
+
+            return false;
+        }
+
+        /// <summary>
+        /// Override of the base class. Resolves the given SecurityKeyIdentifier to a 
+        /// SecurityToken.
+        /// </summary>
+        /// <param name="keyIdentifier">The KeyIdentifier to be resolved.</param>
+        /// <param name="token">The resolved SecurityToken</param>
+        /// <returns>True if successfully resolved.</returns>
+        /// <exception cref="ArgumentNullException">Input argument 'keyIdentifier' is null.</exception>
+        protected override bool TryResolveTokenCore(SecurityKeyIdentifier keyIdentifier, out SecurityToken token)
+        {
+            if (keyIdentifier == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(keyIdentifier));
+            }
+
+            token = null;
+            foreach (SecurityTokenResolver tokenResolver in _tokenResolvers)
+            {
+                if (tokenResolver.TryResolveToken(keyIdentifier, out token))
+                {
+                    return true;
+                }
+            }
+
+            return false;
+        }
+
+        /// <summary>
+        /// Override of the base class. Resolves the given SecurityKeyIdentifierClause to a 
+        /// SecurityToken.
+        /// </summary>
+        /// <param name="keyIdentifierClause">The KeyIdentifier to be resolved.</param>
+        /// <param name="token">The resolved SecurityToken</param>
+        /// <returns>True if successfully resolved.</returns>
+        /// <exception cref="ArgumentNullException">Input argument 'keyIdentifierClause' is null.</exception>
+        protected override bool TryResolveTokenCore(SecurityKeyIdentifierClause keyIdentifierClause, out SecurityToken token)
+        {
+            if (keyIdentifierClause == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(keyIdentifierClause));
+            }
+
+            token = null;
+            foreach (SecurityTokenResolver tokenResolver in _tokenResolvers)
+            {
+                if (tokenResolver.TryResolveToken(keyIdentifierClause, out token))
+                {
+                    return true;
+                }
+            }
+
+            return false;
+        }
+
+        private void AddNonEmptyResolvers(IEnumerable<SecurityTokenResolver> resolvers)
+        {
+            foreach (SecurityTokenResolver resolver in resolvers)
+            {
+                if (resolver != null ) // && resolver != EmptySecurityTokenResolver.Instance)
+                {
+                    _tokenResolvers.Add(resolver);
+                }
+            }
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Tokens/AsymmetricSecurityKey.cs b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Tokens/AsymmetricSecurityKey.cs
new file mode 100644
index 0000000..afdfec3
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Tokens/AsymmetricSecurityKey.cs
@@ -0,0 +1,16 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Text;
+using System.Security.Cryptography;
+
+namespace CoreWCF.IdentityModel.Tokens
+{
+    public abstract class AsymmetricSecurityKey : SecurityKey
+    {
+        public abstract AsymmetricAlgorithm GetAsymmetricAlgorithm(string algorithm, bool privateKey);
+        public abstract HashAlgorithm GetHashAlgorithmForSignature(string algorithm);
+        public abstract AsymmetricSignatureDeformatter GetSignatureDeformatter(string algorithm);
+        public abstract AsymmetricSignatureFormatter GetSignatureFormatter(string algorithm);
+        public abstract bool HasPrivateKey();
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Tokens/BinaryKeyIdentifierClause.cs b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Tokens/BinaryKeyIdentifierClause.cs
new file mode 100644
index 0000000..75a543c
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Tokens/BinaryKeyIdentifierClause.cs
@@ -0,0 +1,75 @@
+﻿
+using CoreWCF;
+using System;
+
+namespace CoreWCF.IdentityModel.Tokens
+{
+    public abstract class BinaryKeyIdentifierClause : SecurityKeyIdentifierClause
+    {
+        private readonly byte[] _identificationData;
+
+        protected BinaryKeyIdentifierClause(string clauseType, byte[] identificationData, bool cloneBuffer)
+            : this(clauseType, identificationData, cloneBuffer, null, 0)
+        {
+        }
+
+        protected BinaryKeyIdentifierClause(string clauseType, byte[] identificationData, bool cloneBuffer, byte[] derivationNonce, int derivationLength)
+            : base(clauseType, derivationNonce, derivationLength)
+        {
+            if (identificationData == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException(nameof(identificationData)));
+            }
+            if (identificationData.Length == 0)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(identificationData), "LengthMustBeGreaterThanZero"));
+            }
+
+            if (cloneBuffer)
+            {
+                _identificationData = SecurityUtils.CloneBuffer(identificationData);
+            }
+            else
+            {
+                _identificationData = identificationData;
+            }
+        }
+
+        public byte[] GetBuffer()
+        {
+            return SecurityUtils.CloneBuffer(_identificationData);
+        }
+
+        protected byte[] GetRawBuffer()
+        {
+            return _identificationData;
+        }
+
+        public override bool Matches(SecurityKeyIdentifierClause keyIdentifierClause)
+        {
+            BinaryKeyIdentifierClause that = keyIdentifierClause as BinaryKeyIdentifierClause;
+            return ReferenceEquals(this, that) || (that != null && that.Matches(_identificationData));
+        }
+
+        public bool Matches(byte[] data)
+        {
+            return Matches(data, 0);
+        }
+
+        public bool Matches(byte[] data, int offset)
+        {
+            if (offset < 0)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(offset), SR.ValueMustBeNonNegative));
+            }
+            return SecurityUtils.MatchesBuffer(_identificationData, 0, data, offset);
+        }
+
+        internal string ToBase64String()
+        {
+            return Convert.ToBase64String(_identificationData);
+        }
+
+       
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Tokens/DerivedKeySecurityToken.cs b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Tokens/DerivedKeySecurityToken.cs
new file mode 100644
index 0000000..7e49cde
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Tokens/DerivedKeySecurityToken.cs
@@ -0,0 +1,298 @@
+using System.Collections;
+using CoreWCF;
+using System.Collections.Generic;
+using System.Collections.ObjectModel;
+using System.Globalization;
+using System.IO;
+using CoreWCF.IdentityModel.Claims;
+using CoreWCF.IdentityModel.Policy;
+using CoreWCF.IdentityModel.Tokens;
+using CoreWCF.IdentityModel.Selectors;
+using System.Security.Cryptography;
+using System.Text;
+using System.Xml;
+using CoreWCF.IdentityModel;
+using System;
+
+namespace CoreWCF.Security.Tokens
+{
+
+    sealed class DerivedKeySecurityToken : SecurityToken
+    {
+        //        public const string DefaultLabel = "WS-SecureConversationWS-SecureConversation";
+        static readonly byte[] DefaultLabel = new byte[]
+            {
+                (byte)'W', (byte)'S', (byte)'-', (byte)'S', (byte)'e', (byte)'c', (byte)'u', (byte)'r', (byte)'e',
+                (byte)'C', (byte)'o', (byte)'n', (byte)'v', (byte)'e', (byte)'r', (byte)'s', (byte)'a', (byte)'t', (byte)'i', (byte)'o', (byte)'n',
+                (byte)'W', (byte)'S', (byte)'-', (byte)'S', (byte)'e', (byte)'c', (byte)'u', (byte)'r', (byte)'e',
+                (byte)'C', (byte)'o', (byte)'n', (byte)'v', (byte)'e', (byte)'r', (byte)'s', (byte)'a', (byte)'t', (byte)'i', (byte)'o', (byte)'n'
+            };
+
+        public const int DefaultNonceLength = 16;
+        public const int DefaultDerivedKeyLength = 32;
+
+        string id;
+        byte[] key;
+        string keyDerivationAlgorithm;
+        string label;
+        int length = -1;
+        byte[] nonce;
+        // either offset or generation must be specified.
+        int offset = -1;
+        int generation = -1;
+        SecurityToken tokenToDerive;
+        SecurityKeyIdentifierClause tokenToDeriveIdentifier;
+        ReadOnlyCollection<SecurityKey> securityKeys;
+
+        // create from scratch
+        public DerivedKeySecurityToken(SecurityToken tokenToDerive, SecurityKeyIdentifierClause tokenToDeriveIdentifier, int length)
+            : this(tokenToDerive, tokenToDeriveIdentifier, length, SecurityUtils.GenerateId())
+        {
+        }
+
+        internal DerivedKeySecurityToken(SecurityToken tokenToDerive, SecurityKeyIdentifierClause tokenToDeriveIdentifier,
+            int length, string id)
+        {
+            if (length != 16 && length != 24 && length != 32)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.Psha1KeyLengthInvalid, length * 8)));
+
+            byte[] nonce = new byte[DefaultNonceLength];
+            RNGCryptoServiceProvider rng = new RNGCryptoServiceProvider();
+            rng.GetBytes(nonce);
+
+            Initialize(id, -1, 0, length, null, nonce, tokenToDerive, tokenToDeriveIdentifier, SecurityAlgorithms.Psha1KeyDerivation);
+        }
+
+        internal DerivedKeySecurityToken(int generation, int offset, int length,
+            string label, int minNonceLength, SecurityToken tokenToDerive,
+            SecurityKeyIdentifierClause tokenToDeriveIdentifier,
+            string derivationAlgorithm, string id)
+        {
+            byte[] nonce = new byte[minNonceLength];
+            RNGCryptoServiceProvider rng = new RNGCryptoServiceProvider();
+            rng.GetBytes(nonce);
+
+            Initialize(id, generation, offset, length, label, nonce, tokenToDerive, tokenToDeriveIdentifier, derivationAlgorithm);
+        }
+
+        // create from xml
+        internal DerivedKeySecurityToken(int generation, int offset, int length,
+            string label, byte[] nonce, SecurityToken tokenToDerive,
+            SecurityKeyIdentifierClause tokenToDeriveIdentifier, string derivationAlgorithm, string id)
+        {
+            Initialize(id, generation, offset, length, label, nonce, tokenToDerive, tokenToDeriveIdentifier, derivationAlgorithm, false);
+        }
+
+        public override string Id
+        {
+            get { return this.id; }
+        }
+
+        public override DateTime ValidFrom
+        {
+            get { return this.tokenToDerive.ValidFrom; }
+        }
+
+        public override DateTime ValidTo
+        {
+            get { return this.tokenToDerive.ValidTo; }
+        }
+
+        public string KeyDerivationAlgorithm
+        {
+            get { return keyDerivationAlgorithm; }
+        }
+
+        public int Generation
+        {
+            get { return this.generation; }
+        }
+
+        public string Label
+        {
+            get { return this.label; }
+        }
+
+        public int Length
+        {
+            get { return this.length; }
+        }
+
+        internal byte[] Nonce
+        {
+            get { return this.nonce; }
+        }
+
+        public int Offset
+        {
+            get { return this.offset; }
+        }
+
+        internal SecurityToken TokenToDerive
+        {
+            get { return this.tokenToDerive; }
+        }
+
+        internal SecurityKeyIdentifierClause TokenToDeriveIdentifier
+        {
+            get { return this.tokenToDeriveIdentifier; }
+        }
+
+        public override ReadOnlyCollection<SecurityKey> SecurityKeys
+        {
+            get
+            {
+                if (this.securityKeys == null)
+                {
+#pragma warning suppress 56503
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.DerivedKeyNotInitialized)));
+                }
+                return this.securityKeys;
+            }
+        }
+
+      
+
+        public byte[] GetKeyBytes()
+        {
+            return SecurityUtils.CloneBuffer(this.key);
+        }
+
+        public byte[] GetNonce()
+        {
+            return SecurityUtils.CloneBuffer(this.nonce);
+        }
+
+        internal bool TryGetSecurityKeys(out ReadOnlyCollection<SecurityKey> keys)
+        {
+            keys = this.securityKeys;
+            return (keys != null);
+        }
+
+        public override string ToString()
+        {
+            StringWriter writer = new StringWriter(CultureInfo.InvariantCulture);
+            writer.WriteLine("DerivedKeySecurityToken:");
+            writer.WriteLine("   Generation: {0}", this.Generation);
+            writer.WriteLine("   Offset: {0}", this.Offset);
+            writer.WriteLine("   Length: {0}", this.Length);
+            writer.WriteLine("   Label: {0}", this.Label);
+            writer.WriteLine("   Nonce: {0}", Convert.ToBase64String(this.Nonce));
+            writer.WriteLine("   TokenToDeriveFrom:");
+            using (XmlTextWriter xmlWriter = new XmlTextWriter(writer))
+            {
+                xmlWriter.Formatting = Formatting.Indented;
+                SecurityStandardsManager.DefaultInstance.SecurityTokenSerializer.WriteKeyIdentifierClause(XmlDictionaryWriter.CreateDictionaryWriter(xmlWriter), this.TokenToDeriveIdentifier);
+            }
+            return writer.ToString();
+        }
+
+        void Initialize(string id, int generation, int offset, int length, string label, byte[] nonce,
+            SecurityToken tokenToDerive, SecurityKeyIdentifierClause tokenToDeriveIdentifier, string derivationAlgorithm)
+        {
+            Initialize(id, generation, offset, length, label, nonce, tokenToDerive, tokenToDeriveIdentifier, derivationAlgorithm, true);
+        }
+
+        void Initialize(string id, int generation, int offset, int length, string label, byte[] nonce,
+            SecurityToken tokenToDerive, SecurityKeyIdentifierClause tokenToDeriveIdentifier, string derivationAlgorithm,
+            bool initializeDerivedKey)
+        {
+            if (id == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("id");
+            }
+            if (tokenToDerive == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("tokenToDerive");
+            }
+            if (tokenToDeriveIdentifier == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("tokentoDeriveIdentifier");
+            }
+
+            if (!SecurityUtils.IsSupportedAlgorithm(derivationAlgorithm, tokenToDerive))
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.DerivedKeyCannotDeriveFromSecret)));
+            }
+            if (nonce == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("nonce");
+            }
+            if (length == -1)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("length"));
+            }
+            if (offset == -1 && generation == -1)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgument(SR.Format(SR.DerivedKeyPosAndGenNotSpecified));
+            }
+            if (offset >= 0 && generation >= 0)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgument(SR.Format(SR.DerivedKeyPosAndGenBothSpecified));
+            }
+
+            this.id = id;
+            this.label = label;
+            this.nonce = nonce;
+            this.length = length;
+            this.offset = offset;
+            this.generation = generation;
+            this.tokenToDerive = tokenToDerive;
+            this.tokenToDeriveIdentifier = tokenToDeriveIdentifier;
+            this.keyDerivationAlgorithm = derivationAlgorithm;
+
+            if (initializeDerivedKey)
+            {
+                InitializeDerivedKey(this.length);
+            }
+        }
+
+        internal void InitializeDerivedKey(int maxKeyLength)
+        {
+            if (this.key != null)
+            {
+                return;
+            }
+            if (this.length > maxKeyLength)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgument(SR.Format(SR.DerivedKeyLengthTooLong, this.length, maxKeyLength));
+            }
+
+            this.key = SecurityUtils.GenerateDerivedKey(this.tokenToDerive, this.keyDerivationAlgorithm,
+                (this.label != null ? Encoding.UTF8.GetBytes(this.label) : DefaultLabel), this.nonce, this.length * 8,
+                ((this.offset >= 0) ? this.offset : this.generation * this.length));
+            if ((this.key == null) || (this.key.Length == 0))
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgument(SR.Format(SR.DerivedKeyCannotDeriveFromSecret));
+            }
+            List<SecurityKey> temp = new List<SecurityKey>(1);
+            temp.Add(new InMemorySymmetricSecurityKey(this.key, false));
+            this.securityKeys = temp.AsReadOnly();
+        }
+
+        internal void InitializeDerivedKey(ReadOnlyCollection<SecurityKey> securityKeys)
+        {
+            this.key = ((SymmetricSecurityKey)securityKeys[0]).GetSymmetricKey();
+            this.securityKeys = securityKeys;
+        }
+
+        internal static void EnsureAcceptableOffset(int offset, int generation, int length, int maxOffset)
+        {
+            if (offset != -1)
+            {
+                if (offset > maxOffset)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new MessageSecurityException(SR.Format(SR.DerivedKeyTokenOffsetTooHigh, offset, maxOffset)));
+                }
+            }
+            else
+            {
+                int effectiveOffset = generation * length;
+                if ((effectiveOffset < generation && effectiveOffset < length) || effectiveOffset > maxOffset)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new MessageSecurityException(SR.Format(SR.DerivedKeyTokenGenerationAndLengthTooHigh, generation, length, maxOffset)));
+                }
+            }
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Tokens/EncryptedKeyHashIdentifierClause.cs b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Tokens/EncryptedKeyHashIdentifierClause.cs
new file mode 100644
index 0000000..e2d9db0
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Tokens/EncryptedKeyHashIdentifierClause.cs
@@ -0,0 +1,35 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Globalization;
+using System.Text;
+
+namespace CoreWCF.IdentityModel.Tokens
+{
+    sealed class EncryptedKeyHashIdentifierClause : BinaryKeyIdentifierClause
+    {
+        public EncryptedKeyHashIdentifierClause(byte[] encryptedKeyHash)
+            : this(encryptedKeyHash, true)
+        {
+        }
+
+        internal EncryptedKeyHashIdentifierClause(byte[] encryptedKeyHash, bool cloneBuffer)
+            : this(encryptedKeyHash, cloneBuffer, null, 0)
+        {
+        }
+
+        internal EncryptedKeyHashIdentifierClause(byte[] encryptedKeyHash, bool cloneBuffer, byte[] derivationNonce, int derivationLength)
+            : base(null, encryptedKeyHash, cloneBuffer, derivationNonce, derivationLength)
+        {
+        }
+
+        public byte[] GetEncryptedKeyHash()
+        {
+            return GetBuffer();
+        }
+
+        public override string ToString()
+        {
+            return string.Format(CultureInfo.InvariantCulture, "EncryptedKeyHashIdentifierClause(Hash = {0})", Convert.ToBase64String(GetRawBuffer()));
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Tokens/GenericXMLSecurityToken.cs b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Tokens/GenericXMLSecurityToken.cs
new file mode 100644
index 0000000..85293ee
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Tokens/GenericXMLSecurityToken.cs
@@ -0,0 +1,187 @@
+﻿using System;
+using System.Collections.ObjectModel;
+using System.Globalization;
+using System.IO;
+using CoreWCF.IdentityModel.Claims;
+using CoreWCF.IdentityModel.Policy;
+using System.Security.Cryptography;
+using System.Security.Principal;
+using System.Xml;
+using System.Runtime.Serialization;
+using System.Collections.Generic;
+
+namespace CoreWCF.IdentityModel.Tokens
+{
+    public class GenericXmlSecurityToken : SecurityToken
+    {
+        const int SupportedPersistanceVersion = 1;
+        string id;
+        SecurityToken proofToken;
+        SecurityKeyIdentifierClause internalTokenReference;
+        SecurityKeyIdentifierClause externalTokenReference;
+        XmlElement tokenXml;
+        ReadOnlyCollection<IAuthorizationPolicy> authorizationPolicies;
+        DateTime effectiveTime;
+        DateTime expirationTime;
+
+        public GenericXmlSecurityToken(
+            XmlElement tokenXml,
+            SecurityToken proofToken,
+            DateTime effectiveTime,
+            DateTime expirationTime,
+            SecurityKeyIdentifierClause internalTokenReference,
+            SecurityKeyIdentifierClause externalTokenReference,
+            ReadOnlyCollection<IAuthorizationPolicy> authorizationPolicies
+            )
+        {
+            if (tokenXml == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("tokenXml");
+            }
+
+            this.id = GetId(tokenXml);
+            this.tokenXml = tokenXml;
+            this.proofToken = proofToken;
+            this.effectiveTime = effectiveTime.ToUniversalTime();
+            this.expirationTime = expirationTime.ToUniversalTime();
+
+            this.internalTokenReference = internalTokenReference;
+            this.externalTokenReference = externalTokenReference;
+            this.authorizationPolicies = authorizationPolicies ?? EmptyReadOnlyCollection<IAuthorizationPolicy>.Instance;
+        }
+
+        public override string Id
+        {
+            get { return this.id; }
+        }
+
+        public override DateTime ValidFrom
+        {
+            get { return this.effectiveTime; }
+        }
+
+        public override DateTime ValidTo
+        {
+            get { return this.expirationTime; }
+        }
+
+        public SecurityKeyIdentifierClause InternalTokenReference
+        {
+            get { return this.internalTokenReference; }
+        }
+
+        public SecurityKeyIdentifierClause ExternalTokenReference
+        {
+            get { return this.externalTokenReference; }
+        }
+
+        public XmlElement TokenXml
+        {
+            get { return this.tokenXml; }
+        }
+
+        public SecurityToken ProofToken
+        {
+            get { return this.proofToken; }
+        }
+
+        public ReadOnlyCollection<IAuthorizationPolicy> AuthorizationPolicies
+        {
+            get { return this.authorizationPolicies; }
+        }
+
+        public override ReadOnlyCollection<SecurityKey> SecurityKeys
+        {
+            get
+            {
+                if (this.proofToken != null)
+                    return this.proofToken.SecurityKeys;
+                else
+                    return EmptyReadOnlyCollection<SecurityKey>.Instance;
+            }
+        }
+
+        public override string ToString()
+        {
+            StringWriter writer = new StringWriter(CultureInfo.InvariantCulture);
+            writer.WriteLine("Generic XML token:");
+            writer.WriteLine("   validFrom: {0}", this.ValidFrom);
+            writer.WriteLine("   validTo: {0}", this.ValidTo);
+            if (this.internalTokenReference != null)
+                writer.WriteLine("   InternalTokenReference: {0}", this.internalTokenReference);
+            if (this.externalTokenReference != null)
+                writer.WriteLine("   ExternalTokenReference: {0}", this.externalTokenReference);
+            writer.WriteLine("   Token Element: ({0}, {1})", this.tokenXml.LocalName, this.tokenXml.NamespaceURI);
+            return writer.ToString();
+        }
+
+        static string GetId(XmlElement tokenXml)
+        {
+            if (tokenXml != null)
+            {
+                string id = tokenXml.GetAttribute(UtilityStrings.IdAttribute, UtilityStrings.Namespace);
+                if (string.IsNullOrEmpty(id))
+                {
+                    // special case SAML 1.1 as this is the only possible ID as
+                    // spec is closed.  SAML 2.0 is xs:ID
+                    id = tokenXml.GetAttribute("AssertionID");
+
+                    // if we are still null, "Id"
+                    if (string.IsNullOrEmpty(id))
+                    {
+                        id = tokenXml.GetAttribute("Id");
+                    }
+
+                    //This fixes the unecnrypted SAML 2.0 case. Eg: <Assertion ID="_05955298-214f-41e7-b4c3-84dbff7f01b9" 
+                    if (string.IsNullOrEmpty(id))
+                    {
+                        id = tokenXml.GetAttribute("ID");
+                    }
+                }
+
+                if (!string.IsNullOrEmpty(id))
+                {
+                    return id;
+                }
+            }
+
+            return null;
+        }
+
+        public override bool CanCreateKeyIdentifierClause<T>()
+        {
+            if (this.internalTokenReference != null && typeof(T) == this.internalTokenReference.GetType())
+                return true;
+
+            if (this.externalTokenReference != null && typeof(T) == this.externalTokenReference.GetType())
+                return true;
+
+            return false;
+        }
+
+        public override T CreateKeyIdentifierClause<T>()
+        {
+            if (this.internalTokenReference != null && typeof(T) == this.internalTokenReference.GetType())
+                return (T)this.internalTokenReference;
+
+            if (this.externalTokenReference != null && typeof(T) == this.externalTokenReference.GetType())
+                return (T)this.externalTokenReference;
+
+            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new SecurityTokenException(SR.Format(SR.UnableToCreateTokenReference)));
+        }
+
+        public override bool MatchesKeyIdentifierClause(SecurityKeyIdentifierClause keyIdentifierClause)
+        {
+            if (this.internalTokenReference != null && this.internalTokenReference.Matches(keyIdentifierClause))
+            {
+                return true;
+            }
+            else if (this.externalTokenReference != null && this.externalTokenReference.Matches(keyIdentifierClause))
+            {
+                return true;
+            }
+
+            return false;
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Tokens/GenericXmlSecurityKeyIdentifierClause.cs b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Tokens/GenericXmlSecurityKeyIdentifierClause.cs
new file mode 100644
index 0000000..7d64b4a
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Tokens/GenericXmlSecurityKeyIdentifierClause.cs
@@ -0,0 +1,77 @@
+﻿using CoreWCF;
+using System.Xml;
+
+namespace CoreWCF.IdentityModel.Tokens
+{
+    public class GenericXmlSecurityKeyIdentifierClause : SecurityKeyIdentifierClause
+    {
+        public GenericXmlSecurityKeyIdentifierClause(XmlElement referenceXml)
+            : this(referenceXml, null, 0)
+        {
+        }
+
+        public GenericXmlSecurityKeyIdentifierClause(XmlElement referenceXml, byte[] derivationNonce, int derivationLength)
+            : base(null, derivationNonce, derivationLength)
+        {
+            ReferenceXml = referenceXml ?? throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(referenceXml));
+        }
+
+        public XmlElement ReferenceXml { get; }
+
+        public override bool Matches(SecurityKeyIdentifierClause keyIdentifierClause)
+        {
+            GenericXmlSecurityKeyIdentifierClause that = keyIdentifierClause as GenericXmlSecurityKeyIdentifierClause;
+            return ReferenceEquals(this, that) || (that != null && that.Matches(ReferenceXml));
+        }
+
+        private bool Matches(XmlElement xmlElement)
+        {
+            if (xmlElement == null)
+            {
+                return false;
+            }
+
+            return CompareNodes(ReferenceXml, xmlElement);
+        }
+
+        private bool CompareNodes(XmlNode originalNode, XmlNode newNode)
+        {
+            if (originalNode.OuterXml == newNode.OuterXml)
+            {
+                return true;
+            }
+
+            if (originalNode.LocalName != newNode.LocalName || originalNode.InnerText != newNode.InnerText)
+            {
+                return false;
+            }
+
+            if (originalNode.InnerXml == newNode.InnerXml)
+            {
+                return true;
+            }
+
+            if (originalNode.HasChildNodes)
+            {
+                if (!newNode.HasChildNodes || originalNode.ChildNodes.Count != newNode.ChildNodes.Count)
+                {
+                    return false;
+                }
+
+                bool childrenStatus = true;
+                for (int i = 0; i < originalNode.ChildNodes.Count; i++)
+                {
+                    childrenStatus = childrenStatus & CompareNodes(originalNode.ChildNodes[i], newNode.ChildNodes[i]);
+                }
+
+                return childrenStatus;
+            }
+            else if (newNode.HasChildNodes)
+            {
+                return false;
+            }
+
+            return true;
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Tokens/LocalIdKeyIdentifierClause.cs b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Tokens/LocalIdKeyIdentifierClause.cs
new file mode 100644
index 0000000..0887a74
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Tokens/LocalIdKeyIdentifierClause.cs
@@ -0,0 +1,89 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Text;
+using System.Globalization;
+
+namespace CoreWCF.IdentityModel.Tokens
+{
+    public class LocalIdKeyIdentifierClause : SecurityKeyIdentifierClause
+    {
+        readonly string localId;
+        readonly Type[] ownerTypes;
+
+        public LocalIdKeyIdentifierClause(string localId)
+            : this(localId, (Type[])null)
+        {
+        }
+
+        public LocalIdKeyIdentifierClause(string localId, Type ownerType)
+            : this(localId, ownerType == null ? (Type[])null : new Type[] { ownerType })
+        {
+        }
+
+        public LocalIdKeyIdentifierClause(string localId, byte[] derivationNonce, int derivationLength, Type ownerType)
+            : this(null, derivationNonce, derivationLength, ownerType == null ? (Type[])null : new Type[] { ownerType })
+        {
+        }
+
+        internal LocalIdKeyIdentifierClause(string localId, Type[] ownerTypes)
+            : this(localId, null, 0, ownerTypes)
+        {
+        }
+
+        internal LocalIdKeyIdentifierClause(string localId, byte[] derivationNonce, int derivationLength, Type[] ownerTypes)
+            : base(null, derivationNonce, derivationLength)
+        {
+            if (localId == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("localId");
+            }
+            if (localId == string.Empty)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgument(SR.Format("ID can't be empty."));
+            }
+            this.localId = localId;
+            this.ownerTypes = ownerTypes;
+        }
+
+        public string LocalId
+        {
+            get { return this.localId; }
+        }
+
+        public Type OwnerType
+        {
+            get { return (this.ownerTypes == null || this.ownerTypes.Length == 0) ? null : this.ownerTypes[0]; }
+        }
+
+        public override bool Matches(SecurityKeyIdentifierClause keyIdentifierClause)
+        {
+            LocalIdKeyIdentifierClause that = keyIdentifierClause as LocalIdKeyIdentifierClause;
+
+            // PreSharp Bug: Parameter 'that' to this public method must be validated: A null-dereference can occur here.
+#pragma warning suppress 56506
+            return ReferenceEquals(this, that) || (that != null && that.Matches(this.localId, this.OwnerType));
+        }
+
+        public bool Matches(string localId, Type ownerType)
+        {
+            if (string.IsNullOrEmpty(localId))
+                return false;
+            if (this.localId != localId)
+                return false;
+            if (this.ownerTypes == null || ownerType == null)
+                return true;
+
+            for (int i = 0; i < this.ownerTypes.Length; ++i)
+            {
+                if (this.ownerTypes[i] == null || this.ownerTypes[i] == ownerType)
+                    return true;
+            }
+            return false;
+        }
+
+        public override string ToString()
+        {
+            return string.Format(CultureInfo.InvariantCulture, "LocalIdKeyIdentifierClause(LocalId = '{0}', Owner = '{1}')", this.LocalId, this.OwnerType);
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Tokens/SecurityKeyIdentifier.cs b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Tokens/SecurityKeyIdentifier.cs
index 5895bb9..ddc4e52 100644
--- a/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Tokens/SecurityKeyIdentifier.cs
+++ b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Tokens/SecurityKeyIdentifier.cs
@@ -8,7 +8,7 @@ using System.Text;
 
 namespace CoreWCF.IdentityModel.Tokens
 {
-    internal class SecurityKeyIdentifier : IEnumerable<SecurityKeyIdentifierClause>
+    public class SecurityKeyIdentifier : IEnumerable<SecurityKeyIdentifierClause>
     {
         const int InitialSize = 2;
         readonly List<SecurityKeyIdentifierClause> clauses;
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Tokens/SecurityToken.cs b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Tokens/SecurityToken.cs
index 5f7da1d..4ecc569 100644
--- a/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Tokens/SecurityToken.cs
+++ b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Tokens/SecurityToken.cs
@@ -11,5 +11,41 @@ namespace CoreWCF.IdentityModel.Tokens
         public abstract ReadOnlyCollection<SecurityKey> SecurityKeys { get; }
         public abstract DateTime ValidFrom { get; }
         public abstract DateTime ValidTo { get; }
+
+        public virtual bool CanCreateKeyIdentifierClause<T>() where T : SecurityKeyIdentifierClause
+        {
+            return ((typeof(T) == typeof(LocalIdKeyIdentifierClause)) && CanCreateLocalKeyIdentifierClause());
+        }
+
+        public virtual T CreateKeyIdentifierClause<T>() where T : SecurityKeyIdentifierClause
+        {
+            if ((typeof(T) == typeof(LocalIdKeyIdentifierClause)) && CanCreateLocalKeyIdentifierClause())
+                return new LocalIdKeyIdentifierClause(this.Id, this.GetType()) as T;
+
+            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new NotSupportedException(
+                SR.Format(SR.TokenDoesNotSupportKeyIdentifierClauseCreation, GetType().Name, typeof(T).Name)));
+        }
+
+        public virtual bool MatchesKeyIdentifierClause(SecurityKeyIdentifierClause keyIdentifierClause)
+        {
+            LocalIdKeyIdentifierClause localKeyIdentifierClause = keyIdentifierClause as LocalIdKeyIdentifierClause;
+            if (localKeyIdentifierClause != null)
+                return localKeyIdentifierClause.Matches(this.Id, this.GetType());
+
+            return false;
+        }
+
+        public virtual SecurityKey ResolveKeyIdentifierClause(SecurityKeyIdentifierClause keyIdentifierClause)
+        {
+            if (this.SecurityKeys.Count != 0 && MatchesKeyIdentifierClause(keyIdentifierClause))
+                return this.SecurityKeys[0];
+
+            return null;
+        }
+
+        bool CanCreateLocalKeyIdentifierClause()
+        {
+            return (this.Id != null);
+        }
     }
 }
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Tokens/SymmetricKey.cs b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Tokens/SymmetricKey.cs
new file mode 100644
index 0000000..fd4dd5a
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Tokens/SymmetricKey.cs
@@ -0,0 +1,109 @@
+using System;
+using System.Security.Cryptography;
+using CoreWCF;
+
+namespace CoreWCF.IdentityModel.Tokens
+{
+    internal class InMemorySymmetricSecurityKey : SymmetricSecurityKey
+    {
+        private int _keySize;
+        private byte[] _symmetricKey;
+
+        public InMemorySymmetricSecurityKey(byte[] symmetricKey)
+            : this(symmetricKey, true)
+        {
+        }
+
+        public InMemorySymmetricSecurityKey(byte[] symmetricKey, bool cloneBuffer)
+        {
+            if (symmetricKey == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException(nameof(symmetricKey)));
+            }
+
+            if (symmetricKey.Length == 0)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format("SymmetricKeyLengthTooShort", symmetricKey.Length)));
+            }
+            _keySize = symmetricKey.Length * 8;
+
+            if (cloneBuffer)
+            {
+                _symmetricKey = new byte[symmetricKey.Length];
+                Buffer.BlockCopy(symmetricKey, 0, _symmetricKey, 0, symmetricKey.Length);
+            }
+            else
+            {
+                _symmetricKey = symmetricKey;
+            }
+        }
+
+        public override int KeySize
+        {
+            get { return _keySize; }
+        }
+
+        public override byte[] DecryptKey(string algorithm, byte[] keyData)
+        {
+            return CryptoHelper.UnwrapKey(_symmetricKey, keyData, algorithm);
+        }
+
+        public override byte[] EncryptKey(string algorithm, byte[] keyData)
+        {
+            return CryptoHelper.WrapKey(_symmetricKey, keyData, algorithm);
+        }
+
+        public override byte[] GenerateDerivedKey(string algorithm, byte[] label, byte[] nonce, int derivedKeyLength, int offset)
+        {
+            return CryptoHelper.GenerateDerivedKey(_symmetricKey, algorithm, label, nonce, derivedKeyLength, offset);
+        }
+
+        public override ICryptoTransform GetDecryptionTransform(string algorithm, byte[] iv)
+        {
+            return CryptoHelper.CreateDecryptor(_symmetricKey, iv, algorithm);
+        }
+
+        public override ICryptoTransform GetEncryptionTransform(string algorithm, byte[] iv)
+        {
+            return CryptoHelper.CreateEncryptor(_symmetricKey, iv, algorithm);
+        }
+
+        public override int GetIVSize(string algorithm)
+        {
+            return CryptoHelper.GetIVSize(algorithm);
+        }
+
+        public override KeyedHashAlgorithm GetKeyedHashAlgorithm(string algorithm)
+        {
+            return CryptoHelper.CreateKeyedHashAlgorithm(_symmetricKey, algorithm);
+        }
+
+        public override SymmetricAlgorithm GetSymmetricAlgorithm(string algorithm)
+        {
+            return CryptoHelper.GetSymmetricAlgorithm(_symmetricKey, algorithm);
+        }
+
+        public override byte[] GetSymmetricKey()
+        {
+            byte[] local = new byte[_symmetricKey.Length];
+            Buffer.BlockCopy(_symmetricKey, 0, local, 0, _symmetricKey.Length);
+
+            return local;
+        }
+
+        public override bool IsAsymmetricAlgorithm(string algorithm)
+        {
+            return (CryptoHelper.IsAsymmetricAlgorithm(algorithm));
+        }
+
+        public override bool IsSupportedAlgorithm(string algorithm)
+        {
+            return (CryptoHelper.IsSymmetricSupportedAlgorithm(algorithm, KeySize));
+        }
+
+        public override bool IsSymmetricAlgorithm(string algorithm)
+        {
+            return CryptoHelper.IsSymmetricAlgorithm(algorithm);
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Tokens/SymmetricSecurityKey.cs b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Tokens/SymmetricSecurityKey.cs
new file mode 100644
index 0000000..8066d92
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Tokens/SymmetricSecurityKey.cs
@@ -0,0 +1,19 @@
+using System.Security.Cryptography;
+
+namespace CoreWCF.IdentityModel.Tokens
+{
+    public abstract class SymmetricSecurityKey : SecurityKey
+    {
+        public abstract byte[] GenerateDerivedKey(string algorithm, byte[] label, byte[] nonce, int derivedKeyLength, int offset);
+
+        public abstract ICryptoTransform GetDecryptionTransform(string algorithm, byte[] iv);
+        public abstract ICryptoTransform GetEncryptionTransform(string algorithm, byte[] iv);
+
+        public abstract int GetIVSize(string algorithm);
+
+        public abstract KeyedHashAlgorithm GetKeyedHashAlgorithm(string algorithm);
+        public abstract SymmetricAlgorithm GetSymmetricAlgorithm(string algorithm);
+
+        public abstract byte[] GetSymmetricKey();
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Tokens/WSSecurityJan2004.cs b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Tokens/WSSecurityJan2004.cs
new file mode 100644
index 0000000..b01d203
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Tokens/WSSecurityJan2004.cs
@@ -0,0 +1,580 @@
+﻿
+using System.Collections.Generic;
+using System.Globalization;
+using CoreWCF.IdentityModel.Selectors;
+using CoreWCF;
+using CoreWCF.Security;
+using System.Text;
+using System.Xml;
+using System;
+//using HexBinary = System.Runtime.Remoting.Metadata.W3cXsd2001.SoapHexBinary;
+using KeyIdentifierClauseEntry = CoreWCF.IdentityModel.Selectors.SecurityTokenSerializer.KeyIdentifierClauseEntry;
+using StrEntry = CoreWCF.IdentityModel.Selectors.SecurityTokenSerializer.StrEntry;
+using TokenEntry = CoreWCF.IdentityModel.Selectors.SecurityTokenSerializer.TokenEntry;
+using CoreWCF.Security.Tokens;
+
+namespace CoreWCF.IdentityModel.Tokens
+{
+    internal class WSSecurityJan2004 : SecurityTokenSerializer.SerializerEntries
+    {
+        public WSSecurityJan2004(KeyInfoSerializer securityTokenSerializer)
+        {
+            SecurityTokenSerializer = securityTokenSerializer;
+        }
+
+        public KeyInfoSerializer SecurityTokenSerializer { get; }
+
+        public override void PopulateKeyIdentifierClauseEntries(IList<KeyIdentifierClauseEntry> clauseEntries)
+        {
+            List<StrEntry> strEntries = new List<StrEntry>();
+            SecurityTokenSerializer.PopulateStrEntries(strEntries);
+            SecurityTokenReferenceJan2004ClauseEntry strClause = new SecurityTokenReferenceJan2004ClauseEntry(SecurityTokenSerializer.EmitBspRequiredAttributes, strEntries);
+            clauseEntries.Add(strClause);
+        }
+
+        protected void PopulateJan2004StrEntries(IList<StrEntry> strEntries)
+        {
+            strEntries.Add(new LocalReferenceStrEntry(SecurityTokenSerializer.EmitBspRequiredAttributes, SecurityTokenSerializer));
+            strEntries.Add(new X509SkiStrEntry(SecurityTokenSerializer.EmitBspRequiredAttributes));
+            strEntries.Add(new X509IssuerSerialStrEntry());
+        }
+
+
+        public override void PopulateStrEntries(IList<StrEntry> strEntries)
+        {
+            PopulateJan2004StrEntries(strEntries);
+        }
+
+        protected void PopulateJan2004TokenEntries(IList<TokenEntry> tokenEntryList)
+        {
+            tokenEntryList.Add(new GenericXmlTokenEntry());
+            tokenEntryList.Add(new UserNamePasswordTokenEntry());
+            tokenEntryList.Add(new X509TokenEntry());
+        }
+
+        public override void PopulateTokenEntries(IList<TokenEntry> tokenEntryList)
+        {
+            PopulateJan2004TokenEntries(tokenEntryList);
+        }
+
+        internal abstract class BinaryTokenEntry : TokenEntry
+        {
+            internal static readonly XmlDictionaryString ElementName = CoreWCF.XD.SecurityJan2004Dictionary.BinarySecurityToken;
+            internal static readonly XmlDictionaryString EncodingTypeAttribute = CoreWCF.XD.SecurityJan2004Dictionary.EncodingType;
+            internal const string EncodingTypeAttributeString = SecurityJan2004Strings.EncodingType;
+            internal const string EncodingTypeValueBase64Binary = SecurityJan2004Strings.EncodingTypeValueBase64Binary;
+            internal const string EncodingTypeValueHexBinary = SecurityJan2004Strings.EncodingTypeValueHexBinary;
+            internal static readonly XmlDictionaryString ValueTypeAttribute = CoreWCF.XD.SecurityJan2004Dictionary.ValueType;
+
+            private string[] _valueTypeUris = null;
+
+            protected BinaryTokenEntry(string valueTypeUri)
+            {
+                _valueTypeUris = new string[1];
+                _valueTypeUris[0] = valueTypeUri;
+            }
+
+            protected BinaryTokenEntry(string[] valueTypeUris)
+            {
+                if (valueTypeUris == null)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(valueTypeUris));
+                }
+
+                _valueTypeUris = new string[valueTypeUris.GetLength(0)];
+                for (int i = 0; i < _valueTypeUris.GetLength(0); ++i)
+                {
+                    _valueTypeUris[i] = valueTypeUris[i];
+                }
+            }
+
+            protected override XmlDictionaryString LocalName { get { return ElementName; } }
+            protected override XmlDictionaryString NamespaceUri { get { return CoreWCF.XD.SecurityJan2004Dictionary.Namespace; } }
+            public override string TokenTypeUri { get { return _valueTypeUris[0]; } }
+            protected override string ValueTypeUri { get { return _valueTypeUris[0]; } }
+            public override bool SupportsTokenTypeUri(string tokenTypeUri)
+            {
+                for (int i = 0; i < _valueTypeUris.GetLength(0); ++i)
+                {
+                    if (_valueTypeUris[i] == tokenTypeUri)
+                    {
+                        return true;
+                    }
+                }
+
+                return false;
+            }
+        }
+
+        private class GenericXmlTokenEntry : TokenEntry
+        {
+            protected override XmlDictionaryString LocalName { get { return null; } }
+            protected override XmlDictionaryString NamespaceUri { get { return null; } }
+            protected override Type[] GetTokenTypesCore() { return new Type[] { typeof(GenericXmlSecurityToken) }; }
+            public override string TokenTypeUri { get { return null; } }
+            protected override string ValueTypeUri { get { return null; } }
+        }
+
+        private class UserNamePasswordTokenEntry : TokenEntry
+        {
+            protected override XmlDictionaryString LocalName { get { return CoreWCF.XD.SecurityJan2004Dictionary.UserNameTokenElement; } }
+            protected override XmlDictionaryString NamespaceUri { get { return CoreWCF.XD.SecurityJan2004Dictionary.Namespace; } }
+            protected override Type[] GetTokenTypesCore() { return new Type[] { typeof(UserNameSecurityToken) }; }
+            public override string TokenTypeUri { get { return SecurityJan2004Strings.UPTokenType; } }
+            protected override string ValueTypeUri { get { return null; } }
+        }
+
+        //class KerberosTokenEntry : BinaryTokenEntry
+        //{
+        //    public KerberosTokenEntry()
+        //        : base(new string[] { SecurityJan2004Strings.KerberosTokenTypeGSS, SecurityJan2004Strings.KerberosTokenType1510 })
+        //    {
+        //    }
+
+        //    protected override Type[] GetTokenTypesCore() { return new Type[] { typeof(KerberosReceiverSecurityToken), typeof(KerberosRequestorSecurityToken) }; }
+        //}
+
+        //protected class SamlTokenEntry : TokenEntry
+        //{
+        //    protected override XmlDictionaryString LocalName { get { return XD.SecurityJan2004Dictionary.SamlAssertion; } }
+        //    protected override XmlDictionaryString NamespaceUri { get { return XD.SecurityJan2004Dictionary.SamlUri; } }
+        //    protected override Type[] GetTokenTypesCore() { return new Type[] { typeof(SamlSecurityToken) }; }
+        //    public override string TokenTypeUri { get { return null; } }
+        //    protected override string ValueTypeUri { get { return null; } }
+        //}
+        protected class WrappedKeyTokenEntry : TokenEntry
+        {
+            protected override XmlDictionaryString LocalName { get { return EncryptedKey.ElementName; } }
+            protected override XmlDictionaryString NamespaceUri { get { return CoreWCF.XD.XmlEncryptionDictionary.Namespace; } }
+            protected override Type[] GetTokenTypesCore() { return new Type[] { typeof(WrappedKeySecurityToken) }; }
+            public override string TokenTypeUri { get { return null; } }
+            protected override string ValueTypeUri { get { return null; } }
+        }
+        protected class X509TokenEntry : BinaryTokenEntry
+        {
+            internal const string ValueTypeAbsoluteUri = SecurityJan2004Strings.X509TokenType;
+
+            public X509TokenEntry()
+                : base(ValueTypeAbsoluteUri)
+            {
+            }
+
+            protected override Type[] GetTokenTypesCore() { return new Type[] { typeof(X509SecurityToken) }; }
+        }
+
+        protected class SecurityTokenReferenceJan2004ClauseEntry : KeyIdentifierClauseEntry
+        {
+            private const int DefaultDerivedKeyLength = 32;
+
+            public SecurityTokenReferenceJan2004ClauseEntry(bool emitBspRequiredAttributes, IList<StrEntry> strEntries)
+            {
+                EmitBspRequiredAttributes = emitBspRequiredAttributes;
+                StrEntries = strEntries;
+            }
+            protected bool EmitBspRequiredAttributes { get; }
+            protected IList<StrEntry> StrEntries { get; }
+
+            protected override XmlDictionaryString LocalName
+            {
+                get
+                {
+                    return CoreWCF.XD.SecurityJan2004Dictionary.SecurityTokenReference;
+                }
+            }
+
+            protected override XmlDictionaryString NamespaceUri
+            {
+                get
+                {
+                    return CoreWCF.XD.SecurityJan2004Dictionary.Namespace;
+                }
+            }
+
+            protected virtual string ReadTokenType(XmlDictionaryReader reader)
+            {
+                return null;
+            }
+
+            public override SecurityKeyIdentifierClause ReadKeyIdentifierClauseCore(XmlDictionaryReader reader)
+            {
+                byte[] nonce = null;
+                int length = 0;
+                if (reader.IsStartElement(CoreWCF.XD.SecurityJan2004Dictionary.SecurityTokenReference, NamespaceUri))
+                {
+                    string nonceString = reader.GetAttribute(CoreWCF.XD.SecureConversationFeb2005Dictionary.Nonce, CoreWCF.XD.SecureConversationFeb2005Dictionary.Namespace);
+                    if (nonceString != null)
+                    {
+                        nonce = Convert.FromBase64String(nonceString);
+                    }
+
+                    string lengthString = reader.GetAttribute(CoreWCF.XD.SecureConversationFeb2005Dictionary.Length, CoreWCF.XD.SecureConversationFeb2005Dictionary.Namespace);
+                    if (lengthString != null)
+                    {
+                        length = Convert.ToInt32(lengthString, CultureInfo.InvariantCulture);
+                    }
+                    else
+                    {
+                        length = DefaultDerivedKeyLength;
+                    }
+                }
+                string tokenType = ReadTokenType(reader);
+                string strId = reader.GetAttribute(CoreWCF.XD.UtilityDictionary.IdAttribute, CoreWCF.XD.UtilityDictionary.Namespace);
+                reader.ReadStartElement(CoreWCF.XD.SecurityJan2004Dictionary.SecurityTokenReference, NamespaceUri);
+                SecurityKeyIdentifierClause clause = null;
+                for (int i = 0; i < StrEntries.Count; ++i)
+                {
+                    if (StrEntries[i].CanReadClause(reader, tokenType))
+                    {
+                        clause = StrEntries[i].ReadClause(reader, nonce, length, tokenType);
+                        break;
+                    }
+                }
+
+                if (clause == null)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new XmlException(SR.Format("CannotReadKeyIdentifierClause", reader.LocalName, reader.NamespaceURI)));
+                }
+
+                if (!string.IsNullOrEmpty(strId))
+                {
+                    clause.Id = strId;
+                }
+
+                reader.ReadEndElement();
+                return clause;
+            }
+
+            public override bool SupportsCore(SecurityKeyIdentifierClause keyIdentifierClause)
+            {
+                for (int i = 0; i < StrEntries.Count; ++i)
+                {
+                    if (StrEntries[i].SupportsCore(keyIdentifierClause))
+                    {
+                        return true;
+                    }
+                }
+                return false;
+            }
+
+            public override void WriteKeyIdentifierClauseCore(XmlDictionaryWriter writer, SecurityKeyIdentifierClause keyIdentifierClause)
+            {
+                for (int i = 0; i < StrEntries.Count; ++i)
+                {
+                    if (StrEntries[i].SupportsCore(keyIdentifierClause))
+                    {
+                        writer.WriteStartElement(CoreWCF.XD.SecurityJan2004Dictionary.Prefix.Value, CoreWCF.XD.SecurityJan2004Dictionary.SecurityTokenReference, CoreWCF.XD.SecurityJan2004Dictionary.Namespace);
+                        StrEntries[i].WriteContent(writer, keyIdentifierClause);
+                        writer.WriteEndElement();
+                        return;
+                    }
+                }
+
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.StandardsManagerCannotWriteObject, keyIdentifierClause.GetType())));
+            }
+        }
+
+        protected abstract class KeyIdentifierStrEntry : StrEntry
+        {
+            protected const string EncodingTypeValueBase64Binary = SecurityJan2004Strings.EncodingTypeValueBase64Binary;
+            protected const string EncodingTypeValueHexBinary = SecurityJan2004Strings.EncodingTypeValueHexBinary;
+            protected const string EncodingTypeValueText = SecurityJan2004Strings.EncodingTypeValueText;
+
+            protected abstract Type ClauseType { get; }
+            protected virtual string DefaultEncodingType { get { return EncodingTypeValueBase64Binary; } }
+            public abstract Type TokenType { get; }
+            protected abstract string ValueTypeUri { get; }
+            protected bool EmitBspRequiredAttributes { get; }
+
+            protected KeyIdentifierStrEntry(bool emitBspRequiredAttributes)
+            {
+                EmitBspRequiredAttributes = emitBspRequiredAttributes;
+            }
+
+            public override bool CanReadClause(XmlDictionaryReader reader, string tokenType)
+            {
+                if (reader.IsStartElement(CoreWCF.XD.SecurityJan2004Dictionary.KeyIdentifier, CoreWCF.XD.SecurityJan2004Dictionary.Namespace))
+                {
+                    string valueType = reader.GetAttribute(CoreWCF.XD.SecurityJan2004Dictionary.ValueType, null);
+                    return (ValueTypeUri == valueType);
+                }
+                return false;
+            }
+
+            protected abstract SecurityKeyIdentifierClause CreateClause(byte[] bytes, byte[] derivationNonce, int derivationLength);
+
+            public override Type GetTokenType(SecurityKeyIdentifierClause clause)
+            {
+                return TokenType;
+            }
+
+            public override SecurityKeyIdentifierClause ReadClause(XmlDictionaryReader reader, byte[] derivationNonce, int derivationLength, string tokenType)
+            {
+                string encodingType = reader.GetAttribute(CoreWCF.XD.SecurityJan2004Dictionary.EncodingType, null);
+                if (encodingType == null)
+                {
+                    encodingType = DefaultEncodingType;
+                }
+
+                reader.ReadStartElement();
+
+                byte[] bytes;
+                if (encodingType == EncodingTypeValueBase64Binary)
+                {
+                    bytes = reader.ReadContentAsBase64();
+                }
+                else if (encodingType == EncodingTypeValueHexBinary)
+                {
+                    throw new NotImplementedException();
+                   // bytes = HexBinary.Parse(reader.ReadContentAsString()).Value;
+                }
+                else if (encodingType == EncodingTypeValueText)
+                {
+                    bytes = new UTF8Encoding().GetBytes(reader.ReadContentAsString());
+                }
+                else
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new Exception("UnknownEncodingInKeyIdentifier"));
+                }
+
+                reader.ReadEndElement();
+
+                return CreateClause(bytes, derivationNonce, derivationLength);
+            }
+
+            public override bool SupportsCore(SecurityKeyIdentifierClause clause)
+            {
+                return ClauseType.IsAssignableFrom(clause.GetType());
+            }
+
+            public override void WriteContent(XmlDictionaryWriter writer, SecurityKeyIdentifierClause clause)
+            {
+                writer.WriteStartElement(CoreWCF.XD.SecurityJan2004Dictionary.Prefix.Value, CoreWCF.XD.SecurityJan2004Dictionary.KeyIdentifier, CoreWCF.XD.SecurityJan2004Dictionary.Namespace);
+                writer.WriteAttributeString(CoreWCF.XD.SecurityJan2004Dictionary.ValueType, null, ValueTypeUri);
+                if (EmitBspRequiredAttributes)
+                {
+                    // Emit the encodingType attribute.
+                    writer.WriteAttributeString(CoreWCF.XD.SecurityJan2004Dictionary.EncodingType, null, DefaultEncodingType);
+                }
+                string encoding = DefaultEncodingType;
+                BinaryKeyIdentifierClause binaryClause = clause as BinaryKeyIdentifierClause;
+
+                byte[] keyIdentifier = binaryClause.GetBuffer();
+                if (encoding == EncodingTypeValueBase64Binary)
+                {
+                    writer.WriteBase64(keyIdentifier, 0, keyIdentifier.Length);
+                }
+                else if (encoding == EncodingTypeValueHexBinary)
+                {
+                    writer.WriteBinHex(keyIdentifier, 0, keyIdentifier.Length);
+                }
+                else if (encoding == EncodingTypeValueText)
+                {
+                    writer.WriteString(new UTF8Encoding().GetString(keyIdentifier, 0, keyIdentifier.Length));
+                }
+                writer.WriteEndElement();
+            }
+        }
+
+        protected class X509SkiStrEntry : KeyIdentifierStrEntry
+        {
+            protected override Type ClauseType { get { return typeof(X509SubjectKeyIdentifierClause); } }
+            public override Type TokenType { get { return typeof(X509SecurityToken); } }
+            protected override string ValueTypeUri { get { return SecurityJan2004Strings.X509SKIValueType; } }
+
+            public X509SkiStrEntry(bool emitBspRequiredAttributes)
+                : base(emitBspRequiredAttributes)
+            {
+            }
+
+            protected override SecurityKeyIdentifierClause CreateClause(byte[] bytes, byte[] derivationNonce, int derivationLength)
+            {
+                return new X509SubjectKeyIdentifierClause(bytes);
+            }
+            public override string GetTokenTypeUri()
+            {
+                return SecurityJan2004Strings.X509TokenType;
+            }
+        }
+
+        protected class LocalReferenceStrEntry : StrEntry
+        {
+            private bool _emitBspRequiredAttributes;
+            private KeyInfoSerializer _tokenSerializer;
+
+            public LocalReferenceStrEntry(bool emitBspRequiredAttributes, KeyInfoSerializer tokenSerializer)
+            {
+                _emitBspRequiredAttributes = emitBspRequiredAttributes;
+                _tokenSerializer = tokenSerializer;
+            }
+
+            public override Type GetTokenType(SecurityKeyIdentifierClause clause)
+            {
+                LocalIdKeyIdentifierClause localClause = clause as LocalIdKeyIdentifierClause;
+                return localClause.OwnerType;
+            }
+
+            public string GetLocalTokenTypeUri(SecurityKeyIdentifierClause clause)
+            {
+                Type tokenType = GetTokenType(clause);
+                return _tokenSerializer.GetTokenTypeUri(tokenType);
+            }
+            public override string GetTokenTypeUri()
+            {
+                return null;
+            }
+
+            public override bool CanReadClause(XmlDictionaryReader reader, string tokenType)
+            {
+                if (reader.IsStartElement(CoreWCF.XD.SecurityJan2004Dictionary.Reference, CoreWCF.XD.SecurityJan2004Dictionary.Namespace))
+                {
+                    string uri = reader.GetAttribute(CoreWCF.XD.SecurityJan2004Dictionary.URI, null);
+                    if (uri != null && uri.Length > 0 && uri[0] == '#')
+                    {
+                        return true;
+                    }
+                }
+                return false;
+            }
+
+            public override SecurityKeyIdentifierClause ReadClause(XmlDictionaryReader reader, byte[] derivationNonce, int derivationLength, string tokenType)
+            {
+                string uri = reader.GetAttribute(CoreWCF.XD.SecurityJan2004Dictionary.URI, null);
+                string tokenTypeUri = reader.GetAttribute(CoreWCF.XD.SecurityJan2004Dictionary.ValueType, null);
+                Type[] tokenTypes = null;
+                if (tokenTypeUri != null)
+                {
+                    tokenTypes = _tokenSerializer.GetTokenTypes(tokenTypeUri);
+                }
+                SecurityKeyIdentifierClause clause = new LocalIdKeyIdentifierClause(uri.Substring(1), derivationNonce, derivationLength, tokenTypes);
+                if (reader.IsEmptyElement)
+                {
+                    reader.Read();
+                }
+                else
+                {
+                    reader.ReadStartElement();
+                    reader.ReadEndElement();
+                }
+                return clause;
+            }
+
+            public override bool SupportsCore(SecurityKeyIdentifierClause clause)
+            {
+                return clause is LocalIdKeyIdentifierClause;
+            }
+
+            public override void WriteContent(XmlDictionaryWriter writer, SecurityKeyIdentifierClause clause)
+            {
+                LocalIdKeyIdentifierClause localIdClause = clause as LocalIdKeyIdentifierClause;
+                writer.WriteStartElement(CoreWCF.XD.SecurityJan2004Dictionary.Prefix.Value, CoreWCF.XD.SecurityJan2004Dictionary.Reference, CoreWCF.XD.SecurityJan2004Dictionary.Namespace);
+                if (_emitBspRequiredAttributes)
+                {
+                    string tokenTypeUri = GetLocalTokenTypeUri(localIdClause);
+                    if (tokenTypeUri != null)
+                    {
+                        writer.WriteAttributeString(CoreWCF.XD.SecurityJan2004Dictionary.ValueType, null, tokenTypeUri);
+                    }
+                }
+                writer.WriteAttributeString(CoreWCF.XD.SecurityJan2004Dictionary.URI, null, "#" + localIdClause.LocalId);
+                writer.WriteEndElement();
+            }
+        }
+
+        protected class X509IssuerSerialStrEntry : StrEntry
+        {
+            public override Type GetTokenType(SecurityKeyIdentifierClause clause)
+            {
+                return typeof(X509SecurityToken);
+            }
+
+            public override bool CanReadClause(XmlDictionaryReader reader, string tokenType)
+            {
+                return reader.IsStartElement(CoreWCF.XD.XmlSignatureDictionary.X509Data, CoreWCF.XD.XmlSignatureDictionary.Namespace);
+            }
+            public override string GetTokenTypeUri()
+            {
+                return SecurityJan2004Strings.X509TokenType;
+            }
+
+            public override SecurityKeyIdentifierClause ReadClause(XmlDictionaryReader reader, byte[] derivationNonce, int derivationLength, string tokenType)
+            {
+                reader.ReadStartElement(CoreWCF.XD.XmlSignatureDictionary.X509Data, CoreWCF.XD.XmlSignatureDictionary.Namespace);
+                reader.ReadStartElement(CoreWCF.XD.XmlSignatureDictionary.X509IssuerSerial, CoreWCF.XD.XmlSignatureDictionary.Namespace);
+                reader.ReadStartElement(CoreWCF.XD.XmlSignatureDictionary.X509IssuerName, CoreWCF.XD.XmlSignatureDictionary.Namespace);
+                string issuerName = reader.ReadContentAsString();
+                reader.ReadEndElement();
+                reader.ReadStartElement(CoreWCF.XD.XmlSignatureDictionary.X509SerialNumber, CoreWCF.XD.XmlSignatureDictionary.Namespace);
+                string serialNumber = reader.ReadContentAsString();
+                reader.ReadEndElement();
+                reader.ReadEndElement();
+                reader.ReadEndElement();
+
+                return new X509IssuerSerialKeyIdentifierClause(issuerName, serialNumber);
+            }
+
+            public override bool SupportsCore(SecurityKeyIdentifierClause clause)
+            {
+                return clause is X509IssuerSerialKeyIdentifierClause;
+            }
+
+            public override void WriteContent(XmlDictionaryWriter writer, SecurityKeyIdentifierClause clause)
+            {
+                X509IssuerSerialKeyIdentifierClause issuerClause = clause as X509IssuerSerialKeyIdentifierClause;
+                writer.WriteStartElement(CoreWCF.XD.XmlSignatureDictionary.Prefix.Value, CoreWCF.XD.XmlSignatureDictionary.X509Data, CoreWCF.XD.XmlSignatureDictionary.Namespace);
+                writer.WriteStartElement(CoreWCF.XD.XmlSignatureDictionary.Prefix.Value, CoreWCF.XD.XmlSignatureDictionary.X509IssuerSerial, CoreWCF.XD.XmlSignatureDictionary.Namespace);
+                writer.WriteElementString(CoreWCF.XD.XmlSignatureDictionary.Prefix.Value, CoreWCF.XD.XmlSignatureDictionary.X509IssuerName, CoreWCF.XD.XmlSignatureDictionary.Namespace, issuerClause.IssuerName);
+                writer.WriteElementString(CoreWCF.XD.XmlSignatureDictionary.Prefix.Value, CoreWCF.XD.XmlSignatureDictionary.X509SerialNumber, CoreWCF.XD.XmlSignatureDictionary.Namespace, issuerClause.IssuerSerialNumber);
+                writer.WriteEndElement();
+                writer.WriteEndElement();
+            }
+        }
+
+        public class IdManager : SignatureTargetIdManager
+        {
+            internal static readonly XmlDictionaryString ElementName = CoreWCF.XD.XmlEncryptionDictionary.EncryptedData;
+
+            private IdManager()
+            {
+            }
+
+            public override string DefaultIdNamespacePrefix
+            {
+                get { return UtilityStrings.Prefix; }
+            }
+
+            public override string DefaultIdNamespaceUri
+            {
+                get { return UtilityStrings.Namespace; }
+            }
+
+            internal static IdManager Instance { get; } = new IdManager();
+
+            public override string ExtractId(XmlDictionaryReader reader)
+            {
+                if (reader == null)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(reader));
+                }
+
+                if (reader.IsStartElement(ElementName, CoreWCF.XD.XmlEncryptionDictionary.Namespace))
+                {
+                    return reader.GetAttribute(CoreWCF.XD.XmlEncryptionDictionary.Id, null);
+                }
+                else
+                {
+                    return reader.GetAttribute(CoreWCF.XD.UtilityDictionary.IdAttribute, CoreWCF.XD.UtilityDictionary.Namespace);
+                }
+            }
+
+            public override void WriteIdAttribute(XmlDictionaryWriter writer, string id)
+            {
+                if (writer == null)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(writer));
+                }
+
+                writer.WriteAttributeString(CoreWCF.XD.UtilityDictionary.Prefix.Value, CoreWCF.XD.UtilityDictionary.IdAttribute, CoreWCF.XD.UtilityDictionary.Namespace, id);
+            }
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Tokens/WSSecurityXXX2005.cs b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Tokens/WSSecurityXXX2005.cs
new file mode 100644
index 0000000..eddbb55
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Tokens/WSSecurityXXX2005.cs
@@ -0,0 +1,249 @@
+﻿using CoreWCF.IdentityModel.Selectors;
+using CoreWCF.Security.Tokens;
+using System;
+using System.Collections.Generic;
+using System.Xml;
+using static CoreWCF.IdentityModel.Selectors.SecurityTokenSerializer;
+
+namespace CoreWCF.IdentityModel.Tokens
+{
+    internal class WSSecurityXXX2005 : WSSecurityJan2004
+    {
+        public WSSecurityXXX2005(KeyInfoSerializer securityTokenSerializer)
+            : base(securityTokenSerializer)
+        {
+        }
+
+        public override void PopulateStrEntries(IList<StrEntry> strEntries)
+        {
+            PopulateJan2004StrEntries(strEntries);
+         //   strEntries.Add(new SamlDirectStrEntry());
+          //  strEntries.Add(new X509ThumbprintStrEntry(this.SecurityTokenSerializer.EmitBspRequiredAttributes));
+            strEntries.Add(new EncryptedKeyHashStrEntry(this.SecurityTokenSerializer.EmitBspRequiredAttributes));
+        }
+
+        public override void PopulateTokenEntries(IList<TokenEntry> tokenEntryList)
+        {
+            PopulateJan2004TokenEntries(tokenEntryList);
+            tokenEntryList.Add(new WSSecurityXXX2005.WrappedKeyTokenEntry());
+           // tokenEntryList.Add(new WSSecurityXXX2005.SamlTokenEntry());
+        }
+
+        public override void PopulateKeyIdentifierClauseEntries(IList<KeyIdentifierClauseEntry> clauseEntries)
+        {
+            List<StrEntry> strEntries = new List<StrEntry>();
+            this.SecurityTokenSerializer.PopulateStrEntries(strEntries);
+            SecurityTokenReferenceXXX2005ClauseEntry strClause = new SecurityTokenReferenceXXX2005ClauseEntry(this.SecurityTokenSerializer.EmitBspRequiredAttributes, strEntries);
+            clauseEntries.Add(strClause);
+        }
+
+        //new class SamlTokenEntry : WSSecurityJan2004.SamlTokenEntry
+        //{
+        //    public override string TokenTypeUri { get { return SecurityXXX2005Strings.SamlTokenType; } }
+        //}
+
+        new class WrappedKeyTokenEntry : WSSecurityJan2004.WrappedKeyTokenEntry
+        {
+            public override string TokenTypeUri { get { return SecurityXXX2005Strings.EncryptedKeyTokenType; } }
+        }
+
+        class SecurityTokenReferenceXXX2005ClauseEntry : SecurityTokenReferenceJan2004ClauseEntry
+        {
+            public SecurityTokenReferenceXXX2005ClauseEntry(bool emitBspRequiredAttributes, IList<StrEntry> strEntries)
+                : base(emitBspRequiredAttributes, strEntries)
+            {
+            }
+
+            protected override string ReadTokenType(XmlDictionaryReader reader)
+            {
+                return reader.GetAttribute(CoreWCF.XD.SecurityXXX2005Dictionary.TokenTypeAttribute, CoreWCF.XD.SecurityXXX2005Dictionary.Namespace);
+            }
+
+            public override void WriteKeyIdentifierClauseCore(XmlDictionaryWriter writer, SecurityKeyIdentifierClause keyIdentifierClause)
+            {
+                for (int i = 0; i < this.StrEntries.Count; ++i)
+                {
+                    if (this.StrEntries[i].SupportsCore(keyIdentifierClause))
+                    {
+                        writer.WriteStartElement(CoreWCF.XD.SecurityJan2004Dictionary.Prefix.Value, CoreWCF.XD.SecurityJan2004Dictionary.SecurityTokenReference, CoreWCF.XD.SecurityJan2004Dictionary.Namespace);
+
+                        string tokenTypeUri = this.GetTokenTypeUri(this.StrEntries[i], keyIdentifierClause);
+                        if (tokenTypeUri != null)
+                        {
+                            writer.WriteAttributeString(CoreWCF.XD.SecurityXXX2005Dictionary.Prefix.Value, CoreWCF.XD.SecurityXXX2005Dictionary.TokenTypeAttribute, CoreWCF.XD.SecurityXXX2005Dictionary.Namespace, tokenTypeUri);
+                        }
+
+                        this.StrEntries[i].WriteContent(writer, keyIdentifierClause);
+                        writer.WriteEndElement();
+                        return;
+                    }
+                }
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.StandardsManagerCannotWriteObject, keyIdentifierClause.GetType())));
+            }
+
+            private string GetTokenTypeUri(StrEntry str, SecurityKeyIdentifierClause keyIdentifierClause)
+            {
+                bool emitTokenType = this.EmitTokenType(str);
+                if (emitTokenType)
+                {
+                    string tokenTypeUri;
+                    if (str is LocalReferenceStrEntry)
+                    {
+                        tokenTypeUri = (str as LocalReferenceStrEntry).GetLocalTokenTypeUri(keyIdentifierClause);
+                        // only emit token type for SAML,Kerberos and Encrypted References
+                        switch (tokenTypeUri)
+                        {
+                            case SecurityXXX2005Strings.Saml20TokenType:
+                            case SecurityXXX2005Strings.SamlTokenType:
+                            case SecurityXXX2005Strings.EncryptedKeyTokenType:
+                            case SecurityJan2004Strings.KerberosTokenTypeGSS: break;
+
+                            default:
+                                tokenTypeUri = null;
+                                break;
+                        }
+                    }
+                    else
+                    {
+                        tokenTypeUri = str.GetTokenTypeUri();
+                    }
+
+                    return tokenTypeUri;
+                }
+                else
+                {
+                    return null;
+                }
+            }
+
+            private bool EmitTokenType(StrEntry str)
+            {
+                bool emitTokenType = false;
+                // we emit tokentype always for SAML and Encrypted Key Tokens 
+                if (
+                    //(str is SamlJan2004KeyIdentifierStrEntry)
+                        //||
+                        (str is EncryptedKeyHashStrEntry)
+                       // || (str is SamlDirectStrEntry)
+                       )
+                {
+                    emitTokenType = true;
+                }
+                else if (this.EmitBspRequiredAttributes)
+                {
+                    if (
+                        //(str is KerberosHashStrEntry)
+                        //||
+                        (str is LocalReferenceStrEntry))
+                    {
+                        emitTokenType = true;
+                    }
+                }
+                return emitTokenType;
+            }
+        }
+
+        class EncryptedKeyHashStrEntry : WSSecurityJan2004.KeyIdentifierStrEntry
+        {
+            protected override Type ClauseType { get { return typeof(EncryptedKeyHashIdentifierClause); } }
+            public override Type TokenType { get { return typeof(WrappedKeySecurityToken); } }
+            protected override string ValueTypeUri { get { return SecurityXXX2005Strings.EncryptedKeyHashValueType; } }
+
+            public EncryptedKeyHashStrEntry(bool emitBspRequiredAttributes)
+                : base(emitBspRequiredAttributes)
+            {
+            }
+
+            public override bool CanReadClause(XmlDictionaryReader reader, string tokenType)
+            {
+                // Backward compatible with V1. Accept if missing.
+                if (tokenType != null && tokenType != SecurityXXX2005Strings.EncryptedKeyTokenType)
+                {
+                    return false;
+                }
+                return base.CanReadClause(reader, tokenType);
+            }
+
+            protected override SecurityKeyIdentifierClause CreateClause(byte[] bytes, byte[] derivationNonce, int derivationLength)
+            {
+                return new EncryptedKeyHashIdentifierClause(bytes, true, derivationNonce, derivationLength);
+            }
+
+            public override string GetTokenTypeUri()
+            {
+                return SecurityXXX2005Strings.EncryptedKeyTokenType;
+            }
+        }
+
+        //class X509ThumbprintStrEntry : WSSecurityJan2004.KeyIdentifierStrEntry
+        //{
+        //    protected override Type ClauseType { get { return typeof(X509ThumbprintKeyIdentifierClause); } }
+        //    public override Type TokenType { get { return typeof(X509SecurityToken); } }
+        //    protected override string ValueTypeUri { get { return SecurityXXX2005Strings.ThumbprintSha1ValueType; } }
+
+        //    public X509ThumbprintStrEntry(bool emitBspRequiredAttributes)
+        //        : base(emitBspRequiredAttributes)
+        //    {
+        //    }
+
+        //    protected override SecurityKeyIdentifierClause CreateClause(byte[] bytes, byte[] derivationNonce, int derivationLength)
+        //    {
+        //        return new X509ThumbprintKeyIdentifierClause(bytes);
+        //    }
+        //    public override string GetTokenTypeUri()
+        //    {
+        //        return CoreWCF.XD.SecurityXXX2005Dictionary.ThumbprintSha1ValueType.Value;
+        //    }
+        //}
+
+        //class SamlDirectStrEntry : StrEntry
+        //{
+        //    public override bool CanReadClause(XmlDictionaryReader reader, string tokenType)
+        //    {
+        //        if (tokenType != CoreWCF.XD.SecurityXXX2005Dictionary.Saml20TokenType.Value)
+        //        {
+        //            return false;
+        //        }
+        //        return (reader.IsStartElement(CoreWCF.XD.SecurityJan2004Dictionary.Reference, CoreWCF.XD.SecurityJan2004Dictionary.Namespace));
+        //    }
+
+        //    public override Type GetTokenType(SecurityKeyIdentifierClause clause)
+        //    {
+        //        return null;
+        //    }
+
+        //    public override string GetTokenTypeUri()
+        //    {
+        //        return CoreWCF.XD.SecurityXXX2005Dictionary.Saml20TokenType.Value;
+        //    }
+
+        //    public override SecurityKeyIdentifierClause ReadClause(XmlDictionaryReader reader, byte[] derivationNone, int derivationLength, string tokenType)
+        //    {
+        //        string samlUri = reader.GetAttribute(CoreWCF.XD.SecurityJan2004Dictionary.URI, null);
+        //        if (reader.IsEmptyElement)
+        //        {
+        //            reader.Read();
+        //        }
+        //        else
+        //        {
+        //            reader.ReadStartElement();
+        //            reader.ReadEndElement();
+        //        }
+        //        return new SamlAssertionDirectKeyIdentifierClause(samlUri, derivationNone, derivationLength);
+        //    }
+
+        //    public override bool SupportsCore(SecurityKeyIdentifierClause clause)
+        //    {
+        //        return typeof(SamlAssertionDirectKeyIdentifierClause).IsAssignableFrom(clause.GetType());
+        //    }
+
+        //    public override void WriteContent(XmlDictionaryWriter writer, SecurityKeyIdentifierClause clause)
+        //    {
+        //        SamlAssertionDirectKeyIdentifierClause samlClause = clause as SamlAssertionDirectKeyIdentifierClause;
+        //        writer.WriteStartElement(CoreWCF.XD.SecurityJan2004Dictionary.Prefix.Value, CoreWCF.XD.SecurityJan2004Dictionary.Reference, CoreWCF.XD.SecurityJan2004Dictionary.Namespace);
+        //        writer.WriteAttributeString(CoreWCF.XD.SecurityJan2004Dictionary.URI, null, samlClause.SamlUri);
+        //        writer.WriteEndElement();
+        //    }
+        //}
+    }
+}
\ No newline at end of file
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Tokens/WSTrust.cs b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Tokens/WSTrust.cs
new file mode 100644
index 0000000..f6f1991
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Tokens/WSTrust.cs
@@ -0,0 +1,176 @@
+﻿namespace CoreWCF.IdentityModel.Security
+{
+    using System;
+    using System.Collections.Generic;
+    using CoreWCF.IdentityModel;
+    using CoreWCF.IdentityModel.Selectors;
+    using CoreWCF.IdentityModel.Tokens;
+    using CoreWCF.Security;
+    using CoreWCF.Security.Tokens;
+    using System.Xml;
+    using KeyIdentifierClauseEntry = CoreWCF.IdentityModel.Selectors.SecurityTokenSerializer.KeyIdentifierClauseEntry;
+
+    internal class WSTrust : SecurityTokenSerializer.SerializerEntries
+    {
+        KeyInfoSerializer securityTokenSerializer;
+        TrustDictionary serializerDictionary;
+
+        public WSTrust(KeyInfoSerializer securityTokenSerializer, TrustDictionary serializerDictionary)
+        {
+            this.securityTokenSerializer = securityTokenSerializer;
+            this.serializerDictionary = serializerDictionary;
+        }
+
+        public TrustDictionary SerializerDictionary
+        {
+            get
+            {
+                return this.serializerDictionary;
+            }
+        }
+
+        public override void PopulateTokenEntries(IList<SecurityTokenSerializer.TokenEntry> tokenEntryList)
+        {
+            tokenEntryList.Add(new BinarySecretTokenEntry(this));
+        }
+
+        public override void PopulateKeyIdentifierClauseEntries(IList<SecurityTokenSerializer.KeyIdentifierClauseEntry> keyIdentifierClauseEntries)
+        {
+            keyIdentifierClauseEntries.Add(new BinarySecretClauseEntry(this));
+            keyIdentifierClauseEntries.Add(new GenericXmlSecurityKeyIdentifierClauseEntry(this));
+        }
+
+        class BinarySecretTokenEntry : SecurityTokenSerializer.TokenEntry
+        {
+            WSTrust parent;
+
+            public BinarySecretTokenEntry(WSTrust parent)
+            {
+                this.parent = parent;
+            }
+
+            protected override XmlDictionaryString LocalName { get { return parent.SerializerDictionary.BinarySecret; } }
+            protected override XmlDictionaryString NamespaceUri { get { return parent.SerializerDictionary.Namespace; } }
+            protected override Type[] GetTokenTypesCore() { return new Type[] { typeof(BinarySecretSecurityToken) }; }
+            public override string TokenTypeUri { get { return null; } }
+            protected override string ValueTypeUri { get { return null; } }
+
+        }
+
+        internal class BinarySecretClauseEntry : KeyIdentifierClauseEntry
+        {
+            WSTrust parent;
+            TrustDictionary otherDictionary = null;
+
+            public BinarySecretClauseEntry(WSTrust parent)
+            {
+                this.parent = parent;
+
+                this.otherDictionary = null;
+
+                if (parent.SerializerDictionary is TrustDec2005Dictionary)
+                {
+                    this.otherDictionary = parent.securityTokenSerializer.DictionaryManager.TrustFeb2005Dictionary;
+                }
+
+                if (parent.SerializerDictionary is TrustFeb2005Dictionary)
+                {
+                    this.otherDictionary = parent.securityTokenSerializer.DictionaryManager.TrustDec2005Dictionary;
+                }
+
+                // always set it, so we don't have to worry about null
+                if (this.otherDictionary == null)
+                    this.otherDictionary = this.parent.SerializerDictionary;
+            }
+
+            protected override XmlDictionaryString LocalName
+            {
+                get { return this.parent.SerializerDictionary.BinarySecret; }
+            }
+
+            protected override XmlDictionaryString NamespaceUri
+            {
+                get { return this.parent.SerializerDictionary.Namespace; }
+            }
+
+            public override SecurityKeyIdentifierClause ReadKeyIdentifierClauseCore(XmlDictionaryReader reader)
+            {
+                byte[] secret = reader.ReadElementContentAsBase64();
+                return new BinarySecretKeyIdentifierClause(secret, false);
+            }
+
+            public override bool SupportsCore(SecurityKeyIdentifierClause keyIdentifierClause)
+            {
+                return keyIdentifierClause is BinarySecretKeyIdentifierClause;
+            }
+
+            public override bool CanReadKeyIdentifierClauseCore(XmlDictionaryReader reader)
+            {
+                return (reader.IsStartElement(this.LocalName, this.NamespaceUri) || reader.IsStartElement(this.LocalName, this.otherDictionary.Namespace));
+            }
+
+            public override void WriteKeyIdentifierClauseCore(XmlDictionaryWriter writer, SecurityKeyIdentifierClause keyIdentifierClause)
+            {
+                BinarySecretKeyIdentifierClause skic = keyIdentifierClause as BinarySecretKeyIdentifierClause;
+                byte[] secret = skic.GetKeyBytes();
+                writer.WriteStartElement(this.parent.SerializerDictionary.Prefix.Value, this.parent.SerializerDictionary.BinarySecret, this.parent.SerializerDictionary.Namespace);
+                writer.WriteBase64(secret, 0, secret.Length);
+                writer.WriteEndElement();
+            }
+        }
+
+        internal class GenericXmlSecurityKeyIdentifierClauseEntry : KeyIdentifierClauseEntry
+        {
+            private WSTrust parent;
+
+            public GenericXmlSecurityKeyIdentifierClauseEntry(WSTrust parent)
+            {
+                this.parent = parent;
+            }
+
+            protected override XmlDictionaryString LocalName
+            {
+                get { return null; }
+            }
+
+            protected override XmlDictionaryString NamespaceUri
+            {
+                get { return null; }
+            }
+
+            public override bool CanReadKeyIdentifierClauseCore(XmlDictionaryReader reader)
+            {
+                return false;
+            }
+
+            public override SecurityKeyIdentifierClause ReadKeyIdentifierClauseCore(XmlDictionaryReader reader)
+            {
+                return null;
+            }
+
+            public override bool SupportsCore(SecurityKeyIdentifierClause keyIdentifierClause)
+            {
+                return keyIdentifierClause is GenericXmlSecurityKeyIdentifierClause;
+            }
+
+            public override void WriteKeyIdentifierClauseCore(XmlDictionaryWriter writer, SecurityKeyIdentifierClause keyIdentifierClause)
+            {
+                GenericXmlSecurityKeyIdentifierClause genericXmlSecurityKeyIdentifierClause = keyIdentifierClause as GenericXmlSecurityKeyIdentifierClause;
+                genericXmlSecurityKeyIdentifierClause.ReferenceXml.WriteTo(writer);
+            }
+        }
+
+        protected static bool CheckElement(XmlElement element, string name, string ns, out string value)
+        {
+            value = null;
+            if (element.LocalName != name || element.NamespaceURI != ns)
+                return false;
+            if (element.FirstChild is XmlText)
+            {
+                value = ((XmlText)element.FirstChild).Value;
+                return true;
+            }
+            return false;
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Tokens/X509IssuerSerialKeyIdentifierClause.cs b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Tokens/X509IssuerSerialKeyIdentifierClause.cs
new file mode 100644
index 0000000..eb051a9
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Tokens/X509IssuerSerialKeyIdentifierClause.cs
@@ -0,0 +1,112 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+// See the LICENSE file in the project root for more information.
+
+using System.Globalization;
+using System.Security.Cryptography;
+using System.Security.Cryptography.X509Certificates;
+using CoreWCF;
+
+namespace CoreWCF.IdentityModel.Tokens
+{
+    public class X509IssuerSerialKeyIdentifierClause : SecurityKeyIdentifierClause
+    {
+        private readonly string _issuerSerialNumber;
+
+        public X509IssuerSerialKeyIdentifierClause(string issuerName, string issuerSerialNumber)
+            : base(null)
+        {
+            if (string.IsNullOrEmpty(issuerName))
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(issuerName));
+            }
+
+            if (string.IsNullOrEmpty(issuerSerialNumber))
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(issuerSerialNumber));
+            }
+
+            IssuerName = issuerName;
+            _issuerSerialNumber = issuerSerialNumber;
+        }
+
+        public X509IssuerSerialKeyIdentifierClause(X509Certificate2 certificate)
+            : base(null)
+        {
+            if (certificate == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(certificate));
+            }
+
+            IssuerName = certificate.Issuer;
+            _issuerSerialNumber = certificate.GetSerialNumberString();
+        }
+
+        public string IssuerName { get; }
+
+        public string IssuerSerialNumber
+        {
+            get { return _issuerSerialNumber; }
+        }
+
+        public override bool Matches(SecurityKeyIdentifierClause keyIdentifierClause)
+        {
+            X509IssuerSerialKeyIdentifierClause that = keyIdentifierClause as X509IssuerSerialKeyIdentifierClause;
+            return ReferenceEquals(this, that) || (that != null && that.Matches(IssuerName, _issuerSerialNumber));
+        }
+
+        public bool Matches(X509Certificate2 certificate)
+        {
+            if (certificate == null)
+            {
+                return false;
+            }
+
+            return Matches(certificate.Issuer, certificate.GetSerialNumberString());
+        }
+
+        public bool Matches(string issuerName, string issuerSerialNumber)
+        {
+            if (issuerName == null)
+            {
+                return false;
+            }
+
+            // If serial numbers dont match, we can avoid the potentially expensive issuer name comparison
+            if (_issuerSerialNumber != issuerSerialNumber)
+            {
+                return false;
+            }
+
+            // Serial numbers match. Do a string comparison of issuer names
+            if (IssuerName == issuerName)
+            {
+                return true;
+            }
+
+            // String equality comparison for issuer names failed
+            // Do a byte-level comparison of the X500 distinguished names corresponding to the issuer names. 
+            // X500DistinguishedName constructor can throw for malformed inputs
+            bool x500IssuerNameMatch = false;
+            try
+            {
+                if (CoreWCF.Security.SecurityUtils.IsEqual(new X500DistinguishedName(IssuerName).RawData,
+                                                                       new X500DistinguishedName(issuerName).RawData))
+                {
+                    x500IssuerNameMatch = true;
+                }
+            }
+            catch (CryptographicException)
+            {
+            }
+
+            return x500IssuerNameMatch;
+        }
+
+        public override string ToString()
+        {
+            return string.Format(CultureInfo.InvariantCulture, "X509IssuerSerialKeyIdentifierClause(Issuer = '{0}', Serial = '{1}')",
+                IssuerName, IssuerSerialNumber);
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Tokens/X509RawDataKeyIdentifierClause.cs b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Tokens/X509RawDataKeyIdentifierClause.cs
new file mode 100644
index 0000000..8bd2b64
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Tokens/X509RawDataKeyIdentifierClause.cs
@@ -0,0 +1,82 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+
+
+using System;
+using System.Globalization;
+using System.Security.Cryptography.X509Certificates;
+using CoreWCF;
+
+namespace CoreWCF.IdentityModel.Tokens
+{
+    public class X509RawDataKeyIdentifierClause : BinaryKeyIdentifierClause
+    {
+        private X509Certificate2 _certificate;
+       // private X509AsymmetricSecurityKey _key;
+
+        public X509RawDataKeyIdentifierClause(X509Certificate2 certificate)
+            : this(GetRawData(certificate), false)
+        {
+            _certificate = certificate;
+        }
+
+        public X509RawDataKeyIdentifierClause(byte[] certificateRawData)
+            : this(certificateRawData, true)
+        {
+        }
+
+        internal X509RawDataKeyIdentifierClause(byte[] certificateRawData, bool cloneBuffer)
+            : base(null, certificateRawData, cloneBuffer)
+        {
+        }
+
+        public override bool CanCreateKey
+        {
+            get { return true; }
+        }
+
+        public override SecurityKey CreateKey()
+        {
+            throw new NotImplementedException();
+            //if (_key == null)
+            //{
+            //    if (_certificate == null)
+            //    {
+            //        _certificate = new X509Certificate2(GetBuffer());
+            //    }
+                
+            // _key = new X509AsymmetricSecurityKey(_certificate);
+            //}
+            //return _key;
+        }
+
+        private static byte[] GetRawData(X509Certificate certificate)
+        {
+            if (certificate == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(certificate));
+            }
+
+            return certificate.GetRawCertData();
+        }
+
+        public byte[] GetX509RawData()
+        {
+            return GetBuffer();
+        }
+
+        public bool Matches(X509Certificate2 certificate)
+        {
+            if (certificate == null)
+            {
+                return false;
+            }
+
+            return Matches(GetRawData(certificate));
+        }
+
+        public override string ToString()
+        {
+            return string.Format(CultureInfo.InvariantCulture, "X509RawDataKeyIdentifierClause(RawData = {0})", ToBase64String());
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Tokens/X509SubjectKeyIdentifierClause.cs b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Tokens/X509SubjectKeyIdentifierClause.cs
new file mode 100644
index 0000000..7069c04
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Tokens/X509SubjectKeyIdentifierClause.cs
@@ -0,0 +1,76 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Text;
+
+namespace CoreWCF.IdentityModel.Tokens
+{
+    using CoreWCF.IdentityModel.Tokens;
+    using System.Globalization;
+    using System.Security.Cryptography.X509Certificates;
+
+    public class X509SubjectKeyIdentifierClause : BinaryKeyIdentifierClause
+    {
+        const string SubjectKeyIdentifierOid = "2.5.29.14";
+        const int SkiDataOffset = 2;
+
+        public X509SubjectKeyIdentifierClause(byte[] ski)
+            : this(ski, true)
+        {
+        }
+
+        internal X509SubjectKeyIdentifierClause(byte[] ski, bool cloneBuffer)
+            : base(null, ski, cloneBuffer)
+        {
+        }
+
+        static byte[] GetSkiRawData(X509Certificate2 certificate)
+        {
+            if (certificate == null)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("certificate");
+
+            X509SubjectKeyIdentifierExtension skiExtension =
+                certificate.Extensions[SubjectKeyIdentifierOid] as X509SubjectKeyIdentifierExtension;
+            if (skiExtension != null)
+            {
+                return skiExtension.RawData;
+            }
+            else
+            {
+                return null;
+            }
+        }
+
+        public byte[] GetX509SubjectKeyIdentifier()
+        {
+            return GetBuffer();
+        }
+
+        public bool Matches(X509Certificate2 certificate)
+        {
+            if (certificate == null)
+                return false;
+
+            byte[] data = GetSkiRawData(certificate);
+            return data != null && Matches(data, SkiDataOffset);
+        }
+
+        public static bool TryCreateFrom(X509Certificate2 certificate, out X509SubjectKeyIdentifierClause keyIdentifierClause)
+        {
+            byte[] data = GetSkiRawData(certificate);
+            keyIdentifierClause = null;
+            if (data != null)
+            {
+                byte[] ski = SecurityUtils.CloneBuffer(data, SkiDataOffset, data.Length - SkiDataOffset);
+                keyIdentifierClause = new X509SubjectKeyIdentifierClause(ski, false);
+            }
+            return keyIdentifierClause != null;
+        }
+
+        public static bool CanCreateFrom(X509Certificate2 certificate)
+        {
+            return null != GetSkiRawData(certificate);
+        }
+
+       
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Tokens/XmlDsigSep2000.cs b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Tokens/XmlDsigSep2000.cs
new file mode 100644
index 0000000..cfbc6f4
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Tokens/XmlDsigSep2000.cs
@@ -0,0 +1,219 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+// See the LICENSE file in the project root for more information.
+
+using System.Collections.Generic;
+using CoreWCF.IdentityModel.Selectors;
+using System.Security.Cryptography.X509Certificates;
+using CoreWCF;
+using System.Xml;
+using KeyIdentifierEntry = CoreWCF.IdentityModel.Selectors.SecurityTokenSerializer.KeyIdentifierEntry;
+
+namespace CoreWCF.IdentityModel.Tokens
+{
+    internal class XmlDsigSep2000 : SecurityTokenSerializer.SerializerEntries
+    {
+        private KeyInfoSerializer _securityTokenSerializer;
+
+        public XmlDsigSep2000(KeyInfoSerializer securityTokenSerializer)
+        {
+            _securityTokenSerializer = securityTokenSerializer;
+        }
+
+        public override void PopulateKeyIdentifierEntries(IList<KeyIdentifierEntry> keyIdentifierEntries)
+        {
+            keyIdentifierEntries.Add(new KeyInfoEntry(_securityTokenSerializer));
+        }
+
+        public override void PopulateKeyIdentifierClauseEntries(IList<SecurityTokenSerializer.KeyIdentifierClauseEntry> keyIdentifierClauseEntries)
+        {
+            keyIdentifierClauseEntries.Add(new X509CertificateClauseEntry());
+        }
+
+        internal class KeyInfoEntry : KeyIdentifierEntry
+        {
+            private KeyInfoSerializer _securityTokenSerializer;
+
+            public KeyInfoEntry(KeyInfoSerializer securityTokenSerializer)
+            {
+                _securityTokenSerializer = securityTokenSerializer;
+            }
+
+            protected override XmlDictionaryString LocalName
+            {
+                get
+                {
+                    return CoreWCF.XD.XmlSignatureDictionary.KeyInfo;
+                }
+            }
+
+            protected override XmlDictionaryString NamespaceUri
+            {
+                get
+                {
+                    return CoreWCF.XD.XmlSignatureDictionary.Namespace;
+                }
+            }
+
+            public override SecurityKeyIdentifier ReadKeyIdentifierCore(XmlDictionaryReader reader)
+            {
+                reader.ReadStartElement(LocalName, NamespaceUri);
+                SecurityKeyIdentifier keyIdentifier = new SecurityKeyIdentifier();
+                while (reader.IsStartElement())
+                {
+                    SecurityKeyIdentifierClause clause = _securityTokenSerializer.ReadKeyIdentifierClause(reader);
+                    if (clause == null)
+                    {
+                        reader.Skip();
+                    }
+                    else
+                    {
+                        keyIdentifier.Add(clause);
+                    }
+                }
+                if (keyIdentifier.Count == 0)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new XmlException("ErrorDeserializingKeyIdentifierClause"));
+                }
+                reader.ReadEndElement();
+                return keyIdentifier;
+            }
+
+            public override bool SupportsCore(SecurityKeyIdentifier keyIdentifier)
+            {
+                return true;
+            }
+
+            public override void WriteKeyIdentifierCore(XmlDictionaryWriter writer, SecurityKeyIdentifier keyIdentifier)
+            {
+                writer.WriteStartElement(CoreWCF.XD.XmlSignatureDictionary.Prefix.Value, LocalName, NamespaceUri);
+                bool clauseWritten = false;
+                foreach (SecurityKeyIdentifierClause clause in keyIdentifier)
+                {
+                    _securityTokenSerializer.InnerSecurityTokenSerializer.WriteKeyIdentifierClause(writer, clause);
+                    clauseWritten = true;
+                }
+                writer.WriteEndElement(); // KeyInfo
+                if (!clauseWritten)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new System.Exception("NoKeyInfoClausesToWrite"));
+                }
+            }
+        }
+
+        // so far, we only support two types of X509Data directly under KeyInfo  - X509Certificate and X509SKI
+        //   <ds:X509Data>
+        //     <ds:X509Certificate>...</ds:X509Certificate>
+        //      or
+        //     <X509SKI>... </X509SKI>
+        //   </ds:X509Data>
+        // only support 1 certificate right now
+        internal class X509CertificateClauseEntry : SecurityTokenSerializer.KeyIdentifierClauseEntry
+        {
+            protected override XmlDictionaryString LocalName
+            {
+                get
+                {
+                    return CoreWCF.XD.XmlSignatureDictionary.X509Data;
+                }
+            }
+
+            protected override XmlDictionaryString NamespaceUri
+            {
+                get
+                {
+                    return CoreWCF.XD.XmlSignatureDictionary.Namespace;
+                }
+            }
+
+            public override SecurityKeyIdentifierClause ReadKeyIdentifierClauseCore(XmlDictionaryReader reader)
+            {
+                SecurityKeyIdentifierClause ski = null;
+                reader.ReadStartElement(CoreWCF.XD.XmlSignatureDictionary.X509Data, NamespaceUri);
+                while (reader.IsStartElement())
+                {
+                    if (ski == null && reader.IsStartElement(CoreWCF.XD.XmlSignatureDictionary.X509Certificate, NamespaceUri))
+                    {
+                        X509Certificate2 certificate = null;
+                        if (!SecurityUtils.TryCreateX509CertificateFromRawData(reader.ReadElementContentAsBase64(), out certificate))
+                        {
+                            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new System.Exception(SR.InvalidX509RawData));
+                        }
+                        ski = new X509RawDataKeyIdentifierClause(certificate);
+                    }
+                    else if (ski == null && reader.IsStartElement(XmlSignatureStrings.X509Ski, NamespaceUri.ToString()))
+                    {
+                        ski = new X509SubjectKeyIdentifierClause(reader.ReadElementContentAsBase64());
+                    }
+                    else if ((ski == null) && reader.IsStartElement(CoreWCF.XD.XmlSignatureDictionary.X509IssuerSerial, CoreWCF.XD.XmlSignatureDictionary.Namespace))
+                    {
+                        reader.ReadStartElement(CoreWCF.XD.XmlSignatureDictionary.X509IssuerSerial, CoreWCF.XD.XmlSignatureDictionary.Namespace);
+                        reader.ReadStartElement(CoreWCF.XD.XmlSignatureDictionary.X509IssuerName, CoreWCF.XD.XmlSignatureDictionary.Namespace);
+                        string issuerName = reader.ReadContentAsString();
+                        reader.ReadEndElement();
+                        reader.ReadStartElement(CoreWCF.XD.XmlSignatureDictionary.X509SerialNumber, CoreWCF.XD.XmlSignatureDictionary.Namespace);
+                        string serialNumber = reader.ReadContentAsString();
+                        reader.ReadEndElement();
+                        reader.ReadEndElement();
+
+                        ski = new X509IssuerSerialKeyIdentifierClause(issuerName, serialNumber);
+                    }
+                    else
+                    {
+                        reader.Skip();
+                    }
+                }
+                reader.ReadEndElement();
+                return ski;
+            }
+
+            public override bool SupportsCore(SecurityKeyIdentifierClause keyIdentifierClause)
+            {
+                return (keyIdentifierClause is X509RawDataKeyIdentifierClause);
+                // This method should not write X509IssuerSerialKeyIdentifierClause or X509SubjectKeyIdentifierClause as that should be written by the WSSecurityXXX classes with SecurityTokenReference tag. 
+                // The XmlDsig entries are written by the X509SecurityTokenHandler.
+            }
+
+            public override void WriteKeyIdentifierClauseCore(XmlDictionaryWriter writer, SecurityKeyIdentifierClause keyIdentifierClause)
+            {
+                X509RawDataKeyIdentifierClause x509Clause = keyIdentifierClause as X509RawDataKeyIdentifierClause;
+
+                if (x509Clause != null)
+                {
+                    writer.WriteStartElement(CoreWCF.XD.XmlSignatureDictionary.Prefix.Value, CoreWCF.XD.XmlSignatureDictionary.X509Data, NamespaceUri);
+
+                    writer.WriteStartElement(CoreWCF.XD.XmlSignatureDictionary.Prefix.Value, CoreWCF.XD.XmlSignatureDictionary.X509Certificate, NamespaceUri);
+                    byte[] certBytes = x509Clause.GetX509RawData();
+                    writer.WriteBase64(certBytes, 0, certBytes.Length);
+                    writer.WriteEndElement();
+
+                    writer.WriteEndElement();
+                }
+
+                X509IssuerSerialKeyIdentifierClause issuerSerialClause = keyIdentifierClause as X509IssuerSerialKeyIdentifierClause;
+                if (issuerSerialClause != null)
+                {
+                    writer.WriteStartElement(CoreWCF.XD.XmlSignatureDictionary.Prefix.Value, CoreWCF.XD.XmlSignatureDictionary.X509Data, CoreWCF.XD.XmlSignatureDictionary.Namespace);
+                    writer.WriteStartElement(CoreWCF.XD.XmlSignatureDictionary.Prefix.Value, CoreWCF.XD.XmlSignatureDictionary.X509IssuerSerial, CoreWCF.XD.XmlSignatureDictionary.Namespace);
+                    writer.WriteElementString(CoreWCF.XD.XmlSignatureDictionary.Prefix.Value, CoreWCF.XD.XmlSignatureDictionary.X509IssuerName, CoreWCF.XD.XmlSignatureDictionary.Namespace, issuerSerialClause.IssuerName);
+                    writer.WriteElementString(CoreWCF.XD.XmlSignatureDictionary.Prefix.Value, CoreWCF.XD.XmlSignatureDictionary.X509SerialNumber, CoreWCF.XD.XmlSignatureDictionary.Namespace, issuerSerialClause.IssuerSerialNumber);
+                    writer.WriteEndElement();
+                    writer.WriteEndElement();
+                    return;
+                }
+
+                X509SubjectKeyIdentifierClause skiClause = keyIdentifierClause as X509SubjectKeyIdentifierClause;
+                if (skiClause != null)
+                {
+                    writer.WriteStartElement(XmlSignatureConstants.Prefix, XmlSignatureConstants.Elements.X509Data, XmlSignatureConstants.Namespace);
+                    writer.WriteStartElement(XmlSignatureConstants.Prefix, XmlSignatureConstants.Elements.X509SKI, XmlSignatureConstants.Namespace);
+                    byte[] ski = skiClause.GetX509SubjectKeyIdentifier();
+                    writer.WriteBase64(ski, 0, ski.Length);
+                    writer.WriteEndElement();
+                    writer.WriteEndElement();
+                    return;
+                }
+            }
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Transform.cs b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Transform.cs
new file mode 100644
index 0000000..c9c271d
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/Transform.cs
@@ -0,0 +1,32 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Text;
+using System.Xml;
+
+namespace CoreWCF.IdentityModel
+{
+    abstract class Transform
+    {
+        protected Transform()
+        {
+        }
+
+        public abstract string Algorithm
+        {
+            get;
+        }
+
+        public virtual bool NeedsInclusiveContext
+        {
+            get { return false; }
+        }
+
+        public abstract object Process(object input, SignatureResourcePool resourcePool, DictionaryManager dictionaryManager);
+
+        public abstract byte[] ProcessAndDigest(object input, SignatureResourcePool resourcePool, string digestAlgorithm, DictionaryManager dictionaryManager);
+
+        public abstract void ReadFrom(XmlDictionaryReader reader, DictionaryManager dictionaryManager, bool preserveComments);
+
+        public abstract void WriteTo(XmlDictionaryWriter writer, DictionaryManager dictionaryManager);
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/TransformFactory.cs b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/TransformFactory.cs
new file mode 100644
index 0000000..b4a3df7
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/TransformFactory.cs
@@ -0,0 +1,14 @@
+﻿using System.Collections;
+using System.IO;
+using System.Security.Cryptography;
+using System.Text;
+using System.Xml;
+
+namespace CoreWCF.IdentityModel
+{
+
+    internal abstract class TransformFactory
+    {
+        public abstract Transform CreateTransform(string transformAlgorithmUri);
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/WrappedKeySecurityToken.cs b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/WrappedKeySecurityToken.cs
new file mode 100644
index 0000000..521f700
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/WrappedKeySecurityToken.cs
@@ -0,0 +1,239 @@
+using System.Collections.ObjectModel;
+using CoreWCF.IdentityModel;
+using CoreWCF.IdentityModel.Tokens;
+using System.Runtime.CompilerServices;
+using System.Security.Cryptography;
+using CoreWCF.Security;
+using System.Xml;
+using System;
+using CoreWCF.Security;
+
+namespace CoreWCF.Security.Tokens
+{
+
+   public class WrappedKeySecurityToken : SecurityToken
+    {
+        string id;
+        DateTime effectiveTime;
+
+       EncryptedKey encryptedKey;
+        ReadOnlyCollection<SecurityKey> securityKey;
+        byte[] wrappedKey;
+        string wrappingAlgorithm;
+        ISspiNegotiation wrappingSspiContext;
+        SecurityToken wrappingToken;
+        SecurityKey wrappingSecurityKey;
+        SecurityKeyIdentifier wrappingTokenReference;
+        bool serializeCarriedKeyName;
+        byte[] wrappedKeyHash;
+        XmlDictionaryString wrappingAlgorithmDictionaryString;
+
+        // sender use
+        internal WrappedKeySecurityToken(string id, byte[] keyToWrap, ISspiNegotiation wrappingSspiContext)
+            : this(id, keyToWrap, (wrappingSspiContext != null) ? (wrappingSspiContext.KeyEncryptionAlgorithm) : null, wrappingSspiContext, null)
+        {
+        }
+
+        // sender use
+        public WrappedKeySecurityToken(string id, byte[] keyToWrap, string wrappingAlgorithm, SecurityToken wrappingToken, SecurityKeyIdentifier wrappingTokenReference)
+            : this(id, keyToWrap, wrappingAlgorithm, null, wrappingToken, wrappingTokenReference)
+        {
+        }
+
+        internal WrappedKeySecurityToken(string id, byte[] keyToWrap, string wrappingAlgorithm, XmlDictionaryString wrappingAlgorithmDictionaryString, SecurityToken wrappingToken, SecurityKeyIdentifier wrappingTokenReference)
+            : this(id, keyToWrap, wrappingAlgorithm, wrappingAlgorithmDictionaryString, wrappingToken, wrappingTokenReference, null, null)
+        {
+        }
+
+        // direct receiver use, chained sender use
+        internal WrappedKeySecurityToken(string id, byte[] keyToWrap, string wrappingAlgorithm, ISspiNegotiation wrappingSspiContext, byte[] wrappedKey)
+            : this(id, keyToWrap, wrappingAlgorithm, null)
+        {
+            if (wrappingSspiContext == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("wrappingSspiContext");
+            }
+            this.wrappingSspiContext = wrappingSspiContext;
+            if (wrappedKey == null)
+            {
+                this.wrappedKey = wrappingSspiContext.Encrypt(keyToWrap);
+            }
+            else
+            {
+                this.wrappedKey = wrappedKey;
+            }
+            this.serializeCarriedKeyName = false;
+        }
+
+        // receiver use
+        internal WrappedKeySecurityToken(string id, byte[] keyToWrap, string wrappingAlgorithm, SecurityToken wrappingToken, SecurityKeyIdentifier wrappingTokenReference, byte[] wrappedKey, SecurityKey wrappingSecurityKey)
+            : this(id, keyToWrap, wrappingAlgorithm, null, wrappingToken, wrappingTokenReference, wrappedKey, wrappingSecurityKey)
+        {
+        }
+
+        WrappedKeySecurityToken(string id, byte[] keyToWrap, string wrappingAlgorithm, XmlDictionaryString wrappingAlgorithmDictionaryString, SecurityToken wrappingToken, SecurityKeyIdentifier wrappingTokenReference, byte[] wrappedKey, SecurityKey wrappingSecurityKey)
+            : this(id, keyToWrap, wrappingAlgorithm, wrappingAlgorithmDictionaryString)
+        {
+            if (wrappingToken == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("wrappingToken");
+            }
+            this.wrappingToken = wrappingToken;
+            this.wrappingTokenReference = wrappingTokenReference;
+            if (wrappedKey == null)
+            {
+                this.wrappedKey = SecurityUtils.EncryptKey(wrappingToken, wrappingAlgorithm, keyToWrap);
+            }
+            else
+            {
+                this.wrappedKey = wrappedKey;
+            }
+            this.wrappingSecurityKey = wrappingSecurityKey;
+            this.serializeCarriedKeyName = true;
+        }
+
+        WrappedKeySecurityToken(string id, byte[] keyToWrap, string wrappingAlgorithm, XmlDictionaryString wrappingAlgorithmDictionaryString)
+        {
+            if (id == null)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("id");
+            if (wrappingAlgorithm == null)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("wrappingAlgorithm");
+            if (keyToWrap == null)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("securityKeyToWrap");
+
+            this.id = id;
+            this.effectiveTime = DateTime.UtcNow;
+            this.securityKey = SecurityUtils.CreateSymmetricSecurityKeys(keyToWrap);
+            this.wrappingAlgorithm = wrappingAlgorithm;
+            this.wrappingAlgorithmDictionaryString = wrappingAlgorithmDictionaryString;
+        }
+
+        public override string Id
+        {
+            get { return this.id; }
+        }
+
+        public override DateTime ValidFrom
+        {
+            get { return this.effectiveTime; }
+        }
+
+        public override DateTime ValidTo
+        {
+            // Never expire
+            get { return DateTime.MaxValue; }
+        }
+
+        internal EncryptedKey EncryptedKey
+        {
+            get { return this.encryptedKey; }
+            set { this.encryptedKey = value; }
+        }
+
+        internal ReferenceList ReferenceList
+        {
+            get
+            {
+                return this.encryptedKey == null ? null : this.encryptedKey.ReferenceList;
+            }
+        }
+
+        public string WrappingAlgorithm
+        {
+            get { return this.wrappingAlgorithm; }
+        }
+
+        internal SecurityKey WrappingSecurityKey
+        {
+            get { return this.wrappingSecurityKey; }
+        }
+
+        public SecurityToken WrappingToken
+        {
+            get { return this.wrappingToken; }
+        }
+
+        public SecurityKeyIdentifier WrappingTokenReference
+        {
+            get { return this.wrappingTokenReference; }
+        }
+
+        internal string CarriedKeyName
+        {
+            get { return null; }
+        }
+
+        public override ReadOnlyCollection<SecurityKey> SecurityKeys
+        {
+            get { return this.securityKey; }
+        }
+
+        internal byte[] GetHash()
+        {
+            if (this.wrappedKeyHash == null)
+            {
+                EnsureEncryptedKeySetUp();
+                using (HashAlgorithm hash = CryptoHelper.NewSha1HashAlgorithm())
+                {
+                    this.wrappedKeyHash = hash.ComputeHash(this.encryptedKey.GetWrappedKey());
+                }
+            }
+            return wrappedKeyHash;
+        }
+
+        public byte[] GetWrappedKey()
+        {
+            return SecurityUtils.CloneBuffer(this.wrappedKey);
+        }
+
+        internal void EnsureEncryptedKeySetUp()
+        {
+            if (this.encryptedKey == null)
+            {
+                EncryptedKey ek = new EncryptedKey();
+                ek.Id = this.Id;
+                if (this.serializeCarriedKeyName)
+                {
+                    ek.CarriedKeyName = this.CarriedKeyName;
+                }
+                else
+                {
+                    ek.CarriedKeyName = null;
+                }
+                ek.EncryptionMethod = this.WrappingAlgorithm;
+                ek.EncryptionMethodDictionaryString = this.wrappingAlgorithmDictionaryString;
+                ek.SetUpKeyWrap(this.wrappedKey);
+                if (this.WrappingTokenReference != null)
+                {
+                    ek.KeyIdentifier = this.WrappingTokenReference;
+                }
+                this.encryptedKey = ek;
+            }
+        }
+
+        public override bool CanCreateKeyIdentifierClause<T>()
+        {
+            if (typeof(T) == typeof(EncryptedKeyHashIdentifierClause))
+                return true;
+
+            return base.CanCreateKeyIdentifierClause<T>();
+        }
+
+        public override T CreateKeyIdentifierClause<T>()
+        {
+            if (typeof(T) == typeof(EncryptedKeyHashIdentifierClause))
+                return new EncryptedKeyHashIdentifierClause(GetHash()) as T;
+
+            return base.CreateKeyIdentifierClause<T>();
+        }
+
+        public override bool MatchesKeyIdentifierClause(SecurityKeyIdentifierClause keyIdentifierClause)
+        {
+            EncryptedKeyHashIdentifierClause encKeyIdentifierClause = keyIdentifierClause as EncryptedKeyHashIdentifierClause;
+            if (encKeyIdentifierClause != null)
+                return encKeyIdentifierClause.Matches(GetHash());
+
+            return base.MatchesKeyIdentifierClause(keyIdentifierClause);
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/XD.cs b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/XD.cs
index 46c76aa..f4ee7c5 100644
--- a/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/XD.cs
+++ b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/XD.cs
@@ -1,4 +1,4 @@
-﻿using System;
+using System;
 using System.Collections.Generic;
 using System.Text;
 
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/XmlAttributeHolder.cs b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/XmlAttributeHolder.cs
new file mode 100644
index 0000000..43a2cf3
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/XmlAttributeHolder.cs
@@ -0,0 +1,110 @@
+namespace CoreWCF.IdentityModel
+{
+    using System.Xml;
+    using System;
+
+    struct XmlAttributeHolder
+    {
+        string prefix;
+        string ns;
+        string localName;
+        string value;
+
+        public static XmlAttributeHolder[] emptyArray = new XmlAttributeHolder[0];
+
+        public XmlAttributeHolder(string prefix, string localName, string ns, string value)
+        {
+            this.prefix = prefix;
+            this.localName = localName;
+            this.ns = ns;
+            this.value = value;
+        }
+
+        public string Prefix
+        {
+            get { return prefix; }
+        }
+
+        public string NamespaceUri
+        {
+            get { return ns; }
+        }
+
+        public string LocalName
+        {
+            get { return localName; }
+        }
+
+        public string Value
+        {
+            get { return value; }
+        }
+
+        public void WriteTo(XmlWriter writer)
+        {
+            writer.WriteStartAttribute(prefix, localName, ns);
+            writer.WriteString(value);
+            writer.WriteEndAttribute();
+        }
+
+        public static void WriteAttributes(XmlAttributeHolder[] attributes, XmlWriter writer)
+        {
+            for (int i = 0; i < attributes.Length; i++)
+                attributes[i].WriteTo(writer);
+        }
+
+        public static XmlAttributeHolder[] ReadAttributes(XmlDictionaryReader reader)
+        {
+            int maxSizeOfHeaders = int.MaxValue;
+            return ReadAttributes(reader, ref maxSizeOfHeaders);
+        }
+
+        public static XmlAttributeHolder[] ReadAttributes(XmlDictionaryReader reader, ref int maxSizeOfHeaders)
+        {
+            if (reader.AttributeCount == 0)
+                return emptyArray;
+            XmlAttributeHolder[] attributes = new XmlAttributeHolder[reader.AttributeCount];
+            reader.MoveToFirstAttribute();
+            for (int i = 0; i < attributes.Length; i++)
+            {
+                string ns = reader.NamespaceURI;
+                string localName = reader.LocalName;
+                string prefix = reader.Prefix;
+                string value = string.Empty;
+                while (reader.ReadAttributeValue())
+                {
+                    if (value.Length == 0)
+                        value = reader.Value;
+                    else
+                        value += reader.Value;
+                }
+                Deduct(prefix, ref maxSizeOfHeaders);
+                Deduct(localName, ref maxSizeOfHeaders);
+                Deduct(ns, ref maxSizeOfHeaders);
+                Deduct(value, ref maxSizeOfHeaders);
+                attributes[i] = new XmlAttributeHolder(prefix, localName, ns, value);
+                reader.MoveToNextAttribute();
+            }
+            reader.MoveToElement();
+            return attributes;
+        }
+
+        static void Deduct(string s, ref int maxSizeOfHeaders)
+        {
+            int byteCount = s.Length * sizeof(char);
+            if (byteCount > maxSizeOfHeaders)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.XmlBufferQuotaExceeded)));
+            }
+            maxSizeOfHeaders -= byteCount;
+        }
+
+        public static string GetAttribute(XmlAttributeHolder[] attributes, string localName, string ns)
+        {
+            for (int i = 0; i < attributes.Length; i++)
+                if (attributes[i].LocalName == localName && attributes[i].NamespaceUri == ns)
+                    return attributes[i].Value;
+            return null;
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/XmlBuffer.cs b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/XmlBuffer.cs
new file mode 100644
index 0000000..6c7b522
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/XmlBuffer.cs
@@ -0,0 +1,152 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Text;
+using System.Collections.Generic;
+using CoreWCF.Runtime;
+using System.Xml;
+using CoreWCF.Channels;
+
+namespace CoreWCF.IdentityModel
+{
+    class XmlBuffer
+    {
+        List<Section> sections;
+        byte[] buffer;
+        int offset;
+        BufferedOutputStream stream;
+        BufferState bufferState;
+        XmlDictionaryWriter writer;
+        XmlDictionaryReaderQuotas quotas;
+
+        enum BufferState
+        {
+            Created,
+            Writing,
+            Reading,
+        }
+
+        struct Section
+        {
+            int offset;
+            int size;
+            XmlDictionaryReaderQuotas quotas;
+
+            public Section(int offset, int size, XmlDictionaryReaderQuotas quotas)
+            {
+                this.offset = offset;
+                this.size = size;
+                this.quotas = quotas;
+            }
+
+            public int Offset
+            {
+                get { return this.offset; }
+            }
+
+            public int Size
+            {
+                get { return this.size; }
+            }
+
+            public XmlDictionaryReaderQuotas Quotas
+            {
+                get { return this.quotas; }
+            }
+        }
+
+        public XmlBuffer(int maxBufferSize)
+        {
+            if (maxBufferSize < 0)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("maxBufferSize", maxBufferSize,
+                                                    SR.Format(SR.ValueMustBeNonNegative)));
+            int initialBufferSize = Math.Min(512, maxBufferSize);
+            stream = new BufferManagerOutputStream(SR.XmlBufferQuotaExceeded, initialBufferSize, maxBufferSize,
+                BufferManager.CreateBufferManager(0, int.MaxValue));
+            sections = new List<Section>(1);
+        }
+
+        public int BufferSize
+        {
+            get
+            {
+                Fx.Assert(bufferState == BufferState.Reading, "Buffer size shuold only be retrieved during Reading state");
+                return buffer.Length;
+            }
+        }
+
+        public int SectionCount
+        {
+            get { return this.sections.Count; }
+        }
+
+        public XmlDictionaryWriter OpenSection(XmlDictionaryReaderQuotas quotas)
+        {
+            if (bufferState != BufferState.Created)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(CreateInvalidStateException());
+            bufferState = BufferState.Writing;
+            this.quotas = new XmlDictionaryReaderQuotas();
+            quotas.CopyTo(this.quotas);
+            if (this.writer == null)
+            {
+                this.writer = XmlDictionaryWriter.CreateBinaryWriter(stream, CoreWCF.XD.Dictionary, null, true);
+            }
+            else
+            {
+                ((IXmlBinaryWriterInitializer)this.writer).SetOutput(stream, CoreWCF.XD.Dictionary, null, true);
+            }
+            return this.writer;
+        }
+
+        public void CloseSection()
+        {
+            if (bufferState != BufferState.Writing)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(CreateInvalidStateException());
+            this.writer.Close();
+            bufferState = BufferState.Created;
+            int size = (int)stream.Length - offset;
+            sections.Add(new Section(offset, size, this.quotas));
+            offset += size;
+        }
+
+        public void Close()
+        {
+            if (bufferState != BufferState.Created)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(CreateInvalidStateException());
+            bufferState = BufferState.Reading;
+            int bufferSize;
+            buffer = stream.ToArray(out bufferSize);
+            writer = null;
+            stream = null;
+        }
+
+        Exception CreateInvalidStateException()
+        {
+            return new InvalidOperationException(SR.Format(SR.XmlBufferInInvalidState));
+        }
+
+        public XmlDictionaryReader GetReader(int sectionIndex)
+        {
+            if (bufferState != BufferState.Reading)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(CreateInvalidStateException());
+            Section section = sections[sectionIndex];
+            XmlDictionaryReader reader = XmlDictionaryReader.CreateBinaryReader(buffer, section.Offset, section.Size, CoreWCF.XD.Dictionary, section.Quotas, null, null);
+            reader.MoveToContent();
+            return reader;
+        }
+
+        public void WriteTo(int sectionIndex, XmlWriter writer)
+        {
+            if (bufferState != BufferState.Reading)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(CreateInvalidStateException());
+            XmlDictionaryReader reader = GetReader(sectionIndex);
+            try
+            {
+                writer.WriteNode(reader, false);
+            }
+            finally
+            {
+                reader.Close();
+            }
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/XmlSignatureConstants.cs b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/XmlSignatureConstants.cs
new file mode 100644
index 0000000..906f75a
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/XmlSignatureConstants.cs
@@ -0,0 +1,62 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Text;
+
+namespace CoreWCF.IdentityModel
+{
+    internal static class XmlSignatureConstants
+    {
+#pragma warning disable 1591
+        public const string Namespace = "http://www.w3.org/2000/09/xmldsig#";
+        public const string Prefix = "ds";
+
+        public static class Algorithms
+        {
+            // Canonicalization.
+            public const string ExcC14N = "http://www.w3.org/2001/10/xml-exc-c14n#";
+            public const string ExcC14NWithComments = "http://www.w3.org/2001/10/xml-exc-c14n#WithComments";
+            // Message Digest
+            public const string Sha1 = Namespace + "sha1";
+            // Enveloped Signature.
+            public const string EnvelopedSignature = Namespace + "enveloped-signature";
+        }
+
+        public static class Attributes
+        {
+            public const string Algorithm = "Algorithm";
+            public const string Id = "Id";
+            public const string Type = "Type";
+            public const string URI = "URI";
+        }
+
+        public static class Elements
+        {
+            public const string CanonicalizationMethod = "CanonicalizationMethod";
+            public const string DigestMethod = "DigestMethod";
+            public const string DigestValue = "DigestValue";
+            public const string Exponent = "Exponent";
+            public const string KeyInfo = "KeyInfo";
+            public const string KeyName = "KeyName";
+            public const string KeyValue = "KeyValue";
+            public const string Modulus = "Modulus";
+            public const string Object = "Object";
+            public const string Reference = "Reference";
+            public const string RetrievalMethod = "RetrievalMethod";
+            public const string RsaKeyValue = "RsaKeyValue";
+            public const string Signature = "Signature";
+            public const string SignatureMethod = "SignatureMethod";
+            public const string SignatureValue = "SignatureValue";
+            public const string SignedInfo = "SignedInfo";
+            public const string Transform = "Transform";
+            public const string Transforms = "Transforms";
+            public const string X509Data = "X509Data";
+            public const string X509IssuerName = "X509IssuerName";
+            public const string X509IssuerSerial = "X509IssuerSerial";
+            public const string X509SerialNumber = "X509SerialNumber";
+            public const string X509SubjectName = "X509SubjectName";
+            public const string X509Certificate = "X509Certificate";
+            public const string X509SKI = "X509SKI";
+        }
+#pragma warning restore 1591
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/MessageSecurityVersion.cs b/src/CoreWCF.Primitives/src/CoreWCF/MessageSecurityVersion.cs
new file mode 100644
index 0000000..308f4ae
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/MessageSecurityVersion.cs
@@ -0,0 +1,289 @@
+using CoreWCF.Security;
+using CoreWCF.IdentityModel.Selectors;
+namespace CoreWCF
+{
+    public abstract class MessageSecurityVersion
+    {
+        public static MessageSecurityVersion WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11
+        {
+            get
+            {
+                return WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11MessageSecurityVersion.Instance;
+            }
+        }
+
+        public static MessageSecurityVersion WSSecurity10WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11BasicSecurityProfile10
+        {
+            get
+            {
+                return WSSecurity10WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11BasicSecurityProfile10MessageSecurityVersion.Instance;
+            }
+        }
+
+        public static MessageSecurityVersion WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11BasicSecurityProfile10
+        {
+            get
+            {
+                return WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11BasicSecurityProfile10MessageSecurityVersion.Instance;
+            }
+        }
+
+        public static MessageSecurityVersion WSSecurity11WSTrust13WSSecureConversation13WSSecurityPolicy12
+        {
+            get
+            {
+                return WSSecurity11WSTrust13WSSecureConversation13WSSecurityPolicy12MessageSecurityVersion.Instance;
+            }
+        }
+
+        public static MessageSecurityVersion WSSecurity10WSTrust13WSSecureConversation13WSSecurityPolicy12BasicSecurityProfile10
+        {
+            get
+            {
+                return WSSecurity10WSTrust13WSSecureConversation13WSSecurityPolicy12BasicSecurityProfile10MessageSecurityVersion.Instance;
+            }
+        }
+
+        public static MessageSecurityVersion WSSecurity11WSTrust13WSSecureConversation13WSSecurityPolicy12BasicSecurityProfile10
+        {
+            get
+            {
+                return WSSecurity11WSTrust13WSSecureConversation13WSSecurityPolicy12BasicSecurityProfile10MessageSecurityVersion.Instance;
+            }
+        }
+
+        public static MessageSecurityVersion Default
+        {
+            get
+            {
+                return WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11MessageSecurityVersion.Instance;
+            }
+        }
+
+        internal static MessageSecurityVersion WSSXDefault
+        {
+            get
+            {
+                return WSSecurity11WSTrust13WSSecureConversation13WSSecurityPolicy12MessageSecurityVersion.Instance;
+            }
+        }
+
+        internal MessageSecurityVersion() { }
+
+        public SecurityVersion SecurityVersion
+        {
+            get
+            {
+                return MessageSecurityTokenVersion.SecurityVersion;
+            }
+        }
+
+        public TrustVersion TrustVersion
+        {
+            get
+            {
+                return MessageSecurityTokenVersion.TrustVersion;
+            }
+        }
+
+        public SecureConversationVersion SecureConversationVersion
+        {
+            get
+            {
+                return MessageSecurityTokenVersion.SecureConversationVersion;
+            }
+        }
+
+        public SecurityTokenVersion SecurityTokenVersion
+        {
+            get
+            {
+                return MessageSecurityTokenVersion;
+            }
+        }
+
+        public abstract SecurityPolicyVersion SecurityPolicyVersion { get; }
+        public abstract BasicSecurityProfileVersion BasicSecurityProfileVersion { get; }
+        internal abstract MessageSecurityTokenVersion MessageSecurityTokenVersion { get; }
+
+        class WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11MessageSecurityVersion : MessageSecurityVersion
+        {
+            static MessageSecurityVersion instance = new WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11MessageSecurityVersion();
+
+            public static MessageSecurityVersion Instance
+            {
+                get { return instance; }
+            }
+
+            public override BasicSecurityProfileVersion BasicSecurityProfileVersion
+            {
+                get { return null; }
+            }
+
+            internal override MessageSecurityTokenVersion MessageSecurityTokenVersion
+            {
+                get { return MessageSecurityTokenVersion.WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005; }
+            }
+
+            public override SecurityPolicyVersion SecurityPolicyVersion
+            {
+                get { return SecurityPolicyVersion.WSSecurityPolicy11; }
+            }
+
+            public override string ToString()
+            {
+                return "WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11";
+            }
+        }
+
+        class WSSecurity10WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11BasicSecurityProfile10MessageSecurityVersion : MessageSecurityVersion
+        {
+            static MessageSecurityVersion instance = new WSSecurity10WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11BasicSecurityProfile10MessageSecurityVersion();
+
+            public static MessageSecurityVersion Instance
+            {
+                get { return instance; }
+            }
+
+            public override BasicSecurityProfileVersion BasicSecurityProfileVersion
+            {
+                get { return BasicSecurityProfileVersion.BasicSecurityProfile10; }
+            }
+
+            internal override MessageSecurityTokenVersion MessageSecurityTokenVersion
+            {
+                get { return MessageSecurityTokenVersion.WSSecurity10WSTrustFebruary2005WSSecureConversationFebruary2005BasicSecurityProfile10; }
+            }
+
+            public override SecurityPolicyVersion SecurityPolicyVersion
+            {
+                get { return SecurityPolicyVersion.WSSecurityPolicy11; }
+            }
+
+            public override string ToString()
+            {
+                return "WSSecurity10WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11BasicSecurityProfile10";
+            }
+        }
+
+        class WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11BasicSecurityProfile10MessageSecurityVersion : MessageSecurityVersion
+        {
+            static MessageSecurityVersion instance = new WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11BasicSecurityProfile10MessageSecurityVersion();
+
+            public static MessageSecurityVersion Instance
+            {
+                get { return instance; }
+            }
+
+            public override SecurityPolicyVersion SecurityPolicyVersion
+            {
+                get { return SecurityPolicyVersion.WSSecurityPolicy11; }
+            }
+
+            public override BasicSecurityProfileVersion BasicSecurityProfileVersion
+            {
+                get { return BasicSecurityProfileVersion.BasicSecurityProfile10; }
+            }
+
+            internal override MessageSecurityTokenVersion MessageSecurityTokenVersion
+            {
+                get { return MessageSecurityTokenVersion.WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005BasicSecurityProfile10; }
+            }
+
+            public override string ToString()
+            {
+                return "WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11BasicSecurityProfile10";
+            }
+        }
+
+        class WSSecurity10WSTrust13WSSecureConversation13WSSecurityPolicy12BasicSecurityProfile10MessageSecurityVersion : MessageSecurityVersion
+        {
+            static MessageSecurityVersion instance = new WSSecurity10WSTrust13WSSecureConversation13WSSecurityPolicy12BasicSecurityProfile10MessageSecurityVersion();
+
+            public static MessageSecurityVersion Instance
+            {
+                get { return instance; }
+            }
+
+            public override SecurityPolicyVersion SecurityPolicyVersion
+            {
+                get { return SecurityPolicyVersion.WSSecurityPolicy12; }
+            }
+
+            public override BasicSecurityProfileVersion BasicSecurityProfileVersion
+            {
+                get { return null; }
+            }
+
+            internal override MessageSecurityTokenVersion MessageSecurityTokenVersion
+            {
+                get { return MessageSecurityTokenVersion.WSSecurity10WSTrust13WSSecureConversation13BasicSecurityProfile10; }
+            }
+
+            public override string ToString()
+            {
+                return "WSSecurity10WSTrust13WSSecureConversation13WSSecurityPolicy12BasicSecurityProfile10";
+            }
+        }
+
+        class WSSecurity11WSTrust13WSSecureConversation13WSSecurityPolicy12MessageSecurityVersion : MessageSecurityVersion
+        {
+            static MessageSecurityVersion instance = new WSSecurity11WSTrust13WSSecureConversation13WSSecurityPolicy12MessageSecurityVersion();
+
+            public static MessageSecurityVersion Instance
+            {
+                get { return instance; }
+            }
+
+            public override SecurityPolicyVersion SecurityPolicyVersion
+            {
+                get { return SecurityPolicyVersion.WSSecurityPolicy12; }
+            }
+
+            public override BasicSecurityProfileVersion BasicSecurityProfileVersion
+            {
+                get { return null; }
+            }
+
+            internal override MessageSecurityTokenVersion MessageSecurityTokenVersion
+            {
+                get { return MessageSecurityTokenVersion.WSSecurity11WSTrust13WSSecureConversation13; }
+            }
+
+            public override string ToString()
+            {
+                return "WSSecurity11WSTrust13WSSecureConversation13WSSecurityPolicy12";
+            }
+        }
+
+        class WSSecurity11WSTrust13WSSecureConversation13WSSecurityPolicy12BasicSecurityProfile10MessageSecurityVersion : MessageSecurityVersion
+        {
+            static MessageSecurityVersion instance = new WSSecurity11WSTrust13WSSecureConversation13WSSecurityPolicy12BasicSecurityProfile10MessageSecurityVersion();
+
+            public static MessageSecurityVersion Instance
+            {
+                get { return instance; }
+            }
+
+            public override SecurityPolicyVersion SecurityPolicyVersion
+            {
+                get { return SecurityPolicyVersion.WSSecurityPolicy12; }
+            }
+
+            public override BasicSecurityProfileVersion BasicSecurityProfileVersion
+            {
+                get { return null; }
+            }
+
+            internal override MessageSecurityTokenVersion MessageSecurityTokenVersion
+            {
+                get { return MessageSecurityTokenVersion.WSSecurity11WSTrust13WSSecureConversation13BasicSecurityProfile10; }
+            }
+
+            public override string ToString()
+            {
+                return "WSSecurity11WSTrust13WSSecureConversation13WSSecurityPolicy12BasicSecurityProfile10";
+            }
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/AcceptorSessionSymmetricTransportSecurityProtocol.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/AcceptorSessionSymmetricTransportSecurityProtocol.cs
new file mode 100644
index 0000000..a7ad353
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/AcceptorSessionSymmetricTransportSecurityProtocol.cs
@@ -0,0 +1,135 @@
+using System.Collections.Generic;
+using System.Collections.ObjectModel;
+using CoreWCF.IdentityModel.Selectors;
+using CoreWCF.IdentityModel.Tokens;
+using CoreWCF.Runtime;
+using CoreWCF;
+using CoreWCF.Channels;
+using CoreWCF.Description;
+using CoreWCF.Security.Tokens;
+using System.Xml;
+using System;
+
+namespace CoreWCF.Security
+{
+
+    sealed class AcceptorSessionSymmetricTransportSecurityProtocol : TransportSecurityProtocol, IAcceptorSecuritySessionProtocol
+    {
+        SecurityToken outgoingSessionToken;
+        SecurityTokenAuthenticator sessionTokenAuthenticator;
+        SecurityTokenResolver sessionTokenResolver;
+        ReadOnlyCollection<SecurityTokenResolver> sessionTokenResolverList;
+        UniqueId sessionId;
+        Collection<SupportingTokenAuthenticatorSpecification> sessionTokenAuthenticatorSpecificationList;
+        bool requireDerivedKeys;
+
+        public AcceptorSessionSymmetricTransportSecurityProtocol(SessionSymmetricTransportSecurityProtocolFactory factory) : base(factory, null, null)
+        {
+            if (factory.ActAsInitiator == true)
+            {
+                Fx.Assert("This protocol can only be used at the recipient.");
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.ProtocolMustBeRecipient, this.GetType().ToString())));
+            }
+            this.requireDerivedKeys = factory.SecurityTokenParameters.RequireDerivedKeys;
+        }
+
+        SessionSymmetricTransportSecurityProtocolFactory Factory
+        {
+            get { return (SessionSymmetricTransportSecurityProtocolFactory)this.SecurityProtocolFactory; }
+        }
+
+        public bool ReturnCorrelationState
+        {
+            get
+            {
+                return false;
+            }
+            set
+            {
+            }
+        }
+
+        public void SetSessionTokenAuthenticator(UniqueId sessionId, SecurityTokenAuthenticator sessionTokenAuthenticator, SecurityTokenResolver sessionTokenResolver)
+        {
+            this.CommunicationObject.ThrowIfDisposedOrImmutable();
+            this.sessionId = sessionId;
+            this.sessionTokenResolver = sessionTokenResolver;
+            Collection<SecurityTokenResolver> tmp = new Collection<SecurityTokenResolver>();
+            tmp.Add(this.sessionTokenResolver);
+            this.sessionTokenResolverList = new ReadOnlyCollection<SecurityTokenResolver>(tmp);
+            this.sessionTokenAuthenticator = sessionTokenAuthenticator;
+            SupportingTokenAuthenticatorSpecification spec = new SupportingTokenAuthenticatorSpecification(this.sessionTokenAuthenticator, this.sessionTokenResolver, SecurityTokenAttachmentMode.Endorsing, this.Factory.SecurityTokenParameters);
+            this.sessionTokenAuthenticatorSpecificationList = new Collection<SupportingTokenAuthenticatorSpecification>();
+            this.sessionTokenAuthenticatorSpecificationList.Add(spec);
+        }
+
+        public SecurityToken GetOutgoingSessionToken()
+        {
+            return this.outgoingSessionToken;
+        }
+
+        public void SetOutgoingSessionToken(SecurityToken token)
+        {
+            if (token == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("token");
+            }
+            this.outgoingSessionToken = token;
+        }
+
+        protected override void VerifyIncomingMessageCore(ref Message message, TimeSpan timeout)
+        {
+            string actor = string.Empty; // message.Version.Envelope.UltimateDestinationActor;
+            ReceiveSecurityHeader securityHeader = this.Factory.StandardsManager.TryCreateReceiveSecurityHeader(message, actor,
+                this.Factory.IncomingAlgorithmSuite, MessageDirection.Input);
+            securityHeader.RequireMessageProtection = false;
+            securityHeader.ReaderQuotas = this.Factory.SecurityBindingElement.ReaderQuotas;
+            IList<SupportingTokenAuthenticatorSpecification> supportingAuthenticators = GetSupportingTokenAuthenticatorsAndSetExpectationFlags(this.Factory, message, securityHeader);
+            ReadOnlyCollection<SecurityTokenResolver> mergedTokenResolvers = MergeOutOfBandResolvers(supportingAuthenticators, this.sessionTokenResolverList);
+            if (supportingAuthenticators != null && supportingAuthenticators.Count > 0)
+            {
+                supportingAuthenticators = new List<SupportingTokenAuthenticatorSpecification>(supportingAuthenticators);
+                supportingAuthenticators.Insert(0, this.sessionTokenAuthenticatorSpecificationList[0]);
+            }
+            else
+            {
+                supportingAuthenticators = this.sessionTokenAuthenticatorSpecificationList;
+            }
+            securityHeader.ConfigureTransportBindingServerReceiveHeader(supportingAuthenticators);
+            securityHeader.ConfigureOutOfBandTokenResolver(mergedTokenResolvers);
+            securityHeader.ExpectEndorsingTokens = true;
+            TimeoutHelper timeoutHelper = new TimeoutHelper(timeout);
+            
+            securityHeader.ReplayDetectionEnabled = this.Factory.DetectReplays;
+            securityHeader.SetTimeParameters(this.Factory.NonceCache, this.Factory.ReplayWindow, this.Factory.MaxClockSkew);
+            // do not enforce key derivation requirement for Cancel messages due to WSE interop
+            securityHeader.EnforceDerivedKeyRequirement = (message.Headers.Action != this.Factory.StandardsManager.SecureConversationDriver.CloseAction.Value);
+            securityHeader.Process(timeoutHelper.RemainingTime(), SecurityUtils.GetChannelBindingFromMessage(message), this.Factory.ExtendedProtectionPolicy);
+            if (securityHeader.Timestamp == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new MessageSecurityException(SR.Format(SR.RequiredTimestampMissingInSecurityHeader)));
+            }
+            bool didSessionSctEndorse = false;
+            if (securityHeader.EndorsingSupportingTokens != null)
+            {
+                for (int i = 0; i < securityHeader.EndorsingSupportingTokens.Count; ++i)
+                {
+                    SecurityContextSecurityToken signingSct = (securityHeader.EndorsingSupportingTokens[i] as SecurityContextSecurityToken);
+                    if (signingSct != null && signingSct.ContextId == this.sessionId)
+                    {
+                        didSessionSctEndorse = true;
+                        break;
+                    }
+                }
+            }
+            if (!didSessionSctEndorse)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new MessageSecurityException(SR.Format(SR.NoSessionTokenPresentInMessage)));
+            }
+            message = securityHeader.ProcessedMessage;
+            AttachRecipientSecurityProperty(message, securityHeader.BasicSupportingTokens, securityHeader.EndorsingSupportingTokens,
+                securityHeader.SignedEndorsingSupportingTokens, securityHeader.SignedSupportingTokens, securityHeader.SecurityTokenAuthorizationPoliciesMapping);
+            base.OnIncomingMessageVerified(message);
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/BasicSecurityProfileVersion.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/BasicSecurityProfileVersion.cs
new file mode 100644
index 0000000..20c8755
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/BasicSecurityProfileVersion.cs
@@ -0,0 +1,24 @@
+namespace CoreWCF.Security
+{
+    public abstract class BasicSecurityProfileVersion
+    {
+        internal BasicSecurityProfileVersion() { }
+
+        public static BasicSecurityProfileVersion BasicSecurityProfile10
+        {
+            get { return BasicSecurityProfile10BasicSecurityProfileVersion.Instance; }
+        }
+
+        class BasicSecurityProfile10BasicSecurityProfileVersion : BasicSecurityProfileVersion
+        {
+            static BasicSecurityProfile10BasicSecurityProfileVersion instance = new BasicSecurityProfile10BasicSecurityProfileVersion();
+
+            public static BasicSecurityProfile10BasicSecurityProfileVersion Instance { get { return instance; } }
+
+            public override string ToString()
+            {
+                return "BasicSecurityProfile10";
+            }
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/BinaryNegotiation.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/BinaryNegotiation.cs
new file mode 100644
index 0000000..687faf9
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/BinaryNegotiation.cs
@@ -0,0 +1,86 @@
+namespace CoreWCF.Security
+{
+    using System;
+    using System.Xml;
+    using CoreWCF.Channels;
+
+    internal sealed class BinaryNegotiation 
+    {
+        private byte[] negotiationData;
+        XmlDictionaryString valueTypeUriDictionaryString;
+        string valueTypeUri;
+
+        public BinaryNegotiation(
+            string valueTypeUri,
+            byte[] negotiationData)
+        {
+            if (valueTypeUri == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("valueTypeUri");
+            }
+            if (negotiationData == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("negotiationData");
+            }
+            this.valueTypeUriDictionaryString = null;
+            this.valueTypeUri = valueTypeUri;
+            this.negotiationData = negotiationData;
+        }
+
+        public BinaryNegotiation(
+            XmlDictionaryString valueTypeDictionaryString,
+            byte[] negotiationData)
+        {
+            if (valueTypeDictionaryString == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("valueTypeDictionaryString");
+            }
+            if (negotiationData == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("negotiationData");
+            }
+            this.valueTypeUriDictionaryString = valueTypeDictionaryString;
+            this.valueTypeUri = valueTypeDictionaryString.Value;
+            this.negotiationData = negotiationData;
+        }
+
+        public void Validate(XmlDictionaryString valueTypeUriDictionaryString)
+        {
+            if (this.valueTypeUri != valueTypeUriDictionaryString.Value)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new SecurityNegotiationException(SR.Format(SR.IncorrectBinaryNegotiationValueType, this.valueTypeUri)));
+            }
+            this.valueTypeUriDictionaryString = valueTypeUriDictionaryString;
+        }
+
+        public void WriteTo(XmlDictionaryWriter writer, string prefix, XmlDictionaryString localName, XmlDictionaryString ns, XmlDictionaryString valueTypeLocalName, XmlDictionaryString valueTypeNs)
+        {
+            writer.WriteStartElement(prefix, localName, ns);
+            writer.WriteStartAttribute(valueTypeLocalName, valueTypeNs);
+            if (valueTypeUriDictionaryString != null)
+                writer.WriteString(valueTypeUriDictionaryString);
+            else
+                writer.WriteString(valueTypeUri);
+            writer.WriteEndAttribute();
+            writer.WriteStartAttribute(XD.SecurityJan2004Dictionary.EncodingType, null);
+            writer.WriteString(XD.SecurityJan2004Dictionary.EncodingTypeValueBase64Binary);
+            writer.WriteEndAttribute();
+            writer.WriteBase64(this.negotiationData, 0, this.negotiationData.Length);
+            writer.WriteEndElement();
+        }
+
+        public string ValueTypeUri
+        {
+            get 
+            { 
+                return this.valueTypeUri;
+            }
+        }
+
+        public byte[] GetNegotiationData()
+        {
+            // avoid copying since this is internal and callers use it as read-only
+            return this.negotiationData;
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/BinarySecretKeyIdentifierClause.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/BinarySecretKeyIdentifierClause.cs
new file mode 100644
index 0000000..0a242b3
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/BinarySecretKeyIdentifierClause.cs
@@ -0,0 +1,53 @@
+﻿
+
+using CoreWCF.IdentityModel;
+using CoreWCF.IdentityModel.Tokens;
+
+namespace CoreWCF.Security
+{
+    public class BinarySecretKeyIdentifierClause : BinaryKeyIdentifierClause
+    {
+        private InMemorySymmetricSecurityKey _symmetricKey;
+
+        public BinarySecretKeyIdentifierClause(byte[] key)
+            : this(key, true)
+        {
+        }
+
+        public BinarySecretKeyIdentifierClause(byte[] key, bool cloneBuffer)
+            : this(key, cloneBuffer, null, 0)
+        {
+        }
+
+        public BinarySecretKeyIdentifierClause(byte[] key, bool cloneBuffer, byte[] derivationNonce, int derivationLength)
+            : base(XD.TrustFeb2005Dictionary.BinarySecretClauseType.Value, key, cloneBuffer, derivationNonce, derivationLength)
+        {
+        }
+
+        public byte[] GetKeyBytes()
+        {
+            return GetBuffer();
+        }
+
+        public override bool CanCreateKey
+        {
+            get { return true; }
+        }
+
+        public override SecurityKey CreateKey()
+        {
+            if (_symmetricKey == null)
+            {
+                _symmetricKey = new InMemorySymmetricSecurityKey(GetBuffer(), false);
+            }
+
+            return _symmetricKey;
+        }
+
+        public override bool Matches(SecurityKeyIdentifierClause keyIdentifierClause)
+        {
+            BinarySecretKeyIdentifierClause that = keyIdentifierClause as BinarySecretKeyIdentifierClause;
+            return ReferenceEquals(this, that) || (that != null && that.Matches(GetRawBuffer()));
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/CanonicalFormWriter.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/CanonicalFormWriter.cs
new file mode 100644
index 0000000..239d16b
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/CanonicalFormWriter.cs
@@ -0,0 +1,82 @@
+
+
+
+using System.IO;
+using System.Text;
+
+namespace CoreWCF.IdentityModel
+{
+    internal abstract class CanonicalFormWriter
+    {
+        // internal static readonly UTF8Encoding Utf8WithoutPreamble = new UTF8Encoding(encoderShouldEmitUTF8Identifier = false);
+        internal static readonly Encoding Utf8WithoutPreamble = Encoding.UTF8;
+
+
+        protected static void EncodeAndWrite(Stream stream, byte[] workBuffer, string s)
+        {
+            if (s.Length > workBuffer.Length)
+            {
+                EncodeAndWrite(stream, s);
+                return;
+            }
+
+            for (int i = 0; i < s.Length; i++)
+            {
+                char c = s[i];
+                if (c < 127)
+                {
+                    workBuffer[i] = (byte)c;
+                }
+                else
+                {
+                    EncodeAndWrite(stream, s);
+                    return;
+                }
+            }
+
+            stream.Write(workBuffer, 0, s.Length);
+        }
+
+        protected static void EncodeAndWrite(Stream stream, byte[] workBuffer, char[] chars)
+        {
+            EncodeAndWrite(stream, workBuffer, chars, chars.Length);
+        }
+
+        protected static void EncodeAndWrite(Stream stream, byte[] workBuffer, char[] chars, int count)
+        {
+            if (count > workBuffer.Length)
+            {
+                EncodeAndWrite(stream, chars, count);
+                return;
+            }
+
+            for (int i = 0; i < count; i++)
+            {
+                char c = chars[i];
+                if (c < 127)
+                {
+                    workBuffer[i] = (byte)c;
+                }
+                else
+                {
+                    EncodeAndWrite(stream, chars, count);
+                    return;
+                }
+            }
+
+            stream.Write(workBuffer, 0, count);
+        }
+
+        private static void EncodeAndWrite(Stream stream, string s)
+        {
+            byte[] buffer = CanonicalFormWriter.Utf8WithoutPreamble.GetBytes(s);
+            stream.Write(buffer, 0, buffer.Length);
+        }
+
+        private static void EncodeAndWrite(Stream stream, char[] chars, int count)
+        {
+            byte[] buffer = CanonicalFormWriter.Utf8WithoutPreamble.GetBytes(chars, 0, count);
+            stream.Write(buffer, 0, buffer.Length);
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/ChannelProtectionRequirements.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/ChannelProtectionRequirements.cs
index d99b47a..8ebdbcb 100644
--- a/src/CoreWCF.Primitives/src/CoreWCF/Security/ChannelProtectionRequirements.cs
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/ChannelProtectionRequirements.cs
@@ -9,7 +9,7 @@ namespace CoreWCF.Security
 {
     // This class is used to describe the message security requirements. It's only here as a placeholder
     // to allow minimal changes to ported code.
-    internal class ChannelProtectionRequirements
+    public class ChannelProtectionRequirements
     {
         bool _isReadOnly;
 
@@ -46,13 +46,13 @@ namespace CoreWCF.Security
         }
 
 
-        public ScopedMessagePartSpecification IncomingSignatureParts { get; }
+        internal ScopedMessagePartSpecification IncomingSignatureParts { get; }
 
-        public ScopedMessagePartSpecification IncomingEncryptionParts { get; }
+        internal ScopedMessagePartSpecification IncomingEncryptionParts { get; }
 
-        public ScopedMessagePartSpecification OutgoingSignatureParts { get; }
+        internal ScopedMessagePartSpecification OutgoingSignatureParts { get; }
 
-        public ScopedMessagePartSpecification OutgoingEncryptionParts { get; }
+        internal ScopedMessagePartSpecification OutgoingEncryptionParts { get; }
 
         public void Add(ChannelProtectionRequirements protectionRequirements)
         {
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/CryptoHelper.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/CryptoHelper.cs
new file mode 100644
index 0000000..0d51e1f
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/CryptoHelper.cs
@@ -0,0 +1,360 @@
+using System.Collections;
+using System.Collections.Generic;
+using CoreWCF.Channels;
+using CoreWCF;
+using System.Reflection;
+using System.Threading;
+using System.IO;
+
+using System.Runtime.InteropServices;
+using CoreWCF.IdentityModel.Tokens;
+using System.Text;
+using System.Xml;
+using System.Diagnostics;
+using System.Diagnostics.CodeAnalysis;
+using System.Security.Cryptography;
+
+using Psha1DerivedKeyGenerator = CoreWCF.IdentityModel.Psha1DerivedKeyGenerator;
+using CryptoAlgorithms = CoreWCF.IdentityModel.CryptoHelper;
+using System;
+using CoreWCF.Runtime;
+
+namespace CoreWCF.Security
+{
+
+
+    static class CryptoHelper
+    {
+        static byte[] emptyBuffer;
+        static readonly RandomNumberGenerator random = new RNGCryptoServiceProvider();
+
+        enum CryptoAlgorithmType
+        {
+            Unknown,
+            Symmetric,
+            Asymmetric
+        }
+
+        internal static byte[] EmptyBuffer
+        {
+            get
+            {
+                if (emptyBuffer == null)
+                {
+                    byte[] tmp = new byte[0];
+                    emptyBuffer = tmp;
+                }
+                return emptyBuffer;
+            }
+        }
+
+        internal static HashAlgorithm NewSha1HashAlgorithm()
+        {
+            return CryptoHelper.CreateHashAlgorithm(SecurityAlgorithms.Sha1Digest);
+        }
+
+        internal static HashAlgorithm NewSha256HashAlgorithm()
+        {
+            return CryptoHelper.CreateHashAlgorithm(SecurityAlgorithms.Sha256Digest);
+        }
+
+        [SuppressMessage("Microsoft.Security.Cryptography", "CA5354:DoNotUseSHA1", Justification = "Cannot change. Required as SOAP spec requires supporting SHA1.")]
+        internal static HashAlgorithm CreateHashAlgorithm(string digestMethod)
+        {
+            object algorithmObject = CryptoAlgorithms.GetAlgorithmFromConfig(digestMethod);
+            if (algorithmObject != null)
+            {
+                HashAlgorithm hashAlgorithm = algorithmObject as HashAlgorithm;
+                if (hashAlgorithm != null)
+                    return hashAlgorithm;
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new MessageSecurityException(SR.Format(SR.CustomCryptoAlgorithmIsNotValidHashAlgorithm, digestMethod)));
+            }
+
+            switch (digestMethod)
+            {
+                case SecurityAlgorithms.Sha1Digest:
+                    //if (SecurityUtilsEx.RequiresFipsCompliance)
+                    //    return new SHA1CryptoServiceProvider();
+                    //else
+                        return new SHA1Managed();
+                case SecurityAlgorithms.Sha256Digest:
+                    //if (SecurityUtilsEx.RequiresFipsCompliance)
+                    //    return new SHA256CryptoServiceProvider();
+                    //else
+                        return new SHA256Managed();
+                default:
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new MessageSecurityException(SR.Format(SR.UnsupportedCryptoAlgorithm, digestMethod)));
+
+            }
+        }
+
+        [SuppressMessage("Microsoft.Security.Cryptography", "CA5354:DoNotUseSHA1", Justification = "Cannot change. Required as SOAP spec requires supporting SHA1.")]
+        internal static HashAlgorithm CreateHashForAsymmetricSignature(string signatureMethod)
+        {
+            object algorithmObject = CryptoAlgorithms.GetAlgorithmFromConfig(signatureMethod);
+            if (algorithmObject != null)
+            {
+                HashAlgorithm hashAlgorithm;
+                SignatureDescription signatureDescription = algorithmObject as SignatureDescription;
+
+                if (signatureDescription != null)
+                {
+                    hashAlgorithm = signatureDescription.CreateDigest();
+                    if (hashAlgorithm != null)
+                        return hashAlgorithm;
+                }
+
+                hashAlgorithm = algorithmObject as HashAlgorithm;
+                if (hashAlgorithm != null)
+                    return hashAlgorithm;
+
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new MessageSecurityException(SR.Format(SR.CustomCryptoAlgorithmIsNotValidAsymmetricSignature, signatureMethod)));
+            }
+
+            switch (signatureMethod)
+            {
+                case SecurityAlgorithms.RsaSha1Signature:
+                case SecurityAlgorithms.DsaSha1Signature:
+                  //  if (SecurityUtilsEx.RequiresFipsCompliance)
+                  //      return new SHA1CryptoServiceProvider();
+                   // else
+                        return new SHA1Managed();
+
+                case SecurityAlgorithms.RsaSha256Signature:
+                  //  if (SecurityUtilsEx.RequiresFipsCompliance)
+                  //      return new SHA256CryptoServiceProvider();
+                   // else
+                        return new SHA256Managed();
+
+                default:
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new MessageSecurityException(SR.Format(SR.UnsupportedCryptoAlgorithm, signatureMethod)));
+            }
+        }
+
+        internal static byte[] ExtractIVAndDecrypt(SymmetricAlgorithm algorithm, byte[] cipherText, int offset, int count)
+        {
+            if (cipherText == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("cipherText");
+            }
+            if (count < 0 || count > cipherText.Length)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("count", SR.Format(SR.ValueMustBeInRange, 0, cipherText.Length)));
+
+            }
+            if (offset < 0 || offset > cipherText.Length - count)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("offset", SR.Format(SR.ValueMustBeInRange, 0, cipherText.Length - count)));
+            }
+
+            int ivSize = algorithm.BlockSize / 8;
+            byte[] iv = new byte[ivSize];
+            Buffer.BlockCopy(cipherText, offset, iv, 0, iv.Length);
+            algorithm.Padding = PaddingMode.ISO10126;
+            algorithm.Mode = CipherMode.CBC;
+            try
+            {
+                using (ICryptoTransform decrTransform = algorithm.CreateDecryptor(algorithm.Key, iv))
+                {
+                    return decrTransform.TransformFinalBlock(cipherText, offset + iv.Length, count - iv.Length);
+                }
+            }
+            catch (CryptographicException ex)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new MessageSecurityException(SR.Format(SR.DecryptionFailed), ex));
+            }
+        }
+
+        internal static void FillRandomBytes(byte[] buffer)
+        {
+            random.GetBytes(buffer);
+        }
+
+        static CryptoAlgorithmType GetAlgorithmType(string algorithm)
+        {
+            object algorithmObject = null;
+
+            try
+            {
+                algorithmObject = CryptoAlgorithms.GetAlgorithmFromConfig(algorithm);
+            }
+            catch (InvalidOperationException)
+            {
+                algorithmObject = null;
+                // We swallow the exception and continue.
+            }
+            if (algorithmObject != null)
+            {
+                SymmetricAlgorithm symmetricAlgorithm = algorithmObject as SymmetricAlgorithm;
+                KeyedHashAlgorithm keyedHashAlgorithm = algorithmObject as KeyedHashAlgorithm;
+                if (symmetricAlgorithm != null || keyedHashAlgorithm != null)
+                    return CryptoAlgorithmType.Symmetric;
+
+                // NOTE: A KeyedHashAlgorithm is symmetric in nature.
+
+                AsymmetricAlgorithm asymmetricAlgorithm = algorithmObject as AsymmetricAlgorithm;
+                SignatureDescription signatureDescription = algorithmObject as SignatureDescription;
+                if (asymmetricAlgorithm != null || signatureDescription != null)
+                    return CryptoAlgorithmType.Asymmetric;
+
+                return CryptoAlgorithmType.Unknown;
+            }
+
+            switch (algorithm)
+            {
+                case SecurityAlgorithms.DsaSha1Signature:
+                case SecurityAlgorithms.RsaSha1Signature:
+                case SecurityAlgorithms.RsaSha256Signature:
+                case SecurityAlgorithms.RsaOaepKeyWrap:
+                case SecurityAlgorithms.RsaV15KeyWrap:
+                    return CryptoAlgorithmType.Asymmetric;
+                case SecurityAlgorithms.HmacSha1Signature:
+                case SecurityAlgorithms.HmacSha256Signature:
+                case SecurityAlgorithms.Aes128Encryption:
+                case SecurityAlgorithms.Aes192Encryption:
+                case SecurityAlgorithms.Aes256Encryption:
+                case SecurityAlgorithms.TripleDesEncryption:
+                case SecurityAlgorithms.Aes128KeyWrap:
+                case SecurityAlgorithms.Aes192KeyWrap:
+                case SecurityAlgorithms.Aes256KeyWrap:
+                case SecurityAlgorithms.TripleDesKeyWrap:
+                case SecurityAlgorithms.Psha1KeyDerivation:
+                case SecurityAlgorithms.Psha1KeyDerivationDec2005:
+                    return CryptoAlgorithmType.Symmetric;
+                default:
+                    return CryptoAlgorithmType.Unknown;
+            }
+        }
+
+        internal static byte[] GenerateIVAndEncrypt(SymmetricAlgorithm algorithm, byte[] plainText, int offset, int count)
+        {
+            byte[] iv;
+            byte[] cipherText;
+            GenerateIVAndEncrypt(algorithm, new ArraySegment<byte>(plainText, offset, count), out iv, out cipherText);
+            byte[] output = Fx.AllocateByteArray(checked(iv.Length + cipherText.Length));
+            Buffer.BlockCopy(iv, 0, output, 0, iv.Length);
+            Buffer.BlockCopy(cipherText, 0, output, iv.Length, cipherText.Length);
+            return output;
+        }
+
+        internal static void GenerateIVAndEncrypt(SymmetricAlgorithm algorithm, ArraySegment<byte> plainText, out byte[] iv, out byte[] cipherText)
+        {
+            int ivSize = algorithm.BlockSize / 8;
+            iv = new byte[ivSize];
+            FillRandomBytes(iv);
+            algorithm.Padding = PaddingMode.PKCS7;
+            algorithm.Mode = CipherMode.CBC;
+            using (ICryptoTransform encrTransform = algorithm.CreateEncryptor(algorithm.Key, iv))
+            {
+                cipherText = encrTransform.TransformFinalBlock(plainText.Array, plainText.Offset, plainText.Count);
+            }
+        }
+
+        internal static bool IsEqual(byte[] a, byte[] b)
+        {
+            if (a == null || b == null || a.Length != b.Length)
+            {
+                return false;
+            }
+
+            for (int i = 0; i < a.Length; i++)
+            {
+                if (a[i] != b[i])
+                {
+                    return false;
+                }
+            }
+            return true;
+        }
+
+        internal static bool IsSymmetricAlgorithm(string algorithm)
+        {
+            return GetAlgorithmType(algorithm) == CryptoAlgorithmType.Symmetric;
+        }
+
+        internal static bool IsSymmetricSupportedAlgorithm(string algorithm, int keySize)
+        {
+            bool found = false;
+            object algorithmObject = null;
+
+            try
+            {
+                algorithmObject = CryptoAlgorithms.GetAlgorithmFromConfig(algorithm);
+            }
+            catch (InvalidOperationException)
+            {
+                algorithmObject = null;
+                // We swallow the exception and continue.
+            }
+            if (algorithmObject != null)
+            {
+                SymmetricAlgorithm symmetricAlgorithm = algorithmObject as SymmetricAlgorithm;
+                KeyedHashAlgorithm keyedHashAlgorithm = algorithmObject as KeyedHashAlgorithm;
+                if (symmetricAlgorithm != null || keyedHashAlgorithm != null)
+                    found = true;
+            }
+
+            switch (algorithm)
+            {
+                case SecurityAlgorithms.DsaSha1Signature:
+                case SecurityAlgorithms.RsaSha1Signature:
+                case SecurityAlgorithms.RsaSha256Signature:
+                case SecurityAlgorithms.RsaOaepKeyWrap:
+                case SecurityAlgorithms.RsaV15KeyWrap:
+                    return false;
+                case SecurityAlgorithms.HmacSha1Signature:
+                case SecurityAlgorithms.HmacSha256Signature:
+                case SecurityAlgorithms.Psha1KeyDerivation:
+                case SecurityAlgorithms.Psha1KeyDerivationDec2005:
+                    return true;
+                case SecurityAlgorithms.Aes128Encryption:
+                case SecurityAlgorithms.Aes128KeyWrap:
+                    return keySize == 128;
+                case SecurityAlgorithms.Aes192Encryption:
+                case SecurityAlgorithms.Aes192KeyWrap:
+                    return keySize == 192;
+                case SecurityAlgorithms.Aes256Encryption:
+                case SecurityAlgorithms.Aes256KeyWrap:
+                    return keySize == 256;
+                case SecurityAlgorithms.TripleDesEncryption:
+                case SecurityAlgorithms.TripleDesKeyWrap:
+                    return keySize == 128 || keySize == 192;
+                default:
+                    if (found)
+                        return true;
+                    return false;
+            }
+        }
+
+        internal static void ValidateBufferBounds(Array buffer, int offset, int count)
+        {
+            if (buffer == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException("buffer"));
+            }
+            if (count < 0 || count > buffer.Length)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("count", SR.Format(SR.ValueMustBeInRange, 0, buffer.Length)));
+            }
+            if (offset < 0 || offset > buffer.Length - count)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("offset", SR.Format(SR.ValueMustBeInRange, 0, buffer.Length - count)));
+            }
+        }
+
+        internal static void ValidateSymmetricKeyLength(int keyLength, SecurityAlgorithmSuite algorithmSuite)
+        {
+            if (!algorithmSuite.IsSymmetricKeyLengthSupported(keyLength))
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new ArgumentOutOfRangeException("algorithmSuite",
+                   SR.Format(SR.UnsupportedKeyLength, keyLength, algorithmSuite.ToString())));
+            }
+            if (keyLength % 8 != 0)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new ArgumentOutOfRangeException("algorithmSuite",
+                   SR.Format(SR.KeyLengthMustBeMultipleOfEight, keyLength)));
+            }
+        }
+
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/DataProtectionSecurityStateEncoder.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/DataProtectionSecurityStateEncoder.cs
new file mode 100644
index 0000000..8da3f0e
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/DataProtectionSecurityStateEncoder.cs
@@ -0,0 +1,91 @@
+namespace CoreWCF.Security
+{
+    using System.Text;
+    using System.Security.Cryptography;
+    //using System.Security.Cryptography.
+    using CoreWCF.Runtime;
+    using System;
+
+    public class DataProtectionSecurityStateEncoder : SecurityStateEncoder
+    {
+        byte[] entropy;
+        bool useCurrentUserProtectionScope;
+
+        public DataProtectionSecurityStateEncoder()
+            : this(true)
+        {
+            // empty
+        }
+
+        public DataProtectionSecurityStateEncoder(bool useCurrentUserProtectionScope)
+            : this(useCurrentUserProtectionScope, null)
+        { }
+
+        public DataProtectionSecurityStateEncoder(bool useCurrentUserProtectionScope, byte[] entropy)
+        {
+            this.useCurrentUserProtectionScope = useCurrentUserProtectionScope;
+            if (entropy == null)
+            {
+                this.entropy = null;
+            }
+            else
+            {
+                this.entropy = Fx.AllocateByteArray(entropy.Length);
+                Buffer.BlockCopy(entropy, 0, this.entropy, 0, entropy.Length);
+            }
+        }
+
+        public bool UseCurrentUserProtectionScope
+        {
+            get
+            {
+                return this.useCurrentUserProtectionScope;
+            }
+        }
+
+        public byte[] GetEntropy()
+        {
+            byte[] result = null;
+            if (this.entropy != null)
+            {
+                result = Fx.AllocateByteArray(this.entropy.Length);
+                Buffer.BlockCopy(this.entropy, 0, result, 0, this.entropy.Length);
+            }
+            return result;
+        }
+
+        public override string ToString()
+        {
+            StringBuilder result = new StringBuilder();
+            result.Append(this.GetType().ToString());
+            result.AppendFormat("{0}  UseCurrentUserProtectionScope={1}", Environment.NewLine, this.useCurrentUserProtectionScope);
+            result.AppendFormat("{0}  Entropy Length={1}", Environment.NewLine, (this.entropy == null) ? 0 : this.entropy.Length);
+            return result.ToString();
+        }
+
+        protected internal override byte[] DecodeSecurityState( byte[] data )
+        {
+            try
+            {
+                return ProtectedData.Unprotect(data, this.entropy, (this.useCurrentUserProtectionScope) ? DataProtectionScope.CurrentUser : DataProtectionScope.LocalMachine);
+            }
+            catch (CryptographicException exception)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new CryptographicException(SR.Format(SR.SecurityStateEncoderDecodingFailure), exception));
+            }
+
+        }
+
+        protected internal override byte[] EncodeSecurityState( byte[] data )
+        {
+            try
+            {
+                return ProtectedData.Protect(data, this.entropy, (this.useCurrentUserProtectionScope) ? DataProtectionScope.CurrentUser : DataProtectionScope.LocalMachine);
+            }
+            catch (CryptographicException exception)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new CryptographicException(SR.Format(SR.SecurityStateEncoderEncodingFailure), exception));
+            }
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/EncryptedData.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/EncryptedData.cs
new file mode 100644
index 0000000..5c90127
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/EncryptedData.cs
@@ -0,0 +1,100 @@
+using System.Security.Cryptography;
+using CoreWCF.Channels;
+using System.Xml;
+using System;
+
+namespace CoreWCF.Security
+{
+    class EncryptedData : EncryptedType
+    {
+        internal static readonly XmlDictionaryString ElementName = XD.XmlEncryptionDictionary.EncryptedData;
+        internal static readonly string ElementType = XmlEncryptionStrings.ElementType;
+        internal static readonly string ContentType = XmlEncryptionStrings.ContentType;
+        SymmetricAlgorithm algorithm;
+        byte[] decryptedBuffer;
+        ArraySegment<byte> buffer;
+        byte[] iv;
+        byte[] cipherText;
+
+        protected override XmlDictionaryString OpeningElementName
+        {
+            get { return ElementName; }
+        }
+
+        void EnsureDecryptionSet()
+        {
+            if (this.State == EncryptionState.DecryptionSetup)
+            {
+                SetPlainText();
+            }
+            else if (this.State != EncryptionState.Decrypted)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new MessageSecurityException(SR.Format(SR.BadEncryptionState)));
+            }
+        }
+
+        protected override void ForceEncryption()
+        {
+            CryptoHelper.GenerateIVAndEncrypt(this.algorithm, this.buffer, out this.iv, out this.cipherText);
+            this.State = EncryptionState.Encrypted;
+            this.buffer = new ArraySegment<byte>(CryptoHelper.EmptyBuffer);
+        }
+
+        public byte[] GetDecryptedBuffer()
+        {
+            EnsureDecryptionSet();
+            return this.decryptedBuffer;
+        }
+
+        protected override void ReadCipherData(XmlDictionaryReader reader)
+        {
+            this.cipherText = reader.ReadContentAsBase64();
+        }
+
+        protected override void ReadCipherData(XmlDictionaryReader reader, long maxBufferSize)
+        {
+            this.cipherText = SecurityUtils.ReadContentAsBase64(reader, maxBufferSize);
+        }
+
+        void SetPlainText()
+        {
+            this.decryptedBuffer = CryptoHelper.ExtractIVAndDecrypt(this.algorithm, this.cipherText, 0, this.cipherText.Length);
+            this.State = EncryptionState.Decrypted;
+        }
+
+        public void SetUpDecryption(SymmetricAlgorithm algorithm)
+        {
+            if (this.State != EncryptionState.Read)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new MessageSecurityException(SR.Format(SR.BadEncryptionState)));
+            }
+            if (algorithm == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("algorithm");
+            }
+            this.algorithm = algorithm;
+            this.State = EncryptionState.DecryptionSetup;
+        }
+
+        public void SetUpEncryption(SymmetricAlgorithm algorithm, ArraySegment<byte> buffer)
+        {
+            if (this.State != EncryptionState.New)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new MessageSecurityException(SR.Format(SR.BadEncryptionState)));
+            }
+            if (algorithm == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("algorithm");
+            }
+            this.algorithm = algorithm;
+            this.buffer = buffer;
+            this.State = EncryptionState.EncryptionSetup;
+        }
+
+        protected override void WriteCipherData(XmlDictionaryWriter writer)
+        {
+            writer.WriteBase64(this.iv, 0, this.iv.Length);
+            writer.WriteBase64(this.cipherText, 0, this.cipherText.Length);
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/EncryptedKey.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/EncryptedKey.cs
new file mode 100644
index 0000000..a84233b
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/EncryptedKey.cs
@@ -0,0 +1,539 @@
+using CoreWCF.IdentityModel;
+using CoreWCF.IdentityModel.Selectors;
+using CoreWCF.IdentityModel.Tokens;
+using CoreWCF.Runtime;
+using System.Runtime.CompilerServices;
+using System.Xml;
+using DictionaryManager = CoreWCF.IdentityModel.DictionaryManager;
+using ISecurityElement = CoreWCF.IdentityModel.ISecurityElement;
+using System;
+using System.Runtime;
+
+
+namespace CoreWCF.Security
+{
+
+    sealed class EncryptedKey : EncryptedType
+    {
+        internal static readonly XmlDictionaryString CarriedKeyElementName = XD.XmlEncryptionDictionary.CarriedKeyName;
+        internal static readonly XmlDictionaryString ElementName = XD.XmlEncryptionDictionary.EncryptedKey;
+        internal static readonly XmlDictionaryString RecipientAttribute = XD.XmlEncryptionDictionary.Recipient;
+
+        string carriedKeyName;
+        string recipient;
+        ReferenceList referenceList;
+        byte[] wrappedKey;
+
+        public string CarriedKeyName
+        {
+            get { return this.carriedKeyName; }
+            set { this.carriedKeyName = value; }
+        }
+
+        public string Recipient
+        {
+            get { return this.recipient; }
+            set { this.recipient = value; }
+        }
+
+        public ReferenceList ReferenceList
+        {
+            get { return this.referenceList; }
+            set { this.referenceList = value; }
+        }
+
+        protected override XmlDictionaryString OpeningElementName
+        {
+            get { return ElementName; }
+        }
+
+        public WSSecurityTokenSerializer SecurityTokenSerializer { get; internal set; }
+
+        protected override void ForceEncryption()
+        {
+            // no work to be done here since, unlike bulk encryption, key wrapping is done eagerly
+        }
+
+        public byte[] GetWrappedKey()
+        {
+            if (this.State == EncryptionState.New)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.BadEncryptionState)));
+            }
+            return this.wrappedKey;
+        }
+
+        public void SetUpKeyWrap(byte[] wrappedKey)
+        {
+            if (this.State != EncryptionState.New)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.BadEncryptionState)));
+            }
+            if (wrappedKey == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("wrappedKey");
+            }
+            this.wrappedKey = wrappedKey;
+            this.State = EncryptionState.Encrypted;
+        }
+
+        protected override void ReadAdditionalAttributes(XmlDictionaryReader reader)
+        {
+            this.recipient = reader.GetAttribute(RecipientAttribute, null);
+        }
+
+        protected override void ReadAdditionalElements(XmlDictionaryReader reader)
+        {
+            if (reader.IsStartElement(ReferenceList.ElementName, EncryptedType.NamespaceUri))
+            {
+                this.referenceList = new ReferenceList();
+                this.referenceList.ReadFrom(reader);
+            }
+            if (reader.IsStartElement(CarriedKeyElementName, EncryptedType.NamespaceUri))
+            {
+                reader.ReadStartElement(CarriedKeyElementName, EncryptedType.NamespaceUri);
+                this.carriedKeyName = reader.ReadString();
+                reader.ReadEndElement();
+            }
+        }
+
+        protected override void ReadCipherData(XmlDictionaryReader reader)
+        {
+            this.wrappedKey = reader.ReadContentAsBase64();
+        }
+
+        protected override void ReadCipherData(XmlDictionaryReader reader, long maxBufferSize)
+        {
+            this.wrappedKey = SecurityUtils.ReadContentAsBase64(reader, maxBufferSize);
+        }
+
+        protected override void WriteAdditionalAttributes(XmlDictionaryWriter writer, DictionaryManager dictionaryManager)
+        {
+            if (this.recipient != null)
+            {
+                writer.WriteAttributeString(RecipientAttribute, null, this.recipient);
+            }
+        }
+
+        protected override void WriteAdditionalElements(XmlDictionaryWriter writer, DictionaryManager dictionaryManager)
+        {
+            if (this.carriedKeyName != null)
+            {
+                writer.WriteStartElement(CarriedKeyElementName, EncryptedType.NamespaceUri);
+                writer.WriteString(this.carriedKeyName);
+                writer.WriteEndElement(); // CarriedKeyName
+            }
+            if (this.referenceList != null)
+            {
+                this.referenceList.WriteTo(writer, dictionaryManager);
+            }
+        }
+
+        protected override void WriteCipherData(XmlDictionaryWriter writer)
+        {
+            writer.WriteBase64(this.wrappedKey, 0, this.wrappedKey.Length);
+        }
+    }
+    internal abstract class EncryptedType : ISecurityElement
+    {
+        internal static readonly XmlDictionaryString NamespaceUri = XD.XmlEncryptionDictionary.Namespace;
+        internal static readonly XmlDictionaryString EncodingAttribute = XD.XmlEncryptionDictionary.Encoding;
+        internal static readonly XmlDictionaryString MimeTypeAttribute = XD.XmlEncryptionDictionary.MimeType;
+        internal static readonly XmlDictionaryString TypeAttribute = XD.XmlEncryptionDictionary.Type;
+        internal static readonly XmlDictionaryString CipherDataElementName = XD.XmlEncryptionDictionary.CipherData;
+        internal static readonly XmlDictionaryString CipherValueElementName = XD.XmlEncryptionDictionary.CipherValue;
+
+        private string _encoding;
+        private EncryptionMethodElement _encryptionMethod;
+        private string _id;
+        private string _wsuId;
+        private SecurityKeyIdentifier _keyIdentifier;
+        private string _mimeType;
+        private EncryptionState _state;
+        private string _type;
+        private SecurityTokenSerializer _tokenSerializer;
+        private bool _shouldReadXmlReferenceKeyInfoClause;
+
+        protected EncryptedType()
+        {
+            _encryptionMethod.Init();
+            _state = EncryptionState.New;
+        }
+
+        public string Encoding
+        {
+            get
+            {
+                return _encoding;
+            }
+            set
+            {
+                _encoding = value;
+            }
+        }
+
+        public string EncryptionMethod
+        {
+            get
+            {
+                return _encryptionMethod.algorithm;
+            }
+            set
+            {
+                _encryptionMethod.algorithm = value;
+            }
+        }
+
+        public XmlDictionaryString EncryptionMethodDictionaryString
+        {
+            get
+            {
+                return _encryptionMethod.algorithmDictionaryString;
+            }
+            set
+            {
+                _encryptionMethod.algorithmDictionaryString = value;
+            }
+        }
+
+        public bool HasId
+        {
+            get
+            {
+                return true;
+            }
+        }
+
+        public string Id
+        {
+            get
+            {
+                return _id;
+            }
+            set
+            {
+                _id = value;
+            }
+        }
+
+        // This is set to true on the client side. And this means that when this knob is set to true and the default serializers on the client side fail 
+        // to read the KeyInfo clause from the incoming response message from a service; then the ckient should 
+        // try to read the keyInfo clause as GenericXmlSecurityKeyIdentifierClause before throwing.
+        public bool ShouldReadXmlReferenceKeyInfoClause
+        {
+            get
+            {
+                return _shouldReadXmlReferenceKeyInfoClause;
+            }
+            set
+            {
+                _shouldReadXmlReferenceKeyInfoClause = value;
+            }
+        }
+
+        public string WsuId
+        {
+            get
+            {
+                return _wsuId;
+            }
+            set
+            {
+                _wsuId = value;
+            }
+        }
+
+        public SecurityKeyIdentifier KeyIdentifier
+        {
+            get
+            {
+                return _keyIdentifier;
+            }
+            set
+            {
+                _keyIdentifier = value;
+            }
+        }
+
+        public string MimeType
+        {
+            get
+            {
+                return _mimeType;
+            }
+            set
+            {
+                _mimeType = value;
+            }
+        }
+
+        public string Type
+        {
+            get
+            {
+                return _type;
+            }
+            set
+            {
+                _type = value;
+            }
+        }
+
+        protected abstract XmlDictionaryString OpeningElementName
+        {
+            get;
+        }
+
+        protected EncryptionState State
+        {
+            get
+            {
+                return _state;
+            }
+            set
+            {
+                _state = value;
+            }
+        }
+        protected abstract void ForceEncryption();
+
+        protected virtual void ReadAdditionalAttributes(XmlDictionaryReader reader)
+        {
+        }
+
+        protected virtual void ReadAdditionalElements(XmlDictionaryReader reader)
+        {
+        }
+
+        protected abstract void ReadCipherData(XmlDictionaryReader reader);
+        protected abstract void ReadCipherData(XmlDictionaryReader reader, long maxBufferSize);
+
+        public void ReadFrom(XmlReader reader)
+        {
+            ReadFrom(reader, 0);
+        }
+
+        public void ReadFrom(XmlDictionaryReader reader)
+        {
+            ReadFrom(reader, 0);
+        }
+
+        public void ReadFrom(XmlReader reader, long maxBufferSize)
+        {
+            ReadFrom(XmlDictionaryReader.CreateDictionaryReader(reader), maxBufferSize);
+        }
+
+        public void ReadFrom(XmlDictionaryReader reader, long maxBufferSize)
+        {
+            ValidateReadState();
+            reader.MoveToStartElement(OpeningElementName, NamespaceUri);
+            _encoding = reader.GetAttribute(EncodingAttribute, null);
+            _id = reader.GetAttribute(XD.XmlEncryptionDictionary.Id, null) ?? SecurityUniqueId.Create().Value;
+            _wsuId = reader.GetAttribute(XD.XmlEncryptionDictionary.Id, XD.UtilityDictionary.Namespace) ?? SecurityUniqueId.Create().Value;
+            _mimeType = reader.GetAttribute(MimeTypeAttribute, null);
+            _type = reader.GetAttribute(TypeAttribute, null);
+            ReadAdditionalAttributes(reader);
+            reader.Read();
+
+            if (reader.IsStartElement(EncryptionMethodElement.ElementName, NamespaceUri))
+            {
+                _encryptionMethod.ReadFrom(reader);
+            }
+
+            if (_tokenSerializer.CanReadKeyIdentifier(reader))
+            {
+                XmlElement xml = null;
+                XmlDictionaryReader localReader;
+
+                if (this.ShouldReadXmlReferenceKeyInfoClause)
+                {
+                    // We create the dom only when needed to not affect perf.
+                    XmlDocument doc = new XmlDocument();
+                    xml = (doc.ReadNode(reader) as XmlElement);
+                    localReader = XmlDictionaryReader.CreateDictionaryReader(new XmlNodeReader(xml));
+                }
+                else
+                {
+                    localReader = reader;
+                }
+
+                try
+                {
+                    this.KeyIdentifier = _tokenSerializer.ReadKeyIdentifier(localReader);
+                }
+                catch (Exception e)
+                {
+                    // In case when the issued token ( custom token) is used as an initiator token; we will fail 
+                    // to read the keyIdentifierClause using the plugged in default serializer. So We need to try to read it as an XmlReferencekeyIdentifierClause 
+                    // if it is the client side.
+
+                    if (Fx.IsFatal(e) || !this.ShouldReadXmlReferenceKeyInfoClause)
+                    {
+                        throw;
+                    }
+
+                    _keyIdentifier = ReadGenericXmlSecurityKeyIdentifier(XmlDictionaryReader.CreateDictionaryReader(new XmlNodeReader(xml)), e);
+                }
+            }
+
+            reader.ReadStartElement(CipherDataElementName, EncryptedType.NamespaceUri);
+            reader.ReadStartElement(CipherValueElementName, EncryptedType.NamespaceUri);
+            if (maxBufferSize == 0)
+                ReadCipherData(reader);
+            else
+                ReadCipherData(reader, maxBufferSize);
+            reader.ReadEndElement(); // CipherValue
+            reader.ReadEndElement(); // CipherData
+
+            ReadAdditionalElements(reader);
+            reader.ReadEndElement(); // OpeningElementName
+            this.State = EncryptionState.Read;
+        }
+
+        private SecurityKeyIdentifier ReadGenericXmlSecurityKeyIdentifier(XmlDictionaryReader localReader, Exception previousException)
+        {
+            throw new NotImplementedException();
+        }
+
+        protected virtual void WriteAdditionalAttributes(XmlDictionaryWriter writer, DictionaryManager dictionaryManager)
+        {
+        }
+
+        protected virtual void WriteAdditionalElements(XmlDictionaryWriter writer, DictionaryManager dictionaryManager)
+        {
+        }
+
+        protected abstract void WriteCipherData(XmlDictionaryWriter writer);
+
+        public void WriteTo(XmlDictionaryWriter writer, DictionaryManager dictionaryManager)
+        {
+            if (writer == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("writer");
+            }
+            ValidateWriteState();
+            writer.WriteStartElement(XmlEncryptionStrings.Prefix, this.OpeningElementName, NamespaceUri);
+            if (_id != null && _id.Length != 0)
+            {
+                writer.WriteAttributeString(XD.XmlEncryptionDictionary.Id, null, this.Id);
+            }
+            if (_type != null)
+            {
+                writer.WriteAttributeString(TypeAttribute, null, this.Type);
+            }
+            if (_mimeType != null)
+            {
+                writer.WriteAttributeString(MimeTypeAttribute, null, this.MimeType);
+            }
+            if (_encoding != null)
+            {
+                writer.WriteAttributeString(EncodingAttribute, null, this.Encoding);
+            }
+            WriteAdditionalAttributes(writer, dictionaryManager);
+            if (_encryptionMethod.algorithm != null)
+            {
+                _encryptionMethod.WriteTo(writer);
+            }
+            if (this.KeyIdentifier != null)
+            {
+                _tokenSerializer.WriteKeyIdentifier(writer, this.KeyIdentifier);
+            }
+
+            writer.WriteStartElement(CipherDataElementName, NamespaceUri);
+            writer.WriteStartElement(CipherValueElementName, NamespaceUri);
+            WriteCipherData(writer);
+            writer.WriteEndElement(); // CipherValue
+            writer.WriteEndElement(); // CipherData
+
+            WriteAdditionalElements(writer, dictionaryManager);
+            writer.WriteEndElement(); // OpeningElementName
+        }
+
+        private void ValidateReadState()
+        {
+            if (this.State != EncryptionState.New)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new Exception("BadEncryptionState"));
+            }
+        }
+
+        private void ValidateWriteState()
+        {
+            if (this.State == EncryptionState.EncryptionSetup)
+            {
+                ForceEncryption();
+            }
+            else if (this.State == EncryptionState.New)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new Exception("BadEncryptionState"));
+            }
+        }
+
+        protected enum EncryptionState
+        {
+            New,
+            Read,
+            DecryptionSetup,
+            Decrypted,
+            EncryptionSetup,
+            Encrypted
+        }
+
+        private struct EncryptionMethodElement
+        {
+            internal string algorithm;
+            internal XmlDictionaryString algorithmDictionaryString;
+            internal static readonly XmlDictionaryString ElementName = XD.XmlEncryptionDictionary.EncryptionMethod;
+
+            public void Init()
+            {
+                this.algorithm = null;
+            }
+
+            public void ReadFrom(XmlDictionaryReader reader)
+            {
+                reader.MoveToStartElement(ElementName, XD.XmlEncryptionDictionary.Namespace);
+                bool isEmptyElement = reader.IsEmptyElement;
+                this.algorithm = reader.GetAttribute(XD.XmlSignatureDictionary.Algorithm, null);
+                if (this.algorithm == null)
+                {
+                   // throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new SecurityMessageSerializationException(
+                   //     string.Format(SRServiceModel.RequiredAttributeMissing, XD.XmlSignatureDictionary.Algorithm.Value, ElementName.Value)));
+                }
+                reader.Read();
+                if (!isEmptyElement)
+                {
+                    while (reader.IsStartElement())
+                    {
+                        reader.Skip();
+                    }
+                    reader.ReadEndElement();
+                }
+            }
+
+            public void WriteTo(XmlDictionaryWriter writer)
+            {
+                writer.WriteStartElement(XmlEncryptionStrings.Prefix, ElementName, XD.XmlEncryptionDictionary.Namespace);
+                if (this.algorithmDictionaryString != null)
+                {
+                    writer.WriteStartAttribute(XD.XmlSignatureDictionary.Algorithm, null);
+                    writer.WriteString(this.algorithmDictionaryString);
+                    writer.WriteEndAttribute();
+                }
+                else
+                {
+                    writer.WriteAttributeString(XD.XmlSignatureDictionary.Algorithm, null, this.algorithm);
+                }
+                if (this.algorithm == XD.SecurityAlgorithmDictionary.RsaOaepKeyWrap.Value)
+                {
+                    writer.WriteStartElement(XmlSignatureStrings.Prefix, XD.XmlSignatureDictionary.DigestMethod, XD.XmlSignatureDictionary.Namespace);
+                    writer.WriteStartAttribute(XD.XmlSignatureDictionary.Algorithm, null);
+                    writer.WriteString(XD.SecurityAlgorithmDictionary.Sha1Digest);
+                    writer.WriteEndAttribute();
+                    writer.WriteEndElement();
+                }
+                writer.WriteEndElement(); // EncryptionMethod
+            }
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/IAcceptorSecuritySessionProtocol.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/IAcceptorSecuritySessionProtocol.cs
new file mode 100644
index 0000000..ce549db
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/IAcceptorSecuritySessionProtocol.cs
@@ -0,0 +1,19 @@
+
+
+using System.Xml;
+
+using CoreWCF;
+using CoreWCF.IdentityModel.Tokens;
+using CoreWCF.IdentityModel.Selectors;
+using CoreWCF.Security.Tokens;
+
+namespace CoreWCF.Security
+{
+    interface IAcceptorSecuritySessionProtocol
+    {
+        bool ReturnCorrelationState { get; set; }
+        SecurityToken GetOutgoingSessionToken();
+        void SetOutgoingSessionToken(SecurityToken token);
+        void SetSessionTokenAuthenticator(UniqueId sessionId, SecurityTokenAuthenticator sessionTokenAuthenticator, SecurityTokenResolver sessionTokenResolver);
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/IListenerSecureConversationSessionSettings.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/IListenerSecureConversationSessionSettings.cs
new file mode 100644
index 0000000..d21ee03
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/IListenerSecureConversationSessionSettings.cs
@@ -0,0 +1,44 @@
+
+using System;
+
+namespace CoreWCF.Security
+{
+    interface IListenerSecureConversationSessionSettings
+    {
+        bool TolerateTransportFailures
+        {
+            get;
+            set;
+        }
+
+        int MaximumPendingSessions
+        {
+            get;
+            set;
+        }
+
+        TimeSpan InactivityTimeout
+        {
+            get;
+            set;
+        }
+
+        TimeSpan MaximumKeyRenewalInterval
+        {
+            get;
+            set;
+        }
+
+        TimeSpan KeyRolloverInterval
+        {
+            get;
+            set;
+        }
+
+        int MaximumPendingKeysPerSession
+        {
+            get;
+            set;
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/ISecureConversationSession.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/ISecureConversationSession.cs
new file mode 100644
index 0000000..e3d657e
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/ISecureConversationSession.cs
@@ -0,0 +1,13 @@
+
+namespace CoreWCF.Security
+{
+    using System.Xml;
+    using CoreWCF;
+    using CoreWCF.Channels;
+
+    public interface ISecureConversationSession : ISecuritySession
+    {
+        void WriteSessionTokenIdentifier(XmlDictionaryWriter writer);
+        bool TryReadSessionTokenIdentifier(XmlReader reader);
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/ISecurityCommunicationObject.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/ISecurityCommunicationObject.cs
new file mode 100644
index 0000000..63d0ff5
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/ISecurityCommunicationObject.cs
@@ -0,0 +1,18 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Text;
+
+using System.Threading.Tasks;
+
+namespace CoreWCF.Security
+{
+    internal interface ISecurityCommunicationObject
+    {
+        TimeSpan DefaultOpenTimeout { get; }
+        TimeSpan DefaultCloseTimeout { get; }
+        void OnAbort();
+        Task OnCloseAsync(TimeSpan timeout);
+        void OnFaulted();
+        Task OnOpenAsync(TimeSpan timeout);
+    }
+}
\ No newline at end of file
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/ISspiNegotiation.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/ISspiNegotiation.cs
new file mode 100644
index 0000000..b9a8c48
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/ISspiNegotiation.cs
@@ -0,0 +1,50 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Text;
+using System.Runtime.CompilerServices;
+using System.Security.Authentication.ExtendedProtection;
+
+namespace CoreWCF.Security
+{
+    interface ISspiNegotiation : IDisposable
+    {
+
+        DateTime ExpirationTimeUtc
+        {
+            get;
+        }
+        /// <summary>
+        /// This indicates if the handshake is complete or not. 
+        /// Note that the IsValidContext flag indicates if the handshake ended in
+        /// success or failure
+        /// </summary>
+        bool IsCompleted
+        {
+            get;
+        }
+
+        bool IsValidContext
+        {
+            get;
+        }
+
+        string KeyEncryptionAlgorithm
+        {
+            get;
+        }
+
+        byte[] Decrypt(byte[] encryptedData);
+
+        byte[] Encrypt(byte[] data);
+
+        byte[] GetOutgoingBlob(byte[] incomingBlob, ChannelBinding channelbinding, ExtendedProtectionPolicy protectionPolicy);
+
+        string GetRemoteIdentityName();
+    }
+
+   // [TypeForwardedFrom("System.ServiceModel, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
+    interface ISspiNegotiationInfo
+    {
+        ISspiNegotiation SspiNegotiation { get; }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/IssuedTokenServiceCredential.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/IssuedTokenServiceCredential.cs
new file mode 100644
index 0000000..4e75148
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/IssuedTokenServiceCredential.cs
@@ -0,0 +1,211 @@
+using System.Collections.Generic;
+using CoreWCF.IdentityModel.Selectors;
+using CoreWCF.IdentityModel.Tokens;
+using CoreWCF;
+using System.Security.Cryptography.X509Certificates;
+using System;
+
+namespace CoreWCF.Security
+{    public class IssuedTokenServiceCredential
+    {
+        internal const bool DefaultAllowUntrustedRsaIssuers = false;
+       // internal const AudienceUriMode DefaultAudienceUriMode = AudienceUriMode.Always;
+        internal const X509CertificateValidationMode DefaultCertificateValidationMode = X509CertificateValidationMode.ChainTrust;
+        internal const X509RevocationMode DefaultRevocationMode = X509RevocationMode.Online;
+        internal const StoreLocation DefaultTrustedStoreLocation = StoreLocation.LocalMachine;
+
+        List<string> allowedAudienceUris;
+       // AudienceUriMode audienceUriMode = DefaultAudienceUriMode;
+        List<X509Certificate2> knownCertificates;
+        SamlSerializer samlSerializer;
+        X509CertificateValidationMode certificateValidationMode = DefaultCertificateValidationMode;
+        X509RevocationMode revocationMode = DefaultRevocationMode;
+        StoreLocation trustedStoreLocation = DefaultTrustedStoreLocation;
+        X509CertificateValidator customCertificateValidator = null;
+        bool allowUntrustedRsaIssuers = DefaultAllowUntrustedRsaIssuers;
+        bool isReadOnly;
+
+        internal IssuedTokenServiceCredential()
+        {
+            this.allowedAudienceUris = new List<string>();
+            this.knownCertificates = new List<X509Certificate2>();
+        }
+
+        internal IssuedTokenServiceCredential(IssuedTokenServiceCredential other)
+        {
+           // this.audienceUriMode = other.audienceUriMode;
+            this.allowedAudienceUris = new List<string>(other.allowedAudienceUris);
+            this.samlSerializer = other.samlSerializer;
+            this.knownCertificates = new List<X509Certificate2>(other.knownCertificates);
+            this.certificateValidationMode = other.certificateValidationMode;
+            this.customCertificateValidator = other.customCertificateValidator;
+            this.trustedStoreLocation = other.trustedStoreLocation;
+            this.revocationMode = other.revocationMode;
+            this.allowUntrustedRsaIssuers = other.allowUntrustedRsaIssuers;
+            this.isReadOnly = other.isReadOnly;
+        }
+
+        public IList<string> AllowedAudienceUris
+        {
+            get
+            {
+                if (this.isReadOnly)
+                    return this.allowedAudienceUris.AsReadOnly();
+                else
+                    return this.allowedAudienceUris;
+            }
+        }
+
+        //public AudienceUriMode AudienceUriMode
+        //{
+        //    get
+        //    {
+        //        return this.audienceUriMode;
+        //    }
+        //    set
+        //    {
+        //        ThrowIfImmutable();
+        //        AudienceUriModeValidationHelper.Validate(audienceUriMode);
+        //        this.audienceUriMode = value;
+        //    }
+        //}
+
+
+        public IList<X509Certificate2> KnownCertificates 
+        { 
+            get 
+            {
+                if (this.isReadOnly)
+                    return this.knownCertificates.AsReadOnly();
+                else
+                    return this.knownCertificates; 
+            }
+        }
+        
+        public SamlSerializer SamlSerializer
+        { 
+            get 
+            { 
+                return this.samlSerializer; 
+            } 
+            set 
+            {
+                ThrowIfImmutable();
+                this.samlSerializer = value;
+            } 
+        }
+
+        public X509CertificateValidationMode CertificateValidationMode
+        {
+            get
+            {
+                return this.certificateValidationMode;
+            }
+            set
+            {
+                X509CertificateValidationModeHelper.Validate(value);
+                ThrowIfImmutable();
+                this.certificateValidationMode = value;
+            }
+        }
+
+        public X509RevocationMode RevocationMode
+        {
+            get
+            {
+                return this.revocationMode;
+            }
+            set
+            {
+                ThrowIfImmutable();
+                this.revocationMode = value;
+            }
+        }
+
+        public StoreLocation TrustedStoreLocation
+        {
+            get
+            {
+                return this.trustedStoreLocation;
+            }
+            set
+            {
+                ThrowIfImmutable();
+                this.trustedStoreLocation = value;
+            }
+        }
+
+        public X509CertificateValidator CustomCertificateValidator
+        {
+            get
+            {
+                return this.customCertificateValidator;
+            }
+            set
+            {
+                ThrowIfImmutable();
+                this.customCertificateValidator = value;
+            }
+        }
+
+        public bool AllowUntrustedRsaIssuers
+        {
+            get
+            {
+                return this.allowUntrustedRsaIssuers;
+            }
+            set
+            {
+                ThrowIfImmutable();
+                this.allowUntrustedRsaIssuers = value;
+            }
+        }
+
+        internal X509CertificateValidator GetCertificateValidator()
+        {
+            if (this.certificateValidationMode == X509CertificateValidationMode.None)
+            {
+                return X509CertificateValidator.None;
+            }
+            else if (this.certificateValidationMode == X509CertificateValidationMode.PeerTrust)
+            {
+                return X509CertificateValidator.PeerTrust;
+            }
+            else if (this.certificateValidationMode == X509CertificateValidationMode.Custom)
+            {
+                if (this.customCertificateValidator == null)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.MissingCustomCertificateValidator)));
+                }
+                return this.customCertificateValidator;
+            }
+            else
+            {
+                bool useMachineContext = this.trustedStoreLocation == StoreLocation.LocalMachine;
+                X509ChainPolicy chainPolicy = new X509ChainPolicy();
+                chainPolicy.RevocationMode = this.revocationMode;
+                if (this.certificateValidationMode == X509CertificateValidationMode.ChainTrust)
+                {
+                    return X509CertificateValidator.CreateChainTrustValidator(useMachineContext, chainPolicy);
+                }
+                else
+                {
+                    return X509CertificateValidator.CreatePeerOrChainTrustValidator(useMachineContext, chainPolicy);
+                }
+            }
+        }
+
+        internal void MakeReadOnly()
+        {
+            this.isReadOnly = true;
+        }
+
+        void ThrowIfImmutable()
+        {
+            if (this.isReadOnly)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.ObjectIsReadOnly)));
+            }
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/MessageCredentialType.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/MessageCredentialType.cs
new file mode 100644
index 0000000..1265c92
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/MessageCredentialType.cs
@@ -0,0 +1,23 @@
+namespace CoreWCF
+{
+    public enum MessageCredentialType
+    {
+        None,
+        Windows,
+        UserName,
+        Certificate,
+        IssuedToken
+    }
+
+    static class MessageCredentialTypeHelper
+    {
+        internal static bool IsDefined(MessageCredentialType value)
+        {
+            return (value == MessageCredentialType.None ||
+                value == MessageCredentialType.UserName ||
+                value == MessageCredentialType.Windows ||
+                value == MessageCredentialType.Certificate ||
+                value == MessageCredentialType.IssuedToken);
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/MessagePartProtectionMode.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/MessagePartProtectionMode.cs
new file mode 100644
index 0000000..81a9153
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/MessagePartProtectionMode.cs
@@ -0,0 +1,44 @@
+﻿namespace CoreWCF.Security
+{
+    internal enum MessagePartProtectionMode
+    {
+        None,
+        Sign,
+        Encrypt,
+        SignThenEncrypt,
+        EncryptThenSign,
+    }
+
+    internal static class MessagePartProtectionModeHelper
+    {
+        public static MessagePartProtectionMode GetProtectionMode(bool sign, bool encrypt, bool signThenEncrypt)
+        {
+            if (sign)
+            {
+                if (encrypt)
+                {
+                    if (signThenEncrypt)
+                    {
+                        return MessagePartProtectionMode.SignThenEncrypt;
+                    }
+                    else
+                    {
+                        return MessagePartProtectionMode.EncryptThenSign;
+                    }
+                }
+                else
+                {
+                    return MessagePartProtectionMode.Sign;
+                }
+            }
+            else if (encrypt)
+            {
+                return MessagePartProtectionMode.Encrypt;
+            }
+            else
+            {
+                return MessagePartProtectionMode.None;
+            }
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/MessageProtectionOrder.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/MessageProtectionOrder.cs
new file mode 100644
index 0000000..f721310
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/MessageProtectionOrder.cs
@@ -0,0 +1,20 @@
+
+namespace CoreWCF.Security
+{
+    public enum MessageProtectionOrder
+    {
+        SignBeforeEncrypt,
+        SignBeforeEncryptAndEncryptSignature,
+        EncryptBeforeSign,
+    }
+
+    static class MessageProtectionOrderHelper
+    {
+        internal static bool IsDefined(MessageProtectionOrder value)
+        {
+            return value == MessageProtectionOrder.SignBeforeEncrypt
+                || value == MessageProtectionOrder.SignBeforeEncryptAndEncryptSignature
+                || value == MessageProtectionOrder.EncryptBeforeSign;
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/MessageSecurityOverHttp.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/MessageSecurityOverHttp.cs
new file mode 100644
index 0000000..e134eb3
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/MessageSecurityOverHttp.cs
@@ -0,0 +1,437 @@
+using System.Runtime;
+using System.Runtime.CompilerServices;
+using CoreWCF.Channels;
+using CoreWCF.Security;
+using CoreWCF.Security.Tokens;
+using System.ComponentModel;
+using CoreWCF;
+using CoreWCF.Runtime;
+using System.Globalization;
+using System;
+
+namespace CoreWCF
+{
+   public class MessageSecurityOverHttp
+    {
+        internal const MessageCredentialType DefaultClientCredentialType = MessageCredentialType.Windows;
+        internal const bool DefaultNegotiateServiceCredential = true;
+
+        MessageCredentialType clientCredentialType;
+        bool negotiateServiceCredential;
+        SecurityAlgorithmSuite algorithmSuite;
+        bool wasAlgorithmSuiteSet;
+
+        public MessageSecurityOverHttp()
+        {
+            clientCredentialType = DefaultClientCredentialType;
+            negotiateServiceCredential = DefaultNegotiateServiceCredential;
+            algorithmSuite = SecurityAlgorithmSuite.Default;
+        }
+
+        public MessageCredentialType ClientCredentialType
+        {
+            get { return this.clientCredentialType; }
+            set
+            {
+                if (!MessageCredentialTypeHelper.IsDefined(value))
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("value"));
+                }
+                this.clientCredentialType = value;
+            }
+        }
+
+        public bool NegotiateServiceCredential
+        {
+            get { return this.negotiateServiceCredential; }
+            set { this.negotiateServiceCredential = value; }
+        }
+
+        public SecurityAlgorithmSuite AlgorithmSuite
+        {
+            get { return this.algorithmSuite; }
+            set
+            {
+                if (value == null)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("value");
+                }
+                this.algorithmSuite = value;
+                wasAlgorithmSuiteSet = true;
+            }
+        }
+
+        internal bool WasAlgorithmSuiteSet
+        {
+            get { return this.wasAlgorithmSuiteSet; }
+        }
+
+        protected virtual bool IsSecureConversationEnabled()
+        {
+            return true;
+        }
+
+        [MethodImpl(MethodImplOptions.NoInlining)]
+        public SecurityBindingElement CreateSecurityBindingElement(bool isSecureTransportMode, bool isReliableSession, MessageSecurityVersion version)
+        {
+            if (isReliableSession && !this.IsSecureConversationEnabled())
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.SecureConversationRequiredByReliableSession)));
+            }
+
+            SecurityBindingElement result;
+            SecurityBindingElement oneShotSecurity = null;
+
+            bool isKerberosSelected = false;
+            bool emitBspAttributes = true;
+            if (isSecureTransportMode)
+            {
+                switch (this.clientCredentialType)
+                {
+                    case MessageCredentialType.None:
+                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.ClientCredentialTypeMustBeSpecifiedForMixedMode)));
+                    case MessageCredentialType.UserName:
+                        oneShotSecurity = SecurityBindingElement.CreateUserNameOverTransportBindingElement();
+                        break;
+                    //case MessageCredentialType.Certificate:
+                    //    oneShotSecurity = SecurityBindingElement.CreateCertificateOverTransportBindingElement();
+                    //    break;
+                    //case MessageCredentialType.Windows:
+                    //    oneShotSecurity = SecurityBindingElement.CreateSspiNegotiationOverTransportBindingElement(true);
+                    //    break;
+                    //case MessageCredentialType.IssuedToken:
+                    //    oneShotSecurity = SecurityBindingElement.CreateIssuedTokenOverTransportBindingElement(IssuedSecurityTokenParameters.CreateInfoCardParameters(new SecurityStandardsManager(new WSSecurityTokenSerializer(emitBspAttributes)), this.algorithmSuite));
+                    //    break;
+                    default:
+                        Fx.Assert("unknown ClientCredentialType");
+                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new NotSupportedException());
+                }
+                if (this.IsSecureConversationEnabled())
+                {
+                    result = SecurityBindingElement.CreateSecureConversationBindingElement(oneShotSecurity, true);
+                }
+                else
+                {
+                    result = oneShotSecurity;
+                }
+            }
+            else
+            {
+                //TODO 
+                //if (negotiateServiceCredential)
+                //{
+                //    switch (this.clientCredentialType)
+                //    {
+                //        case MessageCredentialType.None:
+                //            oneShotSecurity = SecurityBindingElement.CreateSslNegotiationBindingElement(false, true);
+                //            break;
+                //        case MessageCredentialType.UserName:
+                //            oneShotSecurity = SecurityBindingElement.CreateUserNameForSslBindingElement(true);
+                //            break;
+                //        case MessageCredentialType.Certificate:
+                //            oneShotSecurity = SecurityBindingElement.CreateSslNegotiationBindingElement(true, true);
+                //            break;
+                //        case MessageCredentialType.Windows:
+                //            oneShotSecurity = SecurityBindingElement.CreateSspiNegotiationBindingElement(true);
+                //            break;
+                //        case MessageCredentialType.IssuedToken:
+                //            oneShotSecurity = SecurityBindingElement.CreateIssuedTokenForSslBindingElement(IssuedSecurityTokenParameters.CreateInfoCardParameters(new SecurityStandardsManager(new WSSecurityTokenSerializer(emitBspAttributes)), this.algorithmSuite), true);
+                //            break;
+                //        default:
+                //            Fx.Assert("unknown ClientCredentialType");
+                //            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new NotSupportedException());
+                //    }
+                //}
+                //else
+                //{
+                //    switch (this.clientCredentialType)
+                //    {
+                //        case MessageCredentialType.None:
+                //            oneShotSecurity = SecurityBindingElement.CreateAnonymousForCertificateBindingElement();
+                //            break;
+                //        case MessageCredentialType.UserName:
+                //            oneShotSecurity = SecurityBindingElement.CreateUserNameForCertificateBindingElement();
+                //            break;
+                //        case MessageCredentialType.Certificate:
+                //            oneShotSecurity = SecurityBindingElement.CreateMutualCertificateBindingElement();
+                //            break;
+                //        case MessageCredentialType.Windows:
+                //            oneShotSecurity = SecurityBindingElement.CreateKerberosBindingElement();
+                //            isKerberosSelected = true;
+                //            break;
+                //        case MessageCredentialType.IssuedToken:
+                //            oneShotSecurity = SecurityBindingElement.CreateIssuedTokenForCertificateBindingElement(IssuedSecurityTokenParameters.CreateInfoCardParameters(new SecurityStandardsManager(new WSSecurityTokenSerializer(emitBspAttributes)), this.algorithmSuite));
+                //            break;
+                //        default:
+                //            Fx.Assert("unknown ClientCredentialType");
+                //            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new NotSupportedException());
+                //    }
+                //}
+                if (this.IsSecureConversationEnabled())
+                {
+                    result = SecurityBindingElement.CreateSecureConversationBindingElement(oneShotSecurity, true);
+                }
+                else
+                {
+                    result = oneShotSecurity;
+                }
+            }
+
+            // set the algorithm suite and issued token params if required
+            if (wasAlgorithmSuiteSet || (!isKerberosSelected))
+            {
+                result.DefaultAlgorithmSuite = oneShotSecurity.DefaultAlgorithmSuite = this.AlgorithmSuite;
+            }
+            else if (isKerberosSelected)
+            {
+                result.DefaultAlgorithmSuite = oneShotSecurity.DefaultAlgorithmSuite = SecurityAlgorithmSuite.KerberosDefault;
+            }
+
+            result.IncludeTimestamp = true;
+            oneShotSecurity.MessageSecurityVersion = version;
+            result.MessageSecurityVersion = version;
+            if (!isReliableSession)
+            {
+                result.LocalServiceSettings.ReconnectTransportOnFailure = false;
+               // result.LocalClientSettings.ReconnectTransportOnFailure = false;
+            }
+            else
+            {
+                result.LocalServiceSettings.ReconnectTransportOnFailure = true;
+               // result.LocalClientSettings.ReconnectTransportOnFailure = true;
+            }
+
+            if (this.IsSecureConversationEnabled())
+            {
+                string defaultServerIssuedTransitionTokenLifetimeString = "00:15:00";
+                TimeSpan defaultServerIssuedTransitionTokenLifetime = TimeSpan.Parse(defaultServerIssuedTransitionTokenLifetimeString, CultureInfo.InvariantCulture);
+                oneShotSecurity.LocalServiceSettings.IssuedCookieLifetime = defaultServerIssuedTransitionTokenLifetime;
+                //TODO SpNego when port, remove above and enable below.
+        // issue the transition SCT for a short duration only
+        // oneShotSecurity.LocalServiceSettings.IssuedCookieLifetime = SpnegoTokenAuthenticator.defaultServerIssuedTransitionTokenLifetime;
+            }
+
+            return result;
+        }
+
+        //internal static bool TryCreate<TSecurity>(SecurityBindingElement sbe, bool isSecureTransportMode, bool isReliableSession, out TSecurity messageSecurity)
+        //    where TSecurity : MessageSecurityOverHttp
+        //{
+        //    Fx.Assert(null != sbe, string.Empty);
+
+        //    messageSecurity = null;
+
+        //    // do not check local settings: sbe.LocalServiceSettings and sbe.LocalClientSettings
+
+        //    if (!sbe.IncludeTimestamp)
+        //    {
+        //        return false;
+        //    }
+
+        //    // Do not check MessageSecurityVersion: it maybe changed by the wrapper element and gets checked later in the SecuritySection.AreBindingsMatching()
+
+        //    if (sbe.SecurityHeaderLayout != SecurityProtocolFactory.defaultSecurityHeaderLayout)
+        //    {
+        //        return false;
+        //    }
+
+        //    bool negotiateServiceCredential = DefaultNegotiateServiceCredential;
+        //    MessageCredentialType clientCredentialType;
+        //    SecurityAlgorithmSuite algorithmSuite = SecurityAlgorithmSuite.Default;
+        //    bool isSecureConversation;
+
+        //    SecurityBindingElement bootstrapSecurity;
+        //    if (!SecurityBindingElement.IsSecureConversationBinding(sbe, true, out bootstrapSecurity))
+        //    {
+        //        isSecureConversation = false;
+
+        //        bootstrapSecurity = sbe;
+        //    }
+        //    else
+        //    {
+        //        isSecureConversation = true;
+        //    }
+
+        //    if (!isSecureConversation && typeof(TSecurity).Equals(typeof(MessageSecurityOverHttp)))
+        //    {
+        //        return false;
+        //    }
+
+        //    if (!isSecureConversation && isReliableSession)
+        //    {
+        //        return false;
+        //    }
+
+        //    if (isSecureTransportMode && !(bootstrapSecurity is TransportSecurityBindingElement))
+        //    {
+        //        return false;
+        //    }
+
+        //    IssuedSecurityTokenParameters infocardParameters;
+        //    if (isSecureTransportMode)
+        //    {
+        //        if (SecurityBindingElement.IsUserNameOverTransportBinding(bootstrapSecurity))
+        //        {
+        //            clientCredentialType = MessageCredentialType.UserName;
+        //        }
+        //        else if (SecurityBindingElement.IsCertificateOverTransportBinding(bootstrapSecurity))
+        //        {
+        //            clientCredentialType = MessageCredentialType.Certificate;
+        //        }
+        //        else if (SecurityBindingElement.IsSspiNegotiationOverTransportBinding(bootstrapSecurity, true))
+        //        {
+        //            clientCredentialType = MessageCredentialType.Windows;
+        //        }
+        //        else if (SecurityBindingElement.IsIssuedTokenOverTransportBinding(bootstrapSecurity, out infocardParameters))
+        //        {
+        //            if (!IssuedSecurityTokenParameters.IsInfoCardParameters(
+        //                    infocardParameters,
+        //                    new SecurityStandardsManager(
+        //                        sbe.MessageSecurityVersion,
+        //                        new WSSecurityTokenSerializer(
+        //                            sbe.MessageSecurityVersion.SecurityVersion,
+        //                            sbe.MessageSecurityVersion.TrustVersion,
+        //                            sbe.MessageSecurityVersion.SecureConversationVersion,
+        //                            true,
+        //                            null, null, null))))
+        //            {
+        //                return false;
+        //            }
+        //            clientCredentialType = MessageCredentialType.IssuedToken;
+        //        }
+        //        else
+        //        {
+        //            // the standard binding does not support None client credential type in mixed mode
+        //            return false;
+        //        }
+        //    }
+        //    else
+        //    {
+        //        if (SecurityBindingElement.IsSslNegotiationBinding(bootstrapSecurity, false, true))
+        //        {
+        //            negotiateServiceCredential = true;
+        //            clientCredentialType = MessageCredentialType.None;
+        //        }
+        //        else if (SecurityBindingElement.IsUserNameForSslBinding(bootstrapSecurity, true))
+        //        {
+        //            negotiateServiceCredential = true;
+        //            clientCredentialType = MessageCredentialType.UserName;
+        //        }
+        //        else if (SecurityBindingElement.IsSslNegotiationBinding(bootstrapSecurity, true, true))
+        //        {
+        //            negotiateServiceCredential = true;
+        //            clientCredentialType = MessageCredentialType.Certificate;
+        //        }
+        //        else if (SecurityBindingElement.IsSspiNegotiationBinding(bootstrapSecurity, true))
+        //        {
+        //            negotiateServiceCredential = true;
+        //            clientCredentialType = MessageCredentialType.Windows;
+        //        }
+        //        else if (SecurityBindingElement.IsIssuedTokenForSslBinding(bootstrapSecurity, true, out infocardParameters))
+        //        {
+        //            if (!IssuedSecurityTokenParameters.IsInfoCardParameters(
+        //                    infocardParameters,
+        //                    new SecurityStandardsManager(
+        //                        sbe.MessageSecurityVersion,
+        //                        new WSSecurityTokenSerializer(
+        //                            sbe.MessageSecurityVersion.SecurityVersion,
+        //                            sbe.MessageSecurityVersion.TrustVersion,
+        //                            sbe.MessageSecurityVersion.SecureConversationVersion,
+        //                            true,
+        //                            null, null, null))))
+        //            {
+        //                return false;
+        //            }
+        //            negotiateServiceCredential = true;
+        //            clientCredentialType = MessageCredentialType.IssuedToken;
+        //        }
+        //        else if (SecurityBindingElement.IsUserNameForCertificateBinding(bootstrapSecurity))
+        //        {
+        //            negotiateServiceCredential = false;
+        //            clientCredentialType = MessageCredentialType.UserName;
+        //        }
+        //        else if (SecurityBindingElement.IsMutualCertificateBinding(bootstrapSecurity))
+        //        {
+        //            negotiateServiceCredential = false;
+        //            clientCredentialType = MessageCredentialType.Certificate;
+        //        }
+        //        else if (SecurityBindingElement.IsKerberosBinding(bootstrapSecurity))
+        //        {
+        //            negotiateServiceCredential = false;
+        //            clientCredentialType = MessageCredentialType.Windows;
+        //        }
+        //        else if (SecurityBindingElement.IsIssuedTokenForCertificateBinding(bootstrapSecurity, out infocardParameters))
+        //        {
+        //            if (!IssuedSecurityTokenParameters.IsInfoCardParameters(
+        //                    infocardParameters,
+        //                    new SecurityStandardsManager(
+        //                        sbe.MessageSecurityVersion,
+        //                        new WSSecurityTokenSerializer(
+        //                            sbe.MessageSecurityVersion.SecurityVersion,
+        //                            sbe.MessageSecurityVersion.TrustVersion,
+        //                            sbe.MessageSecurityVersion.SecureConversationVersion,
+        //                            true,
+        //                            null, null, null))))
+        //            {
+        //                return false;
+        //            }
+        //            negotiateServiceCredential = false;
+        //            clientCredentialType = MessageCredentialType.IssuedToken;
+        //        }
+        //        else if (SecurityBindingElement.IsAnonymousForCertificateBinding(bootstrapSecurity))
+        //        {
+        //            negotiateServiceCredential = false;
+        //            clientCredentialType = MessageCredentialType.None;
+        //        }
+        //        else
+        //        {
+        //            return false;
+        //        }
+        //    }
+
+        //    // Do not check any Local* settings
+
+        //    // Do not check DefaultAlgorithmSuite: is it often changed after the Security element is created, it will verified by SecuritySectionBase.AreBindingsMatching().
+
+        //    if (typeof(NonDualMessageSecurityOverHttp).Equals(typeof(TSecurity)))
+        //    {
+        //        messageSecurity = (TSecurity)(object)new NonDualMessageSecurityOverHttp();
+        //        ((NonDualMessageSecurityOverHttp)(object)messageSecurity).EstablishSecurityContext = isSecureConversation;
+        //    }
+        //    else
+        //    {
+        //        messageSecurity = (TSecurity)(object)new MessageSecurityOverHttp();
+        //    }
+
+        //    messageSecurity.ClientCredentialType = clientCredentialType;
+        //    messageSecurity.NegotiateServiceCredential = negotiateServiceCredential;
+        //    messageSecurity.AlgorithmSuite = sbe.DefaultAlgorithmSuite;
+        //    return true;
+        //}
+
+        internal bool InternalShouldSerialize()
+        {
+            return this.ShouldSerializeAlgorithmSuite()
+                || this.ShouldSerializeClientCredentialType()
+                || ShouldSerializeNegotiateServiceCredential();
+        }
+
+        [EditorBrowsable(EditorBrowsableState.Never)]
+        public bool ShouldSerializeAlgorithmSuite()
+        {
+            return this.AlgorithmSuite != SecurityAlgorithmSuite.Default;
+        }
+
+        [EditorBrowsable(EditorBrowsableState.Never)]
+        public bool ShouldSerializeClientCredentialType()
+        {
+            return this.ClientCredentialType != DefaultClientCredentialType;
+        }
+
+        [EditorBrowsable(EditorBrowsableState.Never)]
+        public bool ShouldSerializeNegotiateServiceCredential()
+        {
+            return this.NegotiateServiceCredential != DefaultNegotiateServiceCredential;
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/MessageSecurityTokenVersion.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/MessageSecurityTokenVersion.cs
new file mode 100644
index 0000000..d2b4958
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/MessageSecurityTokenVersion.cs
@@ -0,0 +1,204 @@
+using System.Collections.ObjectModel;
+using CoreWCF.Channels;
+using CoreWCF;
+using System.Runtime.Serialization;
+using CoreWCF.IdentityModel.Tokens;
+using CoreWCF.IdentityModel.Selectors;
+using System;
+
+namespace CoreWCF.Security
+{
+    sealed class MessageSecurityTokenVersion : SecurityTokenVersion
+    {
+        SecurityVersion securityVersion;
+        TrustVersion trustVersion;
+        SecureConversationVersion secureConversationVersion;
+        bool emitBspRequiredAttributes;
+        string toString;
+        ReadOnlyCollection<string> supportedSpecs;
+
+        const string bsp10ns = @"http://ws-i.org/profiles/basic-security/core/1.0";
+        static MessageSecurityTokenVersion wss11 = new MessageSecurityTokenVersion(
+            SecurityVersion.WSSecurity11,
+            TrustVersion.WSTrustFeb2005,
+            SecureConversationVersion.WSSecureConversationFeb2005,
+            "WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005",
+            false,
+            XD.SecurityXXX2005Dictionary.Namespace.Value,
+            XD.TrustFeb2005Dictionary.Namespace.Value,
+            XD.SecureConversationFeb2005Dictionary.Namespace.Value);
+        static MessageSecurityTokenVersion wss10bsp10 = new MessageSecurityTokenVersion(
+            SecurityVersion.WSSecurity10,
+            TrustVersion.WSTrustFeb2005,
+            SecureConversationVersion.WSSecureConversationFeb2005,
+            "WSSecurity10WSTrustFebruary2005WSSecureConversationFebruary2005BasicSecurityProfile10",
+            true,
+            XD.SecurityJan2004Dictionary.Namespace.Value,
+            XD.TrustFeb2005Dictionary.Namespace.Value,
+            XD.SecureConversationFeb2005Dictionary.Namespace.Value,
+            bsp10ns);
+        static MessageSecurityTokenVersion wss11bsp10 = new MessageSecurityTokenVersion(
+            SecurityVersion.WSSecurity11,
+            TrustVersion.WSTrustFeb2005,
+            SecureConversationVersion.WSSecureConversationFeb2005,
+            "WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005BasicSecurityProfile10",
+            true,
+            XD.SecurityXXX2005Dictionary.Namespace.Value,
+            XD.TrustFeb2005Dictionary.Namespace.Value,
+            XD.SecureConversationFeb2005Dictionary.Namespace.Value,
+            bsp10ns);
+        static MessageSecurityTokenVersion wss10oasisdec2005bsp10 = new MessageSecurityTokenVersion(
+            SecurityVersion.WSSecurity10,
+            TrustVersion.WSTrust13,
+            SecureConversationVersion.WSSecureConversation13,
+            "WSSecurity10WSTrust13WSSecureConversation13BasicSecurityProfile10",
+            true,
+            XD.SecurityXXX2005Dictionary.Namespace.Value,
+            DXD.TrustDec2005Dictionary.Namespace.Value,
+            DXD.SecureConversationDec2005Dictionary.Namespace.Value
+            );
+        static MessageSecurityTokenVersion wss11oasisdec2005 = new MessageSecurityTokenVersion(
+            SecurityVersion.WSSecurity11,
+            TrustVersion.WSTrust13,
+            SecureConversationVersion.WSSecureConversation13,
+            "WSSecurity11WSTrust13WSSecureConversation13",
+            false,
+            XD.SecurityJan2004Dictionary.Namespace.Value,
+            DXD.TrustDec2005Dictionary.Namespace.Value,
+            DXD.SecureConversationDec2005Dictionary.Namespace.Value
+            );
+        static MessageSecurityTokenVersion wss11oasisdec2005bsp10 = new MessageSecurityTokenVersion(
+            SecurityVersion.WSSecurity11,
+            TrustVersion.WSTrust13,
+            SecureConversationVersion.WSSecureConversation13,
+            "WSSecurity11WSTrust13WSSecureConversation13BasicSecurityProfile10",
+            true,
+            XD.SecurityXXX2005Dictionary.Namespace.Value,
+            DXD.TrustDec2005Dictionary.Namespace.Value,
+            DXD.SecureConversationDec2005Dictionary.Namespace.Value
+            );
+
+        public static MessageSecurityTokenVersion WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005
+        {
+            get
+            {
+                return wss11;
+            }
+        }
+
+        public static MessageSecurityTokenVersion WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005BasicSecurityProfile10
+        {
+            get
+            {
+                return wss11bsp10;
+            }
+        }
+
+        public static MessageSecurityTokenVersion WSSecurity10WSTrustFebruary2005WSSecureConversationFebruary2005BasicSecurityProfile10
+        {
+            get
+            {
+                return wss10bsp10;
+            }
+        }
+
+        public static MessageSecurityTokenVersion WSSecurity10WSTrust13WSSecureConversation13BasicSecurityProfile10
+        {
+            get
+            {
+                return wss10oasisdec2005bsp10;
+            }
+        }
+
+        public static MessageSecurityTokenVersion WSSecurity11WSTrust13WSSecureConversation13
+        {
+            get
+            {
+                return wss11oasisdec2005;
+            }
+        }
+
+        public static MessageSecurityTokenVersion WSSecurity11WSTrust13WSSecureConversation13BasicSecurityProfile10
+        {
+            get
+            {
+                return wss11oasisdec2005bsp10;
+            }
+        }
+
+        public static MessageSecurityTokenVersion GetSecurityTokenVersion(SecurityVersion version, bool emitBspAttributes)
+        {
+            if (version == SecurityVersion.WSSecurity10)
+            {
+                if (emitBspAttributes)
+                    return MessageSecurityTokenVersion.WSSecurity10WSTrustFebruary2005WSSecureConversationFebruary2005BasicSecurityProfile10;
+                else
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new NotSupportedException());
+            }
+            else if (version == SecurityVersion.WSSecurity11)
+            {
+                if (emitBspAttributes)
+                    return MessageSecurityTokenVersion.WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005BasicSecurityProfile10;
+                else
+                    return MessageSecurityTokenVersion.WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005;
+            }
+            else
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new NotSupportedException());
+            }
+        }
+
+        MessageSecurityTokenVersion(SecurityVersion securityVersion, TrustVersion trustVersion, SecureConversationVersion secureConversationVersion, string toString, bool emitBspRequiredAttributes, params string[] supportedSpecs)
+            : base()
+        {
+            this.emitBspRequiredAttributes = emitBspRequiredAttributes;
+            this.supportedSpecs = new ReadOnlyCollection<string>(supportedSpecs);
+            this.toString = toString;
+            this.securityVersion = securityVersion;
+            this.trustVersion = trustVersion;
+            this.secureConversationVersion = secureConversationVersion;
+        }
+
+        public bool EmitBspRequiredAttributes
+        {
+            get
+            {
+                return this.emitBspRequiredAttributes;
+            }
+        }
+
+        public SecurityVersion SecurityVersion
+        {
+            get
+            {
+                return this.securityVersion;
+            }
+        }
+
+        public TrustVersion TrustVersion
+        {
+            get
+            {
+                return this.trustVersion;
+            }
+        }
+
+        public SecureConversationVersion SecureConversationVersion
+        {
+            get
+            {
+                return this.secureConversationVersion;
+            }
+        }
+
+        public override ReadOnlyCollection<string> GetSecuritySpecifications()
+        {
+            return supportedSpecs;
+        }
+
+        public override string ToString()
+        {
+            return this.toString;
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/Namespaces.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/Namespaces.cs
new file mode 100644
index 0000000..2b678f2
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/Namespaces.cs
@@ -0,0 +1,13 @@
+namespace CoreWCF.Security
+{
+    using System.Xml;
+
+    static class Namespaces
+    {
+        internal const string WSPolicy = CoreWCF.Description.MetadataStrings.WSPolicy.NamespaceUri;
+        internal const string WSPolicyPrefix = CoreWCF.Description.MetadataStrings.WSPolicy.Prefix;
+
+        internal const string XmlSchema = @"http://www.w3.org/2001/XMLSchema";
+        internal const string XmlSchemaPrefix = "xsd";
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/NonDualMessageSecurityOverHttp.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/NonDualMessageSecurityOverHttp.cs
new file mode 100644
index 0000000..765a95b
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/NonDualMessageSecurityOverHttp.cs
@@ -0,0 +1,35 @@
+
+namespace CoreWCF
+{
+    using CoreWCF.Channels;
+
+    public sealed class NonDualMessageSecurityOverHttp : MessageSecurityOverHttp
+    {
+        internal const bool DefaultEstablishSecurityContext = true;
+
+        bool establishSecurityContext;
+
+        public NonDualMessageSecurityOverHttp()
+            : base()
+        {
+            this.establishSecurityContext = DefaultEstablishSecurityContext;
+        }
+
+        public bool EstablishSecurityContext
+        {
+            get
+            {
+                return this.establishSecurityContext;
+            }
+            set
+            {
+                this.establishSecurityContext = value;
+            }
+        }
+
+        protected override bool IsSecureConversationEnabled()
+        {
+            return this.establishSecurityContext;
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/NonValidatingSecurityTokenAuthenticator.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/NonValidatingSecurityTokenAuthenticator.cs
new file mode 100644
index 0000000..5861557
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/NonValidatingSecurityTokenAuthenticator.cs
@@ -0,0 +1,29 @@
+﻿using CoreWCF.IdentityModel;
+using CoreWCF.IdentityModel.Policy;
+using CoreWCF.IdentityModel.Selectors;
+using CoreWCF.IdentityModel.Tokens;
+using System;
+using System.Collections.Generic;
+using System.Collections.ObjectModel;
+using System.Text;
+
+namespace CoreWCF.Security
+{
+    class NonValidatingSecurityTokenAuthenticator<TTokenType> : SecurityTokenAuthenticator
+    {
+        public NonValidatingSecurityTokenAuthenticator()
+            : base()
+        { }
+
+        protected override bool CanValidateTokenCore(SecurityToken token)
+        {
+            return (token is TTokenType);
+        }
+
+        protected override ReadOnlyCollection<IAuthorizationPolicy> ValidateTokenCore(SecurityToken token)
+        {
+            return EmptyReadOnlyCollection<IAuthorizationPolicy>.Instance;
+        }
+    }
+}
+
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/NonceCache.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/NonceCache.cs
new file mode 100644
index 0000000..69872dc
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/NonceCache.cs
@@ -0,0 +1,68 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.IO;
+using System.Globalization;
+using System.Runtime;
+using CoreWCF.Runtime;
+
+namespace CoreWCF.Security
+{
+    public abstract class NonceCache
+    {
+        TimeSpan cachingTime;
+        int maxCachedNonces;
+
+        /// <summary>
+        /// TThe max timespan after which a Nonce is deleted from the NonceCache. This value should be atleast twice the maxclock Skew added to the replayWindow size.
+        /// </summary>
+        public TimeSpan CachingTimeSpan
+        {
+            get
+            {
+                return this.cachingTime;
+            }
+            set
+            {
+                if (value < TimeSpan.Zero)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("value", value,
+                        SR.Format(SR.SFxTimeoutOutOfRange0)));
+                }
+
+                if (TimeoutHelper.IsTooLarge(value))
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("value", value,
+                        SR.Format(SR.SFxTimeoutOutOfRangeTooBig)));
+                }
+
+                this.cachingTime = value;
+            }
+        }
+
+        /// <summary>
+        /// The maximum size of the NonceCache.
+        /// </summary>
+        public int CacheSize
+        {
+            get
+            {
+                return this.maxCachedNonces;
+            }
+            set
+            {
+                if (value < 0)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("value", value,
+                                                    SR.Format(SR.ValueMustBeNonNegative)));
+                }
+                this.maxCachedNonces = value;
+
+            }
+        }
+
+        public abstract bool TryAddNonce(byte[] nonce);
+        public abstract bool CheckNonce(byte[] nonce);
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/NonceToken.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/NonceToken.cs
new file mode 100644
index 0000000..ebfc9d0
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/NonceToken.cs
@@ -0,0 +1,33 @@
+using System.Collections;
+using CoreWCF;
+using System.IO;
+using CoreWCF.IdentityModel.Claims;
+using CoreWCF.IdentityModel.Policy;
+using System.Security.Cryptography;
+using CoreWCF.Security.Tokens;
+using System.Text;
+using System.Xml;
+using CoreWCF.IdentityModel;
+
+namespace CoreWCF.Security
+{
+
+
+    sealed class NonceToken : BinarySecretSecurityToken
+    {
+        public NonceToken(byte[] key)
+            : this(SecurityUniqueId.Create().Value, key)
+        {
+        }
+
+        public NonceToken(string id, byte[] key)
+            : base(id, key, false)
+        {
+        }
+
+        public NonceToken(int keySizeInBits)
+            : base(SecurityUniqueId.Create().Value, keySizeInBits, false)
+        {
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/ReceiveSecurityHeader.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/ReceiveSecurityHeader.cs
new file mode 100644
index 0000000..10a2120
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/ReceiveSecurityHeader.cs
@@ -0,0 +1,2188 @@
+using System.Collections.Generic;
+using System.Collections.ObjectModel;
+using System.Diagnostics;
+using CoreWCF.IdentityModel.Policy;
+using CoreWCF.IdentityModel.Selectors;
+using CoreWCF.IdentityModel.Tokens;
+using System.Security.Authentication.ExtendedProtection;
+using System.Security.Cryptography.X509Certificates;
+using CoreWCF;
+using CoreWCF.Channels;
+using CoreWCF.Description;
+using CoreWCF.Security.Tokens;
+using CoreWCF.Diagnostics;
+using System.Runtime;
+using System.Xml;
+using CoreWCF.Runtime.Diagnostics;
+using System;
+using CoreWCF.Runtime;
+using CoreWCF.IdentityModel;
+using System.Security.Cryptography.Xml;
+using XmlAttributeHolder = CoreWCF.Channels.XmlAttributeHolder;
+//using System.Security.Cryptography.Xml;
+
+namespace CoreWCF.Security
+{
+
+
+    abstract class ReceiveSecurityHeader : SecurityHeader
+    {
+        // client->server symmetric binding case: only primaryTokenAuthenticator is set
+        // server->client symmetric binding case: only primary token is set
+        // asymmetric binding case: primaryTokenAuthenticator and wrapping token is set
+
+        SecurityTokenAuthenticator primaryTokenAuthenticator;
+        bool allowFirstTokenMismatch;
+        SecurityToken outOfBandPrimaryToken;
+        IList<SecurityToken> outOfBandPrimaryTokenCollection;
+        SecurityTokenParameters primaryTokenParameters;
+        TokenTracker primaryTokenTracker;
+        SecurityToken wrappingToken;
+        SecurityTokenParameters wrappingTokenParameters;
+        SecurityToken expectedEncryptionToken;
+        SecurityTokenParameters expectedEncryptionTokenParameters;
+        SecurityTokenAuthenticator derivedTokenAuthenticator;
+        // assumes that the caller has done the check for uniqueness of types
+        IList<SupportingTokenAuthenticatorSpecification> supportingTokenAuthenticators;
+        ChannelBinding channelBinding;
+        ExtendedProtectionPolicy extendedProtectionPolicy;
+
+        bool expectEncryption = true;
+        // caller should precompute and set expectations
+        bool expectBasicTokens;
+        bool expectSignedTokens;
+        bool expectEndorsingTokens;
+        bool expectSignature = true;
+        bool requireSignedPrimaryToken;
+        bool expectSignatureConfirmation;
+        // maps from token to wire form (for basic and signed), and also tracks operations done
+        // maps from supporting token parameter to the operations done for that token type
+        List<TokenTracker> supportingTokenTrackers;
+
+        SignatureConfirmations receivedSignatureValues;
+        SignatureConfirmations receivedSignatureConfirmations;
+        List<SecurityTokenAuthenticator> allowedAuthenticators;
+
+        SecurityTokenAuthenticator pendingSupportingTokenAuthenticator;
+
+        WrappedKeySecurityToken wrappedKeyToken;
+        Collection<SecurityToken> basicTokens;
+        Collection<SecurityToken> signedTokens;
+        Collection<SecurityToken> endorsingTokens;
+        Collection<SecurityToken> signedEndorsingTokens;
+        Dictionary<SecurityToken, ReadOnlyCollection<IAuthorizationPolicy>> tokenPoliciesMapping;
+        List<SecurityTokenAuthenticator> wrappedKeyAuthenticator;
+        SecurityTimestamp timestamp;
+        SecurityHeaderTokenResolver universalTokenResolver;
+        SecurityHeaderTokenResolver primaryTokenResolver;
+        ReadOnlyCollection<SecurityTokenResolver> outOfBandTokenResolver;
+        SecurityTokenResolver combinedUniversalTokenResolver;
+        SecurityTokenResolver combinedPrimaryTokenResolver;
+
+        readonly int headerIndex;
+        XmlAttributeHolder[] securityElementAttributes;
+        OrderTracker orderTracker = new OrderTracker();
+        OperationTracker signatureTracker = new OperationTracker();
+        OperationTracker encryptionTracker = new OperationTracker();
+
+        ReceiveSecurityHeaderElementManager elementManager;
+
+        int maxDerivedKeys;
+        int numDerivedKeys;
+        int maxDerivedKeyLength;
+        bool enforceDerivedKeyRequirement = true;
+
+        NonceCache nonceCache;
+        TimeSpan replayWindow;
+        TimeSpan clockSkew;
+        byte[] primarySignatureValue;
+        TimeoutHelper timeoutHelper;
+        SecurityVerifiedMessage securityVerifiedMessage;
+        long maxReceivedMessageSize = TransportDefaults.MaxReceivedMessageSize;
+        XmlDictionaryReaderQuotas readerQuotas;
+        MessageProtectionOrder protectionOrder;
+        bool hasAtLeastOneSupportingTokenExpectedToBeSigned;
+        bool hasEndorsingOrSignedEndorsingSupportingTokens;
+        SignatureResourcePool resourcePool;
+        bool replayDetectionEnabled = false;
+
+        bool hasAtLeastOneItemInsideSecurityHeaderEncrypted = false;
+
+        const int AppendPosition = -1;
+
+       // EventTraceActivity eventTraceActivity;
+
+        protected ReceiveSecurityHeader(Message message, string actor, bool mustUnderstand, bool relay,
+            SecurityStandardsManager standardsManager,
+            SecurityAlgorithmSuite algorithmSuite,
+            int headerIndex,
+            MessageDirection direction)
+            : base(message, actor, mustUnderstand, relay, standardsManager, algorithmSuite, direction)
+        {
+            this.headerIndex = headerIndex;
+            this.elementManager = new ReceiveSecurityHeaderElementManager(this);
+        }
+
+        public Collection<SecurityToken> BasicSupportingTokens
+        {
+            get
+            {
+                return this.basicTokens;
+            }
+        }
+
+        public Collection<SecurityToken> SignedSupportingTokens
+        {
+            get
+            {
+                return this.signedTokens;
+            }
+        }
+
+        public Collection<SecurityToken> EndorsingSupportingTokens
+        {
+            get
+            {
+                return this.endorsingTokens;
+            }
+        }
+
+        public ReceiveSecurityHeaderElementManager ElementManager
+        {
+            get
+            {
+                return this.elementManager;
+            }
+        }
+
+        public Collection<SecurityToken> SignedEndorsingSupportingTokens
+        {
+            get
+            {
+                return this.signedEndorsingTokens;
+            }
+        }
+
+        public SecurityTokenAuthenticator DerivedTokenAuthenticator
+        {
+            get
+            {
+                return this.derivedTokenAuthenticator;
+            }
+            set
+            {
+                ThrowIfProcessingStarted();
+                this.derivedTokenAuthenticator = value;
+            }
+        }
+
+        public List<SecurityTokenAuthenticator> WrappedKeySecurityTokenAuthenticator
+        {
+            get
+            {
+                return this.wrappedKeyAuthenticator;
+            }
+            set
+            {
+                ThrowIfProcessingStarted();
+                this.wrappedKeyAuthenticator = value;
+            }
+        }
+
+        public bool EnforceDerivedKeyRequirement
+        {
+            get
+            {
+                return this.enforceDerivedKeyRequirement;
+            }
+            set
+            {
+                ThrowIfProcessingStarted();
+                this.enforceDerivedKeyRequirement = value;
+            }
+        }
+
+        public byte[] PrimarySignatureValue
+        {
+            get { return this.primarySignatureValue; }
+        }
+
+        public bool EncryptBeforeSignMode
+        {
+            get { return this.orderTracker.EncryptBeforeSignMode; }
+        }
+
+        public SecurityToken EncryptionToken
+        {
+            get { return this.encryptionTracker.Token; }
+        }
+
+        public bool ExpectBasicTokens
+        {
+            get { return this.expectBasicTokens; }
+            set
+            {
+                ThrowIfProcessingStarted();
+                this.expectBasicTokens = value;
+            }
+        }
+
+        public bool ReplayDetectionEnabled
+        {
+            get { return this.replayDetectionEnabled; }
+            set
+            {
+                ThrowIfProcessingStarted();
+                this.replayDetectionEnabled = value;
+            }
+        }
+
+        public bool ExpectEncryption
+        {
+            get { return this.expectEncryption; }
+            set
+            {
+                ThrowIfProcessingStarted();
+                this.expectEncryption = value;
+            }
+        }
+
+        public bool ExpectSignature
+        {
+            get { return this.expectSignature; }
+            set
+            {
+                ThrowIfProcessingStarted();
+                this.expectSignature = value;
+            }
+        }
+
+        public bool ExpectSignatureConfirmation
+        {
+            get { return this.expectSignatureConfirmation; }
+            set
+            {
+                ThrowIfProcessingStarted();
+                this.expectSignatureConfirmation = value;
+            }
+        }
+
+        public bool ExpectSignedTokens
+        {
+            get { return this.expectSignedTokens; }
+            set
+            {
+                ThrowIfProcessingStarted();
+                this.expectSignedTokens = value;
+            }
+        }
+
+        public bool RequireSignedPrimaryToken
+        {
+            get { return this.requireSignedPrimaryToken; }
+            set
+            {
+                ThrowIfProcessingStarted();
+                this.requireSignedPrimaryToken = value;
+            }
+        }
+
+        public bool ExpectEndorsingTokens
+        {
+            get { return this.expectEndorsingTokens; }
+            set
+            {
+                ThrowIfProcessingStarted();
+                this.expectEndorsingTokens = value;
+            }
+        }
+
+        public bool HasAtLeastOneItemInsideSecurityHeaderEncrypted
+        {
+            get { return this.hasAtLeastOneItemInsideSecurityHeaderEncrypted; }
+            set { this.hasAtLeastOneItemInsideSecurityHeaderEncrypted = value; }
+        }
+
+        public SecurityHeaderTokenResolver PrimaryTokenResolver
+        {
+            get
+            {
+                return this.primaryTokenResolver;
+            }
+        }
+
+        public SecurityTokenResolver CombinedUniversalTokenResolver
+        {
+            get { return this.combinedUniversalTokenResolver; }
+        }
+
+        public SecurityTokenResolver CombinedPrimaryTokenResolver
+        {
+            get { return this.combinedPrimaryTokenResolver; }
+        }
+
+        //protected EventTraceActivity EventTraceActivity
+        //{
+        //    get
+        //    {
+        //        if (this.eventTraceActivity == null && FxTrace.Trace.IsEnd2EndActivityTracingEnabled)
+        //        {
+        //            this.eventTraceActivity = EventTraceActivityHelper.TryExtractActivity((OperationContext.Current != null) ? OperationContext.Current.IncomingMessage : null);
+        //        }
+
+        //        return this.eventTraceActivity;
+        //    }
+        //}
+
+        protected void VerifySignatureEncryption()
+        {
+            if ((this.protectionOrder == MessageProtectionOrder.SignBeforeEncryptAndEncryptSignature) &&
+                (!this.orderTracker.AllSignaturesEncrypted))
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new MessageSecurityException(
+                                SR.Format(SR.PrimarySignatureIsRequiredToBeEncrypted)));
+            }
+        }
+
+        internal int HeaderIndex
+        {
+            get { return this.headerIndex; }
+        }
+
+        internal long MaxReceivedMessageSize
+        {
+            get
+            {
+                return this.maxReceivedMessageSize;
+            }
+            set
+            {
+                ThrowIfProcessingStarted();
+                this.maxReceivedMessageSize = value;
+            }
+        }
+
+        internal XmlDictionaryReaderQuotas ReaderQuotas
+        {
+            get { return this.readerQuotas; }
+            set
+            {
+                ThrowIfProcessingStarted();
+
+                if (value == null)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("value");
+
+                this.readerQuotas = value;
+            }
+        }
+
+        public override string Name
+        {
+            get { return this.StandardsManager.SecurityVersion.HeaderName.Value; }
+        }
+
+        public override string Namespace
+        {
+            get { return this.StandardsManager.SecurityVersion.HeaderNamespace.Value; }
+        }
+
+        public Message ProcessedMessage
+        {
+            get { return this.Message; }
+        }
+
+        public MessagePartSpecification RequiredEncryptionParts
+        {
+            get { return this.encryptionTracker.Parts; }
+            set
+            {
+                ThrowIfProcessingStarted();
+                if (value == null)
+                {
+                    throw TraceUtility.ThrowHelperError(new ArgumentNullException("value"), this.Message);
+                }
+                if (!value.IsReadOnly)
+                {
+                    throw TraceUtility.ThrowHelperError(new InvalidOperationException(
+                        SR.Format(SR.MessagePartSpecificationMustBeImmutable)), this.Message);
+                }
+                this.encryptionTracker.Parts = value;
+            }
+        }
+
+        public MessagePartSpecification RequiredSignatureParts
+        {
+            get { return this.signatureTracker.Parts; }
+            set
+            {
+                ThrowIfProcessingStarted();
+                if (value == null)
+                {
+                    throw TraceUtility.ThrowHelperError(new ArgumentNullException("value"), this.Message);
+                }
+                if (!value.IsReadOnly)
+                {
+                    throw TraceUtility.ThrowHelperError(new InvalidOperationException(
+                        SR.Format(SR.MessagePartSpecificationMustBeImmutable)), this.Message);
+                }
+                this.signatureTracker.Parts = value;
+            }
+        }
+
+        protected SignatureResourcePool ResourcePool
+        {
+            get
+            {
+                if (this.resourcePool == null)
+                {
+                    this.resourcePool = new SignatureResourcePool();
+                }
+                return this.resourcePool;
+            }
+        }
+
+        internal SecurityVerifiedMessage SecurityVerifiedMessage
+        {
+            get
+            {
+                return this.securityVerifiedMessage;
+            }
+        }
+
+        public SecurityToken SignatureToken
+        {
+            get { return this.signatureTracker.Token; }
+        }
+
+        public Dictionary<SecurityToken, ReadOnlyCollection<IAuthorizationPolicy>> SecurityTokenAuthorizationPoliciesMapping
+        {
+            get
+            {
+                if (this.tokenPoliciesMapping == null)
+                {
+                    this.tokenPoliciesMapping = new Dictionary<SecurityToken, ReadOnlyCollection<IAuthorizationPolicy>>();
+                }
+                return this.tokenPoliciesMapping;
+            }
+        }
+
+        public SecurityTimestamp Timestamp
+        {
+            get { return this.timestamp; }
+        }
+
+        public int MaxDerivedKeyLength
+        {
+            get
+            {
+                return this.maxDerivedKeyLength;
+            }
+        }
+
+        internal XmlDictionaryReader CreateSecurityHeaderReader()
+        {
+            return this.securityVerifiedMessage.GetReaderAtSecurityHeader();
+        }
+
+        public SignatureConfirmations GetSentSignatureConfirmations()
+        {
+            return this.receivedSignatureConfirmations;
+        }
+
+        public void ConfigureSymmetricBindingServerReceiveHeader(SecurityTokenAuthenticator primaryTokenAuthenticator, SecurityTokenParameters primaryTokenParameters, IList<SupportingTokenAuthenticatorSpecification> supportingTokenAuthenticators)
+        {
+            this.primaryTokenAuthenticator = primaryTokenAuthenticator;
+            this.primaryTokenParameters = primaryTokenParameters;
+            this.supportingTokenAuthenticators = supportingTokenAuthenticators;
+        }
+
+        // encrypted key case
+        public void ConfigureSymmetricBindingServerReceiveHeader(SecurityToken wrappingToken, SecurityTokenParameters wrappingTokenParameters, IList<SupportingTokenAuthenticatorSpecification> supportingTokenAuthenticators)
+        {
+            this.wrappingToken = wrappingToken;
+            this.wrappingTokenParameters = wrappingTokenParameters;
+            this.supportingTokenAuthenticators = supportingTokenAuthenticators;
+        }
+
+        public void ConfigureAsymmetricBindingServerReceiveHeader(SecurityTokenAuthenticator primaryTokenAuthenticator, SecurityTokenParameters primaryTokenParameters, SecurityToken wrappingToken, SecurityTokenParameters wrappingTokenParameters, IList<SupportingTokenAuthenticatorSpecification> supportingTokenAuthenticators)
+        {
+            this.primaryTokenAuthenticator = primaryTokenAuthenticator;
+            this.primaryTokenParameters = primaryTokenParameters;
+            this.wrappingToken = wrappingToken;
+            this.wrappingTokenParameters = wrappingTokenParameters;
+            this.supportingTokenAuthenticators = supportingTokenAuthenticators;
+        }
+
+        public void ConfigureTransportBindingServerReceiveHeader(IList<SupportingTokenAuthenticatorSpecification> supportingTokenAuthenticators)
+        {
+            this.supportingTokenAuthenticators = supportingTokenAuthenticators;
+        }
+
+  
+
+        public void ConfigureSymmetricBindingClientReceiveHeader(SecurityToken primaryToken, SecurityTokenParameters primaryTokenParameters)
+        {
+            this.outOfBandPrimaryToken = primaryToken;
+            this.primaryTokenParameters = primaryTokenParameters;
+        }
+
+        public void ConfigureSymmetricBindingClientReceiveHeader(IList<SecurityToken> primaryTokens, SecurityTokenParameters primaryTokenParameters)
+        {
+            this.outOfBandPrimaryTokenCollection = primaryTokens;
+            this.primaryTokenParameters = primaryTokenParameters;
+        }
+
+        public void ConfigureOutOfBandTokenResolver(ReadOnlyCollection<SecurityTokenResolver> outOfBandResolvers)
+        {
+            if (outOfBandResolvers == null)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("outOfBandResolvers");
+            if (outOfBandResolvers.Count == 0)
+            {
+                return;
+            }
+            this.outOfBandTokenResolver = outOfBandResolvers;
+        }
+
+        protected abstract EncryptedData ReadSecurityHeaderEncryptedItem(XmlDictionaryReader reader, bool readXmlreferenceKeyInfoClause);
+
+        protected abstract byte[] DecryptSecurityHeaderElement(EncryptedData encryptedData, WrappedKeySecurityToken wrappedKeyToken, out SecurityToken encryptionToken);
+
+        protected abstract WrappedKeySecurityToken DecryptWrappedKey(XmlDictionaryReader reader);
+
+        public SignatureConfirmations GetSentSignatureValues()
+        {
+            return this.receivedSignatureValues;
+        }
+
+        protected abstract bool IsReaderAtEncryptedKey(XmlDictionaryReader reader);
+
+        protected abstract bool IsReaderAtEncryptedData(XmlDictionaryReader reader);
+
+        protected abstract bool IsReaderAtReferenceList(XmlDictionaryReader reader);
+
+        protected abstract bool IsReaderAtSignature(XmlDictionaryReader reader);
+
+        protected abstract bool IsReaderAtSecurityTokenReference(XmlDictionaryReader reader);
+
+        protected abstract void OnDecryptionOfSecurityHeaderItemRequiringReferenceListEntry(string id);
+
+        void MarkHeaderAsUnderstood()
+        {
+            // header decryption does not reorder or delete headers
+            MessageHeaderInfo header = this.Message.Headers[this.headerIndex];
+            Fx.Assert(header.Name == this.Name && header.Namespace == this.Namespace && header.Actor == this.Actor, "security header index mismatch");
+            Message.Headers.UnderstoodHeaders.Add(header);
+        }
+
+        protected override void OnWriteStartHeader(XmlDictionaryWriter writer, MessageVersion messageVersion)
+        {
+            this.StandardsManager.SecurityVersion.WriteStartHeader(writer);
+            Channels.XmlAttributeHolder[] attributes = this.securityElementAttributes;
+            for (int i = 0; i < attributes.Length; ++i)
+            {
+                writer.WriteAttributeString(attributes[i].Prefix, attributes[i].LocalName, attributes[i].NamespaceUri, attributes[i].Value);
+            }
+        }
+
+        protected override void OnWriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion)
+        {
+            XmlDictionaryReader securityHeaderReader = GetReaderAtSecurityHeader();
+            securityHeaderReader.ReadStartElement();
+            for (int i = 0; i < this.ElementManager.Count; ++i)
+            {
+                ReceiveSecurityHeaderEntry entry;
+                this.ElementManager.GetElementEntry(i, out entry);
+                XmlDictionaryReader reader = null;
+                if (entry.encrypted)
+                {
+                    reader = this.ElementManager.GetReader(i, false);
+                    writer.WriteNode(reader, false);
+                    reader.Close();
+                    securityHeaderReader.Skip();
+                }
+                else
+                {
+                    writer.WriteNode(securityHeaderReader, false);
+                }
+            }
+            securityHeaderReader.Close();
+        }
+
+        XmlDictionaryReader GetReaderAtSecurityHeader()
+        {
+            XmlDictionaryReader reader = this.SecurityVerifiedMessage.GetReaderAtFirstHeader();
+            for (int i = 0; i < this.HeaderIndex; ++i)
+            {
+                reader.Skip();
+            }
+
+            return reader;
+        }
+
+        Collection<SecurityToken> EnsureSupportingTokens(ref Collection<SecurityToken> list)
+        {
+            if (list == null)
+                list = new Collection<SecurityToken>();
+            return list;
+        }
+
+        void VerifySupportingToken(TokenTracker tracker)
+        {
+            if (tracker == null)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("tracker");
+
+            Fx.Assert(tracker.spec != null, "Supporting token trackers cannot have null specification.");
+
+            SupportingTokenAuthenticatorSpecification spec = tracker.spec;
+
+            if (tracker.token == null)
+            {
+                if (spec.IsTokenOptional)
+                    return;
+                else
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new MessageSecurityException(SR.Format(SR.SupportingTokenNotProvided, spec.TokenParameters, spec.SecurityTokenAttachmentMode)));
+            }
+            switch (spec.SecurityTokenAttachmentMode)
+            {
+                case SecurityTokenAttachmentMode.Endorsing:
+                    if (!tracker.IsEndorsing)
+                    {
+                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new MessageSecurityException(SR.Format(SR.SupportingTokenIsNotEndorsing, spec.TokenParameters)));
+                    }
+                    if (this.EnforceDerivedKeyRequirement && spec.TokenParameters.RequireDerivedKeys && !spec.TokenParameters.HasAsymmetricKey && !tracker.IsDerivedFrom)
+                    {
+                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new MessageSecurityException(SR.Format(SR.SupportingSignatureIsNotDerivedFrom, spec.TokenParameters)));
+                    }
+                    EnsureSupportingTokens(ref endorsingTokens).Add(tracker.token);
+                    break;
+                case SecurityTokenAttachmentMode.Signed:
+                    if (!tracker.IsSigned && this.RequireMessageProtection)
+                    {
+                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new MessageSecurityException(SR.Format(SR.SupportingTokenIsNotSigned, spec.TokenParameters)));
+                    }
+                    EnsureSupportingTokens(ref signedTokens).Add(tracker.token);
+                    break;
+                case SecurityTokenAttachmentMode.SignedEncrypted:
+                    if (!tracker.IsSigned && this.RequireMessageProtection)
+                    {
+                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new MessageSecurityException(SR.Format(SR.SupportingTokenIsNotSigned, spec.TokenParameters)));
+                    }
+                    if (!tracker.IsEncrypted && this.RequireMessageProtection)
+                    {
+                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new MessageSecurityException(SR.Format(SR.SupportingTokenIsNotEncrypted, spec.TokenParameters)));
+                    }
+                    EnsureSupportingTokens(ref basicTokens).Add(tracker.token);
+                    break;
+                case SecurityTokenAttachmentMode.SignedEndorsing:
+                    if (!tracker.IsSigned && this.RequireMessageProtection)
+                    {
+                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new MessageSecurityException(SR.Format(SR.SupportingTokenIsNotSigned, spec.TokenParameters)));
+                    }
+                    if (!tracker.IsEndorsing)
+                    {
+                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new MessageSecurityException(SR.Format(SR.SupportingTokenIsNotEndorsing, spec.TokenParameters)));
+                    }
+                    if (this.EnforceDerivedKeyRequirement && spec.TokenParameters.RequireDerivedKeys && !spec.TokenParameters.HasAsymmetricKey && !tracker.IsDerivedFrom)
+                    {
+                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new MessageSecurityException(SR.Format(SR.SupportingSignatureIsNotDerivedFrom, spec.TokenParameters)));
+                    }
+                    EnsureSupportingTokens(ref signedEndorsingTokens).Add(tracker.token);
+                    break;
+
+                default:
+                    Fx.Assert("Unknown token attachment mode " + spec.SecurityTokenAttachmentMode);
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new NotSupportedException(SR.Format(SR.UnknownTokenAttachmentMode, spec.SecurityTokenAttachmentMode)));
+            }
+        }
+
+        // replay detection done if enableReplayDetection is set to true.
+        public void SetTimeParameters(NonceCache nonceCache, TimeSpan replayWindow, TimeSpan clockSkew)
+        {
+            this.nonceCache = nonceCache;
+            this.replayWindow = replayWindow;
+            this.clockSkew = clockSkew;
+        }
+
+        public void Process(TimeSpan timeout, ChannelBinding channelBinding, ExtendedProtectionPolicy extendedProtectionPolicy)
+        {
+            Fx.Assert(this.ReaderQuotas != null, "Reader quotas must be set before processing");
+            MessageProtectionOrder actualProtectionOrder = this.protectionOrder;
+            bool wasProtectionOrderDowngraded = false;
+            if (this.protectionOrder == MessageProtectionOrder.SignBeforeEncryptAndEncryptSignature)
+            {
+                if (this.RequiredEncryptionParts == null || !this.RequiredEncryptionParts.IsBodyIncluded)
+                {
+                    // Let's downgrade for now. If after signature verification we find a header that 
+                    // is signed and encrypted, we will check for signature encryption too.
+                    actualProtectionOrder = MessageProtectionOrder.SignBeforeEncrypt;
+                    wasProtectionOrderDowngraded = true;
+                }
+            }
+
+            this.channelBinding = channelBinding;
+            this.extendedProtectionPolicy = extendedProtectionPolicy;
+            this.orderTracker.SetRequiredProtectionOrder(actualProtectionOrder);
+
+            SetProcessingStarted();
+            this.timeoutHelper = new TimeoutHelper(timeout);
+            this.Message = this.securityVerifiedMessage = new SecurityVerifiedMessage(this.Message, this);
+            XmlDictionaryReader reader = CreateSecurityHeaderReader();
+            reader.MoveToStartElement();
+            if (reader.IsEmptyElement)
+            {
+                throw TraceUtility.ThrowHelperError(new MessageSecurityException(SR.Format(SR.SecurityHeaderIsEmpty)), this.Message);
+            }
+            if (this.RequireMessageProtection)
+            {
+                this.securityElementAttributes = XmlAttributeHolder.ReadAttributes(reader);
+            }
+            else
+            {
+                this.securityElementAttributes = XmlAttributeHolder.emptyArray;
+            }
+            reader.ReadStartElement();
+
+            if (this.primaryTokenParameters != null)
+            {
+                this.primaryTokenTracker = new TokenTracker(null, this.outOfBandPrimaryToken, this.allowFirstTokenMismatch);
+            }
+            // universalTokenResolver is used for resolving tokens
+            universalTokenResolver = new SecurityHeaderTokenResolver(this);
+            // primary token resolver is used for resolving primary signature and decryption
+            primaryTokenResolver = new SecurityHeaderTokenResolver(this);
+            if (this.outOfBandPrimaryToken != null)
+            {
+                universalTokenResolver.Add(this.outOfBandPrimaryToken, SecurityTokenReferenceStyle.External, this.primaryTokenParameters);
+                primaryTokenResolver.Add(this.outOfBandPrimaryToken, SecurityTokenReferenceStyle.External, this.primaryTokenParameters);
+            }
+            else if (this.outOfBandPrimaryTokenCollection != null)
+            {
+                for (int i = 0; i < this.outOfBandPrimaryTokenCollection.Count; ++i)
+                {
+                    universalTokenResolver.Add(this.outOfBandPrimaryTokenCollection[i], SecurityTokenReferenceStyle.External, this.primaryTokenParameters);
+                    primaryTokenResolver.Add(this.outOfBandPrimaryTokenCollection[i], SecurityTokenReferenceStyle.External, this.primaryTokenParameters);
+                }
+            }
+            if (this.wrappingToken != null)
+            {
+                universalTokenResolver.ExpectedWrapper = this.wrappingToken;
+                universalTokenResolver.ExpectedWrapperTokenParameters = this.wrappingTokenParameters;
+                primaryTokenResolver.ExpectedWrapper = this.wrappingToken;
+                primaryTokenResolver.ExpectedWrapperTokenParameters = this.wrappingTokenParameters;
+            }
+            else if (expectedEncryptionToken != null)
+            {
+                universalTokenResolver.Add(expectedEncryptionToken, SecurityTokenReferenceStyle.External, expectedEncryptionTokenParameters);
+                primaryTokenResolver.Add(expectedEncryptionToken, SecurityTokenReferenceStyle.External, expectedEncryptionTokenParameters);
+            }
+
+            if (this.outOfBandTokenResolver == null)
+            {
+                this.combinedUniversalTokenResolver = this.universalTokenResolver;
+                this.combinedPrimaryTokenResolver = this.primaryTokenResolver;
+            }
+            else
+            {
+                this.combinedUniversalTokenResolver = new AggregateSecurityHeaderTokenResolver(this.universalTokenResolver, this.outOfBandTokenResolver);
+                this.combinedPrimaryTokenResolver = new AggregateSecurityHeaderTokenResolver(this.primaryTokenResolver, this.outOfBandTokenResolver);
+            }
+
+            allowedAuthenticators = new List<SecurityTokenAuthenticator>();
+            if (this.primaryTokenAuthenticator != null)
+            {
+                allowedAuthenticators.Add(this.primaryTokenAuthenticator);
+            }
+            if (this.DerivedTokenAuthenticator != null)
+            {
+                allowedAuthenticators.Add(this.DerivedTokenAuthenticator);
+            }
+            pendingSupportingTokenAuthenticator = null;
+            int numSupportingTokensRequiringDerivation = 0;
+            if (this.supportingTokenAuthenticators != null && this.supportingTokenAuthenticators.Count > 0)
+            {
+                this.supportingTokenTrackers = new List<TokenTracker>(this.supportingTokenAuthenticators.Count);
+                for (int i = 0; i < this.supportingTokenAuthenticators.Count; ++i)
+                {
+                    SupportingTokenAuthenticatorSpecification spec = this.supportingTokenAuthenticators[i];
+                    switch (spec.SecurityTokenAttachmentMode)
+                    {
+                        case SecurityTokenAttachmentMode.Endorsing:
+                            this.hasEndorsingOrSignedEndorsingSupportingTokens = true;
+                            break;
+                        case SecurityTokenAttachmentMode.Signed:
+                            this.hasAtLeastOneSupportingTokenExpectedToBeSigned = true;
+                            break;
+                        case SecurityTokenAttachmentMode.SignedEndorsing:
+                            this.hasEndorsingOrSignedEndorsingSupportingTokens = true;
+                            this.hasAtLeastOneSupportingTokenExpectedToBeSigned = true;
+                            break;
+                        case SecurityTokenAttachmentMode.SignedEncrypted:
+                            this.hasAtLeastOneSupportingTokenExpectedToBeSigned = true;
+                            break;
+                    }
+
+                    if ((this.primaryTokenAuthenticator != null) && (this.primaryTokenAuthenticator.GetType().Equals(spec.TokenAuthenticator.GetType())))
+                    {
+                        pendingSupportingTokenAuthenticator = spec.TokenAuthenticator;
+                    }
+                    else
+                    {
+                        allowedAuthenticators.Add(spec.TokenAuthenticator);
+                    }
+                    if (spec.TokenParameters.RequireDerivedKeys && !spec.TokenParameters.HasAsymmetricKey &&
+                        (spec.SecurityTokenAttachmentMode == SecurityTokenAttachmentMode.Endorsing || spec.SecurityTokenAttachmentMode == SecurityTokenAttachmentMode.SignedEndorsing))
+                    {
+                        ++numSupportingTokensRequiringDerivation;
+                    }
+                    this.supportingTokenTrackers.Add(new TokenTracker(spec));
+                }
+            }
+
+            if (this.DerivedTokenAuthenticator != null)
+            {
+                // we expect key derivation. Compute quotas for derived keys
+                int maxKeyDerivationLengthInBits = this.AlgorithmSuite.DefaultEncryptionKeyDerivationLength >= this.AlgorithmSuite.DefaultSignatureKeyDerivationLength ?
+                    this.AlgorithmSuite.DefaultEncryptionKeyDerivationLength : this.AlgorithmSuite.DefaultSignatureKeyDerivationLength;
+                this.maxDerivedKeyLength = maxKeyDerivationLengthInBits / 8;
+                // the upper bound of derived keys is (1 for primary signature + 1 for encryption + supporting token signatures requiring derivation)*2
+                // the multiplication by 2 is to take care of interop scenarios that may arise that require more derived keys than the lower bound.
+                this.maxDerivedKeys = (1 + 1 + numSupportingTokensRequiringDerivation) * 2;
+            }
+
+            SecurityHeaderElementInferenceEngine engine = SecurityHeaderElementInferenceEngine.GetInferenceEngine(this.Layout);
+            engine.ExecuteProcessingPasses(this, reader);
+            if (this.RequireMessageProtection)
+            {
+                this.ElementManager.EnsureAllRequiredSecurityHeaderTargetsWereProtected();
+                ExecuteMessageProtectionPass(this.hasAtLeastOneSupportingTokenExpectedToBeSigned);
+                if (this.RequiredSignatureParts != null && this.SignatureToken == null)
+                {
+                    throw TraceUtility.ThrowHelperError(new MessageSecurityException(SR.Format(SR.RequiredSignatureMissing)), this.Message);
+                }
+            }
+
+            EnsureDecryptionComplete();
+
+            this.signatureTracker.SetDerivationSourceIfRequired();
+            this.encryptionTracker.SetDerivationSourceIfRequired();
+            if (this.EncryptionToken != null)
+            {
+                if (wrappingToken != null)
+                {
+                    if (!(this.EncryptionToken is WrappedKeySecurityToken) || ((WrappedKeySecurityToken)this.EncryptionToken).WrappingToken != this.wrappingToken)
+                    {
+                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new MessageSecurityException(SR.Format(SR.EncryptedKeyWasNotEncryptedWithTheRequiredEncryptingToken, this.wrappingToken)));
+                    }
+                }
+                else if (expectedEncryptionToken != null)
+                {
+                    if (this.EncryptionToken != expectedEncryptionToken)
+                    {
+                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new MessageSecurityException(SR.Format(SR.MessageWasNotEncryptedWithTheRequiredEncryptingToken)));
+                    }
+                }
+                else if (this.SignatureToken != null && this.EncryptionToken != this.SignatureToken)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new MessageSecurityException(SR.Format(SR.SignatureAndEncryptionTokenMismatch, this.SignatureToken, this.EncryptionToken)));
+                }
+            }
+
+            // ensure that the primary signature was signed with derived keys if required
+            if (this.EnforceDerivedKeyRequirement)
+            {
+                if (this.SignatureToken != null)
+                {
+                    if (this.primaryTokenParameters != null)
+                    {
+                        if (this.primaryTokenParameters.RequireDerivedKeys && !this.primaryTokenParameters.HasAsymmetricKey && !this.primaryTokenTracker.IsDerivedFrom)
+                        {
+                            throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new MessageSecurityException(SR.Format(SR.PrimarySignatureWasNotSignedByDerivedKey, this.primaryTokenParameters)));
+                        }
+                    }
+                    else if (this.wrappingTokenParameters != null && this.wrappingTokenParameters.RequireDerivedKeys)
+                    {
+                        if (!this.signatureTracker.IsDerivedToken)
+                        {
+                            throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new MessageSecurityException(SR.Format(SR.PrimarySignatureWasNotSignedByDerivedWrappedKey, this.wrappingTokenParameters)));
+                        }
+                    }
+                }
+
+                // verify that the encryption is using key derivation
+                if (this.EncryptionToken != null)
+                {
+                    if (wrappingTokenParameters != null)
+                    {
+                        if (wrappingTokenParameters.RequireDerivedKeys && !this.encryptionTracker.IsDerivedToken)
+                        {
+                            throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new MessageSecurityException(SR.Format(SR.MessageWasNotEncryptedByDerivedWrappedKey, this.wrappingTokenParameters)));
+                        }
+                    }
+                    else if (expectedEncryptionTokenParameters != null)
+                    {
+                        if (expectedEncryptionTokenParameters.RequireDerivedKeys && !this.encryptionTracker.IsDerivedToken)
+                        {
+                            throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new MessageSecurityException(SR.Format(SR.MessageWasNotEncryptedByDerivedEncryptionToken, this.expectedEncryptionTokenParameters)));
+                        }
+                    }
+                    else if (primaryTokenParameters != null && !primaryTokenParameters.HasAsymmetricKey && primaryTokenParameters.RequireDerivedKeys && !this.encryptionTracker.IsDerivedToken)
+                    {
+                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new MessageSecurityException(SR.Format(SR.MessageWasNotEncryptedByDerivedEncryptionToken, this.primaryTokenParameters)));
+                    }
+                }
+            }
+
+            if (wasProtectionOrderDowngraded && (this.BasicSupportingTokens != null) && (this.BasicSupportingTokens.Count > 0))
+            {
+                // Basic tokens are always signed and encrypted. So check if Signatures 
+                // are encrypted as well.
+                this.VerifySignatureEncryption();
+            }
+
+            // verify all supporting token parameters have their requirements met
+            if (this.supportingTokenTrackers != null)
+            {
+                for (int i = 0; i < this.supportingTokenTrackers.Count; ++i)
+                {
+                    VerifySupportingToken(this.supportingTokenTrackers[i]);
+                }
+            }
+
+            if (this.replayDetectionEnabled)
+            {
+                if (this.timestamp == null)
+                {
+                    throw TraceUtility.ThrowHelperError(new MessageSecurityException(
+                        SR.Format(SR.NoTimestampAvailableInSecurityHeaderToDoReplayDetection)), this.Message);
+                }
+                if (this.primarySignatureValue == null)
+                {
+                    throw TraceUtility.ThrowHelperError(new MessageSecurityException(
+                        SR.Format(SR.NoSignatureAvailableInSecurityHeaderToDoReplayDetection)), this.Message);
+                }
+
+                AddNonce(this.nonceCache, this.primarySignatureValue);
+
+                // if replay detection is on, redo creation range checks to ensure full coverage
+                this.timestamp.ValidateFreshness(this.replayWindow, this.clockSkew);
+            }
+
+            if (this.ExpectSignatureConfirmation)
+            {
+                this.ElementManager.VerifySignatureConfirmationWasFound();
+            }
+
+            MarkHeaderAsUnderstood();
+        }
+
+        static void AddNonce(NonceCache cache, byte[] nonce)
+        {
+            if (!cache.TryAddNonce(nonce))
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new MessageSecurityException(SR.Format(SR.InvalidOrReplayedNonce), true));
+            }
+        }
+
+        static void CheckNonce(NonceCache cache, byte[] nonce)
+        {
+            if (cache.CheckNonce(nonce))
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new MessageSecurityException(SR.Format(SR.InvalidOrReplayedNonce), true));
+            }
+        }
+
+        protected abstract void EnsureDecryptionComplete();
+
+        protected abstract void ExecuteMessageProtectionPass(bool hasAtLeastOneSupportingTokenExpectedToBeSigned);
+
+        internal void ExecuteSignatureEncryptionProcessingPass()
+        {
+            for (int position = 0; position < this.elementManager.Count; position++)
+            {
+                ReceiveSecurityHeaderEntry entry;
+                this.elementManager.GetElementEntry(position, out entry);
+                switch (entry.elementCategory)
+                {
+                    case ReceiveSecurityHeaderElementCategory.Signature:
+                        if (entry.bindingMode == ReceiveSecurityHeaderBindingModes.Primary)
+                        {
+                            ProcessPrimarySignature((SignedXml)entry.element, entry.encrypted);
+                        }
+                        else
+                        {
+                            ProcessSupportingSignature((SignedXml)entry.element, entry.encrypted);
+                        }
+                        break;
+                    case ReceiveSecurityHeaderElementCategory.ReferenceList:
+                        ProcessReferenceList((ReferenceList)entry.element);
+                        break;
+                    case ReceiveSecurityHeaderElementCategory.Token:
+                        WrappedKeySecurityToken wrappedKeyToken = entry.element as WrappedKeySecurityToken;
+                        if ((wrappedKeyToken != null) && (wrappedKeyToken.ReferenceList != null))
+                        {
+                            Fx.Assert(this.Layout != SecurityHeaderLayout.Strict, "Invalid Calling sequence. This method assumes it will be called only during Lax mode.");
+                            // ExecuteSignatureEncryptionProcessingPass is called only durng Lax mode. In this
+                            // case when we have a EncryptedKey with a ReferencList inside it, we would not 
+                            // have processed the ReferenceList during reading pass. Process this here.
+                            ProcessReferenceList(wrappedKeyToken.ReferenceList, wrappedKeyToken);
+                        }
+                        break;
+                    case ReceiveSecurityHeaderElementCategory.Timestamp:
+                    case ReceiveSecurityHeaderElementCategory.EncryptedKey:
+                    case ReceiveSecurityHeaderElementCategory.EncryptedData:
+                    case ReceiveSecurityHeaderElementCategory.SignatureConfirmation:
+                    case ReceiveSecurityHeaderElementCategory.SecurityTokenReference:
+                        // no op
+                        break;
+                    default:
+                        Fx.Assert("invalid element category");
+                        break;
+                }
+            }
+        }
+
+        internal void ExecuteSubheaderDecryptionPass()
+        {
+            for (int position = 0; position < this.elementManager.Count; position++)
+            {
+                if (this.elementManager.GetElementCategory(position) == ReceiveSecurityHeaderElementCategory.EncryptedData)
+                {
+                    EncryptedData encryptedData = this.elementManager.GetElement<EncryptedData>(position);
+                    bool dummy = false;
+                    ProcessEncryptedData(encryptedData, this.timeoutHelper.RemainingTime(), position, false, ref dummy);
+                }
+            }
+        }
+
+        internal void ExecuteReadingPass(XmlDictionaryReader reader)
+            {
+            int position = 0;
+            while (reader.IsStartElement())
+            {
+                if (IsReaderAtSignature(reader))
+                {
+                    ReadSignature(reader, AppendPosition, null);
+                }
+                else if (IsReaderAtReferenceList(reader))
+                {
+                    ReadReferenceList(reader);
+                }
+                else if (this.StandardsManager.WSUtilitySpecificationVersion.IsReaderAtTimestamp(reader))
+                {
+                    ReadTimestamp(reader);
+                }
+                else if (IsReaderAtEncryptedKey(reader))
+                {
+                    ReadEncryptedKey(reader, false);
+                }
+                else if (IsReaderAtEncryptedData(reader))
+                {
+                    ReadEncryptedData(reader);
+                }
+                else if (this.StandardsManager.SecurityVersion.IsReaderAtSignatureConfirmation(reader))
+                {
+                    ReadSignatureConfirmation(reader, AppendPosition, null);
+                }
+                else if (IsReaderAtSecurityTokenReference(reader))
+                {
+                    ReadSecurityTokenReference(reader);
+                }
+                else
+                {
+                    ReadToken(reader, AppendPosition, null, null, null, this.timeoutHelper.RemainingTime());
+                }
+                position++;
+            }
+
+            reader.ReadEndElement(); // wsse:Security
+            reader.Close();
+        }
+
+        internal void ExecuteFullPass(XmlDictionaryReader reader)
+        {
+            try
+            {
+                bool primarySignatureFound = !this.RequireMessageProtection;
+                int position = 0;
+                while (reader.IsStartElement())
+                {
+                    if (IsReaderAtSignature(reader))
+                    {
+                        SignedXml signedXml = ReadSignature(reader, AppendPosition, null);
+                        if (primarySignatureFound)
+                        {
+                            this.elementManager.SetBindingMode(position, ReceiveSecurityHeaderBindingModes.Endorsing);
+                            ProcessSupportingSignature(signedXml, false);
+                        }
+                        else
+                        {
+                            primarySignatureFound = true;
+                            this.elementManager.SetBindingMode(position, ReceiveSecurityHeaderBindingModes.Primary);
+                            ProcessPrimarySignature(signedXml, false);
+                        }
+                    }
+                    else if (IsReaderAtReferenceList(reader))
+                    {
+                        ReferenceList referenceList = ReadReferenceList(reader);
+                        ProcessReferenceList(referenceList);
+                    }
+                    else if (this.StandardsManager.WSUtilitySpecificationVersion.IsReaderAtTimestamp(reader))
+                    {
+                        ReadTimestamp(reader);
+                    }
+                    else if (IsReaderAtEncryptedKey(reader))
+                    {
+                        ReadEncryptedKey(reader, true);
+                    }
+                    else if (IsReaderAtEncryptedData(reader))
+                    {
+                        EncryptedData encryptedData = ReadEncryptedData(reader);
+                        ProcessEncryptedData(encryptedData, this.timeoutHelper.RemainingTime(), position, true, ref primarySignatureFound);
+                    }
+                    else if (this.StandardsManager.SecurityVersion.IsReaderAtSignatureConfirmation(reader))
+                    {
+                        ReadSignatureConfirmation(reader, AppendPosition, null);
+                    }
+                    else if (IsReaderAtSecurityTokenReference(reader))
+                    {
+                        ReadSecurityTokenReference(reader);
+                    }
+                    else
+                    {
+                        ReadToken(reader, AppendPosition, null, null, null, this.timeoutHelper.RemainingTime());
+                    }
+                    position++;
+                }
+            }
+            catch(Exception ex)
+            {
+                System.Console.WriteLine(ex.Message);
+            }
+            reader.ReadEndElement(); // wsse:Security
+            reader.Close();
+        }
+
+        internal void EnsureDerivedKeyLimitNotReached()
+        {
+            ++this.numDerivedKeys;
+            if (this.numDerivedKeys > this.maxDerivedKeys)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new MessageSecurityException(SR.Format(SR.DerivedKeyLimitExceeded, maxDerivedKeys)));
+            }
+        }
+
+        internal void ExecuteDerivedKeyTokenStubPass(bool isFinalPass)
+        {
+            for (int position = 0; position < this.elementManager.Count; position++)
+            {
+                if (this.elementManager.GetElementCategory(position) == ReceiveSecurityHeaderElementCategory.Token)
+                {
+                    DerivedKeySecurityTokenStub stub = this.elementManager.GetElement(position) as DerivedKeySecurityTokenStub;
+                    if (stub != null)
+                    {
+                        SecurityToken sourceToken = null;
+                        this.universalTokenResolver.TryResolveToken(stub.TokenToDeriveIdentifier, out sourceToken);
+                        if (sourceToken != null)
+                        {
+                            EnsureDerivedKeyLimitNotReached();
+                            DerivedKeySecurityToken derivedKeyToken = stub.CreateToken(sourceToken, this.maxDerivedKeyLength);
+                            this.elementManager.SetElement(position, derivedKeyToken);
+                            AddDerivedKeyTokenToResolvers(derivedKeyToken);
+                        }
+                        else if (isFinalPass)
+                        {
+                            throw TraceUtility.ThrowHelperError(new MessageSecurityException(
+                                SR.Format(SR.UnableToResolveKeyInfoClauseInDerivedKeyToken, stub.TokenToDeriveIdentifier)), this.Message);
+                        }
+                    }
+                }
+            }
+        }
+
+        SecurityToken GetRootToken(SecurityToken token)
+        {
+            if (token is DerivedKeySecurityToken)
+            {
+                return ((DerivedKeySecurityToken)token).TokenToDerive;
+            }
+            else
+            {
+                return token;
+            }
+        }
+
+        void RecordEncryptionTokenAndRemoveReferenceListEntry(string id, SecurityToken encryptionToken)
+        {
+            if (id == null)
+            {
+                throw TraceUtility.ThrowHelperError(new MessageSecurityException(SR.Format(SR.MissingIdInEncryptedElement)), this.Message);
+            }
+
+            OnDecryptionOfSecurityHeaderItemRequiringReferenceListEntry(id);
+            RecordEncryptionToken(encryptionToken);
+        }
+
+        EncryptedData ReadEncryptedData(XmlDictionaryReader reader)
+        {
+            EncryptedData encryptedData = ReadSecurityHeaderEncryptedItem(reader, this.MessageDirection == MessageDirection.Output);
+
+            this.elementManager.AppendEncryptedData(encryptedData);
+            return encryptedData;
+        }
+
+        internal XmlDictionaryReader CreateDecryptedReader(byte[] decryptedBuffer)
+        {
+            return ContextImportHelper.CreateSplicedReader(
+                decryptedBuffer,
+                this.SecurityVerifiedMessage.GetEnvelopeAttributes(),
+                this.SecurityVerifiedMessage.GetHeaderAttributes(),
+                this.securityElementAttributes,
+                this.ReaderQuotas
+                );
+        }
+
+        void ProcessEncryptedData(EncryptedData encryptedData, TimeSpan timeout, int position, bool eagerMode, ref bool primarySignatureFound)
+        {
+           // if (TD.EncryptedDataProcessingStartIsEnabled())
+           // {
+           //     TD.EncryptedDataProcessingStart(this.EventTraceActivity);
+           // }
+
+            string id = encryptedData.Id;
+
+            SecurityToken encryptionToken;
+            byte[] decryptedBuffer = DecryptSecurityHeaderElement(encryptedData, this.wrappedKeyToken, out encryptionToken);
+
+            XmlDictionaryReader decryptedReader = CreateDecryptedReader(decryptedBuffer);
+
+            if (IsReaderAtSignature(decryptedReader))
+            {
+                RecordEncryptionTokenAndRemoveReferenceListEntry(id, encryptionToken);
+                SignedXml signedXml = ReadSignature(decryptedReader, position, decryptedBuffer);
+                if (eagerMode)
+                {
+                    if (primarySignatureFound)
+                    {
+                        this.elementManager.SetBindingMode(position, ReceiveSecurityHeaderBindingModes.Endorsing);
+                        ProcessSupportingSignature(signedXml, true);
+                    }
+                    else
+                    {
+                        primarySignatureFound = true;
+                        this.elementManager.SetBindingMode(position, ReceiveSecurityHeaderBindingModes.Primary);
+                        ProcessPrimarySignature(signedXml, true);
+                    }
+                }
+            }
+            else if (this.StandardsManager.SecurityVersion.IsReaderAtSignatureConfirmation(decryptedReader))
+            {
+                RecordEncryptionTokenAndRemoveReferenceListEntry(id, encryptionToken);
+                ReadSignatureConfirmation(decryptedReader, position, decryptedBuffer);
+            }
+            else
+            {
+                if (IsReaderAtEncryptedData(decryptedReader))
+                {
+
+                    // The purpose of this code is to process a token that arrived at a client as encryptedData.
+
+                    // This is a common scenario for supporting tokens.
+
+                    // We pass readXmlReferenceKeyIdentifierClause as false here because we do not expect the client 
+                    // to receive an encrypted token for itself from the service. The encrypted token is encrypted for some other service. 
+                    // Hence we assume that the KeyInfoClause entry in it is not an XMLReference entry that the client is supposed to understand.
+
+                    // What if the service sends its authentication token as an EncryptedData to the client?
+
+                    EncryptedData ed = ReadSecurityHeaderEncryptedItem(decryptedReader, false);
+                    SecurityToken securityToken;
+                    byte[] db = DecryptSecurityHeaderElement(ed, this.wrappedKeyToken, out securityToken);
+                    XmlDictionaryReader dr = CreateDecryptedReader(db);
+
+
+                    // read the actual token and put it into the system
+                    ReadToken(dr, position, db, encryptionToken, id, timeout);
+
+                    ReceiveSecurityHeaderEntry rshe;
+                    this.ElementManager.GetElementEntry(position, out rshe);
+
+                    // In EncryptBeforeSignMode, we have encrypted the outer token, remember the right id.
+                    // The reason why I have both id's is in that case that one or the other is passed
+                    // we won't have a problem with which one.  SHP accounting should ensure each item has 
+                    // the correct hash.
+                    if (this.EncryptBeforeSignMode)
+                    {
+                        rshe.encryptedFormId = encryptedData.Id;
+                        rshe.encryptedFormWsuId = encryptedData.WsuId;
+                    }
+                    else
+                    {
+                        rshe.encryptedFormId = ed.Id;
+                        rshe.encryptedFormWsuId = ed.WsuId;
+                    }
+
+                    rshe.decryptedBuffer = decryptedBuffer;
+
+                    // setting this to true, will allow a different id match in ReceiveSecurityHeaderEntry.Match
+                    // to one of the ids set above as the token id will not match what the signature reference is looking for.
+
+                    rshe.doubleEncrypted = true;
+
+                    this.ElementManager.ReplaceHeaderEntry(position, rshe);
+                }
+                else
+                    ReadToken(decryptedReader, position, decryptedBuffer, encryptionToken, id, timeout);
+            }
+
+          //  if (TD.EncryptedDataProcessingSuccessIsEnabled())
+          //  {
+          //      TD.EncryptedDataProcessingSuccess(this.EventTraceActivity);
+          //  }
+        }
+
+        void ReadEncryptedKey(XmlDictionaryReader reader, bool processReferenceListIfPresent)
+        {
+            this.orderTracker.OnEncryptedKey();
+
+            WrappedKeySecurityToken wrappedKeyToken = DecryptWrappedKey(reader);
+            if (wrappedKeyToken.WrappingToken != this.wrappingToken)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new MessageSecurityException(SR.Format(SR.EncryptedKeyWasNotEncryptedWithTheRequiredEncryptingToken, this.wrappingToken)));
+            }
+            this.universalTokenResolver.Add(wrappedKeyToken);
+            this.primaryTokenResolver.Add(wrappedKeyToken);
+            if (wrappedKeyToken.ReferenceList != null)
+            {
+                if (!this.EncryptedKeyContainsReferenceList)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new MessageSecurityException(SR.Format(SR.EncryptedKeyWithReferenceListNotAllowed)));
+                }
+                if (!this.ExpectEncryption)
+                {
+                    throw TraceUtility.ThrowHelperError(new MessageSecurityException(SR.Format(SR.EncryptionNotExpected)), this.Message);
+                }
+                if (processReferenceListIfPresent)
+                {
+                    ProcessReferenceList(wrappedKeyToken.ReferenceList, wrappedKeyToken);
+                }
+                this.wrappedKeyToken = wrappedKeyToken;
+            }
+            this.elementManager.AppendToken(wrappedKeyToken, ReceiveSecurityHeaderBindingModes.Primary, null);
+        }
+
+        ReferenceList ReadReferenceList(XmlDictionaryReader reader)
+        {
+            if (!this.ExpectEncryption)
+            {
+                throw TraceUtility.ThrowHelperError(new MessageSecurityException(SR.Format(SR.EncryptionNotExpected)), this.Message);
+            }
+            ReferenceList referenceList = ReadReferenceListCore(reader);
+            this.elementManager.AppendReferenceList(referenceList);
+            return referenceList;
+        }
+
+        protected abstract ReferenceList ReadReferenceListCore(XmlDictionaryReader reader);
+
+        void ProcessReferenceList(ReferenceList referenceList)
+        {
+            ProcessReferenceList(referenceList, null);
+        }
+
+        void ProcessReferenceList(ReferenceList referenceList, WrappedKeySecurityToken wrappedKeyToken)
+        {
+            this.orderTracker.OnProcessReferenceList();
+            ProcessReferenceListCore(referenceList, wrappedKeyToken);
+        }
+
+        protected abstract void ProcessReferenceListCore(ReferenceList referenceList, WrappedKeySecurityToken wrappedKeyToken);
+
+        SignedXml ReadSignature(XmlDictionaryReader reader, int position, byte[] decryptedBuffer)
+        {
+            Fx.Assert((position == AppendPosition) == (decryptedBuffer == null), "inconsistent position, decryptedBuffer parameters");
+            if (!this.ExpectSignature)
+            {
+                throw TraceUtility.ThrowHelperError(new MessageSecurityException(SR.Format(SR.SignatureNotExpected)), this.Message);
+            }
+            SignedXml signedXml = ReadSignatureCore(reader);
+          //  signedXml.Signature.SignedInfo.ReaderProvider = this.ElementManager;
+            int readerIndex;
+            if (decryptedBuffer == null)
+            {
+                this.elementManager.AppendSignature(signedXml);
+                readerIndex = this.elementManager.Count - 1;
+            }
+            else
+            {
+                this.elementManager.SetSignatureAfterDecryption(position, signedXml, decryptedBuffer);
+                readerIndex = position;
+            }
+       //     signedXml.Signature.SignedInfo. .SignatureReaderProviderCallbackContext = (object)(readerIndex);
+            return signedXml;
+        }
+
+        protected abstract void ReadSecurityTokenReference(XmlDictionaryReader reader);
+
+        void ProcessPrimarySignature(SignedXml signedXml, bool isFromDecryptedSource)
+        {
+            this.orderTracker.OnProcessSignature(isFromDecryptedSource);
+
+            this.primarySignatureValue = signedXml.SignatureValue;
+            if (this.replayDetectionEnabled)
+            {
+                CheckNonce(this.nonceCache, this.primarySignatureValue);
+            }
+
+            SecurityToken signingToken = VerifySignature(signedXml, true, this.primaryTokenResolver, null, null);
+            // verify that the signing token is the same as the primary token
+            SecurityToken rootSigningToken = GetRootToken(signingToken);
+            bool isDerivedKeySignature = signingToken is DerivedKeySecurityToken;
+            if (this.primaryTokenTracker != null)
+            {
+                this.primaryTokenTracker.RecordToken(rootSigningToken);
+                this.primaryTokenTracker.IsDerivedFrom = isDerivedKeySignature;
+            }
+            this.AddIncomingSignatureValue(signedXml.SignatureValue , isFromDecryptedSource);
+        }
+
+        void ReadSignatureConfirmation(XmlDictionaryReader reader, int position, byte[] decryptedBuffer)
+        {
+            Fx.Assert((position == AppendPosition) == (decryptedBuffer == null), "inconsistent position, decryptedBuffer parameters");
+            if (!this.ExpectSignatureConfirmation)
+            {
+                throw TraceUtility.ThrowHelperError(new MessageSecurityException(SR.Format(SR.SignatureConfirmationsNotExpected)), this.Message);
+            }
+            if (this.orderTracker.PrimarySignatureDone)
+            {
+                throw TraceUtility.ThrowHelperError(new MessageSecurityException(SR.Format(SR.SignatureConfirmationsOccursAfterPrimarySignature)), this.Message);
+            }
+            ISignatureValueSecurityElement sigConfElement = this.StandardsManager.SecurityVersion.ReadSignatureConfirmation(reader);
+            if (decryptedBuffer == null)
+            {
+                this.AddIncomingSignatureConfirmation(sigConfElement.GetSignatureValue(), false);
+                this.elementManager.AppendSignatureConfirmation(sigConfElement);
+            }
+            else
+            {
+                this.AddIncomingSignatureConfirmation(sigConfElement.GetSignatureValue(), true);
+                this.elementManager.SetSignatureConfirmationAfterDecryption(position, sigConfElement, decryptedBuffer);
+            }
+        }
+
+        TokenTracker GetSupportingTokenTracker(SecurityToken token)
+        {
+            if (this.supportingTokenTrackers == null)
+                return null;
+            for (int i = 0; i < this.supportingTokenTrackers.Count; ++i)
+            {
+                if (supportingTokenTrackers[i].token == token)
+                    return supportingTokenTrackers[i];
+            }
+            return null;
+        }
+
+        protected TokenTracker GetSupportingTokenTracker(SecurityTokenAuthenticator tokenAuthenticator, out SupportingTokenAuthenticatorSpecification spec)
+        {
+            spec = null;
+            if (this.supportingTokenAuthenticators == null)
+                return null;
+            for (int i = 0; i < this.supportingTokenAuthenticators.Count; ++i)
+            {
+                if (supportingTokenAuthenticators[i].TokenAuthenticator == tokenAuthenticator)
+                {
+                    spec = supportingTokenAuthenticators[i];
+                    return supportingTokenTrackers[i];
+                }
+            }
+            return null;
+        }
+
+        protected TAuthenticator FindAllowedAuthenticator<TAuthenticator>(bool removeIfPresent)
+            where TAuthenticator : SecurityTokenAuthenticator
+        {
+            if (this.allowedAuthenticators == null)
+            {
+                return null;
+            }
+            for (int i = 0; i < this.allowedAuthenticators.Count; ++i)
+            {
+                if (allowedAuthenticators[i] is TAuthenticator)
+                {
+                    TAuthenticator result = (TAuthenticator)allowedAuthenticators[i];
+                    if (removeIfPresent)
+                    {
+                        this.allowedAuthenticators.RemoveAt(i);
+                    }
+                    return result;
+                }
+            }
+            return null;
+        }
+
+        void ProcessSupportingSignature(SignedXml signedXml, bool isFromDecryptedSource)
+        {
+            if (!this.ExpectEndorsingTokens)
+            {
+                throw TraceUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.SupportingTokenSignaturesNotExpected)), this.Message);
+            }
+            string id;
+            XmlDictionaryReader reader;
+            object signatureTarget;
+            if (!this.RequireMessageProtection)
+            {
+                if (this.timestamp == null)
+                {
+                    throw TraceUtility.ThrowHelperError(new MessageSecurityException(
+                        SR.Format(SR.SigningWithoutPrimarySignatureRequiresTimestamp)), this.Message);
+                }
+                reader = null;
+                id = this.timestamp.Id;
+                // We would have pre-computed the timestamp digest, if the transport reader
+                // was capable of canonicalization. If we were not able to compute the digest
+                // before hand then the signature verification step will get a new reader
+                // and will recompute the digest.
+                signatureTarget = null;
+            }
+            else
+            {
+                this.elementManager.GetPrimarySignature(out reader, out id);
+                if (reader == null)
+                {
+                    throw TraceUtility.ThrowHelperError(new MessageSecurityException(
+                        SR.Format(SR.NoPrimarySignatureAvailableForSupportingTokenSignatureVerification)), this.Message);
+                }
+                signatureTarget = reader;
+            }
+            SecurityToken signingToken = VerifySignature(signedXml, false, this.universalTokenResolver, signatureTarget, id);
+            if (reader != null)
+            {
+                reader.Close();
+            }
+            if (signingToken == null)
+            {
+                throw TraceUtility.ThrowHelperError(new MessageSecurityException(SR.Format(SR.SignatureVerificationFailed)), this.Message);
+            }
+            SecurityToken rootSigningToken = GetRootToken(signingToken);
+            TokenTracker tracker = GetSupportingTokenTracker(rootSigningToken);
+            if (tracker == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new MessageSecurityException(SR.Format(SR.UnknownSupportingToken, signingToken)));
+            }
+
+            if (tracker.AlreadyReadEndorsingSignature)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new MessageSecurityException(SR.Format(SR.MoreThanOneSupportingSignature, signingToken)));
+
+            tracker.IsEndorsing = true;
+            tracker.AlreadyReadEndorsingSignature = true;
+            tracker.IsDerivedFrom = (signingToken is DerivedKeySecurityToken);
+            AddIncomingSignatureValue(signedXml.SignatureValue, isFromDecryptedSource);
+        }
+
+        void ReadTimestamp(XmlDictionaryReader reader)
+        {
+            if (this.timestamp != null)
+            {
+                throw TraceUtility.ThrowHelperError(new MessageSecurityException(SR.Format(SR.DuplicateTimestampInSecurityHeader)), this.Message);
+            }
+            bool expectTimestampToBeSigned = this.RequireMessageProtection || this.hasEndorsingOrSignedEndorsingSupportingTokens;
+            string expectedDigestAlgorithm = expectTimestampToBeSigned ? this.AlgorithmSuite.DefaultDigestAlgorithm : null;
+            SignatureResourcePool resourcePool = expectTimestampToBeSigned ? this.ResourcePool : null;
+            this.timestamp = this.StandardsManager.WSUtilitySpecificationVersion.ReadTimestamp(reader, expectedDigestAlgorithm, resourcePool);
+            this.timestamp.ValidateRangeAndFreshness(this.replayWindow, this.clockSkew);
+            this.elementManager.AppendTimestamp(this.timestamp);
+        }
+
+        bool IsPrimaryToken(SecurityToken token)
+        {
+            bool result = (token == outOfBandPrimaryToken
+                || (primaryTokenTracker != null && token == primaryTokenTracker.token)
+                || (token == expectedEncryptionToken)
+                || ((token is WrappedKeySecurityToken) && ((WrappedKeySecurityToken)token).WrappingToken == this.wrappingToken));
+            if (!result && this.outOfBandPrimaryTokenCollection != null)
+            {
+                for (int i = 0; i < this.outOfBandPrimaryTokenCollection.Count; ++i)
+                {
+                    if (this.outOfBandPrimaryTokenCollection[i] == token)
+                    {
+                        result = true;
+                        break;
+                    }
+                }
+            }
+            return result;
+        }
+
+        void ReadToken(XmlDictionaryReader reader, int position, byte[] decryptedBuffer,
+            SecurityToken encryptionToken, string idInEncryptedForm, TimeSpan timeout)
+        {
+            Fx.Assert((position == AppendPosition) == (decryptedBuffer == null), "inconsistent position, decryptedBuffer parameters");
+            Fx.Assert((position == AppendPosition) == (encryptionToken == null), "inconsistent position, encryptionToken parameters");
+            string localName = reader.LocalName;
+            string namespaceUri = reader.NamespaceURI;
+            string valueType = reader.GetAttribute(XD.SecurityJan2004Dictionary.ValueType, null);
+
+            SecurityTokenAuthenticator usedTokenAuthenticator;
+            SecurityToken token = ReadToken(reader, this.CombinedUniversalTokenResolver, allowedAuthenticators, out usedTokenAuthenticator);
+            if (token == null)
+            {
+                throw TraceUtility.ThrowHelperError(new MessageSecurityException(SR.Format(SR.TokenManagerCouldNotReadToken, localName, namespaceUri, valueType)), this.Message);
+            }
+            DerivedKeySecurityToken derivedKeyToken = token as DerivedKeySecurityToken;
+            if (derivedKeyToken != null)
+            {
+                EnsureDerivedKeyLimitNotReached();
+                derivedKeyToken.InitializeDerivedKey(this.maxDerivedKeyLength);
+            }
+
+            if (
+                //(usedTokenAuthenticator is SspiNegotiationTokenAuthenticator) ||
+                (usedTokenAuthenticator == this.primaryTokenAuthenticator))
+            {
+                this.allowedAuthenticators.Remove(usedTokenAuthenticator);
+            }
+
+            ReceiveSecurityHeaderBindingModes mode;
+            TokenTracker supportingTokenTracker = null;
+            if (usedTokenAuthenticator == this.primaryTokenAuthenticator)
+            {
+                // this is the primary token. Add to resolver as such
+                this.universalTokenResolver.Add(token, SecurityTokenReferenceStyle.Internal, this.primaryTokenParameters);
+                this.primaryTokenResolver.Add(token, SecurityTokenReferenceStyle.Internal, this.primaryTokenParameters);
+                if (this.pendingSupportingTokenAuthenticator != null)
+                {
+                    this.allowedAuthenticators.Add(this.pendingSupportingTokenAuthenticator);
+                    this.pendingSupportingTokenAuthenticator = null;
+                }
+                this.primaryTokenTracker.RecordToken(token);
+                mode = ReceiveSecurityHeaderBindingModes.Primary;
+            }
+            else if (usedTokenAuthenticator == this.DerivedTokenAuthenticator)
+            {
+                if (token is DerivedKeySecurityTokenStub)
+                {
+                    if (this.Layout == SecurityHeaderLayout.Strict)
+                    {
+                        DerivedKeySecurityTokenStub tmpToken = (DerivedKeySecurityTokenStub)token;
+                        throw TraceUtility.ThrowHelperError(new MessageSecurityException(
+                            SR.Format(SR.UnableToResolveKeyInfoClauseInDerivedKeyToken, tmpToken.TokenToDeriveIdentifier)), this.Message);
+                    }
+                }
+                else
+                {
+                    AddDerivedKeyTokenToResolvers(token);
+                }
+                mode = ReceiveSecurityHeaderBindingModes.Unknown;
+            }
+            else
+            {
+                SupportingTokenAuthenticatorSpecification supportingTokenSpec;
+                supportingTokenTracker = GetSupportingTokenTracker(usedTokenAuthenticator, out supportingTokenSpec);
+                if (supportingTokenTracker == null)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new MessageSecurityException(SR.Format(SR.UnknownTokenAuthenticatorUsedInTokenProcessing, usedTokenAuthenticator)));
+                }
+                if (supportingTokenTracker.token != null)
+                {
+                    supportingTokenTracker = new TokenTracker(supportingTokenSpec);
+                    this.supportingTokenTrackers.Add(supportingTokenTracker);
+                }
+
+                supportingTokenTracker.RecordToken(token);
+                if (encryptionToken != null)
+                {
+                    supportingTokenTracker.IsEncrypted = true;
+                }
+
+                bool isBasic;
+                bool isSignedButNotBasic;
+                SecurityTokenAttachmentModeHelper.Categorize(supportingTokenSpec.SecurityTokenAttachmentMode,
+                   out isBasic, out isSignedButNotBasic, out mode);
+                if (isBasic)
+                {
+                    if (!this.ExpectBasicTokens)
+                    {
+                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new MessageSecurityException(SR.Format(SR.BasicTokenNotExpected)));
+                    }
+
+                    // only basic tokens have to be part of the reference list. Encrypted Saml tokens dont for example
+                    if (this.RequireMessageProtection && encryptionToken != null)
+                    {
+                        RecordEncryptionTokenAndRemoveReferenceListEntry(idInEncryptedForm, encryptionToken);
+                    }
+                }
+                if (isSignedButNotBasic && !this.ExpectSignedTokens)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new MessageSecurityException(SR.Format(SR.SignedSupportingTokenNotExpected)));
+                }
+                this.universalTokenResolver.Add(token, SecurityTokenReferenceStyle.Internal, supportingTokenSpec.TokenParameters);
+            }
+            if (position == AppendPosition)
+            {
+                this.elementManager.AppendToken(token, mode, supportingTokenTracker);
+            }
+            else
+            {
+                this.elementManager.SetTokenAfterDecryption(position, token, mode, decryptedBuffer, supportingTokenTracker);
+            }
+        }
+
+        SecurityToken ReadToken(XmlReader reader, SecurityTokenResolver tokenResolver, IList<SecurityTokenAuthenticator> allowedTokenAuthenticators, out SecurityTokenAuthenticator usedTokenAuthenticator)
+        {
+            SecurityToken token = this.StandardsManager.SecurityTokenSerializer.ReadToken(reader, tokenResolver);
+            if (token is DerivedKeySecurityTokenStub)
+            {
+                if (this.DerivedTokenAuthenticator == null)
+                {
+                    // No Authenticator registered for DerivedKeySecurityToken
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new MessageSecurityException(
+                        SR.Format(SR.UnableToFindTokenAuthenticator, typeof(DerivedKeySecurityToken))));
+                }
+
+                // This is just the stub. Nothing to Validate. Set the usedTokenAuthenticator to 
+                // DerivedKeySecurityTokenAuthenticator.
+                usedTokenAuthenticator = this.DerivedTokenAuthenticator;
+                return token;
+            }
+
+            for (int i = 0; i < allowedTokenAuthenticators.Count; ++i)
+            {
+                SecurityTokenAuthenticator tokenAuthenticator = allowedTokenAuthenticators[i];
+                if (tokenAuthenticator.CanValidateToken(token))
+                {
+                    ReadOnlyCollection<IAuthorizationPolicy> authorizationPolicies;
+                    //ServiceCredentialsSecurityTokenManager.KerberosSecurityTokenAuthenticatorWrapper kerbTokenAuthenticator =
+                    //        tokenAuthenticator as ServiceCredentialsSecurityTokenManager.KerberosSecurityTokenAuthenticatorWrapper;
+                    //if (kerbTokenAuthenticator != null)
+                    //{
+                    //    authorizationPolicies = kerbTokenAuthenticator.ValidateToken(token, this.channelBinding, this.extendedProtectionPolicy);
+                    //}
+                    //else
+                    //{
+                        authorizationPolicies = tokenAuthenticator.ValidateToken(token);
+                   // }
+                    SecurityTokenAuthorizationPoliciesMapping.Add(token, authorizationPolicies);
+                    usedTokenAuthenticator = tokenAuthenticator;
+                    return token;
+                }
+            }
+
+            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new MessageSecurityException(
+                SR.Format(SR.UnableToFindTokenAuthenticator, token.GetType())));
+        }
+
+
+        void AddDerivedKeyTokenToResolvers(SecurityToken token)
+        {
+            this.universalTokenResolver.Add(token);
+            // add it to the primary token resolver only if its root is primary
+            SecurityToken rootToken = GetRootToken(token);
+            if (IsPrimaryToken(rootToken))
+            {
+                primaryTokenResolver.Add(token);
+            }
+        }
+
+        void AddIncomingSignatureConfirmation(byte[] signatureValue, bool isFromDecryptedSource)
+        {
+            if (this.MaintainSignatureConfirmationState)
+            {
+                if (this.receivedSignatureConfirmations == null)
+                {
+                    this.receivedSignatureConfirmations = new SignatureConfirmations();
+                }
+                this.receivedSignatureConfirmations.AddConfirmation(signatureValue, isFromDecryptedSource);
+            }
+        }
+
+        void AddIncomingSignatureValue(byte[] signatureValue, bool isFromDecryptedSource)
+        {
+            // cache incoming signatures only on the server side
+            if (this.MaintainSignatureConfirmationState && !this.ExpectSignatureConfirmation)
+            {
+                if (this.receivedSignatureValues == null)
+                {
+                    this.receivedSignatureValues = new SignatureConfirmations();
+                }
+                this.receivedSignatureValues.AddConfirmation(signatureValue, isFromDecryptedSource);
+            }
+        }
+
+        protected void RecordEncryptionToken(SecurityToken token)
+        {
+            this.encryptionTracker.RecordToken(token);
+        }
+
+        protected void RecordSignatureToken(SecurityToken token)
+        {
+            this.signatureTracker.RecordToken(token);
+        }
+
+        public void SetRequiredProtectionOrder(MessageProtectionOrder protectionOrder)
+        {
+            ThrowIfProcessingStarted();
+            this.protectionOrder = protectionOrder;
+        }
+
+        protected abstract SignedXml ReadSignatureCore(XmlDictionaryReader signatureReader);
+
+        protected abstract SecurityToken VerifySignature(SignedXml signedXml, bool isPrimarySignature,
+            SecurityHeaderTokenResolver resolver, object signatureTarget, string id);
+
+        protected abstract bool TryDeleteReferenceListEntry(string id);
+
+        struct OrderTracker
+        {
+            static readonly ReceiverProcessingOrder[] stateTransitionTableOnDecrypt = new ReceiverProcessingOrder[]
+                {
+                    ReceiverProcessingOrder.Decrypt, ReceiverProcessingOrder.VerifyDecrypt, ReceiverProcessingOrder.Decrypt,
+                    ReceiverProcessingOrder.Mixed, ReceiverProcessingOrder.VerifyDecrypt, ReceiverProcessingOrder.Mixed
+                };
+            static readonly ReceiverProcessingOrder[] stateTransitionTableOnVerify = new ReceiverProcessingOrder[]
+                {
+                    ReceiverProcessingOrder.Verify, ReceiverProcessingOrder.Verify, ReceiverProcessingOrder.DecryptVerify,
+                    ReceiverProcessingOrder.DecryptVerify, ReceiverProcessingOrder.Mixed, ReceiverProcessingOrder.Mixed
+                };
+
+            const int MaxAllowedWrappedKeys = 1;
+
+            int referenceListCount;
+            ReceiverProcessingOrder state;
+            int signatureCount;
+            int unencryptedSignatureCount;
+            int numWrappedKeys;
+            MessageProtectionOrder protectionOrder;
+            bool enforce;
+
+            public bool AllSignaturesEncrypted
+            {
+                get { return this.unencryptedSignatureCount == 0; }
+            }
+
+            public bool EncryptBeforeSignMode
+            {
+                get { return this.enforce && this.protectionOrder == MessageProtectionOrder.EncryptBeforeSign; }
+            }
+
+            public bool EncryptBeforeSignOrderRequirementMet
+            {
+                get { return this.state != ReceiverProcessingOrder.DecryptVerify && this.state != ReceiverProcessingOrder.Mixed; }
+            }
+
+            public bool PrimarySignatureDone
+            {
+                get { return this.signatureCount > 0; }
+            }
+
+            public bool SignBeforeEncryptOrderRequirementMet
+            {
+                get { return this.state != ReceiverProcessingOrder.VerifyDecrypt && this.state != ReceiverProcessingOrder.Mixed; }
+            }
+
+            void EnforceProtectionOrder()
+            {
+                switch (this.protectionOrder)
+                {
+                    case MessageProtectionOrder.SignBeforeEncryptAndEncryptSignature:
+                        if (!this.AllSignaturesEncrypted)
+                        {
+                            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new MessageSecurityException(
+                                SR.Format(SR.PrimarySignatureIsRequiredToBeEncrypted)));
+                        }
+                        goto case MessageProtectionOrder.SignBeforeEncrypt;
+                    case MessageProtectionOrder.SignBeforeEncrypt:
+                        if (!this.SignBeforeEncryptOrderRequirementMet)
+                        {
+                            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new MessageSecurityException(
+                                SR.Format(SR.MessageProtectionOrderMismatch, this.protectionOrder)));
+                        }
+                        break;
+                    case MessageProtectionOrder.EncryptBeforeSign:
+                        if (!this.EncryptBeforeSignOrderRequirementMet)
+                        {
+                            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new MessageSecurityException(
+                                SR.Format(SR.MessageProtectionOrderMismatch, this.protectionOrder)));
+                        }
+                        break;
+                    default:
+                        Fx.Assert("");
+                        break;
+                }
+            }
+
+            public void OnProcessReferenceList()
+            {
+                Fx.Assert(this.enforce, "OrderTracker should have 'enforce' set to true.");
+                if (this.referenceListCount > 0)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new MessageSecurityException(
+                        SR.Format(SR.AtMostOneReferenceListIsSupportedWithDefaultPolicyCheck)));
+                }
+                this.referenceListCount++;
+                this.state = stateTransitionTableOnDecrypt[(int)this.state];
+                if (this.enforce)
+                {
+                    EnforceProtectionOrder();
+                }
+            }
+
+            public void OnProcessSignature(bool isEncrypted)
+            {
+                Fx.Assert(this.enforce, "OrderTracker should have 'enforce' set to true.");
+                if (this.signatureCount > 0)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new MessageSecurityException(SR.Format(SR.AtMostOneSignatureIsSupportedWithDefaultPolicyCheck)));
+                }
+                this.signatureCount++;
+                if (!isEncrypted)
+                {
+                    this.unencryptedSignatureCount++;
+                }
+                this.state = stateTransitionTableOnVerify[(int)this.state];
+                if (this.enforce)
+                {
+                    EnforceProtectionOrder();
+                }
+            }
+
+            public void OnEncryptedKey()
+            {
+                Fx.Assert(this.enforce, "OrderTracker should have 'enforce' set to true.");
+
+                if (this.numWrappedKeys == MaxAllowedWrappedKeys)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new MessageSecurityException(SR.Format(SR.WrappedKeyLimitExceeded, this.numWrappedKeys)));
+
+                this.numWrappedKeys++;
+            }
+
+            public void SetRequiredProtectionOrder(MessageProtectionOrder protectionOrder)
+            {
+                this.protectionOrder = protectionOrder;
+                this.enforce = true;
+            }
+
+            enum ReceiverProcessingOrder : int
+            {
+                None = 0,
+                Verify = 1,
+                Decrypt = 2,
+                DecryptVerify = 3,
+                VerifyDecrypt = 4,
+                Mixed = 5
+            }
+        }
+
+        struct OperationTracker
+        {
+            MessagePartSpecification parts;
+            SecurityToken token;
+            bool isDerivedToken;
+
+            public MessagePartSpecification Parts
+            {
+                get { return this.parts; }
+                set { this.parts = value; }
+            }
+
+            public SecurityToken Token
+            {
+                get { return this.token; }
+            }
+
+            public bool IsDerivedToken
+            {
+                get { return this.isDerivedToken; }
+            }
+
+            public void RecordToken(SecurityToken token)
+            {
+                if (this.token == null)
+                {
+                    this.token = token;
+                }
+                else if (!ReferenceEquals(this.token, token))
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new MessageSecurityException(SR.Format(SR.MismatchInSecurityOperationToken)));
+                }
+            }
+
+            public void SetDerivationSourceIfRequired()
+            {
+                DerivedKeySecurityToken derivedKeyToken = this.token as DerivedKeySecurityToken;
+                if (derivedKeyToken != null)
+                {
+                    this.token = derivedKeyToken.TokenToDerive;
+                    this.isDerivedToken = true;
+                }
+            }
+        }
+    }
+
+    class TokenTracker
+    {
+        public SecurityToken token;
+        public bool IsDerivedFrom;
+        public bool IsSigned;
+        public bool IsEncrypted;
+        public bool IsEndorsing;
+        public bool AlreadyReadEndorsingSignature;
+        bool allowFirstTokenMismatch;
+        public SupportingTokenAuthenticatorSpecification spec;
+
+        public TokenTracker(SupportingTokenAuthenticatorSpecification spec)
+            : this(spec, null, false)
+        {
+        }
+
+        public TokenTracker(SupportingTokenAuthenticatorSpecification spec, SecurityToken token, bool allowFirstTokenMismatch)
+        {
+            this.spec = spec;
+            this.token = token;
+            this.allowFirstTokenMismatch = allowFirstTokenMismatch;
+        }
+
+        public void RecordToken(SecurityToken token)
+        {
+            if (this.token == null)
+            {
+                this.token = token;
+            }
+            else if (this.allowFirstTokenMismatch)
+            {
+                if (!AreTokensEqual(this.token, token))
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new MessageSecurityException(SR.Format(SR.MismatchInSecurityOperationToken)));
+                }
+                this.token = token;
+                this.allowFirstTokenMismatch = false;
+            }
+            else if (!object.ReferenceEquals(this.token, token))
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new MessageSecurityException(SR.Format(SR.MismatchInSecurityOperationToken)));
+            }
+        }
+
+        static bool AreTokensEqual(SecurityToken outOfBandToken, SecurityToken replyToken)
+        {
+            // we support the serialized reply token legacy feature only for X509 certificates.
+            // in this case the thumbprint of the reply certificate must match the outofband certificate's thumbprint
+            if ((outOfBandToken is X509SecurityToken) && (replyToken is X509SecurityToken))
+            {
+                byte[] outOfBandCertificateThumbprint = ((X509SecurityToken)outOfBandToken).Certificate.GetCertHash();
+                byte[] replyCertificateThumbprint = ((X509SecurityToken)replyToken).Certificate.GetCertHash();
+                return (CryptoHelper.IsEqual(outOfBandCertificateThumbprint, replyCertificateThumbprint));
+            }
+            else
+            {
+                return false;
+            }
+        }
+    }
+
+    class AggregateSecurityHeaderTokenResolver : CoreWCF.IdentityModel.Tokens.AggregateTokenResolver
+    {
+        SecurityHeaderTokenResolver tokenResolver;
+
+        public AggregateSecurityHeaderTokenResolver(SecurityHeaderTokenResolver tokenResolver, ReadOnlyCollection<SecurityTokenResolver> outOfBandTokenResolvers) :
+            base(outOfBandTokenResolvers)
+        {
+            if (tokenResolver == null)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("tokenResolver");
+
+            this.tokenResolver = tokenResolver;            
+        }
+
+        protected override bool TryResolveSecurityKeyCore(SecurityKeyIdentifierClause keyIdentifierClause, out SecurityKey key)
+        {
+            bool resolved = false;
+            key = null;
+
+            resolved = this.tokenResolver.TryResolveSecurityKey(keyIdentifierClause, false, out key);
+
+            if (!resolved)
+            {
+                resolved = base.TryResolveSecurityKeyCore(keyIdentifierClause, out key);
+            }
+
+            if (!resolved)
+            {
+                resolved = SecurityUtils.TryCreateKeyFromIntrinsicKeyClause(keyIdentifierClause, this, out key);
+            }
+
+            return resolved;
+        }
+
+        protected override bool TryResolveTokenCore(SecurityKeyIdentifier keyIdentifier, out SecurityToken token)
+        {
+            bool resolved = false;
+            token = null;
+
+            resolved = this.tokenResolver.TryResolveToken(keyIdentifier, false, false, out token);
+
+            if (!resolved)
+            {
+                resolved = base.TryResolveTokenCore(keyIdentifier, out token);
+            }
+
+            if (!resolved)
+            {
+                for (int i = 0; i < keyIdentifier.Count; ++i)
+                {
+                    if (this.TryResolveTokenFromIntrinsicKeyClause(keyIdentifier[i], out token))
+                    {
+                        resolved = true;
+                        break;
+                    }
+                }
+            }
+
+            return resolved;
+        }
+
+        bool TryResolveTokenFromIntrinsicKeyClause(SecurityKeyIdentifierClause keyIdentifierClause, out SecurityToken token)
+        {
+            throw new NotImplementedException();
+            //token = null;
+            //if (keyIdentifierClause is RsaKeyIdentifierClause)
+            //{
+            //    token = new RsaSecurityToken(((RsaKeyIdentifierClause)keyIdentifierClause).Rsa);
+            //    return true;
+            //}
+            //else if (keyIdentifierClause is X509RawDataKeyIdentifierClause)
+            //{
+            //    token = new X509SecurityToken(new X509Certificate2(((X509RawDataKeyIdentifierClause)keyIdentifierClause).GetX509RawData()), false);
+            //    return true;
+            //}
+            //else if (keyIdentifierClause is EncryptedKeyIdentifierClause)
+            //{
+            //    EncryptedKeyIdentifierClause keyClause = (EncryptedKeyIdentifierClause)keyIdentifierClause;
+            //    SecurityKeyIdentifier wrappingTokenReference = keyClause.EncryptingKeyIdentifier;
+            //    SecurityToken unwrappingToken;
+            //    if (this.TryResolveToken(wrappingTokenReference, out unwrappingToken))
+            //    {
+            //        token = SecurityUtils.CreateTokenFromEncryptedKeyClause(keyClause, unwrappingToken);
+            //        return true;
+            //    }
+            //}
+            //return false;
+        }
+
+        protected override bool TryResolveTokenCore(SecurityKeyIdentifierClause keyIdentifierClause, out SecurityToken token)
+        {
+            bool resolved = false;
+            token = null;
+
+            resolved = this.tokenResolver.TryResolveToken(keyIdentifierClause, false, false, out token);
+
+            if (!resolved)
+            {
+                resolved = base.TryResolveTokenCore(keyIdentifierClause, out token);
+            }
+
+            if (!resolved)
+            {
+                resolved = TryResolveTokenFromIntrinsicKeyClause(keyIdentifierClause, out token);
+            }
+
+            return resolved;
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/ReceiveSecurityHeaderBindingModes.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/ReceiveSecurityHeaderBindingModes.cs
new file mode 100644
index 0000000..c2f24ac
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/ReceiveSecurityHeaderBindingModes.cs
@@ -0,0 +1,15 @@
+
+
+namespace CoreWCF.Security
+{
+    
+    enum ReceiveSecurityHeaderBindingModes
+    {
+        Unknown = 0x0,
+        Primary = 0x1,
+        Endorsing = 0x2,
+        Signed = 0x4,
+        SignedEndorsing = 0x8,
+        Basic = 0x10,
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/ReceiveSecurityHeaderElementCategory.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/ReceiveSecurityHeaderElementCategory.cs
new file mode 100644
index 0000000..3a47eb8
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/ReceiveSecurityHeaderElementCategory.cs
@@ -0,0 +1,15 @@
+
+namespace CoreWCF.Security
+{
+    enum ReceiveSecurityHeaderElementCategory
+    {
+        Signature,
+        EncryptedData,
+        EncryptedKey,
+        SignatureConfirmation,
+        ReferenceList,
+        SecurityTokenReference,
+        Timestamp,
+        Token
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/ReceiveSecurityHeaderElementManager.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/ReceiveSecurityHeaderElementManager.cs
new file mode 100644
index 0000000..6bcd63b
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/ReceiveSecurityHeaderElementManager.cs
@@ -0,0 +1,469 @@
+using CoreWCF.IdentityModel.Tokens;
+using System.Runtime;
+using CoreWCF.Runtime;
+using CoreWCF;
+using CoreWCF.Diagnostics;
+using System.Xml;
+//using ISignatureReaderProvider = CoreWCF.IdentityModel.ISignatureReaderProvider;
+using ISignatureValueSecurityElement = CoreWCF.IdentityModel.ISignatureValueSecurityElement;
+using System.Collections.Generic;
+using  System.Security.Cryptography.Xml;
+using System;
+using CoreWCF.IdentityModel;
+
+namespace CoreWCF.Security
+{
+    internal interface ISignatureReaderProvider
+    {
+        XmlDictionaryReader GetReader(object callbackContext);
+    }
+    sealed class ReceiveSecurityHeaderElementManager : ISignatureReaderProvider
+    {
+        const int InitialCapacity = 8;
+        readonly ReceiveSecurityHeader securityHeader;
+        ReceiveSecurityHeaderEntry[] elements;
+        int count;
+        readonly string[] headerIds;
+        string[] predecryptionHeaderIds;
+        string bodyId;
+        string bodyContentId;
+        bool isPrimaryTokenSigned = false;
+
+        public ReceiveSecurityHeaderElementManager(ReceiveSecurityHeader securityHeader)
+        {
+            this.securityHeader = securityHeader;
+            this.elements = new ReceiveSecurityHeaderEntry[InitialCapacity];
+            if (securityHeader.RequireMessageProtection)
+            {
+                this.headerIds = new string[securityHeader.ProcessedMessage.Headers.Count];
+            }
+        }
+
+        public int Count
+        {
+            get { return this.count; }
+        }
+
+        public bool IsPrimaryTokenSigned
+        {
+            get { return this.isPrimaryTokenSigned; }
+            set { this.isPrimaryTokenSigned = value; }
+        }
+
+        public void AppendElement(
+            ReceiveSecurityHeaderElementCategory elementCategory, object element,
+            ReceiveSecurityHeaderBindingModes bindingMode, string id, TokenTracker supportingTokenTracker)
+        {
+            if (id != null)
+            {
+                VerifyIdUniquenessInSecurityHeader(id);
+            }
+            EnsureCapacityToAdd();
+            this.elements[this.count++].SetElement(elementCategory, element, bindingMode, id, false, null, supportingTokenTracker);
+        }
+
+        public void AppendSignature(SignedXml signedXml)
+        {
+            AppendElement(ReceiveSecurityHeaderElementCategory.Signature, signedXml,
+                ReceiveSecurityHeaderBindingModes.Unknown, signedXml.Signature.Id, null);
+        }
+
+        public void AppendReferenceList(ReferenceList referenceList)
+        {
+            AppendElement(ReceiveSecurityHeaderElementCategory.ReferenceList, referenceList,
+                ReceiveSecurityHeaderBindingModes.Unknown, null, null);
+        }
+
+        public void AppendEncryptedData(EncryptedData encryptedData)
+        {
+            AppendElement(ReceiveSecurityHeaderElementCategory.EncryptedData, encryptedData,
+                ReceiveSecurityHeaderBindingModes.Unknown, encryptedData.Id, null);
+        }
+
+        public void AppendSignatureConfirmation(ISignatureValueSecurityElement signatureConfirmationElement)
+        {
+            AppendElement(ReceiveSecurityHeaderElementCategory.SignatureConfirmation, signatureConfirmationElement,
+                ReceiveSecurityHeaderBindingModes.Unknown, signatureConfirmationElement.Id, null);
+        }
+
+        public void AppendTimestamp(SecurityTimestamp timestamp)
+        {
+            AppendElement(ReceiveSecurityHeaderElementCategory.Timestamp, timestamp,
+                ReceiveSecurityHeaderBindingModes.Unknown, timestamp.Id, null);
+        }
+
+        public void AppendSecurityTokenReference(SecurityKeyIdentifierClause strClause, string strId)
+        {
+            if (!String.IsNullOrEmpty(strId))
+            {
+                VerifyIdUniquenessInSecurityHeader(strId);
+                AppendElement(ReceiveSecurityHeaderElementCategory.SecurityTokenReference, strClause, ReceiveSecurityHeaderBindingModes.Unknown, strId, null);
+            }
+        }
+
+        public void AppendToken(SecurityToken token, ReceiveSecurityHeaderBindingModes mode, TokenTracker supportingTokenTracker)
+        {
+            AppendElement(ReceiveSecurityHeaderElementCategory.Token, token,
+                mode, token.Id, supportingTokenTracker);
+        }
+
+        public void EnsureAllRequiredSecurityHeaderTargetsWereProtected()
+        {
+            Fx.Assert(this.securityHeader.RequireMessageProtection, "security header protection checks should only be done for message security");
+            ReceiveSecurityHeaderEntry entry;
+            for (int i = 0; i < this.count; i++)
+            {
+                GetElementEntry(i, out entry);
+                if (!entry.signed)
+                {
+                    switch (entry.elementCategory)
+                    {
+                        case ReceiveSecurityHeaderElementCategory.Timestamp:
+                        case ReceiveSecurityHeaderElementCategory.SignatureConfirmation:
+                            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(
+                                new MessageSecurityException(SR.Format(SR.RequiredSecurityHeaderElementNotSigned, entry.elementCategory, entry.id)));
+                        case ReceiveSecurityHeaderElementCategory.Token:
+                            switch (entry.bindingMode)
+                            {
+                                case ReceiveSecurityHeaderBindingModes.Signed:
+                                case ReceiveSecurityHeaderBindingModes.SignedEndorsing:
+                                case ReceiveSecurityHeaderBindingModes.Basic:
+                                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(
+                                        new MessageSecurityException(SR.Format(SR.RequiredSecurityTokenNotSigned, entry.element, entry.bindingMode)));
+                            }
+                            break;
+                    }
+                }
+                
+                if (!entry.encrypted)
+                {
+                    if (entry.elementCategory == ReceiveSecurityHeaderElementCategory.Token &&
+                        entry.bindingMode == ReceiveSecurityHeaderBindingModes.Basic)
+                    {
+                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(
+                            new MessageSecurityException(SR.Format(SR.RequiredSecurityTokenNotEncrypted, entry.element, entry.bindingMode)));
+                    }
+                }
+            }
+        }
+
+        void EnsureCapacityToAdd()
+        {
+            if (this.count == this.elements.Length)
+            {
+                ReceiveSecurityHeaderEntry[] newElements = new ReceiveSecurityHeaderEntry[this.elements.Length * 2];
+                Array.Copy(this.elements, 0, newElements, 0, this.count);
+                this.elements = newElements;
+            }
+        }
+
+        public object GetElement(int index)
+        {
+            Fx.Assert(0 <= index && index < this.count, "");
+            return this.elements[index].element;
+        }
+
+        public T GetElement<T>(int index) where T : class
+        {
+            Fx.Assert(0 <= index && index < this.count, "");
+            return (T) this.elements[index].element;
+        }
+
+        public void GetElementEntry(int index, out ReceiveSecurityHeaderEntry element)
+        {
+            Fx.Assert(0 <= index && index < this.count, "index out of range");
+            element = this.elements[index];
+        }
+
+        public ReceiveSecurityHeaderElementCategory GetElementCategory(int index)
+        {
+            Fx.Assert(0 <= index && index < this.count, "index out of range");
+            return this.elements[index].elementCategory;
+        }
+
+        public void GetPrimarySignature(out XmlDictionaryReader reader, out string id)
+        {
+            ReceiveSecurityHeaderEntry entry;
+            for (int i = 0; i < this.count; i++)
+            {
+                GetElementEntry(i, out entry);
+                if (entry.elementCategory == ReceiveSecurityHeaderElementCategory.Signature &&
+                    entry.bindingMode == ReceiveSecurityHeaderBindingModes.Primary)
+                {
+                    reader = GetReader(i, false);
+                    id = entry.id;
+                    return;
+                }
+            }
+            reader = null;
+            id = null;
+            return;
+        }
+
+        internal XmlDictionaryReader GetReader(int index, bool requiresEncryptedFormReader)
+        {
+            Fx.Assert(0 <= index && index < this.count, "index out of range");
+            if (!requiresEncryptedFormReader)
+            {
+                byte[] decryptedBuffer = this.elements[index].decryptedBuffer;
+                if (decryptedBuffer != null)
+                {
+                    return this.securityHeader.CreateDecryptedReader(decryptedBuffer);
+                }
+            }
+            XmlDictionaryReader securityHeaderReader = this.securityHeader.CreateSecurityHeaderReader();
+            securityHeaderReader.ReadStartElement();
+            for (int i = 0; securityHeaderReader.IsStartElement() && i < index; i++)
+            {
+                securityHeaderReader.Skip();
+            }
+            return securityHeaderReader;
+        }
+
+        public XmlDictionaryReader GetSignatureVerificationReader(string id, bool requiresEncryptedFormReaderIfDecrypted)
+        {
+            ReceiveSecurityHeaderEntry entry;
+            for (int i = 0; i < this.count; i++)
+            {
+                GetElementEntry(i, out entry);
+                bool encryptedForm = entry.encrypted && requiresEncryptedFormReaderIfDecrypted;
+                bool isSignedToken = (entry.bindingMode == ReceiveSecurityHeaderBindingModes.Signed) || (entry.bindingMode == ReceiveSecurityHeaderBindingModes.SignedEndorsing);
+                if (entry.MatchesId(id, encryptedForm))
+                {
+                    SetSigned(i);
+                    if (!this.IsPrimaryTokenSigned)
+                    {
+                        this.IsPrimaryTokenSigned = entry.bindingMode == ReceiveSecurityHeaderBindingModes.Primary && entry.elementCategory == ReceiveSecurityHeaderElementCategory.Token;
+                    }
+                    return GetReader(i, encryptedForm);
+                }                
+                else if (entry.MatchesId(id, isSignedToken))
+                {
+                    SetSigned(i);
+                    if (!this.IsPrimaryTokenSigned)
+                    {
+                        this.IsPrimaryTokenSigned = entry.bindingMode == ReceiveSecurityHeaderBindingModes.Primary && entry.elementCategory == ReceiveSecurityHeaderElementCategory.Token;
+                    }
+                    return GetReader(i, isSignedToken);
+                }
+            }
+            return null;
+        }
+
+        void OnDuplicateId(string id)
+        {
+            throw TraceUtility.ThrowHelperError(
+                new MessageSecurityException(SR.Format(SR.DuplicateIdInMessageToBeVerified, id)), this.securityHeader.SecurityVerifiedMessage);
+        }
+
+        public void SetBindingMode(int index, ReceiveSecurityHeaderBindingModes bindingMode)
+        {
+            Fx.Assert(0 <= index && index < this.count, "index out of range");
+            this.elements[index].bindingMode = bindingMode;
+        }
+
+        public void SetElement(int index, object element)
+        {
+            Fx.Assert(0 <= index && index < this.count, "");
+            this.elements[index].element = element;
+        }
+
+        public void ReplaceHeaderEntry(int index, ReceiveSecurityHeaderEntry element)
+        {
+            Fx.Assert(0 <= index && index < this.count, "");
+            this.elements[index] = element;
+        }
+
+        public void SetElementAfterDecryption(
+            int index,
+            ReceiveSecurityHeaderElementCategory elementCategory, object element,
+            ReceiveSecurityHeaderBindingModes bindingMode, string id, byte[] decryptedBuffer, TokenTracker supportingTokenTracker)
+        {
+            Fx.Assert(0 <= index && index < this.count, "index out of range");
+            Fx.Assert(this.elements[index].elementCategory == ReceiveSecurityHeaderElementCategory.EncryptedData, "Replaced item must be EncryptedData");
+            if (id != null)
+            {
+                VerifyIdUniquenessInSecurityHeader(id);
+            }
+            this.elements[index].PreserveIdBeforeDecryption();
+            this.elements[index].SetElement(elementCategory, element, bindingMode, id, true, decryptedBuffer, supportingTokenTracker);
+        }
+
+        public void SetSignatureAfterDecryption(int index, SignedXml signedXml, byte[] decryptedBuffer)
+        {
+            SetElementAfterDecryption(index, ReceiveSecurityHeaderElementCategory.Signature,
+                                      signedXml, ReceiveSecurityHeaderBindingModes.Unknown, signedXml.SignedInfo.Id, decryptedBuffer, null);
+        }
+
+        public void SetSignatureConfirmationAfterDecryption(int index, ISignatureValueSecurityElement signatureConfirmationElement, byte[] decryptedBuffer)
+        {
+            SetElementAfterDecryption(index, ReceiveSecurityHeaderElementCategory.SignatureConfirmation,
+                                      signatureConfirmationElement, ReceiveSecurityHeaderBindingModes.Unknown, signatureConfirmationElement.Id, decryptedBuffer, null);
+        }
+
+        internal void SetSigned(int index)
+        {
+            Fx.Assert(0 <= index && index < this.count, "");
+            this.elements[index].signed = true;
+            if (this.elements[index].supportingTokenTracker != null)
+            {
+                this.elements[index].supportingTokenTracker.IsSigned = true;
+            }
+        }
+
+        public void SetTimestampSigned(string id)
+        {
+            for (int i = 0; i < this.count; i++)
+            {
+                if (this.elements[i].elementCategory == ReceiveSecurityHeaderElementCategory.Timestamp &&
+                    this.elements[i].id == id)
+                {
+                    SetSigned(i);
+                }
+            }
+        }
+
+        public void SetTokenAfterDecryption(int index, SecurityToken token, ReceiveSecurityHeaderBindingModes mode, byte[] decryptedBuffer, TokenTracker supportingTokenTracker)
+        {
+            SetElementAfterDecryption(index, ReceiveSecurityHeaderElementCategory.Token, token, mode, token.Id, decryptedBuffer, supportingTokenTracker);
+        }
+
+        internal bool TryGetTokenElementIndexFromStrId(string strId, out int index)
+        {
+            index = -1;
+            SecurityKeyIdentifierClause strClause = null;
+            for (int position = 0; position < this.Count; position++)
+            {
+                if (this.GetElementCategory(position) == ReceiveSecurityHeaderElementCategory.SecurityTokenReference)
+                {
+                    strClause = this.GetElement(position) as SecurityKeyIdentifierClause;
+                    if (strClause.Id == strId)
+                        break;
+                }
+            }
+
+            if (strClause == null)
+                return false;
+
+            for (int position = 0; position < this.Count; position++)
+            {
+                if (this.GetElementCategory(position) == ReceiveSecurityHeaderElementCategory.Token)
+                {
+                    SecurityToken token = this.GetElement(position) as SecurityToken;
+                    if (token.MatchesKeyIdentifierClause(strClause))
+                    {
+                        index = position;
+                        return true;
+                    }
+                }
+            }
+
+            return false;
+        }
+
+        public void VerifyUniquenessAndSetBodyId(string id)
+        {
+            if (id != null)
+            {
+                VerifyIdUniquenessInSecurityHeader(id);
+                VerifyIdUniquenessInMessageHeadersAndBody(id, this.headerIds.Length);
+                this.bodyId = id;
+            }
+        }
+
+        public void VerifyUniquenessAndSetBodyContentId(string id)
+        {
+            if (id != null)
+            {
+                VerifyIdUniquenessInSecurityHeader(id);
+                VerifyIdUniquenessInMessageHeadersAndBody(id, this.headerIds.Length);
+                this.bodyContentId = id;
+            }
+        }
+
+        public void VerifyUniquenessAndSetDecryptedHeaderId(string id, int headerIndex)
+        {
+            if (id != null)
+            {
+                VerifyIdUniquenessInSecurityHeader(id);
+                VerifyIdUniquenessInMessageHeadersAndBody(id, headerIndex);
+                if (this.predecryptionHeaderIds == null)
+                {
+                    this.predecryptionHeaderIds = new string[headerIds.Length];
+                }
+                this.predecryptionHeaderIds[headerIndex] = this.headerIds[headerIndex];
+                this.headerIds[headerIndex] = id;
+            }
+        }
+
+        public void VerifyUniquenessAndSetHeaderId(string id, int headerIndex)
+        {
+            if (id != null)
+            {
+                VerifyIdUniquenessInSecurityHeader(id);
+                VerifyIdUniquenessInMessageHeadersAndBody(id, headerIndex);
+                this.headerIds[headerIndex] = id;
+            }
+        }
+
+        void VerifyIdUniquenessInHeaderIdTable(string id, int headerCount, string[] headerIdTable)
+        {
+            for (int i = 0; i < headerCount; i++)
+            {
+                if (headerIdTable[i] == id)
+                {
+                    OnDuplicateId(id);
+                }
+            }
+        }
+
+        void VerifyIdUniquenessInSecurityHeader(string id)
+        {
+            Fx.Assert(id != null, "Uniqueness should only be tested for non-empty ids");
+            for (int i = 0; i < this.count; i++)
+            {
+                if (this.elements[i].id == id || this.elements[i].encryptedFormId == id)
+                {
+                    OnDuplicateId(id);
+                }
+            }
+        }
+
+        void VerifyIdUniquenessInMessageHeadersAndBody(string id, int headerCount)
+        {
+            Fx.Assert(id != null, "Uniqueness should only be tested for non-empty ids");
+            VerifyIdUniquenessInHeaderIdTable(id, headerCount, this.headerIds);
+            if (this.predecryptionHeaderIds != null)
+            {
+                VerifyIdUniquenessInHeaderIdTable(id, headerCount, this.predecryptionHeaderIds);
+            }
+            if (this.bodyId == id || this.bodyContentId == id)
+            {
+                OnDuplicateId(id);
+            }
+        }
+
+        XmlDictionaryReader ISignatureReaderProvider.GetReader(object callbackContext)
+        {
+            int index = (int)callbackContext;
+            Fx.Assert(index < this.Count, "Invalid Context provided.");
+            return GetReader(index, false);
+        }
+
+        public void VerifySignatureConfirmationWasFound()
+        {
+            ReceiveSecurityHeaderEntry entry;
+            for (int i = 0; i < this.count; i++)
+            {
+                GetElementEntry(i, out entry);
+                if (entry.elementCategory == ReceiveSecurityHeaderElementCategory.SignatureConfirmation)
+                {
+                    return;
+                }
+            }
+
+            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new MessageSecurityException(SR.Format(SR.SignatureConfirmationWasExpected)));
+        }
+
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/ReceiveSecurityHeaderEntry.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/ReceiveSecurityHeaderEntry.cs
new file mode 100644
index 0000000..31d225a
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/ReceiveSecurityHeaderEntry.cs
@@ -0,0 +1,56 @@
+
+
+namespace CoreWCF.Security
+{
+    struct ReceiveSecurityHeaderEntry
+    {
+        internal ReceiveSecurityHeaderElementCategory elementCategory;
+        internal object element;
+        internal ReceiveSecurityHeaderBindingModes bindingMode;
+        internal string id;
+        internal string encryptedFormId;
+        internal string encryptedFormWsuId;
+        internal bool signed;
+        internal bool encrypted;
+        internal byte[] decryptedBuffer;
+        internal TokenTracker supportingTokenTracker;
+        internal bool doubleEncrypted;
+
+        public bool MatchesId(string id, bool requiresEncryptedFormId)
+        {
+            if (doubleEncrypted)
+            {
+                return (this.encryptedFormId == id || this.encryptedFormWsuId == id);
+            }
+            else
+            {
+                if (requiresEncryptedFormId)
+                {
+                    return this.encryptedFormId == id;
+                }
+                else
+                {
+                    return this.id == id;
+                }
+            }
+        }
+
+        public void PreserveIdBeforeDecryption()
+        {
+            this.encryptedFormId = this.id;
+        }
+
+        public void SetElement(
+            ReceiveSecurityHeaderElementCategory elementCategory, object element,
+            ReceiveSecurityHeaderBindingModes bindingMode, string id, bool encrypted, byte[] decryptedBuffer, TokenTracker supportingTokenTracker)
+        {
+            this.elementCategory = elementCategory;
+            this.element = element;
+            this.bindingMode = bindingMode;
+            this.encrypted = encrypted;
+            this.decryptedBuffer = decryptedBuffer;
+            this.supportingTokenTracker = supportingTokenTracker;
+            this.id = id;
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/RequestSecurityToken.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/RequestSecurityToken.cs
new file mode 100644
index 0000000..550898e
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/RequestSecurityToken.cs
@@ -0,0 +1,586 @@
+using System;
+using CoreWCF.Channels;
+using CoreWCF.Description;
+using CoreWCF;
+using CoreWCF.IdentityModel.Claims;
+using CoreWCF.IdentityModel.Policy;
+using CoreWCF.IdentityModel.Tokens;
+using CoreWCF.IdentityModel.Selectors;
+using CoreWCF.Security.Tokens;
+using System.Runtime.Serialization;
+using System.Xml.Serialization;
+using System.Xml.Schema;
+using System.Xml;
+using System.Collections;
+using System.Collections.Generic;
+using System.Collections.ObjectModel;
+using System.IO;
+using CoreWCF.Security;
+using System.Globalization;
+using CoreWCF.Dispatcher;
+using System.Security.Authentication.ExtendedProtection;
+using CoreWCF.IdentityModel;
+
+namespace CoreWCF.Security
+{
+
+    class RequestSecurityToken : BodyWriter
+    {
+        string context;
+        string tokenType;
+        string requestType;
+        SecurityToken entropyToken;
+        BinaryNegotiation negotiationData;
+        XmlElement rstXml;
+        IList<XmlElement> requestProperties;
+        byte[] cachedWriteBuffer;
+        int cachedWriteBufferLength;
+        int keySize;
+        Message message;
+        SecurityKeyIdentifierClause renewTarget;
+        SecurityKeyIdentifierClause closeTarget;
+        OnGetBinaryNegotiationCallback onGetBinaryNegotiation;
+        SecurityStandardsManager standardsManager;
+        bool isReceiver;
+        bool isReadOnly;
+        object appliesTo;
+        DataContractSerializer appliesToSerializer;
+        Type appliesToType;
+
+        object thisLock = new Object();
+
+        public RequestSecurityToken()
+            : this(SecurityStandardsManager.DefaultInstance)
+        {
+        }
+
+        public RequestSecurityToken(MessageSecurityVersion messageSecurityVersion, SecurityTokenSerializer securityTokenSerializer)
+            : this(SecurityUtils.CreateSecurityStandardsManager(messageSecurityVersion, securityTokenSerializer))
+        {
+        }
+
+
+        public RequestSecurityToken(MessageSecurityVersion messageSecurityVersion, 
+                                    SecurityTokenSerializer securityTokenSerializer,
+                                    XmlElement requestSecurityTokenXml,
+                                    string context,
+                                    string tokenType,
+                                    string requestType,
+                                    int keySize,
+                                    SecurityKeyIdentifierClause renewTarget,
+                                    SecurityKeyIdentifierClause closeTarget)
+            : this(SecurityUtils.CreateSecurityStandardsManager(messageSecurityVersion, securityTokenSerializer),
+                   requestSecurityTokenXml,
+                   context,
+                   tokenType,
+                   requestType,
+                   keySize,
+                   renewTarget,
+                   closeTarget)
+        {
+        }
+
+        public RequestSecurityToken(XmlElement requestSecurityTokenXml,
+                                    string context,
+                                    string tokenType,
+                                    string requestType,
+                                    int keySize,
+                                    SecurityKeyIdentifierClause renewTarget,
+                                    SecurityKeyIdentifierClause closeTarget)
+            : this(SecurityStandardsManager.DefaultInstance,
+                   requestSecurityTokenXml,
+                   context,
+                   tokenType,
+                   requestType,
+                   keySize,
+                   renewTarget,
+                   closeTarget)
+        {
+        }
+
+        internal RequestSecurityToken(SecurityStandardsManager standardsManager, 
+                                      XmlElement rstXml,
+                                      string context,
+                                      string tokenType,
+                                      string requestType,
+                                      int keySize,
+                                      SecurityKeyIdentifierClause renewTarget,
+                                      SecurityKeyIdentifierClause closeTarget)
+            : base(true)
+        {
+            if (standardsManager == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException("standardsManager"));
+            }
+            this.standardsManager = standardsManager;
+            if (rstXml == null)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("rstXml");
+            this.rstXml = rstXml;
+            this.context = context;
+            this.tokenType = tokenType;
+            this.keySize = keySize;
+            this.requestType = requestType;
+            this.renewTarget = renewTarget;
+            this.closeTarget = closeTarget;
+            this.isReceiver = true;
+            this.isReadOnly = true;
+        }
+
+        internal RequestSecurityToken(SecurityStandardsManager standardsManager) 
+            : this(standardsManager, true)
+        {
+            // no op
+        }
+
+        internal RequestSecurityToken(SecurityStandardsManager standardsManager, bool isBuffered) 
+            : base(isBuffered)
+        {
+            if (standardsManager == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException("standardsManager"));
+            }
+            this.standardsManager = standardsManager;
+            this.requestType = this.standardsManager.TrustDriver.RequestTypeIssue;
+            this.requestProperties = null;
+            this.isReceiver = false;
+            this.isReadOnly = false;
+        }
+
+        public ChannelBinding GetChannelBinding()
+        {
+            if (this.message == null)
+            {
+                return null;
+            }
+
+            ChannelBindingMessageProperty channelBindingMessageProperty = null;
+            ChannelBindingMessageProperty.TryGet( this.message, out channelBindingMessageProperty );
+            ChannelBinding channelBinding = null;
+
+            if ( channelBindingMessageProperty != null )
+            {
+                channelBinding = channelBindingMessageProperty.ChannelBinding;
+            }
+
+            return channelBinding;
+        }
+
+        /// <summary>
+        /// Will hold a reference to the outbound message from which we will fish the ChannelBinding out of.
+        /// </summary>
+        public Message Message
+        {
+            get { return message; }
+            set { message = value; }
+        }
+
+ 
+        public string Context
+        {
+            get
+            {
+                return this.context;
+            }
+            set 
+            {
+                if (this.IsReadOnly)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.ObjectIsReadOnly)));
+                this.context = value;
+            }
+        }
+
+        public string TokenType
+        {
+            get 
+            {
+                return this.tokenType;
+            }
+            set 
+            {
+                if (this.IsReadOnly)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.ObjectIsReadOnly)));
+                this.tokenType = value;
+            }   
+        }
+
+        public int KeySize
+        {
+            get
+            {
+                return this.keySize;
+            }
+            set
+            {
+                if (this.IsReadOnly)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.ObjectIsReadOnly)));
+                if (value < 0)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("value", SR.Format(SR.ValueMustBeNonNegative)));
+                this.keySize = value;
+            }
+        }
+
+        public bool IsReadOnly
+        {
+            get
+            {
+                return this.isReadOnly;
+            }
+        }
+
+        public delegate void OnGetBinaryNegotiationCallback( ChannelBinding channelBinding );
+        public OnGetBinaryNegotiationCallback OnGetBinaryNegotiation
+        {
+            get
+            {
+                return this.onGetBinaryNegotiation;
+            }
+            set
+            {
+                if (this.IsReadOnly)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.ObjectIsReadOnly)));
+                }
+                this.onGetBinaryNegotiation = value;
+            }
+        }
+
+        public IEnumerable<XmlElement> RequestProperties
+        {
+            get
+            {
+                if (this.isReceiver)
+                {
+                    // PreSharp Bug: Property get methods should not throw exceptions.
+                    #pragma warning suppress 56503
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.ItemNotAvailableInDeserializedRST, "RequestProperties")));
+                }
+                return this.requestProperties;
+            }
+            set
+            {
+                if (this.IsReadOnly)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.ObjectIsReadOnly)));
+                if (value != null)
+                {
+                    int index = 0;
+                    Collection<XmlElement> coll = new Collection<XmlElement>();
+                    foreach (XmlElement property in value)
+                    {
+                        if (property == null)
+                            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException(String.Format(CultureInfo.InvariantCulture, "value[{0}]", index)));
+                        coll.Add(property);
+                        ++index;
+                    }
+                    this.requestProperties = coll;
+                }
+                else
+                {
+                    this.requestProperties = null;
+                }
+            }
+        }
+
+        public string RequestType
+        {
+            get
+            {
+                return this.requestType;
+            }
+            set
+            {
+                if (this.IsReadOnly)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.ObjectIsReadOnly)));
+                if (value == null)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("value");
+                this.requestType = value;
+            }
+        }
+
+        public SecurityKeyIdentifierClause RenewTarget
+        {
+            get
+            {
+                return this.renewTarget;
+            }
+            set
+            {
+                if (this.IsReadOnly)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.ObjectIsReadOnly)));
+                this.renewTarget = value;
+            }
+        }
+
+        public SecurityKeyIdentifierClause CloseTarget
+        {
+            get
+            {
+                return this.closeTarget;
+            }
+            set
+            {
+                if (this.IsReadOnly)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.ObjectIsReadOnly)));
+                this.closeTarget = value;
+            }
+        }
+
+        public XmlElement RequestSecurityTokenXml
+        {
+            get
+            {
+                if (!this.isReceiver)
+                {
+                    // PreSharp Bug: Property get methods should not throw exceptions.
+                    #pragma warning suppress 56503
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.ItemAvailableInDeserializedRSTOnly, "RequestSecurityTokenXml")));
+                }
+                return this.rstXml;
+            }
+        }
+
+        internal SecurityStandardsManager StandardsManager
+        {
+            get
+            {
+                return this.standardsManager;
+            }
+            set
+            {
+                if (this.IsReadOnly)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.ObjectIsReadOnly)));
+                if (value == null)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException("value"));
+                }
+                this.standardsManager = value;
+            }
+        }
+
+        internal bool IsReceiver
+        {
+            get
+            {
+                return this.isReceiver;
+            }
+        }
+
+        internal object AppliesTo
+        {
+            get
+            {
+                if (this.isReceiver)
+                {
+                    // PreSharp Bug: Property get methods should not throw exceptions.
+                    #pragma warning suppress 56503
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.ItemNotAvailableInDeserializedRST, "AppliesTo")));
+                }
+                return this.appliesTo;
+            }
+        }
+
+        internal DataContractSerializer AppliesToSerializer
+        {
+            get
+            {
+                if (this.isReceiver)
+                {
+                    // PreSharp Bug: Property get methods should not throw exceptions.
+                    #pragma warning suppress 56503
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.ItemNotAvailableInDeserializedRST, "AppliesToSerializer")));
+                }
+                return this.appliesToSerializer;
+            }
+        }
+
+        internal Type AppliesToType
+        {
+            get
+            {
+                if (this.isReceiver)
+                {
+                    // PreSharp Bug: Property get methods should not throw exceptions.
+                    #pragma warning suppress 56503
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.ItemNotAvailableInDeserializedRST, "AppliesToType")));
+                }
+                return this.appliesToType;
+            }
+        }
+
+        protected Object ThisLock
+        {
+            get
+            {
+                return this.thisLock;
+            }
+        }
+
+        internal void SetBinaryNegotiation(BinaryNegotiation negotiation)
+        {
+            if (negotiation == null)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("negotiation");
+            if (this.IsReadOnly)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.ObjectIsReadOnly)));
+            this.negotiationData = negotiation;
+        }
+
+        internal BinaryNegotiation GetBinaryNegotiation()
+        {
+            if (this.isReceiver)
+            {
+                return this.standardsManager.TrustDriver.GetBinaryNegotiation(this);
+            }
+            else if (this.negotiationData == null && this.onGetBinaryNegotiation != null)
+            {
+                this.onGetBinaryNegotiation(this.GetChannelBinding());
+            }
+            return this.negotiationData;
+        }
+
+        public SecurityToken GetRequestorEntropy()
+        {
+            return this.GetRequestorEntropy(null);
+        }
+
+        internal SecurityToken GetRequestorEntropy(SecurityTokenResolver resolver) 
+        {
+            if (this.isReceiver)
+            {
+                return this.standardsManager.TrustDriver.GetEntropy(this, resolver);
+            }
+            else
+                return this.entropyToken;
+        }
+
+        //public void SetRequestorEntropy(byte[] entropy)
+        //{
+        //    if (this.IsReadOnly)
+        //        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.ObjectIsReadOnly)));
+        //    this.entropyToken = (entropy != null) ? new NonceToken(entropy) : null;
+        //}
+
+        internal void SetRequestorEntropy(WrappedKeySecurityToken entropyToken)
+        {
+            if (this.IsReadOnly)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.ObjectIsReadOnly)));
+            this.entropyToken = entropyToken;
+        }
+
+        public void SetAppliesTo<T>(T appliesTo, DataContractSerializer serializer)
+        {
+            if (this.IsReadOnly)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.ObjectIsReadOnly)));
+            if (appliesTo != null && serializer == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("serializer");
+            }
+            this.appliesTo = appliesTo;
+            this.appliesToSerializer = serializer;
+            this.appliesToType = typeof(T);
+        }
+
+        public void GetAppliesToQName(out string localName, out string namespaceUri)
+        {
+            if (!this.isReceiver)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.ItemAvailableInDeserializedRSTOnly, "MatchesAppliesTo")));
+            this.standardsManager.TrustDriver.GetAppliesToQName(this, out localName, out namespaceUri);
+        }
+
+        public T GetAppliesTo<T>()
+        {
+            return this.GetAppliesTo<T>(DataContractSerializerDefaults.CreateSerializer(typeof(T), DataContractSerializerDefaults.MaxItemsInObjectGraph));
+        }
+
+        public T GetAppliesTo<T>(XmlObjectSerializer serializer)
+        {
+            if (this.isReceiver)
+            {
+                if (serializer == null)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("serializer");
+                }
+                return this.standardsManager.TrustDriver.GetAppliesTo<T>(this, serializer);
+            }
+            else
+            {
+                return (T)this.appliesTo;
+            }
+        }
+
+        void OnWriteTo(XmlWriter writer)
+        {
+            if (this.isReceiver)
+            {
+                this.rstXml.WriteTo(writer);
+            }
+            else
+            {
+                this.standardsManager.TrustDriver.WriteRequestSecurityToken(this, writer);
+            }
+        }
+
+        public void WriteTo(XmlWriter writer)
+        {
+            if (writer == null)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("writer");
+            if (this.IsReadOnly)
+            {
+                // cache the serialized bytes to ensure repeatability
+                if (this.cachedWriteBuffer == null)
+                {
+                    MemoryStream stream = new MemoryStream();
+                    using (XmlDictionaryWriter binaryWriter = XmlDictionaryWriter.CreateBinaryWriter(stream, XD.Dictionary))
+                    {
+                        this.OnWriteTo(binaryWriter);
+                        binaryWriter.Flush();
+                        stream.Flush();
+                        stream.Seek(0, SeekOrigin.Begin);
+                        this.cachedWriteBuffer = stream.GetBuffer();
+                        this.cachedWriteBufferLength = (int)stream.Length;
+                    }
+                }
+                writer.WriteNode(XmlDictionaryReader.CreateBinaryReader(this.cachedWriteBuffer, 0, this.cachedWriteBufferLength, XD.Dictionary, XmlDictionaryReaderQuotas.Max), false);
+            }
+            else
+                this.OnWriteTo(writer);
+        }
+
+        public static RequestSecurityToken CreateFrom(XmlReader reader) 
+        {
+            return CreateFrom(SecurityStandardsManager.DefaultInstance, reader);
+        }
+
+        public static RequestSecurityToken CreateFrom(XmlReader reader, MessageSecurityVersion messageSecurityVersion, SecurityTokenSerializer securityTokenSerializer)
+        {
+            return CreateFrom(SecurityUtils.CreateSecurityStandardsManager(messageSecurityVersion, securityTokenSerializer), reader);
+        }
+
+        internal static RequestSecurityToken CreateFrom(SecurityStandardsManager standardsManager,  XmlReader reader)
+        {
+            return standardsManager.TrustDriver.CreateRequestSecurityToken(reader);
+        }
+
+        public void MakeReadOnly()
+        {
+            if (!this.isReadOnly)
+            {
+                this.isReadOnly = true;
+                if (this.requestProperties != null)
+                {
+                    this.requestProperties = new ReadOnlyCollection<XmlElement>(this.requestProperties);
+                }
+                this.OnMakeReadOnly();
+            }
+        }
+
+        internal protected virtual void OnWriteCustomAttributes(XmlWriter writer) { }
+
+        internal protected virtual void OnWriteCustomElements(XmlWriter writer) { }
+
+        internal protected virtual void OnMakeReadOnly() { }
+
+        protected override void OnWriteBodyContents(XmlDictionaryWriter writer)
+        {
+            WriteTo(writer);
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/RequestSecurityTokenResponse.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/RequestSecurityTokenResponse.cs
new file mode 100644
index 0000000..bba9e4c
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/RequestSecurityTokenResponse.cs
@@ -0,0 +1,709 @@
+using System;
+using CoreWCF.Channels;
+using CoreWCF;
+using System.Xml;
+using System.Security.Cryptography;
+using System.Runtime.Serialization;
+using System.Xml.Serialization;
+using System.Xml.Schema;
+using System.Security.Principal;
+using System.Collections.Generic;
+using System.Collections.ObjectModel;
+using CoreWCF.IdentityModel.Claims;
+using CoreWCF.IdentityModel.Policy;
+using CoreWCF.IdentityModel.Tokens;
+using CoreWCF.IdentityModel.Selectors;
+using CoreWCF.Security.Tokens;
+using System.IO;
+using CoreWCF.Security;
+
+using Psha1DerivedKeyGenerator = CoreWCF.IdentityModel.Psha1DerivedKeyGenerator;
+using CoreWCF.Dispatcher;
+using CoreWCF.IdentityModel;
+using CoreWCF.Runtime;
+
+namespace CoreWCF.Security
+{
+
+
+    class RequestSecurityTokenResponse : BodyWriter
+    {
+        static int minSaneKeySizeInBits = 8 * 8; // 8 Bytes.
+        static int maxSaneKeySizeInBits = (16 * 1024) * 8; // 16 K
+
+        SecurityStandardsManager standardsManager;
+        string context;
+        int keySize;
+        bool computeKey;
+        string tokenType;
+        SecurityKeyIdentifierClause requestedAttachedReference;
+        SecurityKeyIdentifierClause requestedUnattachedReference;
+        SecurityToken issuedToken;
+        SecurityToken proofToken;
+        SecurityToken entropyToken;
+        BinaryNegotiation negotiationData;
+        XmlElement rstrXml;
+        DateTime effectiveTime;
+        DateTime expirationTime;
+        bool isLifetimeSet;
+        byte[] authenticator;
+        bool isReceiver;
+        bool isReadOnly;
+        byte[] cachedWriteBuffer;
+        int cachedWriteBufferLength;
+        bool isRequestedTokenClosed;
+        object appliesTo;
+        XmlObjectSerializer appliesToSerializer;
+        Type appliesToType;
+        Object thisLock = new Object();
+        private IdentityModel.XmlBuffer issuedTokenBuffer;
+
+        public RequestSecurityTokenResponse()
+            : this(SecurityStandardsManager.DefaultInstance)
+        {
+        }
+
+        public RequestSecurityTokenResponse(MessageSecurityVersion messageSecurityVersion, SecurityTokenSerializer securityTokenSerializer)
+            : this(SecurityUtils.CreateSecurityStandardsManager(messageSecurityVersion, securityTokenSerializer))
+        {
+        }
+
+        public RequestSecurityTokenResponse(XmlElement requestSecurityTokenResponseXml,
+                                            string context,
+                                            string tokenType,
+                                            int keySize,
+                                            SecurityKeyIdentifierClause requestedAttachedReference,
+                                            SecurityKeyIdentifierClause requestedUnattachedReference,
+                                            bool computeKey,
+                                            DateTime validFrom,
+                                            DateTime validTo,
+                                            bool isRequestedTokenClosed)
+            : this(SecurityStandardsManager.DefaultInstance,
+                   requestSecurityTokenResponseXml,
+                   context,
+                   tokenType,
+                   keySize,
+                   requestedAttachedReference,
+                   requestedUnattachedReference,
+                   computeKey,
+                   validFrom,
+                   validTo,
+                   isRequestedTokenClosed)
+        {
+        }
+
+        public RequestSecurityTokenResponse(MessageSecurityVersion messageSecurityVersion, 
+                                            SecurityTokenSerializer securityTokenSerializer, 
+                                            XmlElement requestSecurityTokenResponseXml,
+                                            string context,
+                                            string tokenType,
+                                            int keySize,
+                                            SecurityKeyIdentifierClause requestedAttachedReference,
+                                            SecurityKeyIdentifierClause requestedUnattachedReference,
+                                            bool computeKey,
+                                            DateTime validFrom,
+                                            DateTime validTo,
+                                            bool isRequestedTokenClosed)
+            : this(SecurityUtils.CreateSecurityStandardsManager(messageSecurityVersion, securityTokenSerializer),
+                   requestSecurityTokenResponseXml,
+                   context,
+                   tokenType,
+                   keySize,
+                   requestedAttachedReference,
+                   requestedUnattachedReference,
+                   computeKey,
+                   validFrom,
+                   validTo,
+                   isRequestedTokenClosed)
+        {
+        }
+
+        internal RequestSecurityTokenResponse(SecurityStandardsManager standardsManager)
+            : base(true)
+        {
+            if (standardsManager == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException("standardsManager"));
+            }
+            this.standardsManager = standardsManager;
+            effectiveTime = SecurityUtils.MinUtcDateTime;
+            expirationTime = SecurityUtils.MaxUtcDateTime;
+            isRequestedTokenClosed = false;
+            this.isLifetimeSet = false;
+            this.isReceiver = false;
+            this.isReadOnly = false;
+        }
+        
+        internal RequestSecurityTokenResponse(SecurityStandardsManager standardsManager,
+                                              XmlElement rstrXml,
+                                              string context,
+                                              string tokenType,
+                                              int keySize,
+                                              SecurityKeyIdentifierClause requestedAttachedReference,
+                                              SecurityKeyIdentifierClause requestedUnattachedReference,
+                                              bool computeKey,
+                                              DateTime validFrom,
+                                              DateTime validTo,
+                                              bool isRequestedTokenClosed)
+            : base(true)
+        {
+            if (standardsManager == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException("standardsManager"));
+            }
+            this.standardsManager = standardsManager;
+            if (rstrXml == null)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("rstrXml");
+            this.rstrXml = rstrXml;
+            this.context = context;
+            this.tokenType = tokenType;
+            this.keySize = keySize;
+            this.requestedAttachedReference = requestedAttachedReference;
+            this.requestedUnattachedReference = requestedUnattachedReference;
+            this.computeKey = computeKey;
+            this.effectiveTime = validFrom.ToUniversalTime();
+            this.expirationTime = validTo.ToUniversalTime();
+            this.isLifetimeSet = true;
+            this.isRequestedTokenClosed = isRequestedTokenClosed;
+           // this.issuedTokenBuffer = issuedTokenBuffer;
+            this.isReceiver = true;
+            this.isReadOnly = true;
+        }
+
+        public RequestSecurityTokenResponse(SecurityStandardsManager standardsManager, 
+            XmlElement rstrXml, 
+            string context, 
+            string tokenType, int keySize, SecurityKeyIdentifierClause requestedAttachedReference, 
+            SecurityKeyIdentifierClause requestedUnattachedReference, bool computeKey, DateTime validFrom, DateTime validTo, 
+            bool isRequestedTokenClosed, IdentityModel.XmlBuffer issuedTokenBuffer) : 
+            this(standardsManager, rstrXml, context, tokenType, keySize, requestedAttachedReference, requestedUnattachedReference, computeKey, validFrom, validTo, isRequestedTokenClosed)
+        {
+            this.issuedTokenBuffer = issuedTokenBuffer;
+        }
+
+        public string Context
+        {
+            get
+            {
+                return this.context;
+            }
+            set
+            {
+                if (this.IsReadOnly)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.ObjectIsReadOnly)));
+                this.context = value;
+            }
+        }
+
+        public string TokenType
+        {
+            get
+            {
+                return this.tokenType;
+            }
+            set
+            {
+                if (this.IsReadOnly)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.ObjectIsReadOnly)));
+                this.tokenType = value;
+            }
+        }
+
+        public SecurityKeyIdentifierClause RequestedAttachedReference 
+        {
+            get 
+            { 
+                return this.requestedAttachedReference;
+            } 
+            set 
+            {
+                if (this.IsReadOnly)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.ObjectIsReadOnly)));
+                this.requestedAttachedReference = value;
+            } 
+        }
+
+        public SecurityKeyIdentifierClause RequestedUnattachedReference
+        {
+            get
+            {
+                return this.requestedUnattachedReference;
+            }
+            set
+            {
+                if (this.IsReadOnly)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.ObjectIsReadOnly)));
+                this.requestedUnattachedReference = value;
+            }
+        }
+
+        public DateTime ValidFrom
+        {
+            get
+            {
+                return this.effectiveTime;
+            }
+        }
+
+        public DateTime ValidTo
+        {
+            get 
+            {
+                return this.expirationTime;
+            }
+        }
+
+        public bool ComputeKey
+        {
+            get 
+            {
+                return this.computeKey;
+            }
+            set 
+            {
+                if (this.IsReadOnly)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.ObjectIsReadOnly)));
+                this.computeKey = value;
+            }
+        }
+
+        public int KeySize
+        {
+            get 
+            {
+                return this.keySize;
+            }
+            set
+            {
+                if (this.IsReadOnly)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.ObjectIsReadOnly)));
+                if (value < 0)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("value", SR.Format(SR.ValueMustBeNonNegative)));
+                this.keySize = value;
+            } 
+        }
+
+        public bool IsRequestedTokenClosed
+        {
+            get 
+            {
+                return this.isRequestedTokenClosed;
+            }
+            set
+            {
+                if (this.IsReadOnly)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.ObjectIsReadOnly)));
+                this.isRequestedTokenClosed = value;
+            }
+        }
+
+        public bool IsReadOnly
+        {
+            get
+            {   
+                return this.isReadOnly;
+            }
+        }
+
+        protected Object ThisLock
+        {
+            get
+            {
+                return this.thisLock;
+            }
+        }
+
+        internal bool IsReceiver
+        {
+            get
+            {
+                return this.isReceiver;
+            }
+        }
+
+        internal SecurityStandardsManager StandardsManager
+        {
+            get
+            {
+                return this.standardsManager;
+            }
+            set
+            {
+                if (this.IsReadOnly)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.ObjectIsReadOnly)));
+                this.standardsManager = (value != null ? value : SecurityStandardsManager.DefaultInstance);
+            }
+        }
+
+        public SecurityToken EntropyToken
+        {
+            get
+            {
+                if (this.isReceiver)
+                {
+                    // PreSharp Bug: Property get methods should not throw exceptions.
+                    #pragma warning suppress 56503
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.ItemNotAvailableInDeserializedRSTR, "EntropyToken")));
+                }
+                return this.entropyToken;
+            }
+        }
+
+        public SecurityToken RequestedSecurityToken
+        {
+            get 
+            {
+                if (this.isReceiver)
+                {
+                    // PreSharp Bug: Property get methods should not throw exceptions.
+                    #pragma warning suppress 56503
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.ItemNotAvailableInDeserializedRSTR, "IssuedToken")));
+                }
+                return this.issuedToken;
+            }
+            set
+            {
+                if (this.isReadOnly)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.ObjectIsReadOnly)));
+                this.issuedToken = value;
+            }
+        }
+
+        public SecurityToken RequestedProofToken
+        {
+            get
+            {
+                if (this.isReceiver)
+                {
+                    // PreSharp Bug: Property get methods should not throw exceptions.
+                    #pragma warning suppress 56503
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.ItemNotAvailableInDeserializedRSTR, "ProofToken")));
+                }
+                return this.proofToken;
+            }
+            set
+            {
+                if (this.isReadOnly)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.ObjectIsReadOnly)));
+                this.proofToken = value;
+            }
+        }
+
+        public XmlElement RequestSecurityTokenResponseXml
+        {
+            get
+            {
+                if (!this.isReceiver)
+                {
+                    // PreSharp Bug: Property get methods should not throw exceptions.
+                    #pragma warning suppress 56503
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.ItemAvailableInDeserializedRSTROnly, "RequestSecurityTokenXml")));
+                }
+                return this.rstrXml;
+            }
+        }
+
+        internal object AppliesTo
+        {
+            get
+            {
+                if (this.isReceiver)
+                {
+                    // PreSharp Bug: Property get methods should not throw exceptions.
+                    #pragma warning suppress 56503
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.ItemNotAvailableInDeserializedRST, "AppliesTo")));
+                }
+                return this.appliesTo;
+            }
+        }
+
+        internal XmlObjectSerializer AppliesToSerializer
+        {
+            get
+            {
+                if (this.isReceiver)
+                {
+                    // PreSharp Bug: Property get methods should not throw exceptions.
+                    #pragma warning suppress 56503
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.ItemNotAvailableInDeserializedRST, "AppliesToSerializer")));
+                }
+                return this.appliesToSerializer;
+            }
+        }
+
+        internal Type AppliesToType
+        {
+            get
+            {
+                if (this.isReceiver)
+                {
+                    // PreSharp Bug: Property get methods should not throw exceptions.
+                    #pragma warning suppress 56503
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.ItemNotAvailableInDeserializedRST, "AppliesToType")));
+                }
+                return this.appliesToType;
+            }
+        }
+
+        internal bool IsLifetimeSet
+        {
+            get
+            {
+                if (this.isReceiver)
+                {
+                    // PreSharp Bug: Property get methods should not throw exceptions.
+                    #pragma warning suppress 56503
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.ItemNotAvailableInDeserializedRSTR, "IsLifetimeSet")));
+                }
+                return this.isLifetimeSet;
+            }
+        }
+
+        internal CoreWCF.IdentityModel.XmlBuffer IssuedTokenBuffer
+        {
+            get
+            {
+                return this.issuedTokenBuffer;
+            }
+        }
+
+        public void SetIssuerEntropy(byte[] issuerEntropy)
+        {
+            if (this.IsReadOnly)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.ObjectIsReadOnly)));
+            this.entropyToken = (issuerEntropy != null) ? new NonceToken(issuerEntropy) : null;
+        }
+
+        internal void SetIssuerEntropy(WrappedKeySecurityToken issuerEntropy)
+        {
+            if (this.IsReadOnly)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.ObjectIsReadOnly)));
+            this.entropyToken = issuerEntropy;
+        }
+
+        public SecurityToken GetIssuerEntropy()
+        {
+            return this.GetIssuerEntropy(null);
+        }
+
+        internal SecurityToken GetIssuerEntropy(SecurityTokenResolver resolver)
+        {
+            if (this.isReceiver)
+            {
+                return this.standardsManager.TrustDriver.GetEntropy(this, resolver);
+            }
+            else
+                return this.entropyToken;
+        }
+
+        public void SetLifetime(DateTime validFrom, DateTime validTo)
+        {
+            if (this.IsReadOnly)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.ObjectIsReadOnly)));
+            if (validFrom.ToUniversalTime() > validTo.ToUniversalTime())
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgument(SR.Format(SR.EffectiveGreaterThanExpiration));
+            }
+            this.effectiveTime = validFrom.ToUniversalTime();
+            this.expirationTime = validTo.ToUniversalTime();
+            this.isLifetimeSet = true;
+        }
+
+        public void SetAppliesTo<T>(T appliesTo, XmlObjectSerializer serializer)
+        {
+            if (this.IsReadOnly)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.ObjectIsReadOnly)));
+            if (appliesTo != null && serializer == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("serializer");
+            }
+            this.appliesTo = appliesTo;
+            this.appliesToSerializer = serializer;
+            this.appliesToType = typeof(T);
+        }
+
+        public void GetAppliesToQName(out string localName, out string namespaceUri)
+        {
+            if (!this.isReceiver)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.ItemAvailableInDeserializedRSTOnly, "MatchesAppliesTo")));
+            this.standardsManager.TrustDriver.GetAppliesToQName(this, out localName, out namespaceUri);
+        }
+
+        public T GetAppliesTo<T>()
+        {
+            return this.GetAppliesTo<T>(DataContractSerializerDefaults.CreateSerializer(typeof(T), DataContractSerializerDefaults.MaxItemsInObjectGraph));
+        }
+
+        public T GetAppliesTo<T>(XmlObjectSerializer serializer)
+        {
+            if (this.isReceiver)
+            {
+                if (serializer == null)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("serializer");
+                }
+                return this.standardsManager.TrustDriver.GetAppliesTo<T>(this, serializer);
+            }
+            else
+            {
+                return (T)this.appliesTo;
+            }
+        }
+
+        internal void SetBinaryNegotiation(BinaryNegotiation negotiation)
+        {
+            if (negotiation == null)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("negotiation");
+            if (this.IsReadOnly)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.ObjectIsReadOnly)));
+            this.negotiationData = negotiation;
+        }
+
+        internal BinaryNegotiation GetBinaryNegotiation()
+        {
+            if (this.isReceiver)
+                return this.standardsManager.TrustDriver.GetBinaryNegotiation(this);
+            else
+                return this.negotiationData;
+        }
+
+        internal void SetAuthenticator(byte[] authenticator)
+        {
+            if (authenticator == null)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("authenticator");
+            if (this.IsReadOnly)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.ObjectIsReadOnly)));
+            this.authenticator = Fx.AllocateByteArray(authenticator.Length);
+            Buffer.BlockCopy(authenticator, 0, this.authenticator, 0, authenticator.Length);
+        }
+
+        internal byte[] GetAuthenticator()
+        {
+            if (this.isReceiver)
+                return this.standardsManager.TrustDriver.GetAuthenticator(this);
+            else
+            {
+                if (this.authenticator == null)
+                    return null;
+                else 
+                {
+                    byte[] result = Fx.AllocateByteArray(this.authenticator.Length);
+                    Buffer.BlockCopy(this.authenticator, 0, result, 0, this.authenticator.Length);
+                    return result;
+                }
+            }
+        }
+
+        void OnWriteTo(XmlWriter w)
+        {
+            if (this.isReceiver)
+            {
+                this.rstrXml.WriteTo(w);
+            }
+            else
+            {
+                this.standardsManager.TrustDriver.WriteRequestSecurityTokenResponse(this, w);
+            }
+        }
+
+        public void WriteTo(XmlWriter writer)
+        {
+            if (writer == null)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("writer");
+            if (this.IsReadOnly)
+            {
+                // cache the serialized bytes to ensure repeatability
+                if (this.cachedWriteBuffer == null)
+                {
+                    MemoryStream stream = new MemoryStream();
+                    using (XmlDictionaryWriter binaryWriter = XmlDictionaryWriter.CreateBinaryWriter(stream, XD.Dictionary))
+                    {
+                        this.OnWriteTo(binaryWriter);
+                        binaryWriter.Flush();
+                        stream.Flush();
+                        stream.Seek(0, SeekOrigin.Begin);
+                        this.cachedWriteBuffer = stream.GetBuffer();
+                        this.cachedWriteBufferLength = (int)stream.Length;
+                    }
+                }
+                writer.WriteNode(XmlDictionaryReader.CreateBinaryReader(this.cachedWriteBuffer, 0, this.cachedWriteBufferLength, XD.Dictionary, XmlDictionaryReaderQuotas.Max), false);
+            }
+            else
+                this.OnWriteTo(writer);
+        }
+
+        public static RequestSecurityTokenResponse CreateFrom(XmlReader reader)
+        {
+            return CreateFrom(SecurityStandardsManager.DefaultInstance, reader);
+        }
+
+        public static RequestSecurityTokenResponse CreateFrom(XmlReader reader, MessageSecurityVersion messageSecurityVersion, SecurityTokenSerializer securityTokenSerializer)
+        {
+            return CreateFrom(SecurityUtils.CreateSecurityStandardsManager(messageSecurityVersion, securityTokenSerializer), reader);
+        }
+
+        internal static RequestSecurityTokenResponse CreateFrom(SecurityStandardsManager standardsManager, XmlReader reader)
+        {
+            return standardsManager.TrustDriver.CreateRequestSecurityTokenResponse(reader);
+        }
+
+        protected override void OnWriteBodyContents(XmlDictionaryWriter writer)
+        {
+            WriteTo(writer);
+        }
+
+        public void MakeReadOnly()
+        {
+            if (!this.isReadOnly)
+            {
+                this.isReadOnly = true;
+                this.OnMakeReadOnly();
+            }
+        }
+
+        public GenericXmlSecurityToken GetIssuedToken(SecurityTokenResolver resolver, IList<SecurityTokenAuthenticator> allowedAuthenticators, SecurityKeyEntropyMode keyEntropyMode, byte[] requestorEntropy, string expectedTokenType,
+            ReadOnlyCollection<IAuthorizationPolicy> authorizationPolicies)
+        {
+            return this.GetIssuedToken(resolver, allowedAuthenticators, keyEntropyMode, requestorEntropy, expectedTokenType, authorizationPolicies, 0, false);
+        }
+
+        public virtual GenericXmlSecurityToken GetIssuedToken(SecurityTokenResolver resolver, IList<SecurityTokenAuthenticator> allowedAuthenticators, SecurityKeyEntropyMode keyEntropyMode, byte[] requestorEntropy, string expectedTokenType,
+            ReadOnlyCollection<IAuthorizationPolicy> authorizationPolicies, int defaultKeySize, bool isBearerKeyType)
+        {
+            if (!this.isReceiver)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.ItemAvailableInDeserializedRSTROnly, "GetIssuedToken")));
+
+            return this.standardsManager.TrustDriver.GetIssuedToken(this, resolver, allowedAuthenticators, keyEntropyMode, requestorEntropy, expectedTokenType, authorizationPolicies, defaultKeySize, isBearerKeyType);
+        }
+
+        public virtual GenericXmlSecurityToken GetIssuedToken(string expectedTokenType, ReadOnlyCollection<IAuthorizationPolicy> authorizationPolicies, RSA clientKey)
+        {
+            if (!this.isReceiver)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.ItemAvailableInDeserializedRSTROnly, "GetIssuedToken")));
+
+            return this.standardsManager.TrustDriver.GetIssuedToken(this, expectedTokenType, authorizationPolicies, clientKey);
+        }
+
+        protected internal virtual void OnWriteCustomAttributes(XmlWriter writer)
+        { }
+
+        protected internal virtual void OnWriteCustomElements(XmlWriter writer) 
+        { }
+
+        protected virtual void OnMakeReadOnly() { }
+
+        public static byte[] ComputeCombinedKey(byte[] requestorEntropy, byte[] issuerEntropy, int keySizeInBits)
+        {
+            if (requestorEntropy == null)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("requestorEntropy");
+            if (issuerEntropy == null)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("issuerEntropy");
+            // Do a sanity check here. We don't want to allow invalid keys or keys that are too
+            // large.
+            if ((keySizeInBits < minSaneKeySizeInBits) || (keySizeInBits > maxSaneKeySizeInBits))
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new SecurityNegotiationException(SR.Format(SR.InvalidKeySizeSpecifiedInNegotiation, keySizeInBits, minSaneKeySizeInBits, maxSaneKeySizeInBits)));
+            Psha1DerivedKeyGenerator generator = new Psha1DerivedKeyGenerator(requestorEntropy);
+            return generator.GenerateDerivedKey(new byte[] { }, issuerEntropy, keySizeInBits, 0);
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/RequestSecurityTokenResponseCollection.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/RequestSecurityTokenResponseCollection.cs
new file mode 100644
index 0000000..e3c3ce7
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/RequestSecurityTokenResponseCollection.cs
@@ -0,0 +1,60 @@
+using CoreWCF;
+using CoreWCF.Channels;
+using CoreWCF.IdentityModel.Claims;
+using CoreWCF.IdentityModel.Policy;
+using System.Xml;
+using System;
+using System.Collections.Generic;
+using CoreWCF.Security;
+using System.Globalization;
+
+namespace CoreWCF.Security
+{
+    sealed class RequestSecurityTokenResponseCollection : BodyWriter
+    {
+        IEnumerable<RequestSecurityTokenResponse> rstrCollection;
+        SecurityStandardsManager standardsManager;
+
+        public RequestSecurityTokenResponseCollection(IEnumerable<RequestSecurityTokenResponse> rstrCollection)
+            : this(rstrCollection, SecurityStandardsManager.DefaultInstance)
+        { }
+
+        public RequestSecurityTokenResponseCollection(IEnumerable<RequestSecurityTokenResponse> rstrCollection, SecurityStandardsManager standardsManager)
+            : base(true)
+        {
+            if (rstrCollection == null)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("rstrCollection");
+            int index = 0;
+            foreach (RequestSecurityTokenResponse rstr in rstrCollection)
+            {
+                if (rstr == null)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(String.Format(CultureInfo.InvariantCulture, "rstrCollection[{0}]", index));
+                ++index;
+            }
+            this.rstrCollection = rstrCollection;
+            if (standardsManager == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException("standardsManager"));
+            }
+            this.standardsManager = standardsManager;
+        }
+
+        public IEnumerable<RequestSecurityTokenResponse> RstrCollection
+        {
+            get
+            {
+                return this.rstrCollection;
+            }
+        }
+
+        public void WriteTo(XmlWriter writer)
+        {
+            this.standardsManager.TrustDriver.WriteRequestSecurityTokenResponseCollection(this, writer);
+        }
+
+        protected override void OnWriteBodyContents(XmlDictionaryWriter writer)
+        {
+            WriteTo(writer);
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/SamlSerializer.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/SamlSerializer.cs
new file mode 100644
index 0000000..c99819e
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/SamlSerializer.cs
@@ -0,0 +1,13 @@
+﻿using System;
+using System.Xml;
+
+namespace CoreWCF.Security
+{
+    public class SamlSerializer
+    {
+        internal void PopulateDictionary(IXmlDictionary xmlDictionary)
+        {
+            throw new NotImplementedException();
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/SecureConversationDriver.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/SecureConversationDriver.cs
new file mode 100644
index 0000000..13ad99e
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/SecureConversationDriver.cs
@@ -0,0 +1,67 @@
+
+
+
+using CoreWCF;
+using System.Xml;
+using System;
+
+namespace CoreWCF.Security
+{
+    internal abstract class SecureConversationDriver
+    {
+        public virtual XmlDictionaryString CloseAction
+        {
+            get
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.SecureConversationDriverVersionDoesNotSupportSession));
+            }
+        }
+
+        public virtual XmlDictionaryString CloseResponseAction
+        {
+            get
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.SecureConversationDriverVersionDoesNotSupportSession));
+            }
+        }
+
+        public virtual bool IsSessionSupported
+        {
+            get
+            {
+                return false;
+            }
+        }
+
+        public abstract XmlDictionaryString IssueAction { get; }
+
+        public abstract XmlDictionaryString IssueResponseAction { get; }
+
+        public virtual XmlDictionaryString RenewAction
+        {
+            get
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.SecureConversationDriverVersionDoesNotSupportSession));
+            }
+        }
+
+        public virtual XmlDictionaryString RenewResponseAction
+        {
+            get
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.SecureConversationDriverVersionDoesNotSupportSession));
+            }
+        }
+
+        public abstract XmlDictionaryString Namespace { get; }
+
+        public abstract XmlDictionaryString RenewNeededFaultCode { get; }
+
+        public abstract XmlDictionaryString BadContextTokenFaultCode { get; }
+
+        public abstract string TokenTypeUri { get; }
+
+        public abstract UniqueId GetSecurityContextTokenId(XmlDictionaryReader reader);
+        public abstract bool IsAtSecurityContextToken(XmlDictionaryReader reader);
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/SecureConversationServiceCredential.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/SecureConversationServiceCredential.cs
new file mode 100644
index 0000000..68c45f9
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/SecureConversationServiceCredential.cs
@@ -0,0 +1,66 @@
+namespace CoreWCF.Security
+{
+    using CoreWCF.IdentityModel.Policy;
+    using CoreWCF;
+    using CoreWCF.IdentityModel.Tokens;
+    using System.Runtime.Serialization;
+    using System.Collections.ObjectModel;
+    using System;
+
+    public sealed class SecureConversationServiceCredential
+    {
+        static readonly SecurityStateEncoder defaultSecurityStateEncoder = new DataProtectionSecurityStateEncoder();
+        SecurityStateEncoder securityStateEncoder;
+        Collection<Type> securityContextClaimTypes;
+        bool isReadOnly;
+
+        internal SecureConversationServiceCredential()
+        {
+            this.securityStateEncoder = defaultSecurityStateEncoder;
+            securityContextClaimTypes = new Collection<Type>();
+           // SamlAssertion.AddSamlClaimTypes(securityContextClaimTypes);
+        }
+
+        internal SecureConversationServiceCredential(SecureConversationServiceCredential other)
+        {
+            this.securityStateEncoder = other.securityStateEncoder;
+            this.securityContextClaimTypes = new Collection<Type>();
+            for (int i = 0; i < other.securityContextClaimTypes.Count; ++i)
+            {
+                this.securityContextClaimTypes.Add(other.securityContextClaimTypes[i]);
+            }
+            this.isReadOnly = other.isReadOnly;
+        }
+
+        public SecurityStateEncoder SecurityStateEncoder
+        {
+            get 
+            { 
+                return this.securityStateEncoder; 
+            }
+            set 
+            {
+                ThrowIfImmutable();
+                this.securityStateEncoder = value; 
+            }
+        }
+
+        public Collection<Type> SecurityContextClaimTypes
+        {
+            get { return this.securityContextClaimTypes; }
+        }
+
+        internal void MakeReadOnly()
+        {
+            this.isReadOnly = true;
+        }
+
+        void ThrowIfImmutable()
+        {
+            if (this.isReadOnly)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.ObjectIsReadOnly)));
+            }
+        }
+     }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/SecureConversationVersion.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/SecureConversationVersion.cs
new file mode 100644
index 0000000..6550c6f
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/SecureConversationVersion.cs
@@ -0,0 +1,87 @@
+using System;
+using System.Collections.Generic;
+using System.Text;
+using System.Xml;
+
+namespace CoreWCF.Security
+{
+    public abstract class SecureConversationVersion
+    {
+        readonly XmlDictionaryString scNamespace;
+        readonly XmlDictionaryString prefix;
+        
+        internal SecureConversationVersion(XmlDictionaryString ns, XmlDictionaryString prefix)
+        {
+            this.scNamespace = ns;
+            this.prefix = prefix;
+        }
+
+        public XmlDictionaryString Namespace
+        {
+            get
+            {
+                return this.scNamespace;
+            }
+        }
+
+        public XmlDictionaryString Prefix
+        {
+            get
+            {
+                return this.prefix;
+            }
+        }
+
+        public static SecureConversationVersion Default
+        {
+            get { return WSSecureConversationFeb2005; }
+        }
+
+        public static SecureConversationVersion WSSecureConversationFeb2005
+        {
+            get { return WSSecureConversationVersionFeb2005.Instance; }
+        }
+
+        public static SecureConversationVersion WSSecureConversation13
+        {
+            get { return WSSecureConversationVersion13.Instance; }
+        }
+
+        class WSSecureConversationVersionFeb2005 : SecureConversationVersion
+        {
+            static readonly WSSecureConversationVersionFeb2005 instance = new WSSecureConversationVersionFeb2005();
+
+            protected WSSecureConversationVersionFeb2005()
+                : base(XD.SecureConversationFeb2005Dictionary.Namespace, XD.SecureConversationFeb2005Dictionary.Prefix)
+            {
+            }
+
+            public static SecureConversationVersion Instance
+            {
+                get
+                {
+                    return instance;
+                }
+            }
+        }
+
+        class WSSecureConversationVersion13 : SecureConversationVersion
+        {
+            static readonly WSSecureConversationVersion13 instance = new WSSecureConversationVersion13();
+
+            protected WSSecureConversationVersion13()
+                : base(DXD.SecureConversationDec2005Dictionary.Namespace, DXD.SecureConversationDec2005Dictionary.Prefix)
+            {
+            }
+
+            public static SecureConversationVersion Instance
+            {
+                get
+                {
+                    return instance;
+                }
+            }
+        }
+
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityAlgorithmSuite.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityAlgorithmSuite.cs
index b8ade77..a9e35cf 100644
--- a/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityAlgorithmSuite.cs
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityAlgorithmSuite.cs
@@ -1,6 +1,7 @@
 ﻿using CoreWCF.IdentityModel.Tokens;
 using System;
 using System.Collections.Generic;
+using System.Collections.ObjectModel;
 using System.Text;
 using System.Xml;
 
@@ -229,109 +230,109 @@ namespace CoreWCF.Security
 
         }
 
-        //internal string GetEncryptionKeyDerivationAlgorithm(SecurityToken token, SecureConversationVersion version)
-        //{
-        //    if (token == null)
-        //        throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(token));
+        internal string GetEncryptionKeyDerivationAlgorithm(SecurityToken token, SecureConversationVersion version)
+        {
+            if (token == null)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(token));
 
-        //    string derivationAlgorithm = SecurityUtils.GetKeyDerivationAlgorithm(version);
-        //    if (SecurityUtils.IsSupportedAlgorithm(derivationAlgorithm, token))
-        //        return derivationAlgorithm;
-        //    else
-        //        return null;
-        //}
+            string derivationAlgorithm = SecurityUtils.GetKeyDerivationAlgorithm(version);
+            if (SecurityUtils.IsSupportedAlgorithm(derivationAlgorithm, token))
+                return derivationAlgorithm;
+            else
+                return null;
+        }
 
-        //internal int GetEncryptionKeyDerivationLength(SecurityToken token, SecureConversationVersion version)
-        //{
-        //    if (token == null)
-        //        throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(token));
+        internal int GetEncryptionKeyDerivationLength(SecurityToken token, SecureConversationVersion version)
+        {
+            if (token == null)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(token));
 
-        //    string derivationAlgorithm = SecurityUtils.GetKeyDerivationAlgorithm(version);
-        //    if (SecurityUtils.IsSupportedAlgorithm(derivationAlgorithm, token))
-        //    {
-        //        if (this.DefaultEncryptionKeyDerivationLength % 8 != 0)
-        //            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.Psha1KeyLengthInvalid, this.DefaultEncryptionKeyDerivationLength)));
+            string derivationAlgorithm = SecurityUtils.GetKeyDerivationAlgorithm(version);
+            if (SecurityUtils.IsSupportedAlgorithm(derivationAlgorithm, token))
+            {
+                if (this.DefaultEncryptionKeyDerivationLength % 8 != 0)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.Psha1KeyLengthInvalid, this.DefaultEncryptionKeyDerivationLength)));
 
-        //        return this.DefaultEncryptionKeyDerivationLength / 8;
-        //    }
-        //    else
-        //        return 0;
-        //}
+                return this.DefaultEncryptionKeyDerivationLength / 8;
+            }
+            else
+                return 0;
+        }
 
-        //internal void GetKeyWrapAlgorithm(SecurityToken token, out string keyWrapAlgorithm, out XmlDictionaryString keyWrapAlgorithmDictionaryString)
-        //{
-        //    if (token == null)
-        //        throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(token));
+        internal void GetKeyWrapAlgorithm(SecurityToken token, out string keyWrapAlgorithm, out XmlDictionaryString keyWrapAlgorithmDictionaryString)
+        {
+            if (token == null)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(token));
 
-        //    if (SecurityUtils.IsSupportedAlgorithm(this.DefaultSymmetricKeyWrapAlgorithm, token))
-        //    {
-        //        keyWrapAlgorithm = this.DefaultSymmetricKeyWrapAlgorithm;
-        //        keyWrapAlgorithmDictionaryString = this.DefaultSymmetricKeyWrapAlgorithmDictionaryString;
-        //    }
-        //    else
-        //    {
-        //        keyWrapAlgorithm = this.DefaultAsymmetricKeyWrapAlgorithm;
-        //        keyWrapAlgorithmDictionaryString = this.DefaultAsymmetricKeyWrapAlgorithmDictionaryString;
-        //    }
-        //}
+            if (SecurityUtils.IsSupportedAlgorithm(this.DefaultSymmetricKeyWrapAlgorithm, token))
+            {
+                keyWrapAlgorithm = this.DefaultSymmetricKeyWrapAlgorithm;
+                keyWrapAlgorithmDictionaryString = this.DefaultSymmetricKeyWrapAlgorithmDictionaryString;
+            }
+            else
+            {
+                keyWrapAlgorithm = this.DefaultAsymmetricKeyWrapAlgorithm;
+                keyWrapAlgorithmDictionaryString = this.DefaultAsymmetricKeyWrapAlgorithmDictionaryString;
+            }
+        }
 
-        //internal void GetSignatureAlgorithmAndKey(SecurityToken token, out string signatureAlgorithm, out SecurityKey key, out XmlDictionaryString signatureAlgorithmDictionaryString)
-        //{
-        //    ReadOnlyCollection<SecurityKey> keys = token.SecurityKeys;
-        //    if (keys == null || keys.Count == 0)
-        //    {
-        //        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.SigningTokenHasNoKeys, token)));
-        //    }
+        internal void GetSignatureAlgorithmAndKey(SecurityToken token, out string signatureAlgorithm, out SecurityKey key, out XmlDictionaryString signatureAlgorithmDictionaryString)
+        {
+            ReadOnlyCollection<SecurityKey> keys = token.SecurityKeys;
+            if (keys == null || keys.Count == 0)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.SigningTokenHasNoKeys, token)));
+            }
 
-        //    for (int i = 0; i < keys.Count; i++)
-        //    {
-        //        if (keys[i].IsSupportedAlgorithm(this.DefaultSymmetricSignatureAlgorithm))
-        //        {
-        //            signatureAlgorithm = this.DefaultSymmetricSignatureAlgorithm;
-        //            signatureAlgorithmDictionaryString = this.DefaultSymmetricSignatureAlgorithmDictionaryString;
-        //            key = keys[i];
-        //            return;
-        //        }
-        //        else if (keys[i].IsSupportedAlgorithm(this.DefaultAsymmetricSignatureAlgorithm))
-        //        {
-        //            signatureAlgorithm = this.DefaultAsymmetricSignatureAlgorithm;
-        //            signatureAlgorithmDictionaryString = this.DefaultAsymmetricSignatureAlgorithmDictionaryString;
-        //            key = keys[i];
-        //            return;
-        //        }
-        //    }
+            for (int i = 0; i < keys.Count; i++)
+            {
+                if (keys[i].IsSupportedAlgorithm(this.DefaultSymmetricSignatureAlgorithm))
+                {
+                    signatureAlgorithm = this.DefaultSymmetricSignatureAlgorithm;
+                    signatureAlgorithmDictionaryString = this.DefaultSymmetricSignatureAlgorithmDictionaryString;
+                    key = keys[i];
+                    return;
+                }
+                else if (keys[i].IsSupportedAlgorithm(this.DefaultAsymmetricSignatureAlgorithm))
+                {
+                    signatureAlgorithm = this.DefaultAsymmetricSignatureAlgorithm;
+                    signatureAlgorithmDictionaryString = this.DefaultAsymmetricSignatureAlgorithmDictionaryString;
+                    key = keys[i];
+                    return;
+                }
+            }
 
-        //    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.SigningTokenHasNoKeysSupportingTheAlgorithmSuite, token, this)));
-        //}
+            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.SigningTokenHasNoKeysSupportingTheAlgorithmSuite, token, this)));
+        }
 
-        //internal string GetSignatureKeyDerivationAlgorithm(SecurityToken token, SecureConversationVersion version)
-        //{
-        //    if (token == null)
-        //        throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(token));
+        internal string GetSignatureKeyDerivationAlgorithm(SecurityToken token, SecureConversationVersion version)
+        {
+            if (token == null)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(token));
 
-        //    string derivationAlgorithm = SecurityUtils.GetKeyDerivationAlgorithm(version);
-        //    if (SecurityUtils.IsSupportedAlgorithm(derivationAlgorithm, token))
-        //        return derivationAlgorithm;
-        //    else
-        //        return null;
-        //}
+            string derivationAlgorithm = SecurityUtils.GetKeyDerivationAlgorithm(version);
+            if (SecurityUtils.IsSupportedAlgorithm(derivationAlgorithm, token))
+                return derivationAlgorithm;
+            else
+                return null;
+        }
 
-        //internal int GetSignatureKeyDerivationLength(SecurityToken token, SecureConversationVersion version)
-        //{
-        //    if (token == null)
-        //        throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(token));
+        internal int GetSignatureKeyDerivationLength(SecurityToken token, SecureConversationVersion version)
+        {
+            if (token == null)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(token));
 
-        //    string derivationAlgorithm = SecurityUtils.GetKeyDerivationAlgorithm(version);
-        //    if (SecurityUtils.IsSupportedAlgorithm(derivationAlgorithm, token))
-        //    {
-        //        if (this.DefaultSignatureKeyDerivationLength % 8 != 0)
-        //            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.Psha1KeyLengthInvalid, this.DefaultSignatureKeyDerivationLength)));
+            string derivationAlgorithm = SecurityUtils.GetKeyDerivationAlgorithm(version);
+            if (SecurityUtils.IsSupportedAlgorithm(derivationAlgorithm, token))
+            {
+                if (this.DefaultSignatureKeyDerivationLength % 8 != 0)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.Psha1KeyLengthInvalid, this.DefaultSignatureKeyDerivationLength)));
 
-        //        return this.DefaultSignatureKeyDerivationLength / 8;
-        //    }
-        //    else
-        //        return 0;
-        //}
+                return this.DefaultSignatureKeyDerivationLength / 8;
+            }
+            else
+                return 0;
+        }
 
         //internal void EnsureAcceptableSymmetricSignatureAlgorithm(string algorithm)
         //{
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityAppliedMessage.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityAppliedMessage.cs
new file mode 100644
index 0000000..feea005
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityAppliedMessage.cs
@@ -0,0 +1,455 @@
+using System.IO;
+using System.Runtime;
+using CoreWCF.Runtime;
+using System.Security.Cryptography;
+using CoreWCF.Channels;
+using CoreWCF.Security.Tokens;
+using System.Xml;
+using System;
+using CoreWCF.IdentityModel.Tokens;
+using System.Collections.Generic;
+using IPrefixGenerator = CoreWCF.IdentityModel.IPrefixGenerator;
+using ISecurityElement = CoreWCF.IdentityModel.ISecurityElement;
+using XmlAttributeHolder = CoreWCF.IdentityModel.XmlAttributeHolder;
+
+namespace CoreWCF.Security
+{
+
+    sealed class SecurityAppliedMessage : DelegatingMessage
+    {
+        string bodyId;
+        bool bodyIdInserted;
+        string bodyPrefix = MessageStrings.Prefix;
+        XmlBuffer fullBodyBuffer;
+        ISecurityElement encryptedBodyContent;
+        XmlAttributeHolder[] bodyAttributes;
+        bool delayedApplicationHandled;
+        readonly MessagePartProtectionMode bodyProtectionMode;
+        BodyState state = BodyState.Created;
+        readonly SendSecurityHeader securityHeader;
+        MemoryStream startBodyFragment;
+        MemoryStream endBodyFragment;
+        byte[] fullBodyFragment;
+        int fullBodyFragmentLength;
+
+        public SecurityAppliedMessage(Message messageToProcess, SendSecurityHeader securityHeader, bool signBody, bool encryptBody)
+            : base(messageToProcess)
+        {
+            Fx.Assert(!(messageToProcess is SecurityAppliedMessage), "SecurityAppliedMessage should not be wrapped");
+            this.securityHeader = securityHeader;
+            this.bodyProtectionMode = MessagePartProtectionModeHelper.GetProtectionMode(signBody, encryptBody, securityHeader.SignThenEncrypt);
+        }
+
+        public string BodyId
+        {
+            get { return this.bodyId; }
+        }
+
+        public MessagePartProtectionMode BodyProtectionMode
+        {
+            get { return this.bodyProtectionMode; }
+        }
+
+        internal byte[] PrimarySignatureValue
+        {
+            get { return this.securityHeader.PrimarySignatureValue; }
+        }
+
+        Exception CreateBadStateException(string operation)
+        {
+            return new InvalidOperationException(SR.Format(SR.MessageBodyOperationNotValidInBodyState,
+                operation, this.state));
+        }
+
+        void EnsureUniqueSecurityApplication()
+        {
+            if (this.delayedApplicationHandled)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.DelayedSecurityApplicationAlreadyCompleted)));
+            }
+            this.delayedApplicationHandled = true;
+        }
+
+        protected override void OnBodyToString(XmlDictionaryWriter writer)
+        {
+            if (this.state == BodyState.Created || this.fullBodyFragment != null)
+            {
+                base.OnBodyToString(writer);
+            }
+            else
+            {
+                OnWriteBodyContents(writer);
+            }
+        }
+
+        protected override void OnClose()
+        {
+            try
+            {
+                this.InnerMessage.Close();
+            }
+            finally
+            {
+                this.fullBodyBuffer = null;
+                this.bodyAttributes = null;
+                this.encryptedBodyContent = null;
+                this.state = BodyState.Disposed;
+            }
+        }
+
+        protected override void OnWriteStartBody(XmlDictionaryWriter writer)
+        {
+            if (this.startBodyFragment != null || this.fullBodyFragment != null)
+            {
+                WriteStartInnerMessageWithId(writer);
+                return;
+            }
+
+            switch (this.state)
+            {
+                case BodyState.Created:
+                case BodyState.Encrypted:
+                    this.InnerMessage.WriteStartBody(writer);
+                    return;
+                case BodyState.Signed:
+                case BodyState.EncryptedThenSigned:
+                    XmlDictionaryReader reader = fullBodyBuffer.GetReader(0);
+                    writer.WriteStartElement(reader.Prefix, reader.LocalName, reader.NamespaceURI);
+                    writer.WriteAttributes(reader, false);
+                    reader.Close();
+                    return;
+                case BodyState.SignedThenEncrypted:
+                    writer.WriteStartElement(this.bodyPrefix, XD.MessageDictionary.Body, this.Version.Envelope.DictionaryNamespace);
+                    if (this.bodyAttributes != null)
+                    {
+                        XmlAttributeHolder.WriteAttributes(this.bodyAttributes, writer);
+                    }
+                    return;
+                default:
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(CreateBadStateException("OnWriteStartBody"));
+            }
+        }
+
+        protected override void OnWriteBodyContents(XmlDictionaryWriter writer)
+        {
+            switch (this.state)
+            {
+                case BodyState.Created:
+                    this.InnerMessage.WriteBodyContents(writer);
+                    return;
+                case BodyState.Signed:
+                case BodyState.EncryptedThenSigned:
+                    XmlDictionaryReader reader = fullBodyBuffer.GetReader(0);
+                    reader.ReadStartElement();
+                    while (reader.NodeType != XmlNodeType.EndElement)
+                        writer.WriteNode(reader, false);
+                    reader.ReadEndElement();
+                    reader.Close();
+                    return;
+                case BodyState.Encrypted:
+                case BodyState.SignedThenEncrypted:
+                    this.encryptedBodyContent.WriteTo(writer, ServiceModelDictionaryManager.Instance);
+                    break;
+                default:
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(CreateBadStateException("OnWriteBodyContents"));
+            }
+        }
+
+        protected override void OnWriteMessage(XmlDictionaryWriter writer)
+        {
+            // For Kerb one shot, the channel binding will be need to be fished out of the message, cached and added to the
+            // token before calling ISC.
+
+            AttachChannelBindingTokenIfFound();
+
+            EnsureUniqueSecurityApplication();
+
+            MessagePrefixGenerator prefixGenerator = new MessagePrefixGenerator(writer);
+            this.securityHeader.StartSecurityApplication();
+
+            this.Headers.Add(this.securityHeader);
+
+            this.InnerMessage.WriteStartEnvelope(writer);
+
+            this.Headers.RemoveAt(this.Headers.Count - 1);
+
+            this.securityHeader.ApplyBodySecurity(writer, prefixGenerator);
+
+            this.InnerMessage.WriteStartHeaders(writer);
+            this.securityHeader.ApplySecurityAndWriteHeaders(this.Headers, writer, prefixGenerator);
+
+            this.securityHeader.RemoveSignatureEncryptionIfAppropriate();
+
+            this.securityHeader.CompleteSecurityApplication();
+            this.securityHeader.WriteHeader(writer, this.Version);
+            writer.WriteEndElement();
+
+            if (this.fullBodyFragment != null)
+            {
+                ((IFragmentCapableXmlDictionaryWriter) writer).WriteFragment(this.fullBodyFragment, 0, this.fullBodyFragmentLength);
+            }
+            else
+            {
+                if (this.startBodyFragment != null)
+                {
+                    ((IFragmentCapableXmlDictionaryWriter) writer).WriteFragment(this.startBodyFragment.GetBuffer(), 0, (int) this.startBodyFragment.Length);
+                }
+                else
+                {
+                    OnWriteStartBody(writer);
+                }
+
+                OnWriteBodyContents(writer);
+
+                if (this.endBodyFragment != null)
+                {
+                    ((IFragmentCapableXmlDictionaryWriter) writer).WriteFragment(this.endBodyFragment.GetBuffer(), 0, (int) this.endBodyFragment.Length);
+                }
+                else
+                {
+                    writer.WriteEndElement();
+                }
+            }
+
+            writer.WriteEndElement();
+        }
+
+        void AttachChannelBindingTokenIfFound()
+        {
+            ChannelBindingMessageProperty cbmp = null;
+            ChannelBindingMessageProperty.TryGet(this.InnerMessage, out cbmp);
+
+            if (cbmp != null)
+            {
+                if (this.securityHeader.ElementContainer != null && this.securityHeader.ElementContainer.EndorsingSupportingTokens != null)
+                {
+                    foreach (SecurityToken token in this.securityHeader.ElementContainer.EndorsingSupportingTokens)
+                    {
+                        ProviderBackedSecurityToken pbst = token as ProviderBackedSecurityToken;
+                        if (pbst != null)
+                        {
+                            pbst.ChannelBinding = cbmp.ChannelBinding;
+                        }
+                    }
+                }
+            }
+        }
+
+        void SetBodyId()
+        {
+            this.bodyId = this.InnerMessage.GetBodyAttribute(
+                UtilityStrings.IdAttribute,
+                this.securityHeader.StandardsManager.IdManager.DefaultIdNamespaceUri);
+            if (this.bodyId == null)
+            {
+                this.bodyId = this.securityHeader.GenerateId();
+                this.bodyIdInserted = true;
+            }
+        }
+
+        public void WriteBodyToEncrypt(EncryptedData encryptedData, SymmetricAlgorithm algorithm)
+        {
+            encryptedData.Id = this.securityHeader.GenerateId();
+
+            BodyContentHelper helper = new BodyContentHelper();
+            XmlDictionaryWriter encryptingWriter = helper.CreateWriter();
+            this.InnerMessage.WriteBodyContents(encryptingWriter);
+            encryptedData.SetUpEncryption(algorithm, helper.ExtractResult());
+            this.encryptedBodyContent = encryptedData;
+
+            this.state = BodyState.Encrypted;
+        }
+
+        public void WriteBodyToEncryptThenSign(Stream canonicalStream, EncryptedData encryptedData, SymmetricAlgorithm algorithm)
+        {
+            encryptedData.Id = this.securityHeader.GenerateId();
+            SetBodyId();
+
+            XmlDictionaryWriter encryptingWriter = XmlDictionaryWriter.CreateTextWriter(Stream.Null);
+            // The XmlSerializer body formatter would add a
+            // document declaration to the body fragment when a fresh writer 
+            // is provided. Hence, insert a dummy element here and capture 
+            // the body contents as a fragment.
+            encryptingWriter.WriteStartElement("a");
+            MemoryStream ms = new MemoryStream();
+            ((IFragmentCapableXmlDictionaryWriter)encryptingWriter).StartFragment(ms, true);
+
+            this.InnerMessage.WriteBodyContents(encryptingWriter);
+            ((IFragmentCapableXmlDictionaryWriter)encryptingWriter).EndFragment();
+            encryptingWriter.WriteEndElement();
+            ms.Flush();
+            encryptedData.SetUpEncryption(algorithm, new ArraySegment<byte>(ms.GetBuffer(), 0, (int) ms.Length));
+
+            this.fullBodyBuffer = new XmlBuffer(int.MaxValue);
+            XmlDictionaryWriter canonicalWriter = this.fullBodyBuffer.OpenSection(XmlDictionaryReaderQuotas.Max);
+
+            canonicalWriter.StartCanonicalization(canonicalStream, false, null);
+            WriteStartInnerMessageWithId(canonicalWriter);
+            encryptedData.WriteTo(canonicalWriter, ServiceModelDictionaryManager.Instance);
+            canonicalWriter.WriteEndElement();
+            canonicalWriter.EndCanonicalization();
+            canonicalWriter.Flush();
+
+            this.fullBodyBuffer.CloseSection();
+            this.fullBodyBuffer.Close();
+
+            this.state = BodyState.EncryptedThenSigned;
+        }
+
+        public void WriteBodyToSign(Stream canonicalStream)
+        {
+            SetBodyId();
+
+            this.fullBodyBuffer = new XmlBuffer(int.MaxValue);
+            XmlDictionaryWriter canonicalWriter = this.fullBodyBuffer.OpenSection(XmlDictionaryReaderQuotas.Max);
+            canonicalWriter.StartCanonicalization(canonicalStream, false, null);
+            WriteInnerMessageWithId(canonicalWriter);
+            canonicalWriter.EndCanonicalization();
+            canonicalWriter.Flush();
+            this.fullBodyBuffer.CloseSection();
+            this.fullBodyBuffer.Close();
+
+            this.state = BodyState.Signed;
+        }
+
+        public void WriteBodyToSignThenEncrypt(Stream canonicalStream, EncryptedData encryptedData, SymmetricAlgorithm algorithm)
+        {
+            XmlBuffer buffer = new XmlBuffer(int.MaxValue);
+            XmlDictionaryWriter fragmentingWriter = buffer.OpenSection(XmlDictionaryReaderQuotas.Max);
+            WriteBodyToSignThenEncryptWithFragments(canonicalStream, false, null, encryptedData, algorithm, fragmentingWriter);
+            ((IFragmentCapableXmlDictionaryWriter)fragmentingWriter).WriteFragment(this.startBodyFragment.GetBuffer(), 0, (int)this.startBodyFragment.Length);
+            ((IFragmentCapableXmlDictionaryWriter)fragmentingWriter).WriteFragment(this.endBodyFragment.GetBuffer(), 0, (int)this.endBodyFragment.Length);
+            buffer.CloseSection();
+            buffer.Close();
+
+            this.startBodyFragment = null;
+            this.endBodyFragment = null;
+
+            XmlDictionaryReader reader = buffer.GetReader(0);
+            reader.MoveToContent();
+            this.bodyPrefix = reader.Prefix;
+            if (reader.HasAttributes)
+            {
+                this.bodyAttributes = XmlAttributeHolder.ReadAttributes(reader);
+            }
+            reader.Close();
+        }
+
+        public void WriteBodyToSignThenEncryptWithFragments(
+            Stream stream, bool includeComments, string[] inclusivePrefixes,
+            EncryptedData encryptedData, SymmetricAlgorithm algorithm, XmlDictionaryWriter writer)
+        {
+            IFragmentCapableXmlDictionaryWriter fragmentingWriter = (IFragmentCapableXmlDictionaryWriter) writer;
+
+            SetBodyId();
+            encryptedData.Id = this.securityHeader.GenerateId();
+
+            this.startBodyFragment = new MemoryStream();
+            BufferedOutputStream bodyContentFragment = new BufferManagerOutputStream(SR.XmlBufferQuotaExceeded, 1024, int.MaxValue, this.securityHeader.StreamBufferManager);
+            this.endBodyFragment = new MemoryStream();
+
+            writer.StartCanonicalization(stream, includeComments, inclusivePrefixes);
+
+            fragmentingWriter.StartFragment(this.startBodyFragment, false);
+            WriteStartInnerMessageWithId(writer);
+            fragmentingWriter.EndFragment();
+
+            fragmentingWriter.StartFragment(bodyContentFragment, true);
+            this.InnerMessage.WriteBodyContents(writer);
+            fragmentingWriter.EndFragment();
+
+            fragmentingWriter.StartFragment(this.endBodyFragment, false);
+            writer.WriteEndElement();
+            fragmentingWriter.EndFragment();
+
+            writer.EndCanonicalization();
+
+            int bodyLength;
+            byte[] bodyBuffer = bodyContentFragment.ToArray(out bodyLength);
+
+            encryptedData.SetUpEncryption(algorithm, new ArraySegment<byte>(bodyBuffer, 0, bodyLength));
+            this.encryptedBodyContent = encryptedData;
+
+            this.state = BodyState.SignedThenEncrypted;
+        }
+
+        public void WriteBodyToSignWithFragments(Stream stream, bool includeComments, string[] inclusivePrefixes, XmlDictionaryWriter writer)
+        {
+            IFragmentCapableXmlDictionaryWriter fragmentingWriter = (IFragmentCapableXmlDictionaryWriter) writer;
+
+            SetBodyId();
+            BufferedOutputStream fullBodyFragment = new BufferManagerOutputStream(SR.XmlBufferQuotaExceeded, 1024, int.MaxValue, this.securityHeader.StreamBufferManager);
+            writer.StartCanonicalization(stream, includeComments, inclusivePrefixes);
+            fragmentingWriter.StartFragment(fullBodyFragment, false);
+            WriteStartInnerMessageWithId(writer);
+            this.InnerMessage.WriteBodyContents(writer);
+            writer.WriteEndElement();
+            fragmentingWriter.EndFragment();
+            writer.EndCanonicalization();
+
+            this.fullBodyFragment = fullBodyFragment.ToArray(out this.fullBodyFragmentLength);
+
+            this.state = BodyState.Signed;
+        }
+
+        void WriteInnerMessageWithId(XmlDictionaryWriter writer)
+        {
+            WriteStartInnerMessageWithId(writer);
+            this.InnerMessage.WriteBodyContents(writer);
+            writer.WriteEndElement();
+        }
+
+        void WriteStartInnerMessageWithId(XmlDictionaryWriter writer)
+        {
+            this.InnerMessage.WriteStartBody(writer);
+            if (this.bodyIdInserted)
+            {
+                this.securityHeader.StandardsManager.IdManager.WriteIdAttribute(writer, this.bodyId);
+            }
+        }
+
+        enum BodyState
+        {
+            Created,
+            Signed,
+            SignedThenEncrypted,
+            EncryptedThenSigned,
+            Encrypted,
+            Disposed,
+        }
+
+        struct BodyContentHelper
+        {
+            MemoryStream stream;
+            XmlDictionaryWriter writer;
+
+            public XmlDictionaryWriter CreateWriter()
+            {
+                this.stream = new MemoryStream();
+                this.writer = XmlDictionaryWriter.CreateTextWriter(stream);
+                return this.writer;
+            }
+
+            public ArraySegment<byte> ExtractResult()
+            {
+                this.writer.Flush();
+                return new ArraySegment<byte>(this.stream.GetBuffer(), 0, (int) this.stream.Length);
+            }
+        }
+
+        sealed class MessagePrefixGenerator : IPrefixGenerator
+        {
+            XmlWriter writer;
+
+            public MessagePrefixGenerator(XmlWriter writer)
+            {
+                this.writer = writer;
+            }
+
+            public string GetPrefix(string namespaceUri, int depth, bool isForAttribute)
+            {
+                return this.writer.LookupPrefix(namespaceUri);
+            }
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityContextKeyIdentifierClause.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityContextKeyIdentifierClause.cs
new file mode 100644
index 0000000..69965de
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityContextKeyIdentifierClause.cs
@@ -0,0 +1,65 @@
+﻿using System.Globalization;
+using CoreWCF.IdentityModel.Tokens;
+using System.Runtime.CompilerServices;
+using System.Xml;
+using CoreWCF.IdentityModel;
+
+namespace CoreWCF.Security
+{
+    public class SecurityContextKeyIdentifierClause : SecurityKeyIdentifierClause
+    {
+        readonly UniqueId contextId;
+        readonly UniqueId generation;
+
+        public SecurityContextKeyIdentifierClause(UniqueId contextId)
+            : this(contextId, null)
+        {
+        }
+
+        public SecurityContextKeyIdentifierClause(UniqueId contextId, UniqueId generation)
+            : this(contextId, generation, null, 0)
+        {
+        }
+
+        public SecurityContextKeyIdentifierClause(UniqueId contextId, UniqueId generation, byte[] derivationNonce, int derivationLength)
+            : base(null, derivationNonce, derivationLength)
+        {
+            if (contextId == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("contextId");
+            }
+            this.contextId = contextId;
+            this.generation = generation;
+        }
+
+        public UniqueId ContextId
+        {
+            get { return this.contextId; }
+        }
+
+        public UniqueId Generation
+        {
+            get { return this.generation; }
+        }
+
+        public override bool Matches(SecurityKeyIdentifierClause keyIdentifierClause)
+        {
+            SecurityContextKeyIdentifierClause that = keyIdentifierClause as SecurityContextKeyIdentifierClause;
+
+            // PreSharp Bug: Parameter 'that' to this public method must be validated: A null-dereference can occur here.
+#pragma warning suppress 56506
+            return ReferenceEquals(this, that) || (that != null && that.Matches(this.contextId, this.generation));
+        }
+
+        public bool Matches(UniqueId contextId, UniqueId generation)
+        {
+            return contextId == this.contextId && generation == this.generation;
+        }
+
+        public override string ToString()
+        {
+            return string.Format(CultureInfo.InvariantCulture, "SecurityContextKeyIdentifierClause(ContextId = '{0}', Generation = '{1}')",
+                this.ContextId, this.Generation);
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityContextSecurityTokenAuthenticator.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityContextSecurityTokenAuthenticator.cs
new file mode 100644
index 0000000..6f5988f
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityContextSecurityTokenAuthenticator.cs
@@ -0,0 +1,46 @@
+using System;
+using CoreWCF;
+using System.Collections.ObjectModel;
+using CoreWCF.IdentityModel.Selectors;
+using CoreWCF.IdentityModel.Tokens;
+using CoreWCF.IdentityModel.Policy;
+using System.Xml;
+
+namespace CoreWCF.Security.Tokens
+{
+
+
+    public class SecurityContextSecurityTokenAuthenticator : SecurityTokenAuthenticator
+    {
+        public SecurityContextSecurityTokenAuthenticator()
+            : base()
+        { }
+
+        protected override bool CanValidateTokenCore(SecurityToken token)
+        {
+            return (token is SecurityContextSecurityToken);
+        }
+
+        protected override ReadOnlyCollection<IAuthorizationPolicy> ValidateTokenCore(SecurityToken token)
+        {
+            SecurityContextSecurityToken sct = (SecurityContextSecurityToken)token;
+            if (!IsTimeValid(sct))
+            {
+                this.ThrowExpiredContextFaultException(sct.ContextId, sct);
+            }
+
+            return sct.AuthorizationPolicies;
+        }
+
+        void ThrowExpiredContextFaultException(UniqueId contextId, SecurityContextSecurityToken sct)
+        {
+            throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new Exception(SR.Format(SR.SecurityContextExpired, contextId, sct.KeyGeneration == null ? "none" : sct.KeyGeneration.ToString())));
+        }
+
+        bool IsTimeValid(SecurityContextSecurityToken sct)
+        {
+            DateTime utcNow = DateTime.UtcNow;
+            return (sct.ValidFrom <= utcNow && sct.ValidTo >= utcNow && sct.KeyEffectiveTime <= utcNow);
+        }
+   }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityContextTokenCache.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityContextTokenCache.cs
new file mode 100644
index 0000000..f0554c8
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityContextTokenCache.cs
@@ -0,0 +1,342 @@
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Collections.ObjectModel;
+using CoreWCF.Runtime;
+using CoreWCF.Diagnostics;
+using CoreWCF.Security.Tokens;
+using System.Xml;
+
+namespace CoreWCF.Security 
+{
+
+    // This is the in-memory cache used for caching SCTs
+    sealed class SecurityContextTokenCache : TimeBoundedCache
+    {
+        // if there are less than lowWaterMark entries, no purging is done
+        static int lowWaterMark = 50;
+        // frequency of purging the cache of stale entries
+        // this is set to 10 mins as SCTs are expected to have long lifetimes
+        static TimeSpan purgingInterval = TimeSpan.FromMinutes(10);
+        static double pruningFactor = 0.20;
+        bool replaceOldestEntries = true;
+        static SctEffectiveTimeComparer sctEffectiveTimeComparer = new SctEffectiveTimeComparer();
+        TimeSpan clockSkew;
+
+        public SecurityContextTokenCache( int capacity, bool replaceOldestEntries )
+            : this( capacity, replaceOldestEntries, SecurityProtocolFactory.defaultMaxClockSkew )
+        {
+        }
+
+        public SecurityContextTokenCache(int capacity, bool replaceOldestEntries, TimeSpan clockSkew)
+            : base(lowWaterMark, capacity, null, PurgingMode.TimerBasedPurge, purgingInterval, true)
+
+        {
+            this.replaceOldestEntries = replaceOldestEntries;
+            this.clockSkew = clockSkew;
+        }
+
+        public void AddContext(SecurityContextSecurityToken token)
+        {
+            TryAddContext(token, true);
+        }
+        
+        public bool TryAddContext(SecurityContextSecurityToken token)
+        {
+            return TryAddContext(token, false);
+        }
+
+        bool TryAddContext(SecurityContextSecurityToken token, bool throwOnFailure)
+        {
+            if (token == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("token");
+            }
+
+            if ( !SecurityUtils.IsCurrentlyTimeEffective( token.ValidFrom, token.ValidTo, this.clockSkew ) )
+            {
+                if (token.KeyGeneration == null)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgument(SR.Format(SR.SecurityContextExpiredNoKeyGeneration, token.ContextId));
+                else
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgument(SR.Format(SR.SecurityContextExpired, token.ContextId, token.KeyGeneration.ToString()));
+            }
+
+            if ( !SecurityUtils.IsCurrentlyTimeEffective( token.KeyEffectiveTime, token.KeyExpirationTime, this.clockSkew ) )
+            {
+                if (token.KeyGeneration == null)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgument(SR.Format(SR.SecurityContextKeyExpiredNoKeyGeneration, token.ContextId));
+                else
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgument(SR.Format(SR.SecurityContextKeyExpired, token.ContextId, token.KeyGeneration.ToString()));
+            }
+
+            object hashKey = GetHashKey(token.ContextId, token.KeyGeneration);
+            bool wasTokenAdded = base.TryAddItem(hashKey, (SecurityContextSecurityToken)token.Clone(), false);
+            if (!wasTokenAdded)
+            {
+                if (throwOnFailure)
+                {
+                    if (token.KeyGeneration == null)
+                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.ContextAlreadyRegisteredNoKeyGeneration, token.ContextId)));
+                    else
+                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.ContextAlreadyRegistered, token.ContextId, token.KeyGeneration.ToString())));
+                }
+            }
+            return wasTokenAdded;
+        }
+
+        object GetHashKey(UniqueId contextId, UniqueId generation)
+        {
+            if (generation == null)
+            {
+                return contextId;
+            }
+            else
+            {
+                return new ContextAndGenerationKey(contextId, generation);
+            }
+        }
+
+        public void ClearContexts()
+        {
+            base.ClearItems();
+        }
+
+        public SecurityContextSecurityToken GetContext(UniqueId contextId, UniqueId generation)
+        {
+            if (contextId == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("contextId");
+            }
+            object hashKey = GetHashKey(contextId, generation);
+            SecurityContextSecurityToken sct = (SecurityContextSecurityToken)base.GetItem(hashKey);
+            return sct != null ? (SecurityContextSecurityToken)sct.Clone() : null;
+        }
+
+        public void RemoveContext(UniqueId contextId, UniqueId generation, bool throwIfNotPresent)
+        {
+            if (contextId == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("contextId");
+            }
+            object hashKey = GetHashKey(contextId, generation);
+            if (!base.TryRemoveItem(hashKey) && throwIfNotPresent)
+            {
+                if (generation == null)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.ContextNotPresentNoKeyGeneration, contextId)));
+                else
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.ContextNotPresent, contextId, generation.ToString())));
+            }
+        }
+
+        ArrayList GetMatchingKeys(UniqueId contextId)
+        {
+            if (contextId == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("contextId");
+            }
+            ArrayList matchingKeys = new ArrayList(2);
+
+            bool lockHeld = false;
+            try
+            {
+                try { }
+                finally
+                {
+                    base.CacheLock.AcquireReaderLock(-1);
+                    lockHeld = true;
+                }
+                foreach (object key in this.Entries.Keys)
+                {
+                    bool isMatch = false;
+                    if (key is UniqueId)
+                    {
+                        isMatch = (((UniqueId)key) == contextId);
+                    }
+                    else
+                    {
+                        isMatch = (((ContextAndGenerationKey)key).ContextId == contextId);
+                    }
+                    if (isMatch)
+                    {
+                        matchingKeys.Add(key);
+                    }
+                }
+            }
+            finally
+            {
+                if (lockHeld)
+                {
+                    base.CacheLock.ReleaseReaderLock();
+                }
+            }
+            return matchingKeys;
+        }
+
+        public void RemoveAllContexts(UniqueId contextId)
+        {
+            ArrayList matchingKeys = GetMatchingKeys(contextId);
+            for (int i = 0; i < matchingKeys.Count; ++i)
+            {
+                base.TryRemoveItem(matchingKeys[i]);
+            }
+
+        }
+
+        public void UpdateContextCachingTime(SecurityContextSecurityToken token, DateTime expirationTime)
+        {
+            if (token.ValidTo <= expirationTime.ToUniversalTime())
+            {
+                return;
+            }
+            base.TryReplaceItem(GetHashKey(token.ContextId, token.KeyGeneration), token, expirationTime);
+        }
+
+        public Collection<SecurityContextSecurityToken> GetAllContexts(UniqueId contextId)
+        {
+            ArrayList matchingKeys = GetMatchingKeys(contextId);
+
+            Collection<SecurityContextSecurityToken> matchingContexts = new Collection<SecurityContextSecurityToken>();
+            for (int i = 0; i < matchingKeys.Count; ++i)
+            {
+                SecurityContextSecurityToken token = base.GetItem(matchingKeys[i]) as SecurityContextSecurityToken;
+                if (token != null)
+                {
+                    matchingContexts.Add(token);
+                }
+            }
+            return matchingContexts;
+        }
+
+        protected override ArrayList OnQuotaReached(Hashtable cacheTable)
+        {
+            if (!this.replaceOldestEntries)
+            {
+                //SecurityTraceRecordHelper.TraceSecurityContextTokenCacheFull(this.Capacity, 0);
+                return base.OnQuotaReached(cacheTable);
+            }
+            else
+            {
+                List<SecurityContextSecurityToken> tokens = new List<SecurityContextSecurityToken>(cacheTable.Count);
+                foreach (IExpirableItem value in cacheTable.Values)
+                {
+                    SecurityContextSecurityToken token = (SecurityContextSecurityToken)ExtractItem(value);
+                    tokens.Add(token);
+                }
+                tokens.Sort(sctEffectiveTimeComparer);
+                int pruningAmount = (int)(((double)this.Capacity) * pruningFactor);
+                pruningAmount = pruningAmount <= 0 ? this.Capacity : pruningAmount;
+                ArrayList keys = new ArrayList(pruningAmount);
+                for (int i = 0; i < pruningAmount; ++i)
+                {
+                    keys.Add(GetHashKey(tokens[i].ContextId, tokens[i].KeyGeneration));
+                    OnRemove(tokens[i]);
+                }
+              //  SecurityTraceRecordHelper.TraceSecurityContextTokenCacheFull(this.Capacity, pruningAmount);
+                return keys;
+            }
+        }
+
+        sealed class SctEffectiveTimeComparer : IComparer<SecurityContextSecurityToken>
+        {
+            public int Compare(SecurityContextSecurityToken sct1, SecurityContextSecurityToken sct2)
+            {
+                if (sct1 == sct2)
+                {
+                    return 0;
+                }
+                if (sct1.ValidFrom.ToUniversalTime() < sct2.ValidFrom.ToUniversalTime())
+                {
+                    return -1;
+                }
+                else if (sct1.ValidFrom.ToUniversalTime() > sct2.ValidFrom.ToUniversalTime())
+                {
+                    return 1;
+                }
+                else
+                {
+                    // compare the key effective times
+                    if (sct1.KeyEffectiveTime.ToUniversalTime() < sct2.KeyEffectiveTime.ToUniversalTime())
+                    {
+                        return -1;
+                    }
+                    else if (sct1.KeyEffectiveTime.ToUniversalTime() > sct2.KeyEffectiveTime.ToUniversalTime())
+                    {
+                        return 1;
+                    }
+                    else
+                    {
+                        return 0;
+                    }
+                }
+            }
+        }
+
+        protected override void OnRemove(object item)
+        {
+            ((IDisposable)item).Dispose();
+            base.OnRemove(item);
+        }
+
+        struct ContextAndGenerationKey
+        {
+            UniqueId contextId;
+            UniqueId generation;
+
+            public ContextAndGenerationKey(UniqueId contextId, UniqueId generation)
+            {
+                Fx.Assert(contextId != null && generation != null, "");
+                this.contextId = contextId;
+                this.generation = generation;
+            }
+
+            public UniqueId ContextId
+            {
+                get
+                {
+                    return this.contextId;
+                }
+            }
+
+            public UniqueId Generation
+            {
+                get
+                {
+                    return this.generation;
+                }
+            }
+
+            public override int GetHashCode()
+            {
+                return this.contextId.GetHashCode() ^ this.generation.GetHashCode();
+            }
+
+            public override bool Equals(object obj)
+            {
+                if (obj is ContextAndGenerationKey)
+                {
+                    ContextAndGenerationKey key2 = ((ContextAndGenerationKey)obj);
+                    return (key2.ContextId == this.contextId && key2.Generation == this.generation);
+                }
+                else
+                {
+                    return false;
+                }
+            }
+
+            public static bool operator ==(ContextAndGenerationKey a, ContextAndGenerationKey b)
+            {
+                if (object.ReferenceEquals(a, null))
+                {
+                    return object.ReferenceEquals(b, null);
+                }
+
+                return (a.Equals(b));
+            }
+
+            public static bool operator !=(ContextAndGenerationKey a, ContextAndGenerationKey b)
+            {
+                return !(a == b);
+            }
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityHeader.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityHeader.cs
new file mode 100644
index 0000000..e7c3aac
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityHeader.cs
@@ -0,0 +1,161 @@
+using System.Globalization;
+using CoreWCF.Channels;
+using CoreWCF;
+using CoreWCF.Description;
+using System.Xml;
+using System;
+
+namespace CoreWCF.Security
+{
+
+
+  public abstract class SecurityHeader : MessageHeader
+    {
+        readonly string actor;
+        readonly SecurityAlgorithmSuite algorithmSuite;
+        bool encryptedKeyContainsReferenceList = true;
+        Message message;
+        readonly bool mustUnderstand;
+        readonly bool relay;
+        bool requireMessageProtection = true;
+        bool processingStarted;
+        bool maintainSignatureConfirmationState;
+       readonly SecurityStandardsManager standardsManager;
+        MessageDirection transferDirection;
+        SecurityHeaderLayout layout = SecurityHeaderLayout.Strict;
+
+        public SecurityHeader(Message message,
+            string actor, bool mustUnderstand, bool relay,
+            SecurityStandardsManager standardsManager
+            , SecurityAlgorithmSuite algorithmSuite,
+            MessageDirection transferDirection)
+        {
+            if (message == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("message");
+            }
+            if (actor == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("actor");
+            }
+            if (standardsManager == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("standardsManager");
+            }
+            if (algorithmSuite == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("algorithmSuite");
+            }
+
+            this.message = message;
+            this.actor = actor;
+            this.mustUnderstand = mustUnderstand;
+            this.relay = relay;
+            this.standardsManager = standardsManager;
+            this.algorithmSuite = algorithmSuite;
+            this.transferDirection = transferDirection;
+        }
+
+        public override string Actor
+        {
+            get { return this.actor; }
+        }
+
+        public SecurityAlgorithmSuite AlgorithmSuite
+        {
+            get { return this.algorithmSuite; }
+        }
+
+        public bool EncryptedKeyContainsReferenceList
+        {
+            get { return this.encryptedKeyContainsReferenceList; }
+            set
+            {
+                ThrowIfProcessingStarted();
+                this.encryptedKeyContainsReferenceList = value;
+            }
+        }
+
+        public bool RequireMessageProtection
+        {
+            get { return this.requireMessageProtection; }
+            set
+            {
+                ThrowIfProcessingStarted();
+                this.requireMessageProtection = value;
+            }
+        }
+
+        public bool MaintainSignatureConfirmationState
+        {
+            get { return this.maintainSignatureConfirmationState; }
+            set
+            {
+                ThrowIfProcessingStarted();
+                this.maintainSignatureConfirmationState = value;
+            }
+        }
+
+        protected Message Message
+        {
+            get { return this.message; }
+            set { this.message = value; }
+        }
+
+        public override bool MustUnderstand
+        {
+            get { return this.mustUnderstand; }
+        }
+
+        public override bool Relay
+        {
+            get { return this.relay; }
+        }
+
+        public SecurityHeaderLayout Layout
+        {
+            get
+            {
+                return this.layout;
+            }
+            set
+            {
+                ThrowIfProcessingStarted();
+                this.layout = value;
+            }
+        }
+
+        public SecurityStandardsManager StandardsManager
+        {
+            get { return this.standardsManager; }
+        }
+
+        public MessageDirection MessageDirection
+        {
+            get { return this.transferDirection; }
+        }
+
+        protected MessageVersion Version
+        {
+            get { return this.message.Version; }
+        }
+
+        protected void SetProcessingStarted()
+        {
+            this.processingStarted = true;
+        }
+
+        protected void ThrowIfProcessingStarted()
+        {
+            if (this.processingStarted)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.OperationCannotBeDoneAfterProcessingIsStarted)));
+            }
+        }
+
+        public override string ToString()
+        {
+            return string.Format(CultureInfo.InvariantCulture, "{0}(Actor = '{1}')", GetType().Name, this.Actor);
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityHeaderElementInferenceEngine.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityHeaderElementInferenceEngine.cs
new file mode 100644
index 0000000..0cd196e
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityHeaderElementInferenceEngine.cs
@@ -0,0 +1,35 @@
+using CoreWCF.Security.Tokens;
+using CoreWCF.Channels;
+using System.Xml;
+using System;
+
+namespace CoreWCF.Security
+{
+
+    abstract class SecurityHeaderElementInferenceEngine
+    {
+        public abstract void ExecuteProcessingPasses(ReceiveSecurityHeader securityHeader, XmlDictionaryReader reader);
+
+      //  public abstract void MarkElements(ReceiveSecurityHeaderElementManager elementManager, bool messageSecurityMode);
+
+        public static SecurityHeaderElementInferenceEngine GetInferenceEngine(SecurityHeaderLayout layout)
+        {
+            SecurityHeaderLayoutHelper.Validate(layout);
+
+            switch (layout)
+            {
+                case SecurityHeaderLayout.Strict:
+                    return StrictModeSecurityHeaderElementInferenceEngine.Instance;
+                //TODO (Check)
+                //case SecurityHeaderLayout.Lax:
+                //    return LaxModeSecurityHeaderElementInferenceEngine.Instance;
+                //case SecurityHeaderLayout.LaxTimestampFirst:
+                //    return LaxTimestampFirstModeSecurityHeaderElementInferenceEngine.Instance;
+                //case SecurityHeaderLayout.LaxTimestampLast:
+                //    return LaxTimestampLastModeSecurityHeaderElementInferenceEngine.Instance;
+                default:
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("layout"));
+            }
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityHeaderTokenResolver.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityHeaderTokenResolver.cs
new file mode 100644
index 0000000..d37a5fc
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityHeaderTokenResolver.cs
@@ -0,0 +1,335 @@
+using CoreWCF.IdentityModel.Tokens;
+using CoreWCF;
+using CoreWCF.IdentityModel.Selectors;
+using CoreWCF.Security.Tokens;
+using System.IO;
+using System.Globalization;
+using System.Security.Cryptography.X509Certificates;
+using System;
+using CoreWCF.IdentityModel;
+
+namespace CoreWCF.Security
+{
+
+    internal sealed class SecurityHeaderTokenResolver : SecurityTokenResolver // , System.IdentityModel.IWrappedTokenKeyResolver
+    {
+        const int InitialTokenArraySize = 10;
+        int tokenCount;
+        SecurityTokenEntry[] tokens;
+        SecurityToken expectedWrapper;
+        SecurityTokenParameters expectedWrapperTokenParameters;
+        ReceiveSecurityHeader securityHeader;
+
+        public SecurityHeaderTokenResolver()
+            : this(null)
+        {
+        }
+
+        public SecurityHeaderTokenResolver(ReceiveSecurityHeader securityHeader)
+        {
+            this.tokens = new SecurityTokenEntry[InitialTokenArraySize];
+            this.securityHeader = securityHeader;
+        }
+
+        public SecurityToken ExpectedWrapper
+        {
+            get { return this.expectedWrapper; }
+            set { this.expectedWrapper = value; }
+        }
+
+        public SecurityTokenParameters ExpectedWrapperTokenParameters
+        {
+            get { return this.expectedWrapperTokenParameters; }
+            set { this.expectedWrapperTokenParameters = value; }
+        }
+
+        public void Add(SecurityToken token)
+        {
+            Add(token, SecurityTokenReferenceStyle.Internal, null);
+        }
+
+        public void Add(SecurityToken token, SecurityTokenReferenceStyle allowedReferenceStyle, SecurityTokenParameters tokenParameters)
+        {
+            if (token == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("token");
+            }
+
+            if ((allowedReferenceStyle == SecurityTokenReferenceStyle.External) && (tokenParameters == null))
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgument(SR.Format(SR.ResolvingExternalTokensRequireSecurityTokenParameters));
+            }
+
+            EnsureCapacityToAddToken();
+            this.tokens[this.tokenCount++] = new SecurityTokenEntry(token, tokenParameters, allowedReferenceStyle);
+        }
+
+        void EnsureCapacityToAddToken()
+        {
+            if (this.tokenCount == this.tokens.Length)
+            {
+                SecurityTokenEntry[] newTokens = new SecurityTokenEntry[this.tokens.Length * 2];
+                Array.Copy(this.tokens, 0, newTokens, 0, this.tokenCount);
+                this.tokens = newTokens;
+            }
+        }
+
+        public bool CheckExternalWrapperMatch(SecurityKeyIdentifier keyIdentifier)
+        {
+            if (this.expectedWrapper == null || this.expectedWrapperTokenParameters == null)
+            {
+                return false;
+            }
+
+            for (int i = 0; i < keyIdentifier.Count; i++)
+            {
+                if (this.expectedWrapperTokenParameters.MatchesKeyIdentifierClause(this.expectedWrapper, keyIdentifier[i], SecurityTokenReferenceStyle.External))
+                {
+                    return true;
+                }
+            }
+            return false;
+        }
+
+        internal SecurityToken ResolveToken(SecurityKeyIdentifier keyIdentifier, bool matchOnlyExternalTokens, bool resolveIntrinsicKeyClause)
+        {
+            if (keyIdentifier == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("keyIdentifier");
+            }
+            for (int i = 0; i < keyIdentifier.Count; i++)
+            {
+                SecurityToken token = ResolveToken(keyIdentifier[i], matchOnlyExternalTokens, resolveIntrinsicKeyClause);
+                if (token != null)
+                {
+                    return token;
+                }
+            }
+            return null;
+        }
+
+        SecurityKey ResolveSecurityKeyCore(SecurityKeyIdentifierClause keyIdentifierClause, bool createIntrinsicKeys)
+        {
+            if (keyIdentifierClause == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException("keyIdentifierClause"));
+            }
+
+            SecurityKey securityKey;
+            for (int i = 0; i < this.tokenCount; i++)
+            {
+                securityKey = this.tokens[i].Token.ResolveKeyIdentifierClause(keyIdentifierClause);
+                if (securityKey != null)
+                {
+                    return securityKey;
+                }
+            }
+
+            if (createIntrinsicKeys)
+            {
+                throw new NotImplementedException();
+                //TODO
+               /// if (SecurityUtils.TryCreateKeyFromIntrinsicKeyClause(keyIdentifierClause, this, out securityKey))
+               // {
+               //     return securityKey;
+               // }
+            }
+
+            return null;
+        }
+
+        bool MatchDirectReference(SecurityToken token, SecurityKeyIdentifierClause keyClause)
+        {
+            LocalIdKeyIdentifierClause localClause = keyClause as LocalIdKeyIdentifierClause;
+            if (localClause == null) return false;
+            return token.MatchesKeyIdentifierClause(localClause);
+        }
+
+        internal SecurityToken ResolveToken(SecurityKeyIdentifierClause keyIdentifierClause, bool matchOnlyExternal, bool resolveIntrinsicKeyClause)
+        {
+            if (keyIdentifierClause == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("keyIdentifierClause");
+            }
+
+            SecurityToken resolvedToken = null;
+            for (int i = 0; i < this.tokenCount; i++)
+            {
+                if (matchOnlyExternal && tokens[i].AllowedReferenceStyle != SecurityTokenReferenceStyle.External)
+                {
+                    continue;
+                }
+
+                SecurityToken token = tokens[i].Token;
+                if (tokens[i].TokenParameters != null && tokens[i].TokenParameters.MatchesKeyIdentifierClause(token, keyIdentifierClause, tokens[i].AllowedReferenceStyle))
+                {
+                    resolvedToken = token;
+                    break;
+                }
+                else if (tokens[i].TokenParameters == null)
+                {
+                    // match it according to the allowed reference style
+                    if (tokens[i].AllowedReferenceStyle == SecurityTokenReferenceStyle.Internal && MatchDirectReference(token, keyIdentifierClause))
+                    {
+                        resolvedToken = token;
+                        break;
+                    }
+                }
+            }
+
+            if ((resolvedToken == null) && (keyIdentifierClause is EncryptedKeyIdentifierClause))
+            {
+                EncryptedKeyIdentifierClause keyClause = (EncryptedKeyIdentifierClause)keyIdentifierClause;
+                SecurityKeyIdentifier wrappingTokenReference = keyClause.EncryptingKeyIdentifier;
+                SecurityToken unwrappingToken;
+                if (this.expectedWrapper != null 
+                    && CheckExternalWrapperMatch(wrappingTokenReference))
+                    unwrappingToken = this.expectedWrapper;
+                else
+                    unwrappingToken = ResolveToken(wrappingTokenReference, true, resolveIntrinsicKeyClause);
+                //TODO
+              /*  if (unwrappingToken != null)
+                {
+                    resolvedToken = SecurityUtils.CreateTokenFromEncryptedKeyClause(keyClause, unwrappingToken);
+                }*/
+            }
+            /*TODO
+            if ((resolvedToken == null) && (keyIdentifierClause is X509RawDataKeyIdentifierClause) && (!matchOnlyExternal) && (resolveIntrinsicKeyClause))
+            {
+                resolvedToken = new X509SecurityToken(new X509Certificate2(((X509RawDataKeyIdentifierClause)keyIdentifierClause).GetX509RawData()));
+            }*/
+
+            byte[] derivationNonce = keyIdentifierClause.GetDerivationNonce();
+            if ((resolvedToken != null) && (derivationNonce != null))
+            {
+                // A Implicit Derived Key is specified. Create a derived key off of the resolve token.
+                if (SecurityUtils.GetSecurityKey<SymmetricSecurityKey>(resolvedToken) == null)
+                {
+                    // The resolved token contains no Symmetric Security key and thus we cannot create 
+                    // a derived key off of it.
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new MessageSecurityException(SR.Format(SR.UnableToDeriveKeyFromKeyInfoClause, keyIdentifierClause, resolvedToken)));
+                }
+
+                int derivationLength = (keyIdentifierClause.DerivationLength == 0) ? DerivedKeySecurityToken.DefaultDerivedKeyLength : keyIdentifierClause.DerivationLength;
+                if (derivationLength > this.securityHeader.MaxDerivedKeyLength)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new MessageSecurityException(SR.Format(SR.DerivedKeyLengthSpecifiedInImplicitDerivedKeyClauseTooLong, keyIdentifierClause.ToString(), derivationLength, this.securityHeader.MaxDerivedKeyLength)));
+                bool alreadyDerived = false;
+                for (int i = 0; i < this.tokenCount; ++i)
+                {
+                    DerivedKeySecurityToken derivedKeyToken = this.tokens[i].Token as DerivedKeySecurityToken;
+                    if (derivedKeyToken != null)
+                    {
+                        if ((derivedKeyToken.Length == derivationLength) &&
+                            (CryptoHelper.IsEqual(derivedKeyToken.Nonce, derivationNonce)) && 
+                            (derivedKeyToken.TokenToDerive.MatchesKeyIdentifierClause(keyIdentifierClause)))
+                        {
+                            // This is a implcit derived key for which we have already derived the
+                            // token.
+                            resolvedToken = this.tokens[i].Token;
+                            alreadyDerived = true;
+                            break;
+                        }
+                    }
+                }
+
+                if (!alreadyDerived)
+                {
+                    string psha1Algorithm = SecurityUtils.GetKeyDerivationAlgorithm(this.securityHeader.StandardsManager.MessageSecurityVersion.SecureConversationVersion);
+
+                    resolvedToken = new DerivedKeySecurityToken(-1, 0, derivationLength, null, derivationNonce, resolvedToken, keyIdentifierClause, psha1Algorithm, SecurityUtils.GenerateId());
+                    ((DerivedKeySecurityToken)resolvedToken).InitializeDerivedKey(derivationLength);
+                    Add(resolvedToken, SecurityTokenReferenceStyle.Internal, null);
+                    this.securityHeader.EnsureDerivedKeyLimitNotReached();
+                }
+            }
+
+            return resolvedToken;
+        }
+
+        public override string ToString()
+        {
+            using (StringWriter writer = new StringWriter(CultureInfo.InvariantCulture))
+            {
+                writer.WriteLine("SecurityTokenResolver");
+                writer.WriteLine("    (");
+                writer.WriteLine("    TokenCount = {0},", this.tokenCount);
+                for (int i = 0; i < this.tokenCount; i++)
+                {
+                    writer.WriteLine("    TokenEntry[{0}] = (AllowedReferenceStyle={1}, Token={2}, Parameters={3})",
+                        i, this.tokens[i].AllowedReferenceStyle, this.tokens[i].Token.GetType(), tokens[i].TokenParameters);
+                }
+                writer.WriteLine("    )");
+                return writer.ToString();
+            }
+        }
+
+        protected override bool TryResolveTokenCore(SecurityKeyIdentifier keyIdentifier, out SecurityToken token)
+        {
+            token = ResolveToken(keyIdentifier, false, true);
+            return token != null;
+        }
+
+        internal bool TryResolveToken(SecurityKeyIdentifier keyIdentifier, bool matchOnlyExternalTokens, bool resolveIntrinsicKeyClause, out SecurityToken token)
+        {
+            token = ResolveToken(keyIdentifier, matchOnlyExternalTokens, resolveIntrinsicKeyClause);
+            return token != null;
+        }
+
+        protected override bool TryResolveTokenCore(SecurityKeyIdentifierClause keyIdentifierClause, out SecurityToken token)
+        {
+            token = ResolveToken(keyIdentifierClause, false, true);
+            return token != null;
+        }
+
+        internal bool TryResolveToken(SecurityKeyIdentifierClause keyIdentifierClause, bool matchOnlyExternalTokens, bool resolveIntrinsicKeyClause, out SecurityToken token)
+        {
+            token = ResolveToken(keyIdentifierClause, matchOnlyExternalTokens, resolveIntrinsicKeyClause);
+            return token != null;
+        }
+
+        internal bool TryResolveSecurityKey(SecurityKeyIdentifierClause keyIdentifierClause, bool createIntrinsicKeys, out SecurityKey key)
+        {
+            if (keyIdentifierClause == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("keyIdentifierClause");
+            }
+            key = this.ResolveSecurityKeyCore(keyIdentifierClause, createIntrinsicKeys);
+            return key != null;
+        }
+
+        protected override bool TryResolveSecurityKeyCore(SecurityKeyIdentifierClause keyIdentifierClause, out SecurityKey key)
+        {
+            key = ResolveSecurityKeyCore(keyIdentifierClause, true);
+            return key != null;
+        }
+
+        struct SecurityTokenEntry
+        {
+            SecurityTokenParameters tokenParameters;
+            SecurityToken token;
+            SecurityTokenReferenceStyle allowedReferenceStyle;
+
+            public SecurityTokenEntry(SecurityToken token, SecurityTokenParameters tokenParameters, SecurityTokenReferenceStyle allowedReferenceStyle)
+            {
+                this.token = token;
+                this.tokenParameters = tokenParameters;
+                this.allowedReferenceStyle = allowedReferenceStyle; 
+            }
+
+            public SecurityToken Token
+            {
+                get { return this.token; }
+            }
+
+            public SecurityTokenParameters TokenParameters
+            {
+                get { return this.tokenParameters; }
+            }
+
+            public SecurityTokenReferenceStyle AllowedReferenceStyle
+            {
+                get { return this.allowedReferenceStyle; }
+            }
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityKeyEntropyMode.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityKeyEntropyMode.cs
new file mode 100644
index 0000000..5bc4bc8
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityKeyEntropyMode.cs
@@ -0,0 +1,30 @@
+namespace CoreWCF.Security
+{
+    using System.ComponentModel;
+
+    public enum SecurityKeyEntropyMode
+    {
+        ClientEntropy,
+        ServerEntropy,
+        CombinedEntropy
+    }
+
+    sealed class SecurityKeyEntropyModeHelper
+    {
+        internal static bool IsDefined(SecurityKeyEntropyMode value)
+        {
+            return (value == SecurityKeyEntropyMode.ClientEntropy
+                || value == SecurityKeyEntropyMode.ServerEntropy
+                || value == SecurityKeyEntropyMode.CombinedEntropy);
+        }
+
+        internal static void Validate(SecurityKeyEntropyMode value)
+        {
+            if (!IsDefined(value))
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidEnumArgumentException("value", (int)value,
+                    typeof(SecurityKeyEntropyMode)));
+            }
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityListenerSettingsLifetimeManager.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityListenerSettingsLifetimeManager.cs
new file mode 100644
index 0000000..9791863
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityListenerSettingsLifetimeManager.cs
@@ -0,0 +1,84 @@
+using System;
+using System.Collections.Generic;
+using CoreWCF.Runtime;
+using System.Runtime;
+using CoreWCF;
+using CoreWCF.Channels;
+using System.Threading;
+
+namespace CoreWCF.Security
+{
+    class SecurityListenerSettingsLifetimeManager
+    {
+        SecurityProtocolFactory securityProtocolFactory;
+        SecuritySessionServerSettings sessionSettings;
+        bool sessionMode;
+       // IChannelListener innerListener;
+        int referenceCount;
+
+        public SecurityListenerSettingsLifetimeManager(SecurityProtocolFactory securityProtocolFactory, SecuritySessionServerSettings sessionSettings, bool sessionMode)
+        {
+            this.securityProtocolFactory = securityProtocolFactory;
+            this.sessionSettings = sessionSettings;
+            this.sessionMode = sessionMode;
+         //   this.innerListener = innerListener;
+            // have a reference right from the start so that the state can be aborted before open
+            referenceCount = 1;
+        }
+
+        public void Abort()
+        {
+            if (Interlocked.Decrement(ref this.referenceCount) == 0)
+            {
+               // AbortCore();
+            }
+        }
+
+        public void AddReference()
+        {
+            Interlocked.Increment(ref this.referenceCount);
+        }
+
+        public void Init(TimeSpan timeout) // renaming open to Init
+        {
+            //TimeoutHelper timeoutHelper = new TimeoutHelper(timeout);
+            //if (this.securityProtocolFactory != null)
+            //{
+            //    this.securityProtocolFactory.Init(timeoutHelper.RemainingTime());
+            //}
+            //if (this.sessionMode && this.sessionSettings != null)
+            //{
+            //    this.sessionSettings.Init(timeoutHelper.RemainingTime());
+            //} 
+
+         //   this.innerListener.Open(timeoutHelper.RemainingTime());
+
+            this.SetBufferManager();        
+        }
+
+        void SetBufferManager()
+        {
+           
+        /* TODO
+            ITransportFactorySettings transportSettings = this.innerListener.GetProperty<ITransportFactorySettings>();
+            if (transportSettings == null)
+                return;
+
+            BufferManager bufferManager = transportSettings.BufferManager;
+            if (bufferManager == null)
+                return;
+
+            if (this.securityProtocolFactory != null)
+            {
+                this.securityProtocolFactory.StreamBufferManager = bufferManager;
+            }
+
+            if (this.sessionMode && this.sessionSettings != null && this.sessionSettings.SessionProtocolFactory != null)
+            {
+                this.sessionSettings.SessionProtocolFactory.StreamBufferManager = bufferManager;
+            }
+            */
+        }
+
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityMessageProperty.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityMessageProperty.cs
index d263c63..6cc5a43 100644
--- a/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityMessageProperty.cs
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityMessageProperty.cs
@@ -4,27 +4,29 @@ using System;
 using System.Collections.Generic;
 using System.Collections.ObjectModel;
 using System.Text;
+using CoreWCF.IdentityModel;
+using CoreWCF.Security.Tokens;
 
 namespace CoreWCF.Security
 {
     public class SecurityMessageProperty : IMessageProperty, IDisposable
     {
-        //// This is the list of outgoing supporting tokens
-        //Collection<SupportingTokenSpecification> outgoingSupportingTokens;
-        //Collection<SupportingTokenSpecification> incomingSupportingTokens;
+        // This is the list of outgoing supporting tokens
+        Collection<SupportingTokenSpecification> outgoingSupportingTokens;
+        Collection<SupportingTokenSpecification> incomingSupportingTokens;
         SecurityTokenSpecification transportToken;
-        //SecurityTokenSpecification protectionToken;
-        //SecurityTokenSpecification initiatorToken;
-        //SecurityTokenSpecification recipientToken;
+        SecurityTokenSpecification protectionToken;
+        SecurityTokenSpecification initiatorToken;
+        SecurityTokenSpecification recipientToken;
 
         ServiceSecurityContext securityContext;
-
-        //string senderIdPrefix = "_";
+        ReadOnlyCollection<IAuthorizationPolicy> externalAuthorizationPolicies;
+        string senderIdPrefix = "_";
         bool disposed = false;
 
         public SecurityMessageProperty()
         {
-            securityContext = ServiceSecurityContext.Anonymous;
+            this.securityContext = ServiceSecurityContext.Anonymous;
         }
 
         public ServiceSecurityContext ServiceSecurityContext
@@ -32,158 +34,168 @@ namespace CoreWCF.Security
             get
             {
                 ThrowIfDisposed();
-                return securityContext;
+                return this.securityContext;
+            }
+            set
+            {
+                ThrowIfDisposed();
+                this.securityContext = value;
+            }
+        }
+
+        public ReadOnlyCollection<IAuthorizationPolicy> ExternalAuthorizationPolicies
+        {
+            get
+            {
+                return this.externalAuthorizationPolicies;
+            }
+            set
+            {
+                this.externalAuthorizationPolicies = value;
+            }
+        }
+
+        public SecurityTokenSpecification ProtectionToken
+        {
+            get
+            {
+                ThrowIfDisposed();
+                return this.protectionToken;
+            }
+            set
+            {
+                ThrowIfDisposed();
+                this.protectionToken = value;
+            }
+        }
+
+        public SecurityTokenSpecification InitiatorToken
+        {
+            get
+            {
+                ThrowIfDisposed();
+                return this.initiatorToken;
+            }
+            set
+            {
+                ThrowIfDisposed();
+                this.initiatorToken = value;
+            }
+        }
+
+        public SecurityTokenSpecification RecipientToken
+        {
+            get
+            {
+                ThrowIfDisposed();
+                return this.recipientToken;
             }
             set
             {
                 ThrowIfDisposed();
-                securityContext = value;
+                this.recipientToken = value;
             }
         }
 
-        public ReadOnlyCollection<IAuthorizationPolicy> ExternalAuthorizationPolicies { get; set; }
-
-        //public SecurityTokenSpecification ProtectionToken
-        //{
-        //    get
-        //    {
-        //        ThrowIfDisposed();
-        //        return this.protectionToken;
-        //    }
-        //    set
-        //    {
-        //        ThrowIfDisposed();
-        //        this.protectionToken = value;
-        //    }
-        //}
-
-        //public SecurityTokenSpecification InitiatorToken
-        //{
-        //    get
-        //    {
-        //        ThrowIfDisposed();
-        //        return this.initiatorToken;
-        //    }
-        //    set
-        //    {
-        //        ThrowIfDisposed();
-        //        this.initiatorToken = value;
-        //    }
-        //}
-
-        //public SecurityTokenSpecification RecipientToken
-        //{
-        //    get
-        //    {
-        //        ThrowIfDisposed();
-        //        return this.recipientToken;
-        //    }
-        //    set
-        //    {
-        //        ThrowIfDisposed();
-        //        this.recipientToken = value;
-        //    }
-        //}
-
-        internal SecurityTokenSpecification TransportToken
+        public SecurityTokenSpecification TransportToken
         {
             get
             {
                 ThrowIfDisposed();
-                return transportToken;
+                return this.transportToken;
+            }
+            set
+            {
+                ThrowIfDisposed();
+                this.transportToken = value;
+            }
+        }
+
+
+        public string SenderIdPrefix
+        {
+            get
+            {
+                return this.senderIdPrefix;
             }
             set
+            {
+               /// XmlHelper.ValidateIdPrefix(value);
+                this.senderIdPrefix = value;
+            }
+        }
+
+        public bool HasIncomingSupportingTokens
+        {
+            get
+            {
+                ThrowIfDisposed();
+                return ((this.incomingSupportingTokens != null) && (this.incomingSupportingTokens.Count > 0));
+            }
+        }
+
+        public Collection<SupportingTokenSpecification> IncomingSupportingTokens
+        {
+            get
             {
                 ThrowIfDisposed();
-                transportToken = value;
+                if (this.incomingSupportingTokens == null)
+                {
+                    this.incomingSupportingTokens = new Collection<SupportingTokenSpecification>();
+                }
+                return this.incomingSupportingTokens;
             }
         }
 
+        public Collection<SupportingTokenSpecification> OutgoingSupportingTokens
+        {
+            get
+            {
+                if (this.outgoingSupportingTokens == null)
+                {
+                    this.outgoingSupportingTokens = new Collection<SupportingTokenSpecification>();
+                }
+                return this.outgoingSupportingTokens;
+            }
+        }
 
-        //public string SenderIdPrefix
-        //{
-        //    get
-        //    {
-        //        return this.senderIdPrefix;
-        //    }
-        //    set
-        //    {
-        //        XmlHelper.ValidateIdPrefix(value);
-        //        this.senderIdPrefix = value;
-        //    }
-        //}
-
-        //public bool HasIncomingSupportingTokens
-        //{
-        //    get
-        //    {
-        //        ThrowIfDisposed();
-        //        return ((this.incomingSupportingTokens != null) && (this.incomingSupportingTokens.Count > 0));
-        //    }
-        //}
-
-        //public Collection<SupportingTokenSpecification> IncomingSupportingTokens
-        //{
-        //    get
-        //    {
-        //        ThrowIfDisposed();
-        //        if (this.incomingSupportingTokens == null)
-        //        {
-        //            this.incomingSupportingTokens = new Collection<SupportingTokenSpecification>();
-        //        }
-        //        return this.incomingSupportingTokens;
-        //    }
-        //}
-
-        //public Collection<SupportingTokenSpecification> OutgoingSupportingTokens
-        //{
-        //    get
-        //    {
-        //        if (this.outgoingSupportingTokens == null)
-        //        {
-        //            this.outgoingSupportingTokens = new Collection<SupportingTokenSpecification>();
-        //        }
-        //        return this.outgoingSupportingTokens;
-        //    }
-        //}
-
-        //internal bool HasOutgoingSupportingTokens
-        //{
-        //    get
-        //    {
-        //        return ((this.outgoingSupportingTokens != null) && (this.outgoingSupportingTokens.Count > 0));
-        //    }
-        //}
+        internal bool HasOutgoingSupportingTokens
+        {
+            get
+            {
+                return ((this.outgoingSupportingTokens != null) && (this.outgoingSupportingTokens.Count > 0));
+            }
+        }
 
         public IMessageProperty CreateCopy()
         {
             ThrowIfDisposed();
             SecurityMessageProperty result = new SecurityMessageProperty();
 
-        //    if (this.HasOutgoingSupportingTokens)
-        //    {
-        //        for (int i = 0; i < this.outgoingSupportingTokens.Count; ++i)
-        //        {
-        //            result.OutgoingSupportingTokens.Add(this.outgoingSupportingTokens[i]);
-        //        }
-        //    }
-
-        //    if (this.HasIncomingSupportingTokens)
-        //    {
-        //        for (int i = 0; i < this.incomingSupportingTokens.Count; ++i)
-        //        {
-        //            result.IncomingSupportingTokens.Add(this.incomingSupportingTokens[i]);
-        //        }
-        //    }
-
-            result.securityContext = securityContext;
-        //    result.externalAuthorizationPolicies = this.externalAuthorizationPolicies;
-        //    result.senderIdPrefix = this.senderIdPrefix;
-
-        //    result.protectionToken = this.protectionToken;
-        //    result.initiatorToken = this.initiatorToken;
-        //    result.recipientToken = this.recipientToken;
-            result.transportToken = transportToken;
+            if (this.HasOutgoingSupportingTokens)
+            {
+                for (int i = 0; i < this.outgoingSupportingTokens.Count; ++i)
+                {
+                    result.OutgoingSupportingTokens.Add(this.outgoingSupportingTokens[i]);
+                }
+            }
+
+            if (this.HasIncomingSupportingTokens)
+            {
+                for (int i = 0; i < this.incomingSupportingTokens.Count; ++i)
+                {
+                    result.IncomingSupportingTokens.Add(this.incomingSupportingTokens[i]);
+                }
+            }
+
+            result.securityContext = this.securityContext;
+            result.externalAuthorizationPolicies = this.externalAuthorizationPolicies;
+            result.senderIdPrefix = this.senderIdPrefix;
+
+            result.protectionToken = this.protectionToken;
+            result.initiatorToken = this.initiatorToken;
+            result.recipientToken = this.recipientToken;
+            result.transportToken = this.transportToken;
 
             return result;
         }
@@ -191,7 +203,7 @@ namespace CoreWCF.Security
         public static SecurityMessageProperty GetOrCreate(Message message)
         {
             if (message == null)
-                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(message));
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("message");
 
             SecurityMessageProperty result = null;
             if (message.Properties != null)
@@ -206,101 +218,101 @@ namespace CoreWCF.Security
             return result;
         }
 
-        //void AddAuthorizationPolicies(SecurityTokenSpecification spec, Collection<IAuthorizationPolicy> policies)
-        //{
-        //    if (spec != null && spec.SecurityTokenPolicies != null && spec.SecurityTokenPolicies.Count > 0)
-        //    {
-        //        for (int i = 0; i < spec.SecurityTokenPolicies.Count; ++i)
-        //        {
-        //            policies.Add(spec.SecurityTokenPolicies[i]);
-        //        }
-        //    }
-        //}
-
-        //internal ReadOnlyCollection<IAuthorizationPolicy> GetInitiatorTokenAuthorizationPolicies()
-        //{
-        //    return GetInitiatorTokenAuthorizationPolicies(true);
-        //}
-
-        //internal ReadOnlyCollection<IAuthorizationPolicy> GetInitiatorTokenAuthorizationPolicies(bool includeTransportToken)
-        //{
-        //    return GetInitiatorTokenAuthorizationPolicies(includeTransportToken, null);
-        //}
-
-        //internal ReadOnlyCollection<IAuthorizationPolicy> GetInitiatorTokenAuthorizationPolicies(bool includeTransportToken, SecurityContextSecurityToken supportingSessionTokenToExclude)
-        //{
-        //    // fast path
-        //    if (!this.HasIncomingSupportingTokens)
-        //    {
-        //        if (this.transportToken != null && this.initiatorToken == null && this.protectionToken == null)
-        //        {
-        //            if (includeTransportToken && this.transportToken.SecurityTokenPolicies != null)
-        //            {
-        //                return this.transportToken.SecurityTokenPolicies;
-        //            }
-        //            else
-        //            {
-        //                return EmptyReadOnlyCollection<IAuthorizationPolicy>.Instance;
-        //            }
-        //        }
-        //        else if (this.transportToken == null && this.initiatorToken != null && this.protectionToken == null)
-        //        {
-        //            return this.initiatorToken.SecurityTokenPolicies ?? EmptyReadOnlyCollection<IAuthorizationPolicy>.Instance;
-        //        }
-        //        else if (this.transportToken == null && this.initiatorToken == null && this.protectionToken != null)
-        //        {
-        //            return this.protectionToken.SecurityTokenPolicies ?? EmptyReadOnlyCollection<IAuthorizationPolicy>.Instance;
-        //        }
-        //    }
-
-        //    Collection<IAuthorizationPolicy> policies = new Collection<IAuthorizationPolicy>();
-        //    if (includeTransportToken)
-        //    {
-        //        AddAuthorizationPolicies(this.transportToken, policies);
-        //    }
-        //    AddAuthorizationPolicies(this.initiatorToken, policies);
-        //    AddAuthorizationPolicies(this.protectionToken, policies);
-        //    if (this.HasIncomingSupportingTokens)
-        //    {
-        //        for (int i = 0; i < this.incomingSupportingTokens.Count; ++i)
-        //        {
-        //            if (supportingSessionTokenToExclude != null)
-        //            {
-        //                SecurityContextSecurityToken sct = this.incomingSupportingTokens[i].SecurityToken as SecurityContextSecurityToken;
-        //                if (sct != null && sct.ContextId == supportingSessionTokenToExclude.ContextId)
-        //                {
-        //                    continue;
-        //                }
-        //            }
-        //            SecurityTokenAttachmentMode attachmentMode = this.incomingSupportingTokens[i].SecurityTokenAttachmentMode;
-        //            // a safety net in case more attachment modes get added to the product without 
-        //            // reviewing this code.
-        //            if (attachmentMode == SecurityTokenAttachmentMode.Endorsing
-        //                || attachmentMode == SecurityTokenAttachmentMode.Signed
-        //                || attachmentMode == SecurityTokenAttachmentMode.SignedEncrypted
-        //                || attachmentMode == SecurityTokenAttachmentMode.SignedEndorsing)
-        //            {
-        //                AddAuthorizationPolicies(this.incomingSupportingTokens[i], policies);
-        //            }
-        //        }
-        //    }
-        //    return new ReadOnlyCollection<IAuthorizationPolicy>(policies);
-        //}
+        void AddAuthorizationPolicies(SecurityTokenSpecification spec, Collection<IAuthorizationPolicy> policies)
+        {
+            if (spec != null && spec.SecurityTokenPolicies != null && spec.SecurityTokenPolicies.Count > 0)
+            {
+                for (int i = 0; i < spec.SecurityTokenPolicies.Count; ++i)
+                {
+                    policies.Add(spec.SecurityTokenPolicies[i]);
+                }
+            }
+        }
+
+        internal ReadOnlyCollection<IAuthorizationPolicy> GetInitiatorTokenAuthorizationPolicies()
+        {
+            return GetInitiatorTokenAuthorizationPolicies(true);
+        }
+
+        internal ReadOnlyCollection<IAuthorizationPolicy> GetInitiatorTokenAuthorizationPolicies(bool includeTransportToken)
+        {
+            return GetInitiatorTokenAuthorizationPolicies(includeTransportToken, null);
+        }
+
+        internal ReadOnlyCollection<IAuthorizationPolicy> GetInitiatorTokenAuthorizationPolicies(bool includeTransportToken, SecurityContextSecurityToken supportingSessionTokenToExclude)
+        {
+            // fast path
+            if (!this.HasIncomingSupportingTokens)
+            {
+                if (this.transportToken != null && this.initiatorToken == null && this.protectionToken == null)
+                {
+                    if (includeTransportToken && this.transportToken.SecurityTokenPolicies != null)
+                    {
+                        return this.transportToken.SecurityTokenPolicies;
+                    }
+                    else
+                    {
+                        return EmptyReadOnlyCollection<IAuthorizationPolicy>.Instance;
+                    }
+                }
+                else if (this.transportToken == null && this.initiatorToken != null && this.protectionToken == null)
+                {
+                    return this.initiatorToken.SecurityTokenPolicies ?? EmptyReadOnlyCollection<IAuthorizationPolicy>.Instance;
+                }
+                else if (this.transportToken == null && this.initiatorToken == null && this.protectionToken != null)
+                {
+                    return this.protectionToken.SecurityTokenPolicies ?? EmptyReadOnlyCollection<IAuthorizationPolicy>.Instance;
+                }
+            }
+
+            Collection<IAuthorizationPolicy> policies = new Collection<IAuthorizationPolicy>();
+            if (includeTransportToken)
+            {
+                AddAuthorizationPolicies(this.transportToken, policies);
+            }
+            AddAuthorizationPolicies(this.initiatorToken, policies);
+            AddAuthorizationPolicies(this.protectionToken, policies);
+            if (this.HasIncomingSupportingTokens)
+            {
+                for (int i = 0; i < this.incomingSupportingTokens.Count; ++i)
+                {
+                    if (supportingSessionTokenToExclude != null)
+                    {
+                        SecurityContextSecurityToken sct = this.incomingSupportingTokens[i].SecurityToken as SecurityContextSecurityToken;
+                        if (sct != null && sct.ContextId == supportingSessionTokenToExclude.ContextId)
+                        {
+                            continue;
+                        }
+                    }
+                    SecurityTokenAttachmentMode attachmentMode = this.incomingSupportingTokens[i].SecurityTokenAttachmentMode;
+                    // a safety net in case more attachment modes get added to the product without 
+                    // reviewing this code.
+                    if (attachmentMode == SecurityTokenAttachmentMode.Endorsing
+                        || attachmentMode == SecurityTokenAttachmentMode.Signed
+                        || attachmentMode == SecurityTokenAttachmentMode.SignedEncrypted
+                        || attachmentMode == SecurityTokenAttachmentMode.SignedEndorsing)
+                    {
+                        AddAuthorizationPolicies(this.incomingSupportingTokens[i], policies);
+                    }
+                }
+            }
+            return new ReadOnlyCollection<IAuthorizationPolicy>(policies);
+        }
 
         public void Dispose()
         {
             // do no-op for future V2
-            if (!disposed)
+            if (!this.disposed)
             {
-                disposed = true;
+                this.disposed = true;
             }
         }
 
         void ThrowIfDisposed()
         {
-            if (disposed)
+            if (this.disposed)
             {
-                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ObjectDisposedException(GetType().FullName));
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ObjectDisposedException(this.GetType().FullName));
             }
         }
     }
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityPolicyVersion.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityPolicyVersion.cs
new file mode 100644
index 0000000..c0c694c
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityPolicyVersion.cs
@@ -0,0 +1,82 @@
+using System;
+using System.Collections.Generic;
+using System.Text;
+using System.Xml;
+
+namespace CoreWCF.Security
+{
+    public abstract class SecurityPolicyVersion
+    {
+        readonly String spNamespace;
+        readonly String prefix;
+
+        internal SecurityPolicyVersion(String ns, String prefix)
+        {
+            this.spNamespace = ns;
+            this.prefix = prefix;
+        }
+
+        public String Namespace
+        {
+            get
+            {
+                return this.spNamespace;
+            }
+        }
+
+        public String Prefix
+        {
+            get
+            {
+                return this.prefix;
+            }
+        }
+
+        public static SecurityPolicyVersion WSSecurityPolicy11
+        {
+            get { return WSSecurityPolicyVersion11.Instance; }
+        }
+
+        public static SecurityPolicyVersion WSSecurityPolicy12
+        {
+            get { return WSSecurityPolicyVersion12.Instance; }
+        }
+
+        class WSSecurityPolicyVersion11 : SecurityPolicyVersion
+        {
+            static readonly WSSecurityPolicyVersion11 instance = new WSSecurityPolicyVersion11();
+
+            protected WSSecurityPolicyVersion11()
+                : base(CoreWCF.Security.WSSecurityPolicy11.WsspNamespace, WSSecurityPolicy.WsspPrefix)
+            {
+            }
+
+            public static SecurityPolicyVersion Instance
+            {
+                get
+                {
+                    return instance;
+                }
+            }
+        }
+
+        class WSSecurityPolicyVersion12 : SecurityPolicyVersion
+        {
+            static readonly WSSecurityPolicyVersion12 instance = new WSSecurityPolicyVersion12();
+
+            protected WSSecurityPolicyVersion12()
+                : base(CoreWCF.Security.WSSecurityPolicy12.WsspNamespace, WSSecurityPolicy.WsspPrefix)
+            {
+            }
+
+            public static SecurityPolicyVersion Instance
+            {
+                get
+                {
+                    return instance;
+                }
+            }
+        }
+
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityProtocol.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityProtocol.cs
new file mode 100644
index 0000000..2c1ebbf
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityProtocol.cs
@@ -0,0 +1,649 @@
+
+using System.Collections.Generic;
+using System.Collections.ObjectModel;
+using CoreWCF.IdentityModel.Policy;
+using CoreWCF.IdentityModel.Selectors;
+using CoreWCF.IdentityModel.Tokens;
+using System.Runtime;
+using CoreWCF.Channels;
+using CoreWCF.Description;
+using CoreWCF.Security.Tokens;
+using System.Threading.Tasks;
+using System;
+using CoreWCF.Runtime;
+using CoreWCF.IdentityModel;
+using System.Threading;
+
+namespace CoreWCF.Security
+{
+    // See SecurityProtocolFactory for contracts on subclasses etc
+     abstract class SecurityProtocol : ISecurityCommunicationObject
+    {
+        private static ReadOnlyCollection<SupportingTokenProviderSpecification> s_emptyTokenProviders;
+        private Dictionary<string, Collection<SupportingTokenProviderSpecification>> _mergedSupportingTokenProvidersMap;
+       // private ChannelParameterCollection _channelParameters;
+
+        protected SecurityProtocol(SecurityProtocolFactory factory, EndpointAddress target, Uri via)
+        {
+            SecurityProtocolFactory = factory;
+            Target = target;
+            Via = via;
+            //TODO is it needed ?
+           CommunicationObject = new WrapperSecurityCommunicationObject(this);
+        }
+
+        protected WrapperSecurityCommunicationObject CommunicationObject { get; }
+
+        public SecurityProtocolFactory SecurityProtocolFactory { get; }
+
+        public EndpointAddress Target { get; }
+
+        public Uri Via { get; }
+
+        public ICollection<SupportingTokenProviderSpecification> ChannelSupportingTokenProviderSpecification { get; private set; }
+
+        public Dictionary<string, ICollection<SupportingTokenProviderSpecification>> ScopedSupportingTokenProviderSpecification { get; private set; }
+
+        private static ReadOnlyCollection<SupportingTokenProviderSpecification> EmptyTokenProviders
+        {
+            get
+            {
+                if (s_emptyTokenProviders == null)
+                {
+                    s_emptyTokenProviders = new ReadOnlyCollection<SupportingTokenProviderSpecification>(new List<SupportingTokenProviderSpecification>());
+                }
+                return s_emptyTokenProviders;
+            }
+        }
+
+
+        //public ChannelParameterCollection ChannelParameters
+        //{
+        //    get
+        //    {
+        //        return _channelParameters;
+        //    }
+        //    set
+        //    {
+        //        CommunicationObject.ThrowIfDisposedOrImmutable();
+        //        _channelParameters = value;
+        //    }
+        //}
+
+        // ISecurityCommunicationObject members
+        public TimeSpan DefaultOpenTimeout
+        {
+            get { return ServiceDefaults.OpenTimeout; }
+        }
+
+        public TimeSpan DefaultCloseTimeout
+        {
+            get { return ServiceDefaults.CloseTimeout; }
+        }
+
+        public void OnClosed() { }
+
+        public void OnClosing() { }
+
+        public void OnFaulted() { }
+
+        public void OnOpened() { }
+
+        public void OnOpening() { }
+
+        internal IList<SupportingTokenProviderSpecification> GetSupportingTokenProviders(string action)
+        {
+            if (_mergedSupportingTokenProvidersMap != null && _mergedSupportingTokenProvidersMap.Count > 0)
+            {
+                if (action != null && _mergedSupportingTokenProvidersMap.ContainsKey(action))
+                {
+                    return _mergedSupportingTokenProvidersMap[action];
+                }
+                else if (_mergedSupportingTokenProvidersMap.ContainsKey(MessageHeaders.WildcardAction))
+                {
+                    return _mergedSupportingTokenProvidersMap[MessageHeaders.WildcardAction];
+                }
+            }
+            // return null if the token providers list is empty - this gets a perf benefit since calling Count is expensive for an empty
+            // ReadOnlyCollection
+            return (ChannelSupportingTokenProviderSpecification == EmptyTokenProviders) ? null : (IList<SupportingTokenProviderSpecification>)ChannelSupportingTokenProviderSpecification;
+        }
+
+        protected InitiatorServiceModelSecurityTokenRequirement CreateInitiatorSecurityTokenRequirement()
+        {
+            InitiatorServiceModelSecurityTokenRequirement requirement = new InitiatorServiceModelSecurityTokenRequirement();
+            requirement.TargetAddress = Target;
+            requirement.Via = Via;
+            requirement.SecurityBindingElement = SecurityProtocolFactory.SecurityBindingElement;
+            requirement.SecurityAlgorithmSuite = SecurityProtocolFactory.OutgoingAlgorithmSuite;
+            requirement.MessageSecurityVersion = SecurityProtocolFactory.MessageSecurityVersion.SecurityTokenVersion;
+            //TODO
+            //if (_channelParameters != null)
+            //{
+            //    requirement.Properties[ServiceModelSecurityTokenRequirement.ChannelParametersCollectionProperty] = _channelParameters;
+            //}
+            //
+            return requirement;
+        }
+
+        private InitiatorServiceModelSecurityTokenRequirement CreateInitiatorSecurityTokenRequirement(SecurityTokenParameters parameters, SecurityTokenAttachmentMode attachmentMode)
+        {
+            InitiatorServiceModelSecurityTokenRequirement requirement = CreateInitiatorSecurityTokenRequirement();
+            parameters.InitializeSecurityTokenRequirement(requirement);
+            requirement.KeyUsage = SecurityKeyUsage.Signature;
+            requirement.Properties[ServiceModelSecurityTokenRequirement.MessageDirectionProperty] = MessageDirection.Output;
+            requirement.Properties[ServiceModelSecurityTokenRequirement.SupportingTokenAttachmentModeProperty] = attachmentMode;
+            return requirement;
+        }
+
+        private void AddSupportingTokenProviders(SupportingTokenParameters supportingTokenParameters, bool isOptional, IList<SupportingTokenProviderSpecification> providerSpecList)
+        {
+            for (int i = 0; i < supportingTokenParameters.Endorsing.Count; ++i)
+            {
+                SecurityTokenRequirement requirement = CreateInitiatorSecurityTokenRequirement(supportingTokenParameters.Endorsing[i], SecurityTokenAttachmentMode.Endorsing);
+                try
+                {
+                    if (isOptional)
+                    {
+                        requirement.IsOptionalToken = true;
+                    }
+                    SecurityTokenProvider provider = SecurityProtocolFactory.SecurityTokenManager.CreateSecurityTokenProvider(requirement);
+                    if (provider == null)
+                    {
+                        continue;
+                    }
+                    SupportingTokenProviderSpecification providerSpec = new SupportingTokenProviderSpecification(provider, SecurityTokenAttachmentMode.Endorsing, supportingTokenParameters.Endorsing[i]);
+                    providerSpecList.Add(providerSpec);
+                }
+                catch (Exception e)
+                {
+                    if (!isOptional || Fx.IsFatal(e))
+                    {
+                        throw;
+                    }
+                }
+            }
+
+            for (int i = 0; i < supportingTokenParameters.SignedEndorsing.Count; ++i)
+            {
+                SecurityTokenRequirement requirement = CreateInitiatorSecurityTokenRequirement(supportingTokenParameters.SignedEndorsing[i], SecurityTokenAttachmentMode.SignedEndorsing);
+                try
+                {
+                    if (isOptional)
+                    {
+                        requirement.IsOptionalToken = true;
+                    }
+                    SecurityTokenProvider provider = SecurityProtocolFactory.SecurityTokenManager.CreateSecurityTokenProvider(requirement);
+                    if (provider == null)
+                    {
+                        continue;
+                    }
+                    SupportingTokenProviderSpecification providerSpec = new SupportingTokenProviderSpecification(provider, SecurityTokenAttachmentMode.SignedEndorsing, supportingTokenParameters.SignedEndorsing[i]);
+                    providerSpecList.Add(providerSpec);
+                }
+                catch (Exception e)
+                {
+                    if (!isOptional || Fx.IsFatal(e))
+                    {
+                        throw;
+                    }
+                }
+            }
+
+            for (int i = 0; i < supportingTokenParameters.SignedEncrypted.Count; ++i)
+            {
+                SecurityTokenRequirement requirement = CreateInitiatorSecurityTokenRequirement(supportingTokenParameters.SignedEncrypted[i], SecurityTokenAttachmentMode.SignedEncrypted);
+                try
+                {
+                    if (isOptional)
+                    {
+                        requirement.IsOptionalToken = true;
+                    }
+                    SecurityTokenProvider provider = SecurityProtocolFactory.SecurityTokenManager.CreateSecurityTokenProvider(requirement);
+                    if (provider == null)
+                    {
+                        continue;
+                    }
+                    SupportingTokenProviderSpecification providerSpec = new SupportingTokenProviderSpecification(provider, SecurityTokenAttachmentMode.SignedEncrypted, supportingTokenParameters.SignedEncrypted[i]);
+                    providerSpecList.Add(providerSpec);
+                }
+                catch (Exception e)
+                {
+                    if (!isOptional || Fx.IsFatal(e))
+                    {
+                        throw;
+                    }
+                }
+            }
+
+            for (int i = 0; i < supportingTokenParameters.Signed.Count; ++i)
+            {
+                SecurityTokenRequirement requirement = CreateInitiatorSecurityTokenRequirement(supportingTokenParameters.Signed[i], SecurityTokenAttachmentMode.Signed);
+                try
+                {
+                    if (isOptional)
+                    {
+                        requirement.IsOptionalToken = true;
+                    }
+                    SecurityTokenProvider provider = SecurityProtocolFactory.SecurityTokenManager.CreateSecurityTokenProvider(requirement);
+                    if (provider == null)
+                    {
+                        continue;
+                    }
+                    SupportingTokenProviderSpecification providerSpec = new SupportingTokenProviderSpecification(provider, SecurityTokenAttachmentMode.Signed, supportingTokenParameters.Signed[i]);
+                    providerSpecList.Add(providerSpec);
+                }
+                catch (Exception e)
+                {
+                    if (!isOptional || Fx.IsFatal(e))
+                    {
+                        throw;
+                    }
+                }
+            }
+        }
+
+        private async Task MergeSupportingTokenProvidersAsync(TimeSpan timeout)
+        {
+            if (ScopedSupportingTokenProviderSpecification.Count == 0)
+            {
+                _mergedSupportingTokenProvidersMap = null;
+            }
+            else
+            {
+                TimeoutHelper timeoutHelper = new TimeoutHelper(timeout);
+                SecurityProtocolFactory.ExpectSupportingTokens = true;
+                _mergedSupportingTokenProvidersMap = new Dictionary<string, Collection<SupportingTokenProviderSpecification>>();
+                foreach (string action in ScopedSupportingTokenProviderSpecification.Keys)
+                {
+                    ICollection<SupportingTokenProviderSpecification> scopedProviders = ScopedSupportingTokenProviderSpecification[action];
+                    if (scopedProviders == null || scopedProviders.Count == 0)
+                    {
+                        continue;
+                    }
+                    Collection<SupportingTokenProviderSpecification> mergedProviders = new Collection<SupportingTokenProviderSpecification>();
+                    foreach (SupportingTokenProviderSpecification spec in ChannelSupportingTokenProviderSpecification)
+                    {
+                        mergedProviders.Add(spec);
+                    }
+                    foreach (SupportingTokenProviderSpecification spec in scopedProviders)
+                    {
+                        await SecurityUtils.OpenTokenProviderIfRequiredAsync(spec.TokenProvider, timeoutHelper.GetCancellationToken());
+                        if (spec.SecurityTokenAttachmentMode == SecurityTokenAttachmentMode.Endorsing || spec.SecurityTokenAttachmentMode == SecurityTokenAttachmentMode.SignedEndorsing)
+                        {
+                            if (spec.TokenParameters.RequireDerivedKeys && !spec.TokenParameters.HasAsymmetricKey)
+                            {
+                                SecurityProtocolFactory.ExpectKeyDerivation = true;
+                            }
+                        }
+                        mergedProviders.Add(spec);
+                    }
+                    _mergedSupportingTokenProvidersMap.Add(action, mergedProviders);
+                }
+            }
+        }
+
+        public virtual async Task OnOpenAsync(TimeSpan timeout)
+        {
+            TimeoutHelper timeoutHelper = new TimeoutHelper(timeout);
+            if (SecurityProtocolFactory.ActAsInitiator)
+            {
+                ChannelSupportingTokenProviderSpecification = new Collection<SupportingTokenProviderSpecification>();
+                ScopedSupportingTokenProviderSpecification = new Dictionary<string, ICollection<SupportingTokenProviderSpecification>>();
+
+                AddSupportingTokenProviders(SecurityProtocolFactory.SecurityBindingElement.EndpointSupportingTokenParameters, false, (IList<SupportingTokenProviderSpecification>)ChannelSupportingTokenProviderSpecification);
+                AddSupportingTokenProviders(SecurityProtocolFactory.SecurityBindingElement.OptionalEndpointSupportingTokenParameters, true, (IList<SupportingTokenProviderSpecification>)ChannelSupportingTokenProviderSpecification);
+                foreach (string action in SecurityProtocolFactory.SecurityBindingElement.OperationSupportingTokenParameters.Keys)
+                {
+                    Collection<SupportingTokenProviderSpecification> providerSpecList = new Collection<SupportingTokenProviderSpecification>();
+                    AddSupportingTokenProviders(SecurityProtocolFactory.SecurityBindingElement.OperationSupportingTokenParameters[action], false, providerSpecList);
+                    ScopedSupportingTokenProviderSpecification.Add(action, providerSpecList);
+                }
+
+                foreach (string action in SecurityProtocolFactory.SecurityBindingElement.OptionalOperationSupportingTokenParameters.Keys)
+                {
+                    Collection<SupportingTokenProviderSpecification> providerSpecList;
+                    ICollection<SupportingTokenProviderSpecification> existingList;
+                    if (ScopedSupportingTokenProviderSpecification.TryGetValue(action, out existingList))
+                    {
+                        providerSpecList = ((Collection<SupportingTokenProviderSpecification>)existingList);
+                    }
+                    else
+                    {
+                        providerSpecList = new Collection<SupportingTokenProviderSpecification>();
+                        ScopedSupportingTokenProviderSpecification.Add(action, providerSpecList);
+                    }
+
+                    AddSupportingTokenProviders(SecurityProtocolFactory.SecurityBindingElement.OptionalOperationSupportingTokenParameters[action], true, providerSpecList);
+                }
+
+                if (!ChannelSupportingTokenProviderSpecification.IsReadOnly)
+                {
+                    if (ChannelSupportingTokenProviderSpecification.Count == 0)
+                    {
+                        ChannelSupportingTokenProviderSpecification = EmptyTokenProviders;
+                    }
+                    else
+                    {
+                        SecurityProtocolFactory.ExpectSupportingTokens = true;
+                        foreach (SupportingTokenProviderSpecification tokenProviderSpec in ChannelSupportingTokenProviderSpecification)
+                        {
+                            SecurityUtils.OpenTokenProviderIfRequired(tokenProviderSpec.TokenProvider, timeoutHelper.RemainingTime());
+                            if (tokenProviderSpec.SecurityTokenAttachmentMode == SecurityTokenAttachmentMode.Endorsing || tokenProviderSpec.SecurityTokenAttachmentMode == SecurityTokenAttachmentMode.SignedEndorsing)
+                            {
+                                if (tokenProviderSpec.TokenParameters.RequireDerivedKeys && !tokenProviderSpec.TokenParameters.HasAsymmetricKey)
+                                {
+                                    SecurityProtocolFactory.ExpectKeyDerivation = true;
+                                }
+                            }
+                        }
+                        ChannelSupportingTokenProviderSpecification =
+                            new ReadOnlyCollection<SupportingTokenProviderSpecification>((Collection<SupportingTokenProviderSpecification>)ChannelSupportingTokenProviderSpecification);
+                    }
+                }
+                // create a merged map of the per operation supporting tokens
+                await MergeSupportingTokenProvidersAsync(timeoutHelper.RemainingTime());
+            }
+        }
+
+        public virtual void OnAbort()
+        {
+            if (SecurityProtocolFactory.ActAsInitiator)
+            {
+
+                foreach (SupportingTokenProviderSpecification spec in ChannelSupportingTokenProviderSpecification)
+                {
+                    SecurityUtils.AbortTokenProviderIfRequired(spec.TokenProvider);
+                }
+                foreach (string action in ScopedSupportingTokenProviderSpecification.Keys)
+                {
+                    ICollection<SupportingTokenProviderSpecification> supportingProviders = ScopedSupportingTokenProviderSpecification[action];
+                    foreach (SupportingTokenProviderSpecification spec in supportingProviders)
+                    {
+                        SecurityUtils.AbortTokenProviderIfRequired(spec.TokenProvider);
+                    }
+                }
+            }
+        }
+
+        //public virtual async Task OnCloseAsync(CancellationToken token)
+        //{
+        //    if (SecurityProtocolFactory.ActAsInitiator)
+        //    {
+        //        /*
+        //        TimeoutHelper timeoutHelper = new TimeoutHelper(timeout);
+        //        foreach (SupportingTokenProviderSpecification spec in ChannelSupportingTokenProviderSpecification)
+        //        {
+        //            await SecurityUtils.CloseTokenProviderIfRequiredAsync(spec.TokenProvider, timeoutHelper.RemainingTime());
+        //        }
+
+        //        foreach (string action in ScopedSupportingTokenProviderSpecification.Keys)
+        //        {
+        //            ICollection<SupportingTokenProviderSpecification> supportingProviders = ScopedSupportingTokenProviderSpecification[action];
+        //            foreach (SupportingTokenProviderSpecification spec in supportingProviders)
+        //            {
+        //                await SecurityUtils.CloseTokenProviderIfRequiredAsync(spec.TokenProvider, timeoutHelper.RemainingTime());
+        //            }
+        //        }*/
+        //    }
+        //}
+
+        private static void SetSecurityHeaderId(SendSecurityHeader securityHeader, Message message)
+        {
+            SecurityMessageProperty messageProperty = message.Properties.Security;
+            if (messageProperty != null)
+            {
+                securityHeader.IdPrefix = messageProperty.SenderIdPrefix;
+            }
+        }
+
+        private void AddSupportingTokenSpecification(SecurityMessageProperty security, IList<SecurityToken> tokens, SecurityTokenAttachmentMode attachmentMode, IDictionary<SecurityToken, ReadOnlyCollection<IAuthorizationPolicy>> tokenPoliciesMapping)
+        {
+            if (tokens == null || tokens.Count == 0)
+            {
+                return;
+            }
+
+            for (int i = 0; i < tokens.Count; ++i)
+            {
+                security.IncomingSupportingTokens.Add(new SupportingTokenSpecification(tokens[i], tokenPoliciesMapping[tokens[i]], attachmentMode));
+            }
+        }
+
+        protected void AddSupportingTokenSpecification(SecurityMessageProperty security, IList<SecurityToken> basicTokens, IList<SecurityToken> endorsingTokens, IList<SecurityToken> signedEndorsingTokens, IList<SecurityToken> signedTokens, IDictionary<SecurityToken, ReadOnlyCollection<IAuthorizationPolicy>> tokenPoliciesMapping)
+        {
+            AddSupportingTokenSpecification(security, basicTokens, SecurityTokenAttachmentMode.SignedEncrypted, tokenPoliciesMapping);
+            AddSupportingTokenSpecification(security, endorsingTokens, SecurityTokenAttachmentMode.Endorsing, tokenPoliciesMapping);
+            AddSupportingTokenSpecification(security, signedEndorsingTokens, SecurityTokenAttachmentMode.SignedEndorsing, tokenPoliciesMapping);
+            AddSupportingTokenSpecification(security, signedTokens, SecurityTokenAttachmentMode.Signed, tokenPoliciesMapping);
+        }
+
+        protected SendSecurityHeader CreateSendSecurityHeader(Message message, string actor, SecurityProtocolFactory factory)
+        {
+            return CreateSendSecurityHeader(message, actor, factory, true);
+        }
+
+        protected SendSecurityHeader CreateSendSecurityHeaderForTransportProtocol(Message message, string actor, SecurityProtocolFactory factory)
+        {
+            return CreateSendSecurityHeader(message, actor, factory, false);
+        }
+
+        private SendSecurityHeader CreateSendSecurityHeader(Message message, string actor, SecurityProtocolFactory factory, bool requireMessageProtection)
+        {
+            MessageDirection transferDirection = factory.ActAsInitiator ? MessageDirection.Input : MessageDirection.Output;
+            SendSecurityHeader sendSecurityHeader = factory.StandardsManager.CreateSendSecurityHeader(
+                message,
+                actor, true, false,
+                factory.OutgoingAlgorithmSuite, transferDirection);
+            sendSecurityHeader.Layout = factory.SecurityHeaderLayout;
+            sendSecurityHeader.RequireMessageProtection = requireMessageProtection;
+            SetSecurityHeaderId(sendSecurityHeader, message);
+            if (factory.AddTimestamp)
+            {
+                sendSecurityHeader.AddTimestamp(factory.TimestampValidityDuration);
+            }
+
+            sendSecurityHeader.StreamBufferManager = factory.StreamBufferManager;
+            return sendSecurityHeader;
+        }
+
+        internal void AddMessageSupportingTokens(Message message, ref IList<SupportingTokenSpecification> supportingTokens)
+        {
+            SecurityMessageProperty supportingTokensProperty = message.Properties.Security;
+            if (supportingTokensProperty != null && supportingTokensProperty.HasOutgoingSupportingTokens)
+            {
+                if (supportingTokens == null)
+                {
+                    supportingTokens = new Collection<SupportingTokenSpecification>();
+                }
+
+                for (int i = 0; i < supportingTokensProperty.OutgoingSupportingTokens.Count; ++i)
+                {
+                    SupportingTokenSpecification spec = supportingTokensProperty.OutgoingSupportingTokens[i];
+                    if (spec.SecurityTokenParameters == null)
+                    {
+                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new MessageSecurityException(SR.SenderSideSupportingTokensMustSpecifySecurityTokenParameters));
+                    }
+                    supportingTokens.Add(spec);
+                }
+            }
+        }
+
+        internal async Task<IList<SupportingTokenSpecification>> TryGetSupportingTokensAsync(SecurityProtocolFactory factory, EndpointAddress target, Uri via, Message message, TimeSpan timeout)
+        {
+            IList<SupportingTokenSpecification> supportingTokens = null;
+            if (!factory.ActAsInitiator)
+            {
+                return null;
+            }
+
+            if (message == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(message));
+            }
+
+            TimeoutHelper timeoutHelper = new TimeoutHelper(timeout);
+            IList<SupportingTokenProviderSpecification> supportingTokenProviders = GetSupportingTokenProviders(message.Headers.Action);
+            if (supportingTokenProviders != null && supportingTokenProviders.Count > 0)
+            {
+                supportingTokens = new Collection<SupportingTokenSpecification>();
+                for (int i = 0; i < supportingTokenProviders.Count; ++i)
+                {
+                    SupportingTokenProviderSpecification spec = supportingTokenProviders[i];
+                    SecurityToken supportingToken;
+                    supportingToken = await spec.TokenProvider.GetTokenAsync(timeoutHelper.GetCancellationToken());
+
+                    supportingTokens.Add(new SupportingTokenSpecification(supportingToken, EmptyReadOnlyCollection<IAuthorizationPolicy>.Instance, spec.SecurityTokenAttachmentMode, spec.TokenParameters));
+                }
+            }
+
+            // add any runtime supporting tokens
+            AddMessageSupportingTokens(message, ref supportingTokens);
+            return supportingTokens;
+        }
+
+        protected ReadOnlyCollection<SecurityTokenResolver> MergeOutOfBandResolvers(IList<SupportingTokenAuthenticatorSpecification> supportingAuthenticators, ReadOnlyCollection<SecurityTokenResolver> primaryResolvers)
+        {
+            Collection<SecurityTokenResolver> outOfBandResolvers = null;
+            if (supportingAuthenticators != null && supportingAuthenticators.Count > 0)
+            {
+                for (int i = 0; i < supportingAuthenticators.Count; ++i)
+                {
+                    if (supportingAuthenticators[i].TokenResolver != null)
+                    {
+                        outOfBandResolvers = outOfBandResolvers ?? new Collection<SecurityTokenResolver>();
+                        outOfBandResolvers.Add(supportingAuthenticators[i].TokenResolver);
+                    }
+                }
+            }
+
+            if (outOfBandResolvers != null)
+            {
+                if (primaryResolvers != null)
+                {
+                    for (int i = 0; i < primaryResolvers.Count; ++i)
+                    {
+                        outOfBandResolvers.Insert(0, primaryResolvers[i]);
+                    }
+                }
+                return new ReadOnlyCollection<SecurityTokenResolver>(outOfBandResolvers);
+            }
+            else
+            {
+                return primaryResolvers ?? EmptyReadOnlyCollection<SecurityTokenResolver>.Instance;
+            }
+        }
+
+        protected void AddSupportingTokens(SendSecurityHeader securityHeader, IList<SupportingTokenSpecification> supportingTokens)
+        {
+            if (supportingTokens != null)
+            {
+                for (int i = 0; i < supportingTokens.Count; ++i)
+                {
+                    SecurityToken token = supportingTokens[i].SecurityToken;
+                    SecurityTokenParameters tokenParameters = supportingTokens[i].SecurityTokenParameters;
+                    switch (supportingTokens[i].SecurityTokenAttachmentMode)
+                    {
+                        case SecurityTokenAttachmentMode.Signed:
+                            securityHeader.AddSignedSupportingToken(token, tokenParameters);
+                            break;
+                        case SecurityTokenAttachmentMode.Endorsing:
+                            securityHeader.AddEndorsingSupportingToken(token, tokenParameters);
+                            break;
+                        case SecurityTokenAttachmentMode.SignedEncrypted:
+                            securityHeader.AddBasicSupportingToken(token, tokenParameters);
+                            break;
+                        case SecurityTokenAttachmentMode.SignedEndorsing:
+                            securityHeader.AddSignedEndorsingSupportingToken(token, tokenParameters);
+                            break;
+                        default:
+                            Fx.Assert("Unknown token attachment mode " + supportingTokens[i].SecurityTokenAttachmentMode.ToString());
+                            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new NotSupportedException(SR.Format(SR.UnknownTokenAttachmentMode, supportingTokens[i].SecurityTokenAttachmentMode.ToString())));
+                    }
+                }
+            }
+        }
+
+        internal static async Task<SecurityToken> GetTokenAsync(SecurityTokenProvider provider, EndpointAddress target, TimeSpan timeout)
+        {
+            if (provider == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new MessageSecurityException(SR.Format(SR.TokenProviderCannotGetTokensForTarget, target)));
+            }
+
+            SecurityToken token = null;
+
+            try
+            {
+                token = await provider.GetTokenAsync(new TimeoutHelper(timeout).GetCancellationToken());
+            }
+            catch (SecurityTokenException exception)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new MessageSecurityException(SR.Format(SR.TokenProviderCannotGetTokensForTarget, target), exception));
+            }
+            catch (SecurityNegotiationException sne)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new SecurityNegotiationException(SR.Format(SR.TokenProviderCannotGetTokensForTarget, target), sne));
+            }
+
+            return token;
+        }
+
+        public abstract Task<Message> SecureOutgoingMessageAsync(Message message, CancellationToken token);
+
+        // subclasses that offer correlation should override this version
+        public virtual async Task<(SecurityProtocolCorrelationState, Message)> SecureOutgoingMessageAsync(Message message , CancellationToken token, SecurityProtocolCorrelationState correlationState)
+        {
+            return (null, await SecureOutgoingMessageAsync(message, token));
+        }
+
+        protected virtual void OnOutgoingMessageSecured(Message securedMessage)
+        {
+        }
+
+        protected virtual void OnSecureOutgoingMessageFailure(Message message)
+        {
+        }
+
+        public abstract void VerifyIncomingMessage(ref Message message, TimeSpan timeout);
+
+        // subclasses that offer correlation should override this version
+        public virtual SecurityProtocolCorrelationState VerifyIncomingMessage(ref Message message, TimeSpan timeout, params SecurityProtocolCorrelationState[] correlationStates)
+        {
+            VerifyIncomingMessage(ref message, timeout);
+            return null;
+        }
+
+        protected virtual void OnIncomingMessageVerified(Message verifiedMessage)
+        {
+        }
+
+        protected virtual void OnVerifyIncomingMessageFailure(Message message, Exception exception)
+        {
+        }
+        protected IList<SupportingTokenAuthenticatorSpecification> GetSupportingTokenAuthenticatorsAndSetExpectationFlags(SecurityProtocolFactory factory, Message message,
+    ReceiveSecurityHeader securityHeader)
+        {
+
+            if (message == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("message");
+            }
+            bool expectBasicTokens;
+            bool expectSignedTokens;
+            bool expectEndorsingTokens;
+            IList<SupportingTokenAuthenticatorSpecification> authenticators = factory.GetSupportingTokenAuthenticators(message.Headers.Action,
+                out expectSignedTokens, out expectBasicTokens, out expectEndorsingTokens);
+            securityHeader.ExpectBasicTokens = expectBasicTokens;
+            securityHeader.ExpectEndorsingTokens = expectEndorsingTokens;
+            securityHeader.ExpectSignedTokens = expectSignedTokens;
+            return authenticators;
+        }
+
+        public Task OnCloseAsync(TimeSpan timeout)
+        {
+            return Task.CompletedTask;
+           // throw new NotImplementedException();
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityProtocolCorrelationState.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityProtocolCorrelationState.cs
new file mode 100644
index 0000000..d774d7b
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityProtocolCorrelationState.cs
@@ -0,0 +1,38 @@
+using CoreWCF.IdentityModel.Claims;
+using CoreWCF;
+using CoreWCF.IdentityModel.Policy;
+using CoreWCF.IdentityModel.Tokens;
+using CoreWCF.Security.Tokens;
+using CoreWCF.Diagnostics;
+
+namespace CoreWCF.Security
+{
+    class SecurityProtocolCorrelationState
+    {
+        SecurityToken token;
+        SignatureConfirmations signatureConfirmations;
+       // ServiceModelActivity activity;
+
+        public SecurityProtocolCorrelationState(SecurityToken token)
+        {
+            this.token = token;
+          //  this.activity = DiagnosticUtility.ShouldUseActivity ? ServiceModelActivity.Current : null;
+        }
+
+        public SecurityToken Token
+        {
+            get { return this.token; }
+        }
+
+        internal SignatureConfirmations SignatureConfirmations
+        {
+            get { return this.signatureConfirmations; }
+            set { this.signatureConfirmations = value; }
+        }
+
+        //internal ServiceModelActivity Activity
+        //{
+        //    get { return this.activity; }
+        //}
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityProtocolFactory.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityProtocolFactory.cs
new file mode 100644
index 0000000..3fae983
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityProtocolFactory.cs
@@ -0,0 +1,1118 @@
+using System.Collections.Generic;
+using System.Collections.ObjectModel;
+using CoreWCF.IdentityModel.Selectors;
+using CoreWCF.IdentityModel.Tokens;
+using System.Runtime;
+using System.Security.Authentication.ExtendedProtection;
+using CoreWCF;
+using CoreWCF.Channels;
+using CoreWCF.Description;
+using CoreWCF.Dispatcher;
+using CoreWCF.Security.Tokens;
+using System.Globalization;
+using System;
+using CoreWCF.Runtime;
+using System.Threading.Tasks;
+
+namespace CoreWCF.Security
+{
+
+
+    /*
+     * See
+     * http://xws/gxa/main/specs/security/security_profiles/SecurityProfiles.doc
+     * for details on security protocols
+
+     * Concrete implementations are required to me thread safe after
+     * Open() is called;
+
+     * instances of concrete protocol factories are scoped to a
+     * channel/listener factory;
+
+     * Each channel/listener factory must have a
+     * SecurityProtocolFactory set on it before open/first use; the
+     * factory instance cannot be changed once the factory is opened
+     * or listening;
+
+     * security protocol instances are scoped to a channel and will be
+     * created by the Create calls on protocol factories;
+
+     * security protocol instances are required to be thread-safe.
+
+     * for typical subclasses, factory wide state and immutable
+     * settings are expected to be on the ProtocolFactory itself while
+     * channel-wide state is maintained internally in each security
+     * protocol instance;
+
+     * the security protocol instance set on a channel cannot be
+     * changed; however, the protocol instance may change internal
+     * state; this covers RM's SCT renego case; by keeping state
+     * change internal to protocol instances, we get better
+     * coordination with concurrent message security on channels;
+
+     * the primary pivot in creating a security protocol instance is
+     * initiator (client) vs. responder (server), NOT sender vs
+     * receiver
+
+     * Create calls for input and reply channels will contain the
+     * listener-wide state (if any) created by the corresponding call
+     * on the factory;
+
+     */
+
+    // Whether we need to add support for targetting different SOAP roles is tracked by 19144
+ 
+   public abstract class SecurityProtocolFactory 
+    {
+        internal const bool defaultAddTimestamp = true;
+        internal const bool defaultDeriveKeys = true;
+        internal const bool defaultDetectReplays = true;
+        internal const string defaultMaxClockSkewString = "00:05:00";
+        internal const string defaultReplayWindowString = "00:05:00";
+        internal static readonly TimeSpan defaultMaxClockSkew = TimeSpan.Parse(defaultMaxClockSkewString, CultureInfo.InvariantCulture);
+        internal static readonly TimeSpan defaultReplayWindow = TimeSpan.Parse(defaultReplayWindowString, CultureInfo.InvariantCulture);
+        internal const int defaultMaxCachedNonces = 900000;
+        internal const string defaultTimestampValidityDurationString = "00:05:00";
+        internal static readonly TimeSpan defaultTimestampValidityDuration = TimeSpan.Parse(defaultTimestampValidityDurationString, CultureInfo.InvariantCulture);
+        internal const SecurityHeaderLayout defaultSecurityHeaderLayout = SecurityHeaderLayout.Strict;
+
+        static ReadOnlyCollection<SupportingTokenAuthenticatorSpecification> emptyTokenAuthenticators;
+
+        bool actAsInitiator;
+        bool isDuplexReply;
+        bool addTimestamp = defaultAddTimestamp;
+        bool detectReplays = defaultDetectReplays;
+        bool expectIncomingMessages;
+        bool expectOutgoingMessages;
+        SecurityAlgorithmSuite incomingAlgorithmSuite = SecurityAlgorithmSuite.Default;
+
+
+        // per receiver protocol factory lists
+        ICollection<SupportingTokenAuthenticatorSpecification> channelSupportingTokenAuthenticatorSpecification;
+        Dictionary<string, ICollection<SupportingTokenAuthenticatorSpecification>> scopedSupportingTokenAuthenticatorSpecification;        
+        Dictionary<string, MergedSupportingTokenAuthenticatorSpecification> mergedSupportingTokenAuthenticatorsMap;
+
+        int maxCachedNonces = defaultMaxCachedNonces;
+        TimeSpan maxClockSkew = defaultMaxClockSkew;
+        NonceCache nonceCache = null;
+        SecurityAlgorithmSuite outgoingAlgorithmSuite = SecurityAlgorithmSuite.Default;
+        TimeSpan replayWindow = defaultReplayWindow;
+        SecurityStandardsManager standardsManager = SecurityStandardsManager.DefaultInstance;
+        SecurityTokenManager securityTokenManager;
+        SecurityBindingElement securityBindingElement;
+        string requestReplyErrorPropertyName;
+        NonValidatingSecurityTokenAuthenticator<DerivedKeySecurityToken> derivedKeyTokenAuthenticator;
+        TimeSpan timestampValidityDuration = defaultTimestampValidityDuration;
+       // AuditLogLocation auditLogLocation;
+        bool suppressAuditFailure;
+        SecurityHeaderLayout securityHeaderLayout;
+       // AuditLevel serviceAuthorizationAuditLevel;
+       // AuditLevel messageAuthenticationAuditLevel;
+        bool expectKeyDerivation;
+        bool expectChannelBasicTokens;
+        bool expectChannelSignedTokens;
+        bool expectChannelEndorsingTokens;
+        bool expectSupportingTokens;
+        Uri listenUri;
+        MessageSecurityVersion messageSecurityVersion;
+       // WrapperSecurityCommunicationObject communicationObject;
+        Uri privacyNoticeUri;
+        int privacyNoticeVersion;
+        IMessageFilterTable<EndpointAddress> endpointFilterTable;
+        ExtendedProtectionPolicy extendedProtectionPolicy;
+        BufferManager streamBufferManager = null;
+
+        protected SecurityProtocolFactory()
+        {
+            this.channelSupportingTokenAuthenticatorSpecification = new Collection<SupportingTokenAuthenticatorSpecification>();
+            this.scopedSupportingTokenAuthenticatorSpecification = new Dictionary<string, ICollection<SupportingTokenAuthenticatorSpecification>>();
+            //TODO do we need this ? 
+            //  this.communicationObject = new WrapperSecurityCommunicationObject(this);
+        }
+
+        internal SecurityProtocolFactory(SecurityProtocolFactory factory)
+            : this()
+        {
+            if (factory == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("factory");
+            }
+
+            this.actAsInitiator = factory.actAsInitiator;
+            this.addTimestamp = factory.addTimestamp;
+            this.detectReplays = factory.detectReplays;
+            this.incomingAlgorithmSuite = factory.incomingAlgorithmSuite;
+            this.maxCachedNonces = factory.maxCachedNonces;
+            this.maxClockSkew = factory.maxClockSkew;
+            this.outgoingAlgorithmSuite = factory.outgoingAlgorithmSuite;
+            this.replayWindow = factory.replayWindow;
+            this.channelSupportingTokenAuthenticatorSpecification = new Collection<SupportingTokenAuthenticatorSpecification>(new List<SupportingTokenAuthenticatorSpecification>(factory.channelSupportingTokenAuthenticatorSpecification));
+            this.scopedSupportingTokenAuthenticatorSpecification = new Dictionary<string, ICollection<SupportingTokenAuthenticatorSpecification>>(factory.scopedSupportingTokenAuthenticatorSpecification);
+            this.standardsManager = factory.standardsManager;
+            this.timestampValidityDuration = factory.timestampValidityDuration;
+           // this.auditLogLocation = factory.auditLogLocation;
+            this.suppressAuditFailure = factory.suppressAuditFailure;
+           // this.serviceAuthorizationAuditLevel = factory.serviceAuthorizationAuditLevel;
+           // this.messageAuthenticationAuditLevel = factory.messageAuthenticationAuditLevel;
+            if (factory.securityBindingElement != null)
+            {
+                this.securityBindingElement = (SecurityBindingElement) factory.securityBindingElement.Clone();
+            }
+            this.securityTokenManager = factory.securityTokenManager;
+            this.privacyNoticeUri = factory.privacyNoticeUri;
+            this.privacyNoticeVersion = factory.privacyNoticeVersion;
+            this.endpointFilterTable = factory.endpointFilterTable;
+            this.extendedProtectionPolicy = factory.extendedProtectionPolicy;
+            this.nonceCache = factory.nonceCache;
+        }
+
+        //protected WrapperSecurityCommunicationObject CommunicationObject
+        //{
+        //    get { return this.communicationObject; } 
+        //}
+
+        // The ActAsInitiator value is set automatically on Open and
+        // remains unchanged thereafter.  ActAsInitiator is true for
+        // the initiator of the message exchange, such as the sender
+        // of a datagram, sender of a request and sender of either leg
+        // of a duplex exchange.
+        public bool ActAsInitiator
+        {
+            get
+            {
+                return this.actAsInitiator;
+            }
+        }
+
+        public BufferManager StreamBufferManager
+        {
+            get
+            {
+                if (this.streamBufferManager == null)
+                {
+                    this.streamBufferManager = BufferManager.CreateBufferManager(0, int.MaxValue);
+                }
+
+                return this.streamBufferManager;
+            }
+            set
+            {
+                this.streamBufferManager = value;
+            }
+        }
+
+        public ExtendedProtectionPolicy ExtendedProtectionPolicy
+        {
+            get { return this.extendedProtectionPolicy; }
+            set { this.extendedProtectionPolicy = value; }
+        }
+
+        internal bool IsDuplexReply
+        {
+            get
+            {
+                return this.isDuplexReply;
+            }
+            set
+            {
+                this.isDuplexReply = value;
+            }
+        }
+
+        public bool AddTimestamp
+        {
+            get
+            {
+                return this.addTimestamp;
+            }
+            set
+            {
+                ThrowIfImmutable();
+                this.addTimestamp = value;
+            }
+        }
+
+        //public AuditLogLocation AuditLogLocation
+        //{
+        //    get
+        //    {
+        //        return this.auditLogLocation;
+        //    }
+        //    set
+        //    {
+        //        ThrowIfImmutable();
+        //        AuditLogLocationHelper.Validate(value);
+        //        this.auditLogLocation = value;
+        //    }
+        //}
+
+        //public bool SuppressAuditFailure
+        //{
+        //    get
+        //    {
+        //        return this.suppressAuditFailure;
+        //    }
+        //    set
+        //    {
+        //        ThrowIfImmutable();
+        //        this.suppressAuditFailure = value;
+        //    }
+        //}
+
+        //public AuditLevel ServiceAuthorizationAuditLevel
+        //{
+        //    get
+        //    {
+        //        return this.serviceAuthorizationAuditLevel;
+        //    }
+        //    set
+        //    {
+        //        ThrowIfImmutable();
+        //        AuditLevelHelper.Validate(value);
+        //        this.serviceAuthorizationAuditLevel = value;
+        //    }
+        //}
+
+        //public AuditLevel MessageAuthenticationAuditLevel
+        //{
+        //    get
+        //    {
+        //        return this.messageAuthenticationAuditLevel;
+        //    }
+        //    set
+        //    {
+        //        ThrowIfImmutable();
+        //        AuditLevelHelper.Validate(value);
+        //        this.messageAuthenticationAuditLevel = value;
+        //    }
+        //}
+
+
+        public bool DetectReplays
+        {
+            get
+            {
+                return this.detectReplays;
+            }
+            set
+            {
+                ThrowIfImmutable();
+                this.detectReplays = value;
+            }
+        }
+
+        public Uri PrivacyNoticeUri
+        {
+            get 
+            {
+                return this.privacyNoticeUri; 
+            }
+            set
+            {
+                ThrowIfImmutable();
+                this.privacyNoticeUri = value;
+            }
+        }
+
+        public int PrivacyNoticeVersion
+        {
+            get
+            {
+                return this.privacyNoticeVersion;
+            }
+            set
+            {
+                ThrowIfImmutable();
+                this.privacyNoticeVersion = value;
+            }
+        }
+
+        internal IMessageFilterTable<EndpointAddress> EndpointFilterTable
+        {
+            get
+            {
+                return this.endpointFilterTable;
+            }
+            set
+            {
+                ThrowIfImmutable();
+                this.endpointFilterTable = value;
+            }
+        }
+
+        static ReadOnlyCollection<SupportingTokenAuthenticatorSpecification> EmptyTokenAuthenticators
+        {
+            get
+            {
+                if (emptyTokenAuthenticators == null)
+                {
+                    emptyTokenAuthenticators = Array.AsReadOnly(new SupportingTokenAuthenticatorSpecification[0]);
+                }
+                return emptyTokenAuthenticators;
+            }
+        }
+
+        internal NonValidatingSecurityTokenAuthenticator<DerivedKeySecurityToken> DerivedKeyTokenAuthenticator
+        {
+            get
+            {
+                return this.derivedKeyTokenAuthenticator;
+            }
+        }
+
+        internal bool ExpectIncomingMessages
+        {
+            get
+            {
+                return this.expectIncomingMessages;
+            }
+        }
+
+        internal bool ExpectOutgoingMessages
+        {
+            get
+            {
+                return this.expectOutgoingMessages;
+            }
+        }
+
+        internal bool ExpectKeyDerivation
+        {
+            get { return this.expectKeyDerivation; }
+            set { this.expectKeyDerivation = value; }
+        }
+
+        internal bool ExpectSupportingTokens
+        {
+            get { return this.expectSupportingTokens; }
+            set { this.expectSupportingTokens = value; }
+        }
+
+        public SecurityAlgorithmSuite IncomingAlgorithmSuite
+        {
+            get
+            {
+                return this.incomingAlgorithmSuite;
+            }
+            set
+            {
+                ThrowIfImmutable();
+                if (value == null)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException("value"));
+                }
+                this.incomingAlgorithmSuite = value;
+            }
+        }
+
+        //protected bool IsReadOnly
+        //{
+        //    get
+        //    {
+        //        return this.CommunicationObject.State != CommunicationState.Created;
+        //    }
+        //}
+
+        public int MaxCachedNonces
+        {
+            get
+            {
+                return this.maxCachedNonces;
+            }
+            set
+            {
+                ThrowIfImmutable();
+                if (value <= 0)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("value"));
+                }
+                this.maxCachedNonces = value;
+            }
+        }
+
+        public TimeSpan MaxClockSkew
+        {
+            get
+            {
+                return this.maxClockSkew;
+            }
+            set
+            {
+                ThrowIfImmutable();
+                if (value < TimeSpan.Zero)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("value"));
+                }
+                this.maxClockSkew = value;
+            }
+        }
+
+        public NonceCache NonceCache
+        {
+            get
+            {
+                return this.nonceCache;
+            }
+            set
+            {
+                ThrowIfImmutable();
+                this.nonceCache = value;
+            }
+        }
+        
+        public SecurityAlgorithmSuite OutgoingAlgorithmSuite
+        {
+            get
+            {
+                return this.outgoingAlgorithmSuite;
+            }
+            set
+            {
+                ThrowIfImmutable();
+                if (value == null)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException("value"));
+                }
+                this.outgoingAlgorithmSuite = value;
+            }
+        }
+
+        public TimeSpan ReplayWindow
+        {
+            get
+            {
+                return this.replayWindow;
+            }
+            set
+            {
+                ThrowIfImmutable();
+                if (value <= TimeSpan.Zero)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("value", SR.Format(SR.TimeSpanMustbeGreaterThanTimeSpanZero)));
+                }
+                this.replayWindow = value;
+            }
+        }
+
+        public ICollection<SupportingTokenAuthenticatorSpecification> ChannelSupportingTokenAuthenticatorSpecification
+        {
+            get 
+            {
+                return this.channelSupportingTokenAuthenticatorSpecification;
+            }
+        }
+
+        public Dictionary<string, ICollection<SupportingTokenAuthenticatorSpecification>> ScopedSupportingTokenAuthenticatorSpecification
+        {
+            get
+            {
+                return this.scopedSupportingTokenAuthenticatorSpecification;
+            }
+        }
+
+        public SecurityBindingElement SecurityBindingElement
+        {
+            get { return this.securityBindingElement; }
+            set
+            {
+                ThrowIfImmutable();
+                if (value != null)
+                {
+                    value = (SecurityBindingElement) value.Clone();
+                }
+                this.securityBindingElement = value;
+            }
+        }
+
+       internal SecurityTokenManager SecurityTokenManager
+        {
+            get { return this.securityTokenManager; }
+            set
+            {
+                ThrowIfImmutable();
+                this.securityTokenManager = value;
+            }
+        }
+
+        public virtual bool SupportsDuplex
+        {
+            get
+            {
+                return false;
+            }
+        }
+
+        public SecurityHeaderLayout SecurityHeaderLayout
+        {
+            get
+            {
+                return this.securityHeaderLayout;
+            }
+            set
+            {
+                ThrowIfImmutable();
+                this.securityHeaderLayout = value;
+            }
+        }
+
+        public virtual bool SupportsReplayDetection
+        {
+            get
+            {
+                return true;
+            }
+        }
+
+        public virtual bool SupportsRequestReply
+        {
+            get
+            {
+                return true;
+            }
+        }
+
+        public SecurityStandardsManager StandardsManager
+        {
+            get
+            {
+                return this.standardsManager;
+            }
+            set
+            {
+                ThrowIfImmutable();
+                if (value == null)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException("value"));
+                }
+                this.standardsManager = value;
+            }
+        }
+
+        public TimeSpan TimestampValidityDuration
+        {
+            get
+            {
+                return this.timestampValidityDuration;
+            }
+            set
+            {
+                ThrowIfImmutable();
+                if (value <= TimeSpan.Zero)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("value", SR.Format("TimeSpanMustbeGreaterThanTimeSpanZero")));
+                }
+                this.timestampValidityDuration = value;
+            }
+        }
+
+        public Uri ListenUri
+        {
+            get { return this.listenUri; }
+            set 
+            {
+                ThrowIfImmutable();
+                this.listenUri = value;
+            }
+        }
+
+        internal MessageSecurityVersion MessageSecurityVersion
+        {
+            get { return this.messageSecurityVersion; }
+        }
+
+       
+        public virtual void OnAbort()
+        {
+            if (!this.actAsInitiator)
+            {
+                foreach (SupportingTokenAuthenticatorSpecification spec in this.channelSupportingTokenAuthenticatorSpecification)
+                {
+                    SecurityUtils.AbortTokenAuthenticatorIfRequired(spec.TokenAuthenticator);
+                }
+                foreach (string action in this.scopedSupportingTokenAuthenticatorSpecification.Keys)
+                {
+                    ICollection<SupportingTokenAuthenticatorSpecification> supportingAuthenticators = this.scopedSupportingTokenAuthenticatorSpecification[action];
+                    foreach (SupportingTokenAuthenticatorSpecification spec in supportingAuthenticators)
+                    {
+                        SecurityUtils.AbortTokenAuthenticatorIfRequired(spec.TokenAuthenticator);
+                    }
+                }
+            }
+        }
+
+        public virtual void OnClose(TimeSpan timeout)
+        {
+            TimeoutHelper timeoutHelper = new TimeoutHelper(timeout);
+            if (!this.actAsInitiator)
+            {
+                foreach (SupportingTokenAuthenticatorSpecification spec in this.channelSupportingTokenAuthenticatorSpecification)
+                {
+                    SecurityUtils.CloseTokenAuthenticatorIfRequired(spec.TokenAuthenticator, timeoutHelper.RemainingTime());
+                }
+                foreach (string action in this.scopedSupportingTokenAuthenticatorSpecification.Keys)
+                {
+                    ICollection<SupportingTokenAuthenticatorSpecification> supportingAuthenticators = this.scopedSupportingTokenAuthenticatorSpecification[action];
+                    foreach (SupportingTokenAuthenticatorSpecification spec in supportingAuthenticators)
+                    {
+                        SecurityUtils.CloseTokenAuthenticatorIfRequired(spec.TokenAuthenticator, timeoutHelper.RemainingTime());
+                    }
+                }
+            }
+        }
+
+        public virtual object CreateListenerSecurityState()
+        {
+            return null;
+        }
+
+        internal SecurityProtocol CreateSecurityProtocol(EndpointAddress target, Uri via, object listenerSecurityState, bool isReturnLegSecurityRequired, TimeSpan timeout)
+        {
+            ThrowIfNotOpen();
+            SecurityProtocol securityProtocol = OnCreateSecurityProtocol(target, via, listenerSecurityState, timeout);
+            if (securityProtocol == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new MessageSecurityException(SR.Format(SR.ProtocolFactoryCouldNotCreateProtocol)));
+            }
+            return securityProtocol;
+        }
+
+        public virtual EndpointIdentity GetIdentityOfSelf()
+        {
+            return null;
+        }
+
+        public virtual T GetProperty<T>()
+        {
+            throw new NotImplementedException();
+            //if (typeof(T) == typeof(Collection<ISecurityContextSecurityTokenCache>))
+            //{
+            //    ThrowIfNotOpen();
+            //    Collection<ISecurityContextSecurityTokenCache> result = new Collection<ISecurityContextSecurityTokenCache>();
+            //    if (channelSupportingTokenAuthenticatorSpecification != null)
+            //    {
+            //        foreach (SupportingTokenAuthenticatorSpecification spec in this.channelSupportingTokenAuthenticatorSpecification)
+            //        {
+            //            if (spec.TokenAuthenticator is ISecurityContextSecurityTokenCacheProvider)
+            //            {
+            //                result.Add(((ISecurityContextSecurityTokenCacheProvider)spec.TokenAuthenticator).TokenCache);
+            //            }
+            //        }
+            //    }
+            //    return (T)(object)(result);
+            //}
+            //else
+            //{
+            //    return default(T);
+            //}
+        }
+        internal abstract SecurityProtocol OnCreateSecurityProtocol(EndpointAddress target, Uri via, object listenerSecurityState, TimeSpan timeout);
+       // internal abstract SecurityProtocol OnCreateSecurityProtocol(EndpointAddress target, Uri via,  TimeSpan timeout);
+
+        void VerifyTypeUniqueness(ICollection<SupportingTokenAuthenticatorSpecification> supportingTokenAuthenticators)
+        {
+            // its ok to go brute force here since we are dealing with a small number of authenticators
+            foreach (SupportingTokenAuthenticatorSpecification spec in supportingTokenAuthenticators)
+            {
+                Type authenticatorType = spec.TokenAuthenticator.GetType();
+                int numSkipped = 0;
+                foreach (SupportingTokenAuthenticatorSpecification spec2 in supportingTokenAuthenticators)
+                {
+                    Type spec2AuthenticatorType = spec2.TokenAuthenticator.GetType();
+                    if (object.ReferenceEquals(spec, spec2))
+                    {
+                        if (numSkipped > 0)
+                        {
+                            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.MultipleSupportingAuthenticatorsOfSameType, spec.TokenParameters.GetType())));
+                        }
+                        ++numSkipped;
+                        continue;
+                    }
+                    else if (authenticatorType.IsAssignableFrom(spec2AuthenticatorType) || spec2AuthenticatorType.IsAssignableFrom(authenticatorType))
+                    {
+                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.MultipleSupportingAuthenticatorsOfSameType, spec.TokenParameters.GetType())));
+                    }
+                }
+            }
+        }
+
+        internal IList<SupportingTokenAuthenticatorSpecification> GetSupportingTokenAuthenticators(string action, out bool expectSignedTokens, out bool expectBasicTokens, out bool expectEndorsingTokens)
+        {
+            if (this.mergedSupportingTokenAuthenticatorsMap != null && this.mergedSupportingTokenAuthenticatorsMap.Count > 0)
+            {
+                if (action != null && this.mergedSupportingTokenAuthenticatorsMap.ContainsKey(action))
+                {
+                    MergedSupportingTokenAuthenticatorSpecification mergedSpec = this.mergedSupportingTokenAuthenticatorsMap[action];
+                    expectSignedTokens = mergedSpec.ExpectSignedTokens;
+                    expectBasicTokens = mergedSpec.ExpectBasicTokens;
+                    expectEndorsingTokens = mergedSpec.ExpectEndorsingTokens;
+                    return mergedSpec.SupportingTokenAuthenticators;
+                }
+                else if (this.mergedSupportingTokenAuthenticatorsMap.ContainsKey(MessageHeaders.WildcardAction))
+                {
+                    MergedSupportingTokenAuthenticatorSpecification mergedSpec = this.mergedSupportingTokenAuthenticatorsMap[MessageHeaders.WildcardAction];
+                    expectSignedTokens = mergedSpec.ExpectSignedTokens;
+                    expectBasicTokens = mergedSpec.ExpectBasicTokens;
+                    expectEndorsingTokens = mergedSpec.ExpectEndorsingTokens;
+                    return mergedSpec.SupportingTokenAuthenticators;
+                }
+            }
+            expectSignedTokens = this.expectChannelSignedTokens;
+            expectBasicTokens = this.expectChannelBasicTokens;
+            expectEndorsingTokens = this.expectChannelEndorsingTokens;
+            // in case the channelSupportingTokenAuthenticators is empty return null so that its Count does not get accessed.
+            return (Object.ReferenceEquals(this.channelSupportingTokenAuthenticatorSpecification, EmptyTokenAuthenticators)) ? null : (IList<SupportingTokenAuthenticatorSpecification>) this.channelSupportingTokenAuthenticatorSpecification;
+        }
+
+        void MergeSupportingTokenAuthenticators(TimeSpan timeout)
+        {
+            if (this.scopedSupportingTokenAuthenticatorSpecification.Count == 0)
+            {
+                this.mergedSupportingTokenAuthenticatorsMap = null;
+            }
+            else
+            {
+                TimeoutHelper timeoutHelper = new TimeoutHelper(timeout);
+                this.expectSupportingTokens = true;
+                this.mergedSupportingTokenAuthenticatorsMap = new Dictionary<string, MergedSupportingTokenAuthenticatorSpecification>();
+                foreach (string action in this.scopedSupportingTokenAuthenticatorSpecification.Keys)
+                {
+                    ICollection<SupportingTokenAuthenticatorSpecification> scopedAuthenticators = this.scopedSupportingTokenAuthenticatorSpecification[action];
+                    if (scopedAuthenticators == null || scopedAuthenticators.Count == 0)
+                    {
+                        continue;
+                    }
+                    Collection<SupportingTokenAuthenticatorSpecification> mergedAuthenticators = new Collection<SupportingTokenAuthenticatorSpecification>();
+                    bool expectSignedTokens = this.expectChannelSignedTokens;
+                    bool expectBasicTokens = this.expectChannelBasicTokens;
+                    bool expectEndorsingTokens = this.expectChannelEndorsingTokens;
+                    foreach (SupportingTokenAuthenticatorSpecification spec in this.channelSupportingTokenAuthenticatorSpecification)
+                    {
+                        mergedAuthenticators.Add(spec);
+                    }
+                    foreach (SupportingTokenAuthenticatorSpecification spec in scopedAuthenticators)
+                    {
+                        SecurityUtils.OpenTokenAuthenticatorIfRequiredAsync(spec.TokenAuthenticator, timeoutHelper.GetCancellationToken());
+                        
+                        mergedAuthenticators.Add(spec);
+                        if (spec.SecurityTokenAttachmentMode == SecurityTokenAttachmentMode.Endorsing ||
+                            spec.SecurityTokenAttachmentMode == SecurityTokenAttachmentMode.SignedEndorsing)
+                        {
+                            if (spec.TokenParameters.RequireDerivedKeys && !spec.TokenParameters.HasAsymmetricKey)
+                            {
+                                this.expectKeyDerivation = true;
+                            }
+                        }
+                        SecurityTokenAttachmentMode mode = spec.SecurityTokenAttachmentMode;
+                        if (mode == SecurityTokenAttachmentMode.SignedEncrypted
+                            || mode == SecurityTokenAttachmentMode.Signed
+                            || mode == SecurityTokenAttachmentMode.SignedEndorsing)
+                        {
+                            expectSignedTokens = true;
+                            if (mode == SecurityTokenAttachmentMode.SignedEncrypted)
+                            {
+                                expectBasicTokens = true;
+                            }
+                        }
+                        if (mode == SecurityTokenAttachmentMode.Endorsing || mode == SecurityTokenAttachmentMode.SignedEndorsing)
+                        {
+                            expectEndorsingTokens = true;
+                        }
+                    }
+                    VerifyTypeUniqueness(mergedAuthenticators);
+                    MergedSupportingTokenAuthenticatorSpecification mergedSpec = new MergedSupportingTokenAuthenticatorSpecification();
+                    mergedSpec.SupportingTokenAuthenticators = mergedAuthenticators;
+                    mergedSpec.ExpectBasicTokens = expectBasicTokens;
+                    mergedSpec.ExpectEndorsingTokens = expectEndorsingTokens;
+                    mergedSpec.ExpectSignedTokens = expectSignedTokens;
+                    mergedSupportingTokenAuthenticatorsMap.Add(action, mergedSpec);
+                }
+            }
+        }
+
+        protected RecipientServiceModelSecurityTokenRequirement CreateRecipientSecurityTokenRequirement()
+        {
+            RecipientServiceModelSecurityTokenRequirement requirement = new RecipientServiceModelSecurityTokenRequirement();
+            requirement.SecurityBindingElement = this.securityBindingElement;
+            requirement.SecurityAlgorithmSuite = this.IncomingAlgorithmSuite;
+            requirement.ListenUri = this.listenUri;
+            requirement.MessageSecurityVersion = this.MessageSecurityVersion.SecurityTokenVersion;
+           // requirement.AuditLogLocation = this.auditLogLocation;
+           // requirement.SuppressAuditFailure = this.suppressAuditFailure;
+           // requirement.MessageAuthenticationAuditLevel = this.messageAuthenticationAuditLevel;
+            requirement.Properties[ServiceModelSecurityTokenRequirement.ExtendedProtectionPolicy] = this.extendedProtectionPolicy;
+            if (this.endpointFilterTable != null)
+            {
+                requirement.Properties.Add(ServiceModelSecurityTokenRequirement.EndpointFilterTableProperty, this.endpointFilterTable);
+            }
+            return requirement;
+        }
+
+        RecipientServiceModelSecurityTokenRequirement CreateRecipientSecurityTokenRequirement(SecurityTokenParameters parameters, SecurityTokenAttachmentMode attachmentMode)
+        {
+            RecipientServiceModelSecurityTokenRequirement requirement = CreateRecipientSecurityTokenRequirement();
+            parameters.InitializeSecurityTokenRequirement(requirement);
+            requirement.KeyUsage = SecurityKeyUsage.Signature;
+            requirement.Properties[ServiceModelSecurityTokenRequirement.MessageDirectionProperty] = MessageDirection.Input;
+            requirement.Properties[ServiceModelSecurityTokenRequirement.SupportingTokenAttachmentModeProperty] = attachmentMode;
+            requirement.Properties[ServiceModelSecurityTokenRequirement.ExtendedProtectionPolicy] = this.extendedProtectionPolicy;
+            return requirement;
+        }
+
+        void AddSupportingTokenAuthenticators(SupportingTokenParameters supportingTokenParameters, bool isOptional, IList<SupportingTokenAuthenticatorSpecification> authenticatorSpecList)
+        {
+            for (int i = 0; i < supportingTokenParameters.Endorsing.Count; ++i)
+            {
+                SecurityTokenRequirement requirement = this.CreateRecipientSecurityTokenRequirement(supportingTokenParameters.Endorsing[i], SecurityTokenAttachmentMode.Endorsing);
+                try
+                {
+                    CoreWCF.IdentityModel.Selectors.SecurityTokenResolver resolver;
+                    CoreWCF.IdentityModel.Selectors.SecurityTokenAuthenticator authenticator = this.SecurityTokenManager.CreateSecurityTokenAuthenticator(requirement, out resolver);
+                    SupportingTokenAuthenticatorSpecification authenticatorSpec = new SupportingTokenAuthenticatorSpecification(authenticator, resolver, SecurityTokenAttachmentMode.Endorsing, supportingTokenParameters.Endorsing[i], isOptional);
+                    authenticatorSpecList.Add(authenticatorSpec);
+                }
+                catch (Exception e)
+                {
+                    if (!isOptional || Fx.IsFatal(e))
+                    {
+                        throw;
+                    }
+                }
+            }
+            for (int i = 0; i < supportingTokenParameters.SignedEndorsing.Count; ++i)
+            {
+                SecurityTokenRequirement requirement = this.CreateRecipientSecurityTokenRequirement(supportingTokenParameters.SignedEndorsing[i], SecurityTokenAttachmentMode.SignedEndorsing);
+                try
+                {
+                    CoreWCF.IdentityModel.Selectors.SecurityTokenResolver resolver;
+                    CoreWCF.IdentityModel.Selectors.SecurityTokenAuthenticator authenticator = this.SecurityTokenManager.CreateSecurityTokenAuthenticator(requirement, out resolver);
+                    SupportingTokenAuthenticatorSpecification authenticatorSpec = new SupportingTokenAuthenticatorSpecification(authenticator, resolver, SecurityTokenAttachmentMode.SignedEndorsing, supportingTokenParameters.SignedEndorsing[i], isOptional);
+                    authenticatorSpecList.Add(authenticatorSpec);
+                }
+                catch (Exception e)
+                {
+                    if (!isOptional || Fx.IsFatal(e))
+                    {
+                        throw;
+                    }
+                }
+            }
+            for (int i = 0; i < supportingTokenParameters.SignedEncrypted.Count; ++i)
+            {
+                SecurityTokenRequirement requirement = this.CreateRecipientSecurityTokenRequirement(supportingTokenParameters.SignedEncrypted[i], SecurityTokenAttachmentMode.SignedEncrypted);
+                try
+                {
+                    CoreWCF.IdentityModel.Selectors.SecurityTokenResolver resolver;
+                    CoreWCF.IdentityModel.Selectors.SecurityTokenAuthenticator authenticator = this.SecurityTokenManager.CreateSecurityTokenAuthenticator(requirement, out resolver);
+                    SupportingTokenAuthenticatorSpecification authenticatorSpec = new SupportingTokenAuthenticatorSpecification(authenticator, resolver, SecurityTokenAttachmentMode.SignedEncrypted, supportingTokenParameters.SignedEncrypted[i], isOptional);
+                    authenticatorSpecList.Add(authenticatorSpec);
+                }
+                catch (Exception e)
+                {
+                    if (!isOptional || Fx.IsFatal(e))
+                    {
+                        throw;
+                    }
+                }
+            }
+            for (int i = 0; i < supportingTokenParameters.Signed.Count; ++i)
+            {
+                SecurityTokenRequirement requirement = this.CreateRecipientSecurityTokenRequirement(supportingTokenParameters.Signed[i], SecurityTokenAttachmentMode.Signed);
+                try
+                {
+                    CoreWCF.IdentityModel.Selectors.SecurityTokenResolver resolver;
+                    CoreWCF.IdentityModel.Selectors.SecurityTokenAuthenticator authenticator = this.SecurityTokenManager.CreateSecurityTokenAuthenticator(requirement, out resolver);
+                    SupportingTokenAuthenticatorSpecification authenticatorSpec = new SupportingTokenAuthenticatorSpecification(authenticator, resolver, SecurityTokenAttachmentMode.Signed, supportingTokenParameters.Signed[i], isOptional);
+                    authenticatorSpecList.Add(authenticatorSpec);
+                }
+                catch (Exception e)
+                {
+                    if (!isOptional || Fx.IsFatal(e))
+                    {
+                        throw;
+                    }
+                }
+            }
+        }
+
+        public virtual Task OpenAsync(TimeSpan timeout) // renaming to Init
+        {
+            if (this.SecurityBindingElement == null)
+            {
+                this.OnPropertySettingsError("SecurityBindingElement", true);
+            }
+            if (this.SecurityTokenManager == null)
+            {
+                this.OnPropertySettingsError("SecurityTokenManager", true);
+            }
+            this.messageSecurityVersion = this.standardsManager.MessageSecurityVersion;
+            TimeoutHelper timeoutHelper = new TimeoutHelper(timeout);
+            this.expectOutgoingMessages = this.ActAsInitiator || this.SupportsRequestReply;
+            this.expectIncomingMessages = !this.ActAsInitiator || this.SupportsRequestReply;
+            if (!this.actAsInitiator)
+            {
+                AddSupportingTokenAuthenticators(this.securityBindingElement.EndpointSupportingTokenParameters, false, (IList<SupportingTokenAuthenticatorSpecification>)this.channelSupportingTokenAuthenticatorSpecification);
+                AddSupportingTokenAuthenticators(this.securityBindingElement.OptionalEndpointSupportingTokenParameters, true, (IList<SupportingTokenAuthenticatorSpecification>)this.channelSupportingTokenAuthenticatorSpecification);
+                foreach (string action in this.securityBindingElement.OperationSupportingTokenParameters.Keys)
+                {
+                    Collection<SupportingTokenAuthenticatorSpecification> authenticatorSpecList = new Collection<SupportingTokenAuthenticatorSpecification>();
+                    AddSupportingTokenAuthenticators(this.securityBindingElement.OperationSupportingTokenParameters[action], false, authenticatorSpecList);
+                    this.scopedSupportingTokenAuthenticatorSpecification.Add(action, authenticatorSpecList);
+                }
+                foreach (string action in this.securityBindingElement.OptionalOperationSupportingTokenParameters.Keys)
+                {
+                    Collection<SupportingTokenAuthenticatorSpecification> authenticatorSpecList;
+                    ICollection<SupportingTokenAuthenticatorSpecification> existingList;
+                    if (this.scopedSupportingTokenAuthenticatorSpecification.TryGetValue(action, out existingList))
+                    {
+                        authenticatorSpecList = ((Collection<SupportingTokenAuthenticatorSpecification>)existingList);
+                    }
+                    else
+                    {
+                        authenticatorSpecList = new Collection<SupportingTokenAuthenticatorSpecification>();
+                        this.scopedSupportingTokenAuthenticatorSpecification.Add(action, authenticatorSpecList);
+                    }
+                    this.AddSupportingTokenAuthenticators(this.securityBindingElement.OptionalOperationSupportingTokenParameters[action], true, authenticatorSpecList);
+                }
+                // validate the token authenticator types and create a merged map if needed.
+                if (!this.channelSupportingTokenAuthenticatorSpecification.IsReadOnly)
+                {
+                    if (this.channelSupportingTokenAuthenticatorSpecification.Count == 0)
+                    {
+                        this.channelSupportingTokenAuthenticatorSpecification = EmptyTokenAuthenticators;
+                    }
+                    else
+                    {
+                        this.expectSupportingTokens = true;
+                        foreach (SupportingTokenAuthenticatorSpecification tokenAuthenticatorSpec in this.channelSupportingTokenAuthenticatorSpecification)
+                        {
+                            SecurityUtils.OpenTokenAuthenticatorIfRequiredAsync(tokenAuthenticatorSpec.TokenAuthenticator, timeoutHelper.GetCancellationToken());
+                            if (tokenAuthenticatorSpec.SecurityTokenAttachmentMode == SecurityTokenAttachmentMode.Endorsing
+                                || tokenAuthenticatorSpec.SecurityTokenAttachmentMode == SecurityTokenAttachmentMode.SignedEndorsing)
+                            {
+                                if (tokenAuthenticatorSpec.TokenParameters.RequireDerivedKeys && !tokenAuthenticatorSpec.TokenParameters.HasAsymmetricKey)
+                                {
+                                    expectKeyDerivation = true;
+                                }
+                            }
+                            SecurityTokenAttachmentMode mode = tokenAuthenticatorSpec.SecurityTokenAttachmentMode;
+                            if (mode == SecurityTokenAttachmentMode.SignedEncrypted
+                                || mode == SecurityTokenAttachmentMode.Signed
+                                || mode == SecurityTokenAttachmentMode.SignedEndorsing)
+                            {
+                                this.expectChannelSignedTokens = true;
+                                if (mode == SecurityTokenAttachmentMode.SignedEncrypted)
+                                {
+                                    this.expectChannelBasicTokens = true;
+                                }
+                            }
+                            if (mode == SecurityTokenAttachmentMode.Endorsing || mode == SecurityTokenAttachmentMode.SignedEndorsing)
+                            {
+                                this.expectChannelEndorsingTokens = true;
+                            }
+                        }
+                        this.channelSupportingTokenAuthenticatorSpecification =
+                            new ReadOnlyCollection<SupportingTokenAuthenticatorSpecification>((Collection<SupportingTokenAuthenticatorSpecification>)this.channelSupportingTokenAuthenticatorSpecification);
+                    }
+                }
+                VerifyTypeUniqueness(this.channelSupportingTokenAuthenticatorSpecification);
+                MergeSupportingTokenAuthenticators(timeoutHelper.RemainingTime());
+            }
+
+            //if (this.DetectReplays)
+            //{
+            //    if (!this.SupportsReplayDetection)
+            //    {
+            //        throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgument("DetectReplays", SR.GetString(SR.SecurityProtocolCannotDoReplayDetection, this));
+            //    }
+            //    if (this.MaxClockSkew == TimeSpan.MaxValue || this.ReplayWindow == TimeSpan.MaxValue)
+            //    {
+            //        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.GetString(SR.NoncesCachedInfinitely)));
+            //    }
+
+            //    // If DetectReplays is true and nonceCache is null then use the default InMemoryNonceCache. 
+            //    if (this.nonceCache == null)
+            //    {
+            //        // The nonce needs to be cached for replayWindow + 2*clockSkew to eliminate replays
+            //        this.nonceCache = new InMemoryNonceCache(this.ReplayWindow + this.MaxClockSkew + this.MaxClockSkew, this.MaxCachedNonces);
+            //    }
+            //}
+
+            //this.derivedKeyTokenAuthenticator = new NonValidatingSecurityTokenAuthenticator<DerivedKeySecurityToken>();
+            return Task.CompletedTask;
+        }
+
+        public virtual Task OnCloseAsync(TimeSpan timeout)
+        {
+            this.OnClose(timeout);
+            return Task.CompletedTask;
+        }
+
+       
+        internal void Open(string propertyName, bool requiredForForwardDirection, SecurityTokenAuthenticator authenticator, TimeSpan timeout)
+        {
+            if (authenticator != null)
+            {
+                TimeoutHelper helper = new TimeoutHelper(timeout);
+                SecurityUtils.OpenTokenAuthenticatorIfRequiredAsync(authenticator, helper.GetCancellationToken());
+            }
+            else
+            {
+                OnPropertySettingsError(propertyName, requiredForForwardDirection);
+            }
+        }
+
+        internal void Open(string propertyName, bool requiredForForwardDirection, SecurityTokenProvider provider, TimeSpan timeout)
+        {
+            if (provider != null)
+            {
+                SecurityUtils.OpenTokenProviderIfRequired(provider, timeout);
+            }
+            else
+            {
+                OnPropertySettingsError(propertyName, requiredForForwardDirection);
+            }
+        }
+
+        internal void OnPropertySettingsError(string propertyName, bool requiredForForwardDirection)
+        {
+            if (requiredForForwardDirection)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(
+                    SR.Format(SR.PropertySettingErrorOnProtocolFactory, propertyName, this),
+                    propertyName));
+            }
+            else if (this.requestReplyErrorPropertyName == null)
+            {
+                this.requestReplyErrorPropertyName = propertyName;
+            }
+        }
+
+        void ThrowIfReturnDirectionSecurityNotSupported()
+        {
+            if (this.requestReplyErrorPropertyName != null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(
+                    SR.Format(SR.PropertySettingErrorOnProtocolFactory, this.requestReplyErrorPropertyName, this),
+                    this.requestReplyErrorPropertyName));
+            }
+        }
+
+        internal void ThrowIfImmutable()
+        {
+           // this.communicationObject.ThrowIfDisposedOrImmutable();
+        }
+
+        void ThrowIfNotOpen()
+        {
+           // this.communicationObject.ThrowIfNotOpened();
+        }
+    }
+
+    struct MergedSupportingTokenAuthenticatorSpecification
+    {
+        public Collection<SupportingTokenAuthenticatorSpecification> SupportingTokenAuthenticators;
+        public bool ExpectSignedTokens;
+        public bool ExpectEndorsingTokens;
+        public bool ExpectBasicTokens;
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/SecuritySessionOperation.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/SecuritySessionOperation.cs
new file mode 100644
index 0000000..05d4125
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/SecuritySessionOperation.cs
@@ -0,0 +1,10 @@
+namespace CoreWCF.Security
+{
+    enum SecuritySessionOperation
+    {
+        None,
+        Issue,
+        Renew,
+        Close,
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/SecuritySessionSecurityTokenAuthenticator.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/SecuritySessionSecurityTokenAuthenticator.cs
new file mode 100644
index 0000000..2643f86
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/SecuritySessionSecurityTokenAuthenticator.cs
@@ -0,0 +1,1356 @@
+using System.Collections.Generic;
+using System.Collections.ObjectModel;
+using System.Globalization;
+using CoreWCF.IdentityModel.Claims;
+using CoreWCF.IdentityModel.Policy;
+using CoreWCF.IdentityModel.Selectors;
+using CoreWCF.IdentityModel.Tokens;
+using CoreWCF.Runtime;
+using System.Runtime.Serialization;
+using CoreWCF;
+using CoreWCF.Channels;
+using CoreWCF.Description;
+using CoreWCF.Dispatcher;
+using CoreWCF.Security.Tokens;
+using System.Xml;
+using System;
+using System.Threading.Tasks;
+using CoreWCF.Diagnostics;
+using System.Threading;
+using CoreWCF.IdentityModel;
+
+namespace CoreWCF.Security
+{
+
+
+    class SecuritySessionSecurityTokenAuthenticator  : CommunicationObjectSecurityTokenAuthenticator, IIssuanceSecurityTokenAuthenticator //, ILogonTokenCacheManager
+    {
+        internal static readonly TimeSpan defaultSessionTokenLifetime = TimeSpan.MaxValue;
+        internal const int defaultMaxCachedSessionTokens = Int32.MaxValue;  
+        internal static readonly SecurityStandardsManager defaultStandardsManager = SecurityStandardsManager.DefaultInstance;
+
+        bool isClientAnonymous;
+        TimeSpan sessionTokenLifetime;
+        ISecurityContextSecurityTokenCache issuedTokenCache;
+        SecurityContextSecurityTokenAuthenticator sessionTokenAuthenticator;
+        SecuritySessionHost rstListener;
+        SecurityBindingElement bootstrapSecurityBindingElement;
+        BindingContext issuerBindingContext;
+        SecurityStandardsManager standardsManager;
+        SecurityAlgorithmSuite securityAlgorithmSuite;
+        SecurityKeyEntropyMode keyEntropyMode;
+        TimeSpan keyRenewalInterval;
+        SecurityTokenParameters issuedTokenParameters;
+        Uri listenUri;
+        string sctUri;
+        IMessageFilterTable<EndpointAddress> endpointFilterTable;
+        bool shouldMatchRstWithEndpointFilter;
+        int maximumConcurrentNegotiations;
+        TimeSpan negotiationTimeout;
+        Object thisLock = new Object();
+        bool preserveBootstrapTokens;
+
+        IssuedSecurityTokenHandler issuedSecurityTokenHandler;
+        RenewedSecurityTokenHandler renewedSecurityTokenHandler;
+
+        public SecuritySessionSecurityTokenAuthenticator()
+           // : base()
+        {
+            this.sessionTokenAuthenticator = new SecurityContextSecurityTokenAuthenticator();
+            this.sessionTokenLifetime = defaultSessionTokenLifetime;
+            this.isClientAnonymous = false;
+            this.standardsManager = defaultStandardsManager;
+            this.keyEntropyMode = SecurityKeyEntropyMode.CombinedEntropy;// AcceleratedTokenProvider.defaultKeyEntropyMode;
+            this.maximumConcurrentNegotiations = 128;// AcceleratedTokenAuthenticator.defaultServerMaxActiveNegotiations;
+            this.negotiationTimeout =  TimeSpan.Parse("00:01:00", CultureInfo.InvariantCulture); // AcceleratedTokenAuthenticator.defaultServerMaxNegotiationLifetime;
+        }
+
+        public IssuedSecurityTokenHandler IssuedSecurityTokenHandler
+        {
+            get
+            {
+                return this.issuedSecurityTokenHandler;
+            }
+            set
+            {
+                this.issuedSecurityTokenHandler = value;
+            }
+        }
+
+        public RenewedSecurityTokenHandler RenewedSecurityTokenHandler
+        {
+            get
+            {
+                return this.renewedSecurityTokenHandler;
+            }
+            set
+            {
+                this.renewedSecurityTokenHandler = value;
+            }
+        }
+
+        public SecurityAlgorithmSuite SecurityAlgorithmSuite
+        {
+            get
+            {
+                return this.securityAlgorithmSuite;
+            }
+            set
+            {
+                this.CommunicationObject.ThrowIfDisposedOrImmutable();
+                this.securityAlgorithmSuite = value;
+            }
+        }
+
+        public SecurityKeyEntropyMode KeyEntropyMode
+        {
+            get
+            {
+                return this.keyEntropyMode;
+            }
+            set
+            {
+                this.CommunicationObject.ThrowIfDisposedOrImmutable();
+                SecurityKeyEntropyModeHelper.Validate(value);
+                this.keyEntropyMode = value;
+            }
+        }
+
+        public bool IsClientAnonymous
+        {
+            get
+            {
+                return this.isClientAnonymous;
+            }
+            set
+            {
+                this.CommunicationObject.ThrowIfDisposedOrImmutable();
+                this.isClientAnonymous = value;
+            }
+        }
+
+        public TimeSpan SessionTokenLifetime
+        {
+            get
+            {
+                return this.sessionTokenLifetime;
+            }
+            set
+            {
+                this.CommunicationObject.ThrowIfDisposedOrImmutable();
+                if (value <= TimeSpan.Zero)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("value", SR.Format(SR.TimeSpanMustbeGreaterThanTimeSpanZero)));
+                }
+
+                if (TimeoutHelper.IsTooLarge(value))
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("value", value,
+                        SR.Format(SR.SFxTimeoutOutOfRangeTooBig)));
+                }
+                this.sessionTokenLifetime = value;
+            }
+        }
+
+        public TimeSpan KeyRenewalInterval
+        {
+            get
+            {
+                return this.keyRenewalInterval;
+            }
+            set
+            {
+                this.CommunicationObject.ThrowIfDisposedOrImmutable();
+                if (value <= TimeSpan.Zero)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("value", SR.Format(SR.TimeSpanMustbeGreaterThanTimeSpanZero)));
+                }
+
+                if (TimeoutHelper.IsTooLarge(value))
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("value", value,
+                        SR.Format(SR.SFxTimeoutOutOfRangeTooBig)));
+                }
+                this.keyRenewalInterval = value;
+            }
+        }
+
+        public int MaximumConcurrentNegotiations
+        {
+            get
+            {
+                return this.maximumConcurrentNegotiations;
+            }
+            set
+            {
+                this.CommunicationObject.ThrowIfDisposedOrImmutable();
+                if (value < 0)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("value", SR.Format(SR.ValueMustBeNonNegative)));
+                }
+                this.maximumConcurrentNegotiations = value;
+            }
+        }
+
+        public TimeSpan NegotiationTimeout
+        {
+            get
+            {
+                return this.negotiationTimeout;
+            }
+            set
+            {
+                this.CommunicationObject.ThrowIfDisposedOrImmutable();
+                if (value <= TimeSpan.Zero)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("value"));
+                }
+                this.negotiationTimeout = value;
+            }
+        }
+
+        public SecurityContextSecurityTokenAuthenticator SessionTokenAuthenticator
+        {
+            get
+            {
+                return this.sessionTokenAuthenticator;
+            }
+        }
+
+        public ISecurityContextSecurityTokenCache IssuedTokenCache
+        {
+            get
+            {
+                return this.issuedTokenCache;
+            }
+            set
+            {
+                this.CommunicationObject.ThrowIfDisposedOrImmutable();
+                this.issuedTokenCache = value;
+            }
+        }
+
+        public SecurityStandardsManager StandardsManager
+        {
+            get
+            {
+                return this.standardsManager;
+            }
+            set
+            {
+                this.CommunicationObject.ThrowIfDisposedOrImmutable();
+                if (value == null)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException("value"));
+                }
+                if (!value.TrustDriver.IsSessionSupported)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.TrustDriverVersionDoesNotSupportSession), "value"));
+                }
+                if (!value.SecureConversationDriver.IsSessionSupported)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.SecureConversationDriverVersionDoesNotSupportSession), "value"));
+                }
+                this.standardsManager = value;
+            }
+        }
+
+        public SecurityTokenParameters IssuedSecurityTokenParameters
+        {
+            get
+            {
+                return this.issuedTokenParameters;
+            }
+            set
+            {
+                this.CommunicationObject.ThrowIfDisposedOrImmutable();
+                this.issuedTokenParameters = value;
+            }
+        }
+
+        public BindingContext IssuerBindingContext
+        {
+            get
+            {
+                return this.issuerBindingContext;
+            }
+            set
+            {
+                this.CommunicationObject.ThrowIfDisposedOrImmutable();
+                if (value == null)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("value");
+                }
+                this.issuerBindingContext = value.Clone();
+            }
+        }
+
+        public SecurityBindingElement BootstrapSecurityBindingElement
+        {
+            get { return this.bootstrapSecurityBindingElement; }
+            set
+            {
+                this.CommunicationObject.ThrowIfDisposedOrImmutable();
+                if (value == null)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("value");
+                }
+                this.bootstrapSecurityBindingElement = (SecurityBindingElement)value.Clone();
+            }
+        }
+
+        public IMessageFilterTable<EndpointAddress> EndpointFilterTable
+        {
+            get
+            {
+                return this.endpointFilterTable;
+            }
+            set
+            {
+                this.CommunicationObject.ThrowIfDisposedOrImmutable();
+                this.endpointFilterTable = value;
+            }
+        }
+
+        public Uri ListenUri
+        {
+            get { return this.listenUri; }
+            set
+            {
+                this.CommunicationObject.ThrowIfDisposedOrImmutable();
+                this.listenUri = value;
+            }
+        }
+
+        public virtual XmlDictionaryString IssueAction
+        {
+            get
+            {
+                return standardsManager.SecureConversationDriver.IssueAction;
+            }
+        }
+
+        public virtual XmlDictionaryString IssueResponseAction
+        {
+            get
+            {
+                return standardsManager.SecureConversationDriver.IssueResponseAction;
+            }
+        }
+
+        public bool PreserveBootstrapTokens
+        {
+            get
+            {
+                return this.preserveBootstrapTokens;
+            }
+            set
+            {
+                this.preserveBootstrapTokens = value;
+            }
+        }
+
+        public virtual XmlDictionaryString RenewAction
+        {
+            get
+            {
+                return standardsManager.SecureConversationDriver.RenewAction;
+            }
+        }
+
+        public virtual XmlDictionaryString RenewResponseAction
+        {
+            get
+            {
+                return standardsManager.SecureConversationDriver.RenewResponseAction;
+            }
+        }
+
+        public virtual XmlDictionaryString CloseAction
+        {
+            get
+            {
+                return standardsManager.SecureConversationDriver.CloseAction;
+            }
+        }
+
+        public virtual XmlDictionaryString CloseResponseAction
+        {
+            get
+            {
+                return standardsManager.SecureConversationDriver.CloseResponseAction;
+            }
+        }
+
+        //public bool RemoveCachedLogonToken(string username)
+        //{
+        //    if (this.RequestSecurityTokenListener != null)
+        //    {
+        //        //
+        //        // this is the SCT case, delegate to the RST's listener list
+        //        //
+        //        IChannelListener listener = null;
+        //        ILogonTokenCacheManager manager = null;
+
+        //        for (int i = 0; i < this.RequestSecurityTokenListener.ChannelDispatchers.Count; i++)
+        //        {
+        //            listener = this.RequestSecurityTokenListener.ChannelDispatchers[i].Listener;
+
+        //            if (listener != null)
+        //            {
+        //                manager = listener.GetProperty<ILogonTokenCacheManager>();
+
+        //                if (manager != null)
+        //                    return manager.RemoveCachedLogonToken(username);
+        //            }
+        //        }
+        //    }
+        //    return false;
+        //}
+
+        //public void FlushLogonTokenCache()
+        //{
+        //    if (this.RequestSecurityTokenListener != null && this.RequestSecurityTokenListener.ChannelDispatchers.Count > 0)
+        //    {
+        //        //
+        //        // this is the SCT case, delegate to the RST's listener list
+        //        //
+        //        IChannelListener listener = null;
+        //        ILogonTokenCacheManager manager = null;
+
+        //        for (int i = 0; i < this.RequestSecurityTokenListener.ChannelDispatchers.Count; i++)
+        //        {
+        //            listener = this.RequestSecurityTokenListener.ChannelDispatchers[i].Listener;
+
+        //            if (listener != null)
+        //            {
+        //                manager = listener.GetProperty<ILogonTokenCacheManager>();
+
+        //                if (manager != null)
+        //                    manager.FlushLogonTokenCache();
+        //            }
+        //        }
+        //    }
+
+       // }
+
+        Message HandleOperationException(SecuritySessionOperation operation, Message request, Exception e)
+        {
+           // SecurityTraceRecordHelper.TraceServerSessionOperationException(operation, e, this.ListenUri);
+            return CreateFault(request, e);
+        }
+
+        Message CreateFault(Message request, Exception e)
+        {
+            FaultCode subCode;
+            FaultReason reason;
+            bool isSenderFault;
+            if (e is QuotaExceededException)
+            {
+                // send a receiver fault so that the sender can retry
+                subCode = new FaultCode(DotNetSecurityStrings.SecurityServerTooBusyFault, DotNetSecurityStrings.Namespace);
+                reason = new FaultReason(SR.Format(SR.PendingSessionsExceededFaultReason), CultureInfo.CurrentCulture);
+                isSenderFault = false;
+            }
+            else if (e is EndpointNotFoundException)
+            {
+                // send a receiver fault so that the sender can retry
+                subCode = new FaultCode(AddressingStrings.EndpointUnavailable, request.Version.Addressing.Namespace);
+                reason = new FaultReason(SR.Format(SR.SecurityListenerClosingFaultReason), CultureInfo.CurrentCulture);
+                isSenderFault = false;
+            }
+            else
+            {
+                subCode = new FaultCode(TrustApr2004Strings.InvalidRequestFaultCode, TrustFeb2005Strings.Namespace);
+                reason = new FaultReason(SR.Format(SR.InvalidRequestTrustFaultCode), CultureInfo.CurrentCulture);
+                isSenderFault = true;
+            }
+            FaultCode faultCode;
+            if (isSenderFault)
+            {
+                faultCode = FaultCode.CreateSenderFaultCode(subCode);
+            }
+            else
+            {
+                faultCode = FaultCode.CreateReceiverFaultCode(subCode);
+            }
+            MessageFault fault = MessageFault.CreateFault(faultCode, reason);
+            Message faultReply = Message.CreateMessage(request.Version, fault, request.Version.Addressing.DefaultFaultAction);
+            faultReply.Headers.RelatesTo = request.Headers.MessageId;
+            return faultReply;
+        }
+
+        void NotifyOperationCompletion(SecuritySessionOperation operation, SecurityContextSecurityToken newSessionToken, SecurityContextSecurityToken previousSessionToken, EndpointAddress remoteAddress)
+        {
+            if (operation == SecuritySessionOperation.Issue)
+            {
+                if (this.issuedSecurityTokenHandler != null)
+                {
+                    this.issuedSecurityTokenHandler(newSessionToken, remoteAddress);
+                }
+                else
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new SecurityNegotiationException(SR.IssueSessionTokenHandlerNotSet));
+                }
+            }
+            else if (operation == SecuritySessionOperation.Renew)
+            {
+                if (this.renewedSecurityTokenHandler != null)
+                {
+                    this.renewedSecurityTokenHandler(newSessionToken, previousSessionToken);
+                }
+                else
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new SecurityNegotiationException(SR.RenewSessionTokenHandlerNotSet));
+                }
+            }
+            else
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new NotSupportedException());
+            }
+        }
+
+        public override Task CloseAsync(CancellationToken token)
+        {
+           /* TimeoutHelper timeoutHelper = new TimeoutHelper(timeout);
+            if (this.rstListener != null)
+            {
+                this.rstListener.Close(timeoutHelper.RemainingTime());
+                this.rstListener = null;
+            }*/
+           
+           return base.CloseAsync(token);
+        }
+
+        public override Task OpenAsync(CancellationToken token)
+        {
+            if (this.BootstrapSecurityBindingElement == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.BootstrapSecurityBindingElementNotSet, this.GetType())));
+            }
+            if (this.IssuerBindingContext == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.IssuerBuildContextNotSet, this.GetType())));
+            }
+            if (this.IssuedSecurityTokenParameters == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.IssuedSecurityTokenParametersNotSet, this.GetType())));
+            }
+            if (this.SecurityAlgorithmSuite == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.SecurityAlgorithmSuiteNotSet, this.GetType())));
+            }
+            if (this.IssuedTokenCache == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.IssuedTokenCacheNotSet, this.GetType())));
+            }
+            //TimeoutHelper timeoutHelper = new TimeoutHelper(timeout);
+            SetupSessionListener();
+           // this.rstListener.Open(timeoutHelper.RemainingTime());
+            this.sctUri = this.StandardsManager.SecureConversationDriver.TokenTypeUri;
+            return base.OpenAsync();
+           // base.OnOpen(timeoutHelper.RemainingTime());
+        }
+
+        protected override bool CanValidateTokenCore(SecurityToken token)
+        {
+            return (token is SecurityContextSecurityToken);
+        }
+
+        protected override ReadOnlyCollection<IAuthorizationPolicy> ValidateTokenCore(SecurityToken token)
+        {
+            SecurityContextSecurityToken sct = (SecurityContextSecurityToken)token;
+            return sct.AuthorizationPolicies;
+        }
+
+        static bool IsSameIdentity(ReadOnlyCollection<IAuthorizationPolicy> authorizationPolicies, ServiceSecurityContext incomingContext)
+        {
+            Claim identityClaim = SecurityUtils.GetPrimaryIdentityClaim(authorizationPolicies);
+
+            if (identityClaim == null)
+            {
+                return incomingContext.IsAnonymous;
+            }
+            else
+            {
+                return Claim.DefaultComparer.Equals(incomingContext.IdentityClaim, identityClaim);
+            }
+        }
+
+        DateTime GetKeyExpirationTime(SecurityToken currentToken, DateTime keyEffectiveTime)
+        {
+            DateTime keyExpirationTime = TimeoutHelper.Add(keyEffectiveTime, this.keyRenewalInterval);
+            DateTime tokenExpirationTime = (currentToken != null) ? currentToken.ValidTo : TimeoutHelper.Add(keyEffectiveTime, this.sessionTokenLifetime);
+            if (keyExpirationTime > tokenExpirationTime)
+            {
+                keyExpirationTime = tokenExpirationTime;
+            }
+            return keyExpirationTime;
+        }
+
+        internal static ReadOnlyCollection<IAuthorizationPolicy> CreateSecureConversationPolicies(SecurityMessageProperty security, DateTime expirationTime)
+        {
+            return CreateSecureConversationPolicies(security, null, expirationTime);
+        }
+
+        static ReadOnlyCollection<IAuthorizationPolicy> CreateSecureConversationPolicies(SecurityMessageProperty security, ReadOnlyCollection<IAuthorizationPolicy> currentTokenPolicies, DateTime expirationTime)
+        {
+            if (security == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("security");
+            }
+
+            List<IAuthorizationPolicy> authorizationPolicies = new List<IAuthorizationPolicy>();
+            if ((security.ServiceSecurityContext != null) &&
+                (security.ServiceSecurityContext.AuthorizationPolicies != null))
+            {
+                authorizationPolicies.AddRange(security.ServiceSecurityContext.AuthorizationPolicies);
+
+                // Remove any Transport token policies. We do not include
+                // these in the SCT as these policies will be available with
+                // the application messages as well.
+                if ((security.TransportToken != null) &&
+                    (security.TransportToken.SecurityTokenPolicies != null) &&
+                    (security.TransportToken.SecurityTokenPolicies.Count > 0))
+                {
+                    foreach (IAuthorizationPolicy policy in security.TransportToken.SecurityTokenPolicies)
+                    {
+                        if (authorizationPolicies.Contains(policy))
+                        {
+                            authorizationPolicies.Remove(policy);
+                        }
+                    }
+                }
+
+                if (currentTokenPolicies != null)
+                {
+                    for (int i = 0; i < currentTokenPolicies.Count; ++i)
+                    {
+                        if (authorizationPolicies.Contains(currentTokenPolicies[i]))
+                        {
+                            authorizationPolicies.Remove(currentTokenPolicies[i]);
+                        }
+                    }
+                }
+
+                UnconditionalPolicy sctPolicy;
+                for (int i = 0; i < authorizationPolicies.Count; i++)
+                {
+                    if (authorizationPolicies[i].GetType() == typeof(UnconditionalPolicy))
+                    {
+                        UnconditionalPolicy bootstrapPolicy = (UnconditionalPolicy)authorizationPolicies[i];
+                        sctPolicy = new UnconditionalPolicy(bootstrapPolicy.PrimaryIdentity, bootstrapPolicy.Issuances, expirationTime);
+                        authorizationPolicies[i] = sctPolicy;
+                    }
+                }
+            }
+
+            return authorizationPolicies.AsReadOnly();
+        }
+
+        SecurityContextSecurityToken IssueToken(RequestSecurityToken rst, Message request, SecurityContextSecurityToken currentToken, ReadOnlyCollection<IAuthorizationPolicy> currentTokenPolicies, out RequestSecurityTokenResponse rstr)
+        {
+            if (rst.TokenType != null && rst.TokenType != this.sctUri)
+            {
+                throw TraceUtility.ThrowHelperWarning(new InvalidOperationException(SR.Format(SR.CannotIssueRstTokenType, rst.TokenType)), request);
+            }
+            // ensure that a SecurityContext is present in the message
+            ServiceSecurityContext clientContext;
+            SecurityMessageProperty securityProperty = request.Properties.Security;
+            if (securityProperty != null)
+            {
+                clientContext = securityProperty.ServiceSecurityContext;
+            }
+            else
+            {
+                clientContext = ServiceSecurityContext.Anonymous;
+            }
+            if (clientContext == null)
+            {
+                throw TraceUtility.ThrowHelperWarning(new InvalidOperationException(SR.Format(SR.SecurityContextMissing, request.Headers.Action)), request);
+            }
+            if (currentToken != null)
+            {
+                // ensure that the same party is renewing the token
+                if (!IsSameIdentity(currentToken.AuthorizationPolicies, clientContext))
+                {
+                    throw TraceUtility.ThrowHelperWarning(new SecurityNegotiationException(SR.Format(SR.WrongIdentityRenewingToken)), request);
+                }
+            }
+
+            // check if the client specified entropy
+            byte[] proofKey;
+            byte[] issuerEntropy;
+            int issuedKeySize;
+            SecurityToken proofToken;
+            WSTrust.Driver.ProcessRstAndIssueKey(rst, null, this.KeyEntropyMode, this.SecurityAlgorithmSuite, out issuedKeySize,
+                out issuerEntropy, out proofKey, out proofToken);
+            SecurityContextSecurityToken newToken;
+            DateTime keyEffectiveTime = DateTime.UtcNow;
+            DateTime keyExpirationTime = GetKeyExpirationTime(currentToken, keyEffectiveTime);
+            ReadOnlyCollection<IAuthorizationPolicy> authorizationPolicies = (securityProperty != null) ?
+                    CreateSecureConversationPolicies(securityProperty, currentTokenPolicies, keyExpirationTime) : EmptyReadOnlyCollection<IAuthorizationPolicy>.Instance;
+            if (currentToken != null)
+            {
+                newToken = new SecurityContextSecurityToken(currentToken, SecurityUtils.GenerateId(), proofKey,
+                    SecurityUtils.GenerateUniqueId(), keyEffectiveTime, keyExpirationTime, authorizationPolicies);
+            }
+            else
+            {
+                UniqueId contextId = SecurityUtils.GenerateUniqueId();
+                string id = SecurityUtils.GenerateId();
+                DateTime tokenEffectiveTime = keyEffectiveTime;
+                DateTime tokenExpirationTime = TimeoutHelper.Add(tokenEffectiveTime, this.sessionTokenLifetime);
+                newToken = new SecurityContextSecurityToken(contextId, id, proofKey, tokenEffectiveTime, tokenExpirationTime, null, keyEffectiveTime,
+                    keyExpirationTime, authorizationPolicies);
+                if (this.preserveBootstrapTokens)
+                {
+                    newToken.BootstrapMessageProperty = (securityProperty == null) ? null : (SecurityMessageProperty)securityProperty.CreateCopy();
+                    SecurityUtils.ErasePasswordInUsernameTokenIfPresent(newToken.BootstrapMessageProperty);
+                }
+            }
+
+            rstr = new RequestSecurityTokenResponse(this.standardsManager);
+            rstr.Context = rst.Context;
+            rstr.KeySize = issuedKeySize;
+            rstr.RequestedUnattachedReference = this.IssuedSecurityTokenParameters.CreateKeyIdentifierClause(newToken, SecurityTokenReferenceStyle.External);
+            rstr.RequestedAttachedReference = this.IssuedSecurityTokenParameters.CreateKeyIdentifierClause(newToken, SecurityTokenReferenceStyle.Internal);
+            rstr.TokenType = this.sctUri;
+            rstr.RequestedSecurityToken = newToken;
+            if (issuerEntropy != null)
+            {
+                rstr.SetIssuerEntropy(issuerEntropy);
+                rstr.ComputeKey = true;
+            }
+            if (proofToken != null)
+            {
+                rstr.RequestedProofToken = proofToken;
+            }
+            rstr.SetLifetime(keyEffectiveTime, keyExpirationTime);
+            return newToken;
+        }
+
+        static SecurityTokenSpecification GetMatchingEndorsingSct(SecurityContextKeyIdentifierClause sctSkiClause, SecurityMessageProperty supportingTokenProperty)
+        {
+            if (sctSkiClause == null)
+            {
+                return null;
+            }
+            for (int i = 0; i < supportingTokenProperty.IncomingSupportingTokens.Count; ++i)
+            {
+                if (supportingTokenProperty.IncomingSupportingTokens[i].SecurityTokenAttachmentMode != SecurityTokenAttachmentMode.Endorsing
+                    && supportingTokenProperty.IncomingSupportingTokens[i].SecurityTokenAttachmentMode != SecurityTokenAttachmentMode.SignedEndorsing)
+                {
+                    continue;
+                }
+                SecurityContextSecurityToken sct = supportingTokenProperty.IncomingSupportingTokens[i].SecurityToken as SecurityContextSecurityToken;
+                if (sct != null && sctSkiClause.Matches(sct.ContextId, sct.KeyGeneration))
+                {
+                    return supportingTokenProperty.IncomingSupportingTokens[i];
+                }
+            }
+            return null;
+        }
+
+        /* TODO check when renew scenario ?
+        protected virtual Message ProcessRenewRequest(Message request)
+        {
+            this.CommunicationObject.ThrowIfClosedOrNotOpen();
+            try
+            {
+                // first verify that the session token being renewed is present as a supportingToken
+                SecurityMessageProperty supportingTokenProperty = request.Properties.Security;
+                if (supportingTokenProperty == null || !supportingTokenProperty.HasIncomingSupportingTokens)
+                {
+                    throw TraceUtility.ThrowHelperWarning(new SecurityNegotiationException(SR.Format(SR.RenewSessionMissingSupportingToken)), request);
+                }
+
+                RequestSecurityToken rst;
+                XmlDictionaryReader bodyReader = request.GetReaderAtBodyContents();
+                using (bodyReader)
+                {
+                    rst = this.StandardsManager.TrustDriver.CreateRequestSecurityToken(bodyReader);
+                    request.ReadFromBodyContentsToEnd(bodyReader);
+                }
+                if (rst.RequestType != this.StandardsManager.TrustDriver.RequestTypeRenew)
+                {
+                    throw TraceUtility.ThrowHelperWarning(new SecurityNegotiationException(SR.Format(SR.InvalidRstRequestType, rst.RequestType)), request);
+                }
+                if (rst.RenewTarget == null)
+                {
+                    throw TraceUtility.ThrowHelperWarning(new SecurityNegotiationException(SR.Format(SR.NoRenewTargetSpecified)), request);
+                }
+                SecurityContextKeyIdentifierClause sctSkiClause = rst.RenewTarget as SecurityContextKeyIdentifierClause;
+                SecurityTokenSpecification sessionToken = GetMatchingEndorsingSct(sctSkiClause, supportingTokenProperty);
+                if (sctSkiClause == null || sessionToken == null)
+                {
+                    throw TraceUtility.ThrowHelperWarning(new SecurityNegotiationException(SR.Format(SR.BadRenewTarget, rst.RenewTarget)), request);
+                }
+                RequestSecurityTokenResponse rstr;
+                SecurityContextSecurityToken newToken = this.IssueToken(rst, request, (SecurityContextSecurityToken)sessionToken.SecurityToken, sessionToken.SecurityTokenPolicies, out rstr);
+                rstr.MakeReadOnly();
+                BodyWriter replyMessage = rstr;
+                if (this.StandardsManager.MessageSecurityVersion.TrustVersion == TrustVersion.WSTrust13)
+                {
+                    List<RequestSecurityTokenResponse> rstrList = new List<RequestSecurityTokenResponse>(1);
+                    rstrList.Add(rstr);
+                    RequestSecurityTokenResponseCollection rstrc = new RequestSecurityTokenResponseCollection(rstrList, this.StandardsManager);
+                    replyMessage = rstrc;
+                }
+                this.NotifyOperationCompletion(SecuritySessionOperation.Renew, newToken, (SecurityContextSecurityToken)sessionToken.SecurityToken, request.Headers.ReplyTo);
+                Message response = CreateReply(request, this.RenewResponseAction, replyMessage);
+
+                if (!newToken.IsCookieMode)
+                {
+                    this.issuedTokenCache.AddContext(newToken);
+                }
+                return response;
+            }
+            finally
+            {
+                RemoveCachedTokensIfRequired(request.Properties.Security);
+            }
+        }*/
+
+        static void AddTokenToRemoveIfRequired(SecurityToken token, Collection<SecurityContextSecurityToken> sctsToRemove)
+        {
+            SecurityContextSecurityToken sct = token as SecurityContextSecurityToken;
+            if (sct != null)
+            {
+                sctsToRemove.Add(sct);
+            }
+        }
+
+        internal static void RemoveCachedTokensIfRequired(SecurityMessageProperty security)
+        {
+            if (security == null)
+            {
+                return;
+            }
+            // ILogonTokenCacheManager logonManager = OperationContext.Current.EndpointDispatcher.ChannelDispatcher.Listener.GetProperty<ILogonTokenCacheManager>();
+
+            // Collection<ISecurityContextSecurityTokenCache> sctCaches = OperationContext.Current.EndpointDispatcher.ChannelDispatcher.Channels .GetProperty<Collection<ISecurityContextSecurityTokenCache>>();
+            // if ( (sctCaches == null || sctCaches.Count == 0))
+            // {
+            //     return;
+            //  }
+            //TODO debug and incorporate above logic
+            Collection<ISecurityContextSecurityTokenCache> sctCaches = new Collection<ISecurityContextSecurityTokenCache>();
+            Collection<SecurityContextSecurityToken> securityContextTokensToRemove = new Collection<SecurityContextSecurityToken>();
+            if (security.ProtectionToken != null)
+            {
+                AddTokenToRemoveIfRequired(security.ProtectionToken.SecurityToken, securityContextTokensToRemove);
+            }
+            if (security.InitiatorToken != null)
+            {
+                AddTokenToRemoveIfRequired(security.InitiatorToken.SecurityToken, securityContextTokensToRemove);
+            }
+            if (security.HasIncomingSupportingTokens)
+            {
+                for (int i = 0; i < security.IncomingSupportingTokens.Count; ++i)
+                {
+                    if (security.IncomingSupportingTokens[i].SecurityTokenAttachmentMode == SecurityTokenAttachmentMode.Endorsing
+                        || security.IncomingSupportingTokens[i].SecurityTokenAttachmentMode == SecurityTokenAttachmentMode.SignedEncrypted
+                        || security.IncomingSupportingTokens[i].SecurityTokenAttachmentMode == SecurityTokenAttachmentMode.SignedEndorsing)
+                    {
+                        AddTokenToRemoveIfRequired(security.IncomingSupportingTokens[i].SecurityToken, securityContextTokensToRemove);
+                    }
+                }
+            }
+            if (sctCaches != null)
+            {
+                for (int i = 0; i < securityContextTokensToRemove.Count; ++i)
+                {
+                    for (int j = 0; j < sctCaches.Count; ++j)
+                    {
+                        sctCaches[j].RemoveContext(securityContextTokensToRemove[i].ContextId, securityContextTokensToRemove[i].KeyGeneration);
+                    }
+                }
+            }
+        }
+
+        protected virtual Message ProcessIssueRequest(Message request)
+        {
+            try
+            {
+                RequestSecurityToken rst;
+                using (XmlDictionaryReader bodyReader = request.GetReaderAtBodyContents())
+                {
+                    rst = this.StandardsManager.TrustDriver.CreateRequestSecurityToken(bodyReader);
+                    request.ReadFromBodyContentsToEnd(bodyReader);
+                }
+                if (rst.RequestType != null && rst.RequestType != this.StandardsManager.TrustDriver.RequestTypeIssue)
+                {
+                    throw TraceUtility.ThrowHelperWarning(new SecurityNegotiationException(SR.Format(SR.InvalidRstRequestType, rst.RequestType)), request);
+                }
+                // echo the AppliesTo in the reply if it is an issue request
+                EndpointAddress appliesTo = null;
+                DataContractSerializer appliesToSerializer;
+                string appliesToName;
+                string appliesToNamespace;
+                rst.GetAppliesToQName(out appliesToName, out appliesToNamespace);
+                if (appliesToName == AddressingStrings.EndpointReference && appliesToNamespace == request.Version.Addressing.Namespace)
+                {
+                    throw new NotImplementedException();
+                    //TODO need to check
+                   /* if (request.Version.Addressing == AddressingVersion.WSAddressing10)
+                    {
+                        appliesToSerializer = DataContractSerializerDefaults.CreateSerializer(typeof(EndpointAddress10), DataContractSerializerDefaults.MaxItemsInObjectGraph);
+                        appliesTo = rst.GetAppliesTo<EndpointAddress10>(appliesToSerializer).ToEndpointAddress();
+                    }
+                    else if (request.Version.Addressing == AddressingVersion.WSAddressingAugust2004)
+                    {
+                        appliesToSerializer = DataContractSerializerDefaults.CreateSerializer(typeof(EndpointAddressAugust2004), DataContractSerializerDefaults.MaxItemsInObjectGraph);
+                        appliesTo = rst.GetAppliesTo<EndpointAddressAugust2004>(appliesToSerializer).ToEndpointAddress();
+                    }
+                    else
+                    {
+                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(
+                            new ProtocolException(SR.Format(SR.AddressingVersionNotSupported, request.Version.Addressing)));
+                    }*/
+                }
+                else
+                {
+                    appliesTo = null;
+                    appliesToSerializer = null;
+                }
+                if (this.shouldMatchRstWithEndpointFilter)
+                {
+                    SecurityUtils.MatchRstWithEndpointFilter(request, this.endpointFilterTable, this.listenUri);
+                }
+                RequestSecurityTokenResponse rstr;
+                SecurityContextSecurityToken issuedToken = this.IssueToken(rst, request, null, null, out rstr);
+                if (appliesTo != null)
+                {
+                    //if (request.Version.Addressing == AddressingVersion.WSAddressing10)
+                    //{
+                    //    rstr.SetAppliesTo<EndpointAddress10>(EndpointAddress10.FromEndpointAddress(appliesTo), appliesToSerializer);
+                    //}
+                    //else if (request.Version.Addressing == AddressingVersion.WSAddressingAugust2004)
+                    //{
+                    //    rstr.SetAppliesTo<EndpointAddressAugust2004>(EndpointAddressAugust2004.FromEndpointAddress(appliesTo), appliesToSerializer);
+                    //}
+                    //else
+                    //{
+                    //    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(
+                    //        new ProtocolException(SR.Format(SR.AddressingVersionNotSupported, request.Version.Addressing)));
+                    //}
+                }
+                rstr.MakeReadOnly();
+                BodyWriter replyMessage = rstr;
+                if (this.StandardsManager.MessageSecurityVersion.TrustVersion == TrustVersion.WSTrust13)
+                {
+                    List<RequestSecurityTokenResponse> rstrList = new List<RequestSecurityTokenResponse>(1);
+                    rstrList.Add(rstr);
+                    RequestSecurityTokenResponseCollection rstrc = new RequestSecurityTokenResponseCollection(rstrList, this.StandardsManager);
+                    replyMessage = rstrc;
+                }
+                this.NotifyOperationCompletion(SecuritySessionOperation.Issue, issuedToken, null, request.Headers.ReplyTo);
+                Message response = CreateReply(request, this.IssueResponseAction, replyMessage);
+                if (!issuedToken.IsCookieMode)
+                {
+                    this.issuedTokenCache.AddContext(issuedToken);
+                }
+                return response;
+            }
+            finally
+            {
+                RemoveCachedTokensIfRequired(request.Properties.Security);
+            }
+        }
+
+        internal static bool DoesSkiClauseMatchSigningToken(SecurityContextKeyIdentifierClause skiClause, Message request)
+        {
+            SecurityMessageProperty securityProperty = request.Properties.Security;
+            if (securityProperty == null)
+            {
+                throw TraceUtility.ThrowHelperWarning(new SecurityNegotiationException(SR.Format(SR.SFxSecurityContextPropertyMissingFromRequestMessage)), request);
+            }
+            SecurityContextSecurityToken sct = (securityProperty.ProtectionToken != null) ? (securityProperty.ProtectionToken.SecurityToken as SecurityContextSecurityToken) : null;
+            if (sct != null && skiClause.Matches(sct.ContextId, sct.KeyGeneration))
+            {
+                return true;
+            }
+
+            if (securityProperty.HasIncomingSupportingTokens)
+            {
+                for (int i = 0; i < securityProperty.IncomingSupportingTokens.Count; ++i)
+                {
+                    if (securityProperty.IncomingSupportingTokens[i].SecurityTokenAttachmentMode == SecurityTokenAttachmentMode.Endorsing)
+                    {
+                        sct = securityProperty.IncomingSupportingTokens[i].SecurityToken as SecurityContextSecurityToken;
+                        if (sct != null && skiClause.Matches(sct.ContextId, sct.KeyGeneration))
+                        {
+                            return true;
+                        }
+                    }
+                }
+            }
+            return false;
+        }
+
+        static Message CreateReply(Message request, XmlDictionaryString action, BodyWriter body)
+        {
+            if (request.Headers.MessageId != null)
+            {
+                Message reply = Message.CreateMessage(request.Version, ActionHeader.Create(action, request.Version.Addressing), body);
+               // reply.InitializeReply(request);
+                return reply;
+            }
+            else
+            {
+                // the message id may not be present if MapToHttp is true
+                return Message.CreateMessage(request.Version, ActionHeader.Create(action, request.Version.Addressing), body);
+            }
+        }
+
+        Message ProcessRequest(Message request)
+        {
+            SecuritySessionOperation operation = SecuritySessionOperation.None;
+            try
+            {
+                if (request == null)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("request");
+                }
+                if (request.Headers.Action == this.IssueAction.Value)
+                {
+                    operation = SecuritySessionOperation.Issue;
+                    return this.ProcessIssueRequest(request);
+                }
+                //TODO renew later ?
+                //else if (request.Headers.Action == this.RenewAction.Value)
+                //{
+                //    operation = SecuritySessionOperation.Renew;
+                //    return this.ProcessRenewRequest(request);
+                //}
+                else
+                {
+                    throw TraceUtility.ThrowHelperWarning(new SecurityNegotiationException(SR.Format(SR.InvalidActionForNegotiationMessage, request.Headers.Action)), request);
+                }
+            }
+            catch (Exception e)
+            {
+                if (Fx.IsFatal(e))
+                {
+                    throw;
+                }
+
+                return this.HandleOperationException(operation, request, e);
+            }
+        }
+
+        internal SecuritySessionHost RequestSecurityTokenListener
+        {
+            get
+            {
+                return this.rstListener;
+            }
+        }
+
+        void SetupSessionListener()
+        {
+            ChannelBuilder channelBuilder = new ChannelBuilder(this.IssuerBindingContext, false); //TODO addChannelDemuxerIfRequired to true
+            //channelBuilder.Binding.Elements.Insert(0, new ReplyAdapterBindingElement());
+            //channelBuilder.Binding.Elements.Insert(0, new SecuritySessionAuthenticatorBindingElement(this));
+
+            List<string> supportedMessageActions = new List<string>();
+            supportedMessageActions.Add(this.IssueAction.Value);
+           supportedMessageActions.Add(this.RenewAction.Value);
+
+            SecurityBindingElement securityBindingElement = this.IssuerBindingContext.Binding.Elements.Find<SecurityBindingElement>();
+            //foreach (SecurityTokenParameters stp in new SecurityTokenParametersEnumerable(securityBindingElement))
+            //{
+            //    if (stp is SecureConversationSecurityTokenParameters)
+            //    {
+            //        SecureConversationSecurityTokenParameters scstp = (SecureConversationSecurityTokenParameters)stp;
+            //        if (!scstp.CanRenewSession)
+            //        {
+            //            supportedMessageActions.Remove(this.RenewAction.Value);
+            //            break;
+            //        }
+            //    }
+            //}
+
+            MessageFilter issueAndRenewFilter = new SessionActionFilter(this.standardsManager, supportedMessageActions.ToArray());
+            SecuritySessionHost sessionListener = new SecuritySessionHost(this, issueAndRenewFilter, this.ListenUri, channelBuilder);
+            this.rstListener = sessionListener;
+        }
+
+        /* TODO needed ?
+        internal IChannelListener<TChannel> BuildResponderChannelListener<TChannel>(BindingContext context)
+            where TChannel : class, IChannel
+        {
+            SecurityCredentialsManager securityCredentials = this.IssuerBindingContext.BindingParameters.Find<SecurityCredentialsManager>();
+            if (securityCredentials == null)
+            {
+                securityCredentials = ServiceCredentials.CreateDefaultCredentials();
+            }
+            this.bootstrapSecurityBindingElement.ReaderQuotas = this.IssuerBindingContext.GetInnerProperty<XmlDictionaryReaderQuotas>();
+            if (this.bootstrapSecurityBindingElement.ReaderQuotas == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.EncodingBindingElementDoesNotHandleReaderQuotas)));
+            }
+
+            TransportBindingElement transportBindingElement = context.RemainingBindingElements.Find<TransportBindingElement>();
+            if (transportBindingElement != null)
+                this.bootstrapSecurityBindingElement.MaxReceivedMessageSize = transportBindingElement.MaxReceivedMessageSize;
+
+            SecurityProtocolFactory bootstrapSecurityProtocolFactory = this.bootstrapSecurityBindingElement.CreateSecurityProtocolFactory<TChannel>(this.IssuerBindingContext.Clone(), securityCredentials, true, this.IssuerBindingContext.Clone());
+            if (bootstrapSecurityProtocolFactory is MessageSecurityProtocolFactory)
+            {
+                MessageSecurityProtocolFactory soapBindingFactory = (MessageSecurityProtocolFactory)bootstrapSecurityProtocolFactory;
+                soapBindingFactory.ApplyConfidentiality = soapBindingFactory.ApplyIntegrity
+                = soapBindingFactory.RequireConfidentiality = soapBindingFactory.RequireIntegrity = true;
+
+                soapBindingFactory.ProtectionRequirements.IncomingSignatureParts.ChannelParts.IsBodyIncluded = true;
+                soapBindingFactory.ProtectionRequirements.OutgoingSignatureParts.ChannelParts.IsBodyIncluded = true;
+
+                MessagePartSpecification bodyPart = new MessagePartSpecification(true);
+                soapBindingFactory.ProtectionRequirements.OutgoingSignatureParts.AddParts(bodyPart, this.IssueResponseAction);
+                soapBindingFactory.ProtectionRequirements.OutgoingEncryptionParts.AddParts(bodyPart, this.IssueResponseAction);
+                soapBindingFactory.ProtectionRequirements.OutgoingSignatureParts.AddParts(bodyPart, this.RenewResponseAction);
+                soapBindingFactory.ProtectionRequirements.OutgoingEncryptionParts.AddParts(bodyPart, this.RenewResponseAction);
+
+                soapBindingFactory.ProtectionRequirements.IncomingSignatureParts.AddParts(bodyPart, this.IssueAction);
+                soapBindingFactory.ProtectionRequirements.IncomingEncryptionParts.AddParts(bodyPart, this.IssueAction);
+                soapBindingFactory.ProtectionRequirements.IncomingSignatureParts.AddParts(bodyPart, this.RenewAction);
+                soapBindingFactory.ProtectionRequirements.IncomingEncryptionParts.AddParts(bodyPart, this.RenewAction);
+            }
+
+            SupportingTokenParameters renewSupportingTokenParameters = new SupportingTokenParameters();
+            SecurityContextSecurityTokenParameters sctParameters = new SecurityContextSecurityTokenParameters();
+            sctParameters.RequireDerivedKeys = this.IssuedSecurityTokenParameters.RequireDerivedKeys;
+            renewSupportingTokenParameters.Endorsing.Add(sctParameters);
+            bootstrapSecurityProtocolFactory.SecurityBindingElement.OperationSupportingTokenParameters.Add(this.RenewAction.Value, renewSupportingTokenParameters);
+            bootstrapSecurityProtocolFactory.SecurityTokenManager = new SessionRenewSecurityTokenManager(bootstrapSecurityProtocolFactory.SecurityTokenManager, this.sessionTokenAuthenticator, (SecurityTokenResolver)this.IssuedTokenCache);
+
+            SecurityChannelListener<TChannel> securityChannelListener = new SecurityChannelListener<TChannel>(
+                this.bootstrapSecurityBindingElement, this.IssuerBindingContext);
+            securityChannelListener.SecurityProtocolFactory = bootstrapSecurityProtocolFactory;
+            securityChannelListener.SendUnsecuredFaults = !SecurityUtils.IsCompositeDuplexBinding(context);
+
+            ChannelBuilder channelBuilder = new ChannelBuilder(context, true);
+            securityChannelListener.InitializeListener(channelBuilder);
+            this.shouldMatchRstWithEndpointFilter = SecurityUtils.ShouldMatchRstWithEndpointFilter(this.bootstrapSecurityBindingElement);
+            return securityChannelListener;
+        }*/
+
+       internal class SecuritySessionHost //: ServiceHostBase
+        {
+            ChannelBuilder channelBuilder;
+            MessageFilter filter;
+            Uri listenUri;
+            SecuritySessionSecurityTokenAuthenticator authenticator;
+
+            public SecuritySessionHost(SecuritySessionSecurityTokenAuthenticator authenticator, MessageFilter filter, Uri listenUri, ChannelBuilder channelBuilder)
+            {
+                this.authenticator = authenticator;
+                this.filter = filter;
+                this.listenUri = listenUri;
+                this.channelBuilder = channelBuilder;
+            }
+
+            //protected override ServiceDescription CreateDescription(out IDictionary<string, ContractDescription> implementedContracts)
+            //{
+            //    implementedContracts = null;
+            //    return null;
+            //}
+
+            internal ChannelDispatcher InitializeServiceHost()
+            {
+                MessageFilter contractFilter = this.filter;
+                int filterPriority = Int32.MaxValue - 10;
+                List<Type> endpointChannelTypes = new List<Type> {  typeof(IReplyChannel),
+                                                           typeof(IDuplexChannel),
+                                                           typeof(IReplySessionChannel),
+                                                           typeof(IDuplexSessionChannel) };
+
+              //  IChannelListener listener = null;
+                BindingParameterCollection parameters = new BindingParameterCollection(this.channelBuilder.BindingParameters);
+                Binding binding = this.channelBuilder.Binding;
+                binding.ReceiveTimeout = this.authenticator.NegotiationTimeout;
+                // parameters.Add(new ChannelDemuxerFilter(contractFilter, filterPriority));
+                // DispatcherBuilder.MaybeCreateListener(true, endpointChannelTypes, binding, parameters,
+                //                                      this.listenUri, "", ListenUriMode.Explicit, this.ServiceThrottle, out listener);
+                //   if (listener == null)
+                // {
+                //      throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.CannotCreateTwoWayListenerForNegotiation)));
+                //  }
+
+                var bindingQname = new XmlQualifiedName(binding.Name, binding.Namespace);
+                var channelDispatcher = new ChannelDispatcher(listenUri, binding, bindingQname.ToString(), binding, endpointChannelTypes);
+                channelDispatcher.MessageVersion = binding.MessageVersion;
+                channelDispatcher.ManualAddressing = true;
+              //  channelDispatcher.ServiceThrottle = new ServiceThrottle(this);
+              //  channelDispatcher.ServiceThrottle.MaxConcurrentCalls = this.authenticator.MaximumConcurrentNegotiations;
+              //  channelDispatcher.ServiceThrottle.MaxConcurrentSessions = this.authenticator.MaximumConcurrentNegotiations;
+
+                EndpointDispatcher endpointDispatcher = new EndpointDispatcher(new EndpointAddress(this.listenUri), "IssueAndRenewSession", NamingHelper.DefaultNamespace, true);
+                endpointDispatcher.DispatchRuntime.SingletonInstanceContext = new InstanceContext(null, this.authenticator, false);
+                endpointDispatcher.DispatchRuntime.ConcurrencyMode = ConcurrencyMode.Multiple;
+                endpointDispatcher.AddressFilter = new MatchAllMessageFilter();
+                endpointDispatcher.ContractFilter = contractFilter;
+                endpointDispatcher.FilterPriority = filterPriority;
+                endpointDispatcher.DispatchRuntime.PrincipalPermissionMode = PrincipalPermissionMode.None;
+                endpointDispatcher.DispatchRuntime.InstanceContextProvider = new SingletonInstanceContextProvider(endpointDispatcher.DispatchRuntime);
+                endpointDispatcher.DispatchRuntime.SynchronizationContext = null;
+
+                if (this.authenticator.IssuerBindingContext != null && this.authenticator.IssuerBindingContext.BindingParameters != null)
+                {
+                    ServiceAuthenticationManager serviceAuthenticationManager = this.authenticator.IssuerBindingContext.BindingParameters.Find<ServiceAuthenticationManager>();
+                    if (serviceAuthenticationManager != null)
+                    {
+                        endpointDispatcher.DispatchRuntime.ServiceAuthenticationManager = new SCTServiceAuthenticationManagerWrapper(serviceAuthenticationManager);
+                    }
+                }
+
+                DispatchOperation operation = new DispatchOperation(endpointDispatcher.DispatchRuntime, "*", MessageHeaders.WildcardAction, MessageHeaders.WildcardAction);
+                operation.Formatter = new MessageOperationFormatter();
+                operation.Invoker = new SecuritySessionAuthenticatorInvoker(this.authenticator);
+
+                endpointDispatcher.DispatchRuntime.UnhandledDispatchOperation = operation;
+                channelDispatcher.Endpoints.Add(endpointDispatcher);
+                channelDispatcher.Init();
+                var openTask = channelDispatcher.OpenAsync();
+                Fx.Assert(openTask.IsCompleted, "ChannelDispatcher should open synchronously");
+                openTask.GetAwaiter().GetResult();
+                return channelDispatcher;
+               // this.ChannelDispatchers.Add(channelDispatcher);
+            }
+
+            class SecuritySessionAuthenticatorInvoker : IOperationInvoker
+            {
+                SecuritySessionSecurityTokenAuthenticator parent;
+
+                internal SecuritySessionAuthenticatorInvoker(SecuritySessionSecurityTokenAuthenticator parent)
+                {
+                    this.parent = parent;
+                }
+
+                public bool IsSynchronous { get { return true; } }
+
+                public object[] AllocateInputs()
+                {
+                    return EmptyArray<object>.Allocate(1);
+                }
+
+                public  ValueTask<(object returnValue, object[] outputs)> InvokeAsync(object instance, object[] inputs)
+                {
+                   object[] outputs = EmptyArray<object>.Allocate(0);
+                    Message message = inputs[0] as Message;
+                    if (message == null)
+                    {
+                        return new ValueTask<(object returnValue, object[] outputs)>(((object)null, outputs));
+                    }
+                    object returnVal =  parent.ProcessRequest(message);
+                    return new ValueTask<(object returnValue, object[] outputs)>((returnVal, outputs));
+                }
+            }
+        }
+
+
+        class SecuritySessionAuthenticatorBindingElement : BindingElement
+        {
+            SecuritySessionSecurityTokenAuthenticator authenticator;
+
+            public SecuritySessionAuthenticatorBindingElement(SecuritySessionSecurityTokenAuthenticator authenticator)
+            {
+                this.authenticator = authenticator;
+            }
+
+            /*
+            public override IChannelListener<TChannel> BuildChannelListener<TChannel>(BindingContext context)
+            {
+                if (context == null)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("context");
+                }
+
+                return authenticator.BuildResponderChannelListener<TChannel>(context);
+            }*/
+
+            public override BindingElement Clone()
+            {
+                return new SecuritySessionAuthenticatorBindingElement(this.authenticator);
+            }
+
+            public override T GetProperty<T>(BindingContext context)
+            {
+                if (typeof(T) == typeof(ISecurityCapabilities))
+                {
+                    return (T)(object)authenticator.BootstrapSecurityBindingElement.GetProperty<ISecurityCapabilities>(context);
+                }
+
+                return context.GetInnerProperty<T>();
+            }
+        }
+
+        //public class SessionRenewSecurityTokenManager : SecurityTokenManager
+        //{
+        //    SecurityTokenManager innerTokenManager;
+        //    SecurityTokenAuthenticator renewTokenAuthenticator;
+        //    SecurityTokenResolver renewTokenResolver;
+
+        //    public SessionRenewSecurityTokenManager(SecurityTokenManager innerTokenManager, SecurityTokenAuthenticator renewTokenAuthenticator,
+        //        SecurityTokenResolver renewTokenResolver)
+        //    {
+        //        this.innerTokenManager = innerTokenManager;
+        //        this.renewTokenAuthenticator = renewTokenAuthenticator;
+        //        this.renewTokenResolver = renewTokenResolver;
+        //    }
+
+        //    public override SecurityTokenAuthenticator CreateSecurityTokenAuthenticator(SecurityTokenRequirement tokenRequirement, out SecurityTokenResolver outOfBandTokenResolver)
+        //    {
+        //        if (tokenRequirement == null)
+        //            throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("tokenRequirement");
+
+        //        if (tokenRequirement.TokenType == ServiceModelSecurityTokenTypes.SecurityContext)
+        //        {
+        //            outOfBandTokenResolver = this.renewTokenResolver;
+        //            return this.renewTokenAuthenticator;
+        //        }
+        //        else
+        //        {
+        //            return this.innerTokenManager.CreateSecurityTokenAuthenticator(tokenRequirement, out outOfBandTokenResolver);
+        //        }
+        //    }
+
+        //    public override SecurityTokenProvider CreateSecurityTokenProvider(SecurityTokenRequirement requirement)
+        //    {
+        //        return this.innerTokenManager.CreateSecurityTokenProvider(requirement);
+        //    }
+
+        //    public override SecurityTokenSerializer CreateSecurityTokenSerializer(SecurityTokenVersion version)
+        //    {
+        //        return this.innerTokenManager.CreateSecurityTokenSerializer(version);
+        //    }
+
+
+        //}
+    }
+
+    class SessionActionFilter : HeaderFilter
+    {
+        SecurityStandardsManager standardsManager;
+        string[] actions;
+
+        public SessionActionFilter(SecurityStandardsManager standardsManager, params string[] actions)
+        {
+            this.actions = actions;
+            this.standardsManager = standardsManager;
+        }
+
+        public override bool Match(Message message)
+        {
+            for (int i = 0; i < this.actions.Length; ++i)
+            {
+                if (message.Headers.Action == this.actions[i])
+                {
+                    return this.standardsManager.DoesMessageContainSecurityHeader(message);
+                }
+            }
+            return false;
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/SecuritySessionServerSettings.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/SecuritySessionServerSettings.cs
new file mode 100644
index 0000000..c579701
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/SecuritySessionServerSettings.cs
@@ -0,0 +1,2531 @@
+using System.Collections.Generic;
+using System.Diagnostics;
+using CoreWCF.IdentityModel.Claims;
+using CoreWCF.IdentityModel.Selectors;
+using CoreWCF.IdentityModel.Tokens;
+using System.Runtime;
+using CoreWCF;
+using CoreWCF.Channels;
+using CoreWCF.Description;
+using CoreWCF.Diagnostics;
+using CoreWCF.Dispatcher;
+using CoreWCF.Security.Tokens;
+using System.Threading;
+using System.Xml;
+using System.Globalization;
+using CoreWCF.Diagnostics;
+using System;
+using CoreWCF.Runtime;
+using CoreWCF.Configuration;
+using System.Threading.Tasks;
+using System.Net;
+using CoreWCF.IdentityModel;
+
+namespace CoreWCF.Security
+{
+    public sealed class SecuritySessionServerSettings : IListenerSecureConversationSessionSettings, ISecurityCommunicationObject
+    {
+        internal const string defaultKeyRenewalIntervalString = "15:00:00";
+        internal const string defaultKeyRolloverIntervalString = "00:05:00";
+        internal const string defaultInactivityTimeoutString = "00:02:00";
+
+        internal static readonly TimeSpan defaultKeyRenewalInterval = TimeSpan.Parse(defaultKeyRenewalIntervalString, CultureInfo.InvariantCulture);
+        internal static readonly TimeSpan defaultKeyRolloverInterval = TimeSpan.Parse(defaultKeyRolloverIntervalString, CultureInfo.InvariantCulture);
+        internal const bool defaultTolerateTransportFailures = true;
+        internal const int defaultMaximumPendingSessions = 128;
+        internal static readonly TimeSpan defaultInactivityTimeout = TimeSpan.Parse(defaultInactivityTimeoutString, CultureInfo.InvariantCulture);
+
+        int maximumPendingSessions;
+        Dictionary<UniqueId, SecurityContextSecurityToken> pendingSessions1;
+        Dictionary<UniqueId, SecurityContextSecurityToken> pendingSessions2;
+        IOThreadTimer inactivityTimer;
+        TimeSpan inactivityTimeout;
+        bool tolerateTransportFailures;
+        TimeSpan maximumKeyRenewalInterval;
+        TimeSpan keyRolloverInterval;
+        int maximumPendingKeysPerSession;
+        SecurityProtocolFactory sessionProtocolFactory;
+        ICommunicationObject channelAcceptor;
+        Dictionary<UniqueId, IServerSecuritySessionChannel> activeSessions;
+        SecurityServiceDispatcher securityServiceDispatcher;
+        ChannelBuilder channelBuilder;
+        SecurityStandardsManager standardsManager;
+        SecurityTokenParameters issuedTokenParameters;
+        SecurityTokenAuthenticator sessionTokenAuthenticator;
+        ISecurityContextSecurityTokenCache sessionTokenCache;
+        SecurityTokenResolver sessionTokenResolver;
+        WrapperSecurityCommunicationObject communicationObject;
+        volatile bool acceptNewWork;
+        MessageVersion messageVersion;
+        TimeSpan closeTimeout;
+        TimeSpan openTimeout;
+        TimeSpan sendTimeout;
+        Uri listenUri;
+        SecurityListenerSettingsLifetimeManager settingsLifetimeManager;
+        bool canRenewSession = true;
+        readonly object thisLock = new object();
+
+        public event EventHandler Closed;
+        public event EventHandler Closing;
+        public event EventHandler Faulted;
+        public event EventHandler Opened;
+        public event EventHandler Opening;
+
+        public SecuritySessionServerSettings()
+        {
+            activeSessions = new Dictionary<UniqueId, IServerSecuritySessionChannel>();
+
+            this.maximumKeyRenewalInterval = defaultKeyRenewalInterval;
+            this.maximumPendingKeysPerSession = 5;
+            this.keyRolloverInterval = defaultKeyRolloverInterval;
+            this.inactivityTimeout = defaultInactivityTimeout;
+            this.tolerateTransportFailures = defaultTolerateTransportFailures;
+            this.maximumPendingSessions = defaultMaximumPendingSessions;
+            this.communicationObject = new WrapperSecurityCommunicationObject(this);
+        }
+
+        internal ChannelBuilder ChannelBuilder
+        {
+            get
+            {
+                return this.channelBuilder;
+            }
+            set
+            {
+                this.communicationObject.ThrowIfDisposedOrImmutable();
+                this.channelBuilder = value;
+            }
+        }
+
+        internal  WrapperSecurityCommunicationObject WrapperCommunicationObj
+        {
+            get { return this.communicationObject; }
+        }
+        internal SecurityListenerSettingsLifetimeManager SettingsLifetimeManager
+        {
+            get
+            {
+                return this.settingsLifetimeManager;
+            }
+            set
+            {
+                this.communicationObject.ThrowIfDisposedOrImmutable();
+                this.settingsLifetimeManager = value;
+            }
+        }
+
+        internal SecurityServiceDispatcher SecurityServiceDispatcher
+        {
+            get
+            {
+                return this.securityServiceDispatcher;
+            }
+            set
+            {
+                this.communicationObject.ThrowIfDisposedOrImmutable();
+                this.securityServiceDispatcher = value;
+            }
+        }
+
+        Uri Uri
+        {
+            get
+            {
+                this.communicationObject.ThrowIfNotOpened();
+                return this.listenUri;
+            }
+        }
+
+       internal object ThisLock
+        {
+            get
+            {
+                return this.thisLock;
+            }
+        }
+
+        public SecurityTokenAuthenticator SessionTokenAuthenticator
+        {
+            get
+            {
+                return this.sessionTokenAuthenticator;
+            }
+        }
+
+        public ISecurityContextSecurityTokenCache SessionTokenCache
+        {
+            get
+            {
+                return this.sessionTokenCache;
+            }
+        }
+
+        public SecurityTokenResolver SessionTokenResolver
+        {
+            get
+            {
+                return this.sessionTokenResolver;
+            }
+        }
+
+        public SecurityTokenParameters IssuedSecurityTokenParameters
+        {
+            get
+            {
+                return this.issuedTokenParameters;
+            }
+            set
+            {
+                this.communicationObject.ThrowIfDisposedOrImmutable();
+                this.issuedTokenParameters = value;
+            }
+        }
+
+        internal SecurityStandardsManager SecurityStandardsManager
+        {
+            get
+            {
+                return this.standardsManager;
+            }
+            set
+            {
+                this.communicationObject.ThrowIfDisposedOrImmutable();
+                this.standardsManager = value;
+            }
+        }
+
+        public bool TolerateTransportFailures
+        {
+            get
+            {
+                return this.tolerateTransportFailures;
+            }
+            set
+            {
+                this.communicationObject.ThrowIfDisposedOrImmutable();
+                this.tolerateTransportFailures = value;
+            }
+        }
+
+        public bool CanRenewSession
+        {
+            get
+            {
+                return this.canRenewSession;
+            }
+            set
+            {
+                this.canRenewSession = value;
+            }
+        }
+
+        public int MaximumPendingSessions
+        {
+            get
+            {
+                return this.maximumPendingSessions;
+            }
+            set
+            {
+                if (value <= 0)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("value"));
+                }
+
+                this.communicationObject.ThrowIfDisposedOrImmutable();
+                this.maximumPendingSessions = value;
+            }
+        }
+
+        public TimeSpan InactivityTimeout
+        {
+            get
+            {
+                return this.inactivityTimeout;
+            }
+            set
+            {
+                if (value <= TimeSpan.Zero)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("value", SR.Format(SR.TimeSpanMustbeGreaterThanTimeSpanZero)));
+                }
+
+                this.communicationObject.ThrowIfDisposedOrImmutable();
+                this.inactivityTimeout = value;
+            }
+        }
+
+        public TimeSpan MaximumKeyRenewalInterval
+        {
+            get
+            {
+                return this.maximumKeyRenewalInterval;
+            }
+            set
+            {
+                if (value <= TimeSpan.Zero)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("value", SR.Format(SR.TimeSpanMustbeGreaterThanTimeSpanZero)));
+                }
+                this.communicationObject.ThrowIfDisposedOrImmutable();
+                this.maximumKeyRenewalInterval = value;
+            }
+        }
+
+        public TimeSpan KeyRolloverInterval
+        {
+            get
+            {
+                return this.keyRolloverInterval;
+            }
+            set
+            {
+                if (value <= TimeSpan.Zero)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("value", SR.Format(SR.TimeSpanMustbeGreaterThanTimeSpanZero)));
+                }
+                this.communicationObject.ThrowIfDisposedOrImmutable();
+                this.keyRolloverInterval = value;
+            }
+        }
+
+        public int MaximumPendingKeysPerSession
+        {
+            get
+            {
+                return this.maximumPendingKeysPerSession;
+            }
+            set
+            {
+                if (value <= 0)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("value", SR.Format(SR.ValueMustBeGreaterThanZero)));
+                }
+                this.communicationObject.ThrowIfDisposedOrImmutable();
+                this.maximumPendingKeysPerSession = value;
+            }
+        }
+
+        public SecurityProtocolFactory SessionProtocolFactory
+        {
+            get
+            {
+                return this.sessionProtocolFactory;
+            }
+            set
+            {
+                this.communicationObject.ThrowIfDisposedOrImmutable();
+                this.sessionProtocolFactory = value;
+            }
+        }
+
+        public MessageVersion MessageVersion
+        {
+            get
+            {
+                return this.messageVersion;
+            }
+        }
+
+        public TimeSpan OpenTimeout
+        {
+            get
+            {
+                return this.openTimeout;
+            }
+        }
+
+        public TimeSpan CloseTimeout
+        {
+            get
+            {
+                return this.closeTimeout;
+            }
+        }
+
+        public TimeSpan SendTimeout
+        {
+            get
+            {
+                return this.sendTimeout;
+            }
+        }
+
+
+        // ISecurityCommunicationObject members
+        public TimeSpan DefaultOpenTimeout
+        {
+            get { return ServiceDefaults.OpenTimeout; }
+        }
+
+        public TimeSpan DefaultCloseTimeout
+        {
+            get { return ServiceDefaults.CloseTimeout; }
+        }
+
+
+        public void OnFaulted()
+        {
+        }
+
+        public void OnOpened()
+        {
+        }
+
+        public void OnOpening()
+        {
+        }
+
+        public void OnAbort()
+        {
+            this.AbortPendingChannels();
+            this.OnAbortCore();
+        }
+
+        internal void Abort()
+        {
+            this.communicationObject.Abort();
+        }
+
+        void OnCloseCore(TimeSpan timeout)
+        {
+            TimeoutHelper timeoutHelper = new TimeoutHelper(timeout);
+            if (this.inactivityTimer != null)
+            {
+                this.inactivityTimer.Cancel();
+            }
+            if (this.sessionProtocolFactory != null)
+            {
+                this.sessionProtocolFactory.OnCloseAsync(timeoutHelper.RemainingTime());
+            }
+            if (this.sessionTokenAuthenticator != null)
+            {
+                SecurityUtils.CloseTokenAuthenticatorIfRequired(this.sessionTokenAuthenticator, timeoutHelper.RemainingTime());
+            }
+        }
+
+        void OnAbortCore()
+        {
+            if (this.inactivityTimer != null)
+            {
+                this.inactivityTimer.Cancel();
+            }
+            if (this.sessionProtocolFactory != null)
+            {
+                this.sessionProtocolFactory.OnCloseAsync(TimeSpan.Zero);
+            }
+            if (this.sessionTokenAuthenticator != null)
+            {
+                SecurityUtils.AbortTokenAuthenticatorIfRequired(this.sessionTokenAuthenticator);
+            }
+        }
+
+        private Task SetupSessionTokenAuthenticatorAsync()
+        {
+            RecipientServiceModelSecurityTokenRequirement requirement = new RecipientServiceModelSecurityTokenRequirement();
+            this.issuedTokenParameters.InitializeSecurityTokenRequirement(requirement);
+            requirement.KeyUsage = SecurityKeyUsage.Signature;
+            requirement.ListenUri = this.listenUri;
+            requirement.SecurityBindingElement = this.sessionProtocolFactory.SecurityBindingElement;
+            requirement.SecurityAlgorithmSuite = this.sessionProtocolFactory.IncomingAlgorithmSuite;
+            requirement.SupportSecurityContextCancellation = true;
+            requirement.MessageSecurityVersion = sessionProtocolFactory.MessageSecurityVersion.SecurityTokenVersion;
+            // requirement.AuditLogLocation = sessionProtocolFactory.AuditLogLocation;
+            // requirement.SuppressAuditFailure = sessionProtocolFactory.SuppressAuditFailure;
+            // requirement.MessageAuthenticationAuditLevel = sessionProtocolFactory.MessageAuthenticationAuditLevel;
+            requirement.Properties[ServiceModelSecurityTokenRequirement.MessageDirectionProperty] = MessageDirection.Input;
+            if (sessionProtocolFactory.EndpointFilterTable != null)
+            {
+                requirement.Properties[ServiceModelSecurityTokenRequirement.EndpointFilterTableProperty] = sessionProtocolFactory.EndpointFilterTable;
+            }
+            this.sessionTokenAuthenticator = this.sessionProtocolFactory.SecurityTokenManager.CreateSecurityTokenAuthenticator(requirement, out this.sessionTokenResolver);
+            if (!(this.sessionTokenAuthenticator is IIssuanceSecurityTokenAuthenticator))
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.SecuritySessionRequiresIssuanceAuthenticator, typeof(IIssuanceSecurityTokenAuthenticator), this.sessionTokenAuthenticator.GetType())));
+            }
+            if (sessionTokenResolver == null || (!(sessionTokenResolver is ISecurityContextSecurityTokenCache)))
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.SecuritySessionRequiresSecurityContextTokenCache, this.sessionTokenResolver.GetType(), typeof(ISecurityContextSecurityTokenCache))));
+            }
+            this.sessionTokenCache = (ISecurityContextSecurityTokenCache)this.sessionTokenResolver;
+            return Task.CompletedTask;
+        }
+
+
+        public void Init(TimeSpan timeout) // renaming to Init
+        {
+
+        }
+
+        public void StopAcceptingNewWork()
+        {
+            this.acceptNewWork = false;
+        }
+
+        int GetPendingSessionCount()
+        {
+            return this.pendingSessions1.Count + this.pendingSessions2.Count;
+            //+ ((IInputQueueChannelAcceptor)this.channelAcceptor).PendingCount;
+        }
+
+        void AbortPendingChannels()
+        {
+            lock (ThisLock)
+            {
+                if (this.pendingSessions1 != null)
+                {
+                    foreach (IServerReliableChannelBinder pendingChannelBinder in pendingSessions1.Values)
+                    {
+                        pendingChannelBinder.Abort();
+                    }
+                }
+                if (this.pendingSessions2 != null)
+                {
+                    foreach (IServerReliableChannelBinder pendingChannelBinder in pendingSessions2.Values)
+                    {
+                        pendingChannelBinder.Abort();
+                    }
+                }
+            }
+        }
+
+        //void ClosePendingChannels(TimeSpan timeout)
+        //{
+        //    TimeoutHelper timeoutHelper = new TimeoutHelper(timeout);
+        //    lock (ThisLock)
+        //    {
+        //        foreach (IServerReliableChannelBinder pendingChannelBinder in pendingSessions1.Values)
+        //        {
+        //            pendingChannelBinder.Close(timeoutHelper.RemainingTime());
+        //        }
+        //        foreach (IServerReliableChannelBinder pendingChannelBinder in pendingSessions2.Values)
+        //        {
+        //            pendingChannelBinder.Close(timeoutHelper.RemainingTime());
+        //        }
+        //    }
+        //}
+
+        void ConfigureSessionSecurityProtocolFactory()
+        {
+            //TODO while implementing message security
+
+            //if (this.sessionProtocolFactory is SessionSymmetricMessageSecurityProtocolFactory)
+            //{
+            //    AddressingVersion addressing = MessageVersion.Default.Addressing;
+            //    if (this.channelBuilder != null)
+            //    {
+            //        MessageEncodingBindingElement encoding = this.channelBuilder.Binding.Elements.Find<MessageEncodingBindingElement>();
+            //        if (encoding != null)
+            //        {
+            //            addressing = encoding.MessageVersion.Addressing;
+            //        }
+            //    }
+
+            //    if (addressing != AddressingVersion.WSAddressing10 && addressing != AddressingVersion.WSAddressingAugust2004)
+            //    {
+            //        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(
+            //            new ProtocolException(SR.Format(SR.AddressingVersionNotSupported, addressing)));
+            //    }
+
+            //    SessionSymmetricMessageSecurityProtocolFactory messagePf = (SessionSymmetricMessageSecurityProtocolFactory)this.sessionProtocolFactory;
+            //    if (!messagePf.ApplyIntegrity || !messagePf.RequireIntegrity)
+            //    {
+            //        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.SecuritySessionRequiresMessageIntegrity)));
+            //    }
+            //    MessagePartSpecification bodyPart = new MessagePartSpecification(true);
+            //    messagePf.ProtectionRequirements.IncomingSignatureParts.AddParts(bodyPart, this.SecurityStandardsManager.SecureConversationDriver.CloseAction);
+            //    messagePf.ProtectionRequirements.IncomingSignatureParts.AddParts(bodyPart, this.SecurityStandardsManager.SecureConversationDriver.CloseResponseAction);
+            //    messagePf.ProtectionRequirements.OutgoingSignatureParts.AddParts(bodyPart, this.SecurityStandardsManager.SecureConversationDriver.CloseResponseAction);
+            //    messagePf.ProtectionRequirements.OutgoingSignatureParts.AddParts(bodyPart, this.SecurityStandardsManager.SecureConversationDriver.CloseAction);
+            //    messagePf.ProtectionRequirements.OutgoingSignatureParts.AddParts(bodyPart, addressing.FaultAction);
+            //    messagePf.ProtectionRequirements.OutgoingSignatureParts.AddParts(bodyPart, addressing.DefaultFaultAction);
+            //    messagePf.ProtectionRequirements.OutgoingSignatureParts.AddParts(bodyPart, DotNetSecurityStrings.SecuritySessionFaultAction);
+            //    if (messagePf.ApplyConfidentiality)
+            //    {
+            //        messagePf.ProtectionRequirements.OutgoingEncryptionParts.AddParts(MessagePartSpecification.NoParts, this.SecurityStandardsManager.SecureConversationDriver.CloseResponseAction);
+            //        messagePf.ProtectionRequirements.OutgoingEncryptionParts.AddParts(MessagePartSpecification.NoParts, this.SecurityStandardsManager.SecureConversationDriver.CloseAction);
+            //        messagePf.ProtectionRequirements.OutgoingEncryptionParts.AddParts(bodyPart, addressing.FaultAction);
+            //        messagePf.ProtectionRequirements.OutgoingEncryptionParts.AddParts(bodyPart, addressing.DefaultFaultAction);
+            //        messagePf.ProtectionRequirements.OutgoingEncryptionParts.AddParts(bodyPart, DotNetSecurityStrings.SecuritySessionFaultAction);
+            //    }
+            //    if (messagePf.RequireConfidentiality)
+            //    {
+            //        messagePf.ProtectionRequirements.IncomingEncryptionParts.AddParts(MessagePartSpecification.NoParts, this.SecurityStandardsManager.SecureConversationDriver.CloseAction);
+            //        messagePf.ProtectionRequirements.IncomingEncryptionParts.AddParts(MessagePartSpecification.NoParts, this.SecurityStandardsManager.SecureConversationDriver.CloseResponseAction);
+            //    }
+            //    messagePf.SecurityTokenParameters = this.IssuedSecurityTokenParameters;
+            //}
+            //else
+            if (this.sessionProtocolFactory is SessionSymmetricTransportSecurityProtocolFactory)
+            {
+                SessionSymmetricTransportSecurityProtocolFactory transportPf = (SessionSymmetricTransportSecurityProtocolFactory)this.sessionProtocolFactory;
+                transportPf.AddTimestamp = true;
+                transportPf.SecurityTokenParameters = this.IssuedSecurityTokenParameters;
+                transportPf.SecurityTokenParameters.RequireDerivedKeys = false;
+            }
+            else
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new NotSupportedException());
+            }
+        }
+
+        /*
+        internal IChannelAcceptor<TChannel> CreateAcceptor<TChannel>()
+            where TChannel : class, IChannel
+        {
+            if (this.channelAcceptor != null)
+            {
+                Fx.Assert("SecuritySessionServerSettings.CreateAcceptor (this.channelAcceptor != null)");
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.SSSSCreateAcceptor)));
+            }
+            object listenerSecurityState = this.sessionProtocolFactory.CreateListenerSecurityState();
+            if (typeof(TChannel) == typeof(IReplySessionChannel))
+            {
+                this.channelAcceptor = new SecuritySessionChannelAcceptor<IReplySessionChannel>(this.securityServiceDispatcher, listenerSecurityState);
+            }
+            else if (typeof(TChannel) == typeof(IDuplexSessionChannel))
+            {
+                this.channelAcceptor = new SecuritySessionChannelAcceptor<IDuplexSessionChannel>(this.securityServiceDispatcher, listenerSecurityState);
+            }
+            else
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new NotSupportedException());
+            }
+            return (IChannelAcceptor<TChannel>)this.channelAcceptor;
+        }*/
+
+        /*
+        internal IChannelListener CreateInnerChannelListener()
+        {
+            if (this.ChannelBuilder.CanBuildChannelListener<IDuplexSessionChannel>())
+            {
+                return this.ChannelBuilder.BuildChannelListener<IDuplexSessionChannel>(new MatchNoneMessageFilter(), int.MinValue);
+            }
+            else if (this.ChannelBuilder.CanBuildChannelListener<IDuplexChannel>())
+            {
+                return this.ChannelBuilder.BuildChannelListener<IDuplexChannel>(new MatchNoneMessageFilter(), int.MinValue);
+            }
+            else if (this.ChannelBuilder.CanBuildChannelListener<IReplyChannel>())
+            {
+                return this.ChannelBuilder.BuildChannelListener<IReplyChannel>(new MatchNoneMessageFilter(), int.MinValue);
+            }
+            else
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new NotSupportedException());
+            }
+        }*/
+
+        void OnTokenRenewed(SecurityToken newToken, SecurityToken oldToken)
+        {
+            this.communicationObject.ThrowIfClosed();
+            if (!this.acceptNewWork)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new EndpointNotFoundException(SR.Format(SR.SecurityListenerClosing)));
+            }
+            SecurityContextSecurityToken newSecurityContextToken = newToken as SecurityContextSecurityToken;
+            if (newSecurityContextToken == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.SessionTokenIsNotSecurityContextToken, newToken.GetType(), typeof(SecurityContextSecurityToken))));
+            }
+            SecurityContextSecurityToken oldSecurityContextToken = oldToken as SecurityContextSecurityToken;
+            if (oldSecurityContextToken == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.SessionTokenIsNotSecurityContextToken, oldToken.GetType(), typeof(SecurityContextSecurityToken))));
+            }
+            IServerSecuritySessionChannel sessionChannel = this.FindSessionChannel(newSecurityContextToken.ContextId);
+            if (sessionChannel == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new MessageSecurityException(SR.Format(SR.CannotFindSecuritySession, newSecurityContextToken.ContextId)));
+            }
+            sessionChannel.RenewSessionToken(newSecurityContextToken, oldSecurityContextToken);
+        }
+
+
+        IServerReliableChannelBinder CreateChannelBinder(SecurityContextSecurityToken sessionToken, EndpointAddress remoteAddress)
+        {
+            IServerReliableChannelBinder result = null;
+
+
+          //  MessageFilter sctFilter = new SecuritySessionFilter(sessionToken.ContextId, this.sessionProtocolFactory.StandardsManager, (this.sessionProtocolFactory.SecurityHeaderLayout == SecurityHeaderLayout.Strict), this.SecurityStandardsManager.SecureConversationDriver.RenewAction.Value, this.SecurityStandardsManager.SecureConversationDriver.RenewResponseAction.Value);
+            int sctPriority = Int32.MaxValue;
+            TolerateFaultsMode faultMode = this.TolerateTransportFailures ? TolerateFaultsMode.Always : TolerateFaultsMode.Never;
+           // lock (ThisLock)
+           // {
+                //if (this.ChannelBuilder.CanBuildChannelListener<IDuplexSessionChannel>())
+                //{
+                //    result = ServerReliableChannelBinder<IDuplexSessionChannel>.CreateBinder(this.ChannelBuilder, remoteAddress, sctFilter, sctPriority, faultMode,
+                //        this.CloseTimeout, this.SendTimeout);
+                //}
+                //else if (this.ChannelBuilder.CanBuildChannelListener<IDuplexChannel>())
+                //{
+                //    result = ServerReliableChannelBinder<IDuplexChannel>.CreateBinder(this.ChannelBuilder, remoteAddress, sctFilter, sctPriority, faultMode,
+                //        this.CloseTimeout, this.SendTimeout);
+                //}
+                //else
+
+                //if (this.ChannelBuilder.CanBuildChannelListener<IReplyChannel>())
+                //{
+                //    result = ServerReliableChannelBinder<IReplyChannel>.CreateBinder(this.ChannelBuilder, remoteAddress, sctFilter, sctPriority, faultMode,
+                //        this.CloseTimeout, this.SendTimeout);
+                //}
+           // }
+          //  if (result == null)
+            //{
+            //    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new NotSupportedException());
+            //}
+
+           // result.Open(this.OpenTimeout);
+           // SessionInitiationMessageHandler handler = new SessionInitiationMessageHandler(result, this, sessionToken);
+           // handler.BeginReceive(TimeSpan.MaxValue);
+            return result;
+        }
+
+        void OnTokenIssued(SecurityToken issuedToken, EndpointAddress tokenRequestor)
+        {
+            this.communicationObject.ThrowIfClosed(); //TODO mark open
+            if (!this.acceptNewWork)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new EndpointNotFoundException(SR.Format(SR.SecurityListenerClosing)));
+            }
+            SecurityContextSecurityToken issuedSecurityContextToken = issuedToken as SecurityContextSecurityToken;
+            if (issuedSecurityContextToken == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.SessionTokenIsNotSecurityContextToken, issuedToken.GetType(), typeof(SecurityContextSecurityToken))));
+            }
+           // IServerReliableChannelBinder channelBinder = CreateChannelBinder(issuedSecurityContextToken, tokenRequestor ?? EndpointAddress.AnonymousAddress);
+            bool wasSessionAdded = false;
+            try
+            {
+                this.AddPendingSession(issuedSecurityContextToken.ContextId, issuedSecurityContextToken);
+                wasSessionAdded = true;
+            }
+            finally
+            {
+                //if (!wasSessionAdded)
+                //{
+                //    channelBinder.Abort();
+                //}
+            }
+        }
+       internal SecurityContextSecurityToken GetSecurityContextSecurityToken(UniqueId sessionId)
+        {
+            if (this.pendingSessions1 != null && this.pendingSessions1.ContainsKey(sessionId))
+                return this.pendingSessions1[sessionId];
+            if (this.pendingSessions2 != null && this.pendingSessions2.ContainsKey(sessionId))
+                return this.pendingSessions2[sessionId];
+            return null;
+        }
+
+        void OnTimer(object state)
+        {
+            if (this.communicationObject.State == CommunicationState.Closed
+                || this.communicationObject.State == CommunicationState.Faulted)
+            {
+                return;
+            }
+            try
+            {
+                this.ClearPendingSessions();
+            }
+            catch (Exception e)
+            {
+                if (Fx.IsFatal(e))
+                {
+                    throw;
+                }
+            }
+            finally
+            {
+                if (this.communicationObject.State != CommunicationState.Closed
+                    && this.communicationObject.State != CommunicationState.Closing
+                    && this.communicationObject.State != CommunicationState.Faulted)
+                {
+                    this.inactivityTimer.Set(this.inactivityTimeout);
+                }
+            }
+        }
+
+        void AddPendingSession(UniqueId sessionId, SecurityContextSecurityToken securityToken)
+        {
+            lock (ThisLock)
+            {
+                if ((GetPendingSessionCount() + 1) > this.MaximumPendingSessions)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new QuotaExceededException(SR.Format(SR.SecuritySessionLimitReached)));
+                }
+                if (this.pendingSessions1.ContainsKey(sessionId) || this.pendingSessions2.ContainsKey(sessionId))
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new MessageSecurityException(SR.Format(SR.SecuritySessionAlreadyPending, sessionId)));
+                }
+                this.pendingSessions1.Add(sessionId, securityToken);
+            }
+            //SecurityTraceRecordHelper.TracePendingSessionAdded(sessionId, this.Uri);
+            //if (TD.SecuritySessionRatioIsEnabled())
+            //{
+            //    TD.SecuritySessionRatio(GetPendingSessionCount(), this.MaximumPendingSessions);
+            //}
+        }
+
+        void TryCloseBinder(IServerReliableChannelBinder binder, TimeSpan timeout)
+        {
+            bool abortBinder = false;
+            try
+            {
+                binder.CloseAsync(timeout);
+            }
+            catch (CommunicationException e)
+            {
+                abortBinder = true;
+                DiagnosticUtility.TraceHandledException(e, TraceEventType.Information);
+            }
+            catch (TimeoutException e)
+            {
+                abortBinder = true;
+
+                //if (TD.CloseTimeoutIsEnabled())
+                //{
+                //    TD.CloseTimeout(e.Message);
+                //}
+                DiagnosticUtility.TraceHandledException(e, TraceEventType.Information);
+            }
+            finally
+            {
+                if (abortBinder)
+                {
+                    binder.Abort();
+                }
+            }
+        }
+
+        // this method should be called by the timer under ThisLock
+        void ClearPendingSessions()
+        {
+            lock (ThisLock)
+            {
+                if (this.pendingSessions1.Count == 0 && this.pendingSessions2.Count == 0)
+                {
+                    return;
+                }
+                foreach (UniqueId sessionId in this.pendingSessions2.Keys)
+                {
+                    SecurityContextSecurityToken token = this.pendingSessions2[sessionId];
+                    try
+                    {
+                        //TryCloseBinder(channelBinder, this.CloseTimeout);
+                        this.SessionTokenCache.RemoveAllContexts(sessionId);
+                    }
+                    catch (CommunicationException e)
+                    {
+                        DiagnosticUtility.TraceHandledException(e, TraceEventType.Information);
+                    }
+                    catch (TimeoutException e)
+                    {
+                        //if (TD.CloseTimeoutIsEnabled())
+                        //{
+                        //    TD.CloseTimeout(e.Message);
+                        //}
+                        DiagnosticUtility.TraceHandledException(e, TraceEventType.Information);
+                    }
+                    catch (ObjectDisposedException e)
+                    {
+                        DiagnosticUtility.TraceHandledException(e, TraceEventType.Information);
+                    }
+                    // SecurityTraceRecordHelper.TracePendingSessionClosed(sessionId, this.Uri);
+                }
+                this.pendingSessions2.Clear();
+                Dictionary<UniqueId, SecurityContextSecurityToken> temp = this.pendingSessions2;
+                this.pendingSessions2 = this.pendingSessions1;
+                this.pendingSessions1 = temp;
+            }
+        }
+
+      internal  bool RemovePendingSession(UniqueId sessionId)
+        {
+            bool result;
+            lock (ThisLock)
+            {
+                if (this.pendingSessions1.ContainsKey(sessionId))
+                {
+                    this.pendingSessions1.Remove(sessionId);
+                    result = true;
+                }
+                else if (pendingSessions2.ContainsKey(sessionId))
+                {
+                    this.pendingSessions2.Remove(sessionId);
+                    result = true;
+                }
+                else
+                {
+                    result = false;
+                }
+            }
+            /* if (result)
+             {
+                 SecurityTraceRecordHelper.TracePendingSessionActivated(sessionId, this.Uri);
+                 if (TD.SecuritySessionRatioIsEnabled())
+                 {
+                     TD.SecuritySessionRatio(GetPendingSessionCount(), this.MaximumPendingSessions);
+                 }
+             }*/
+            return result;
+        }
+
+        IServerSecuritySessionChannel FindSessionChannel(UniqueId sessionId)
+        {
+            IServerSecuritySessionChannel result;
+            lock (ThisLock)
+            {
+                this.activeSessions.TryGetValue(sessionId, out result);
+            }
+            return result;
+        }
+
+        void AddSessionChannel(UniqueId sessionId, IServerSecuritySessionChannel channel)
+        {
+            lock (ThisLock)
+            {
+                this.activeSessions.Add(sessionId, channel);
+            }
+        }
+
+       internal void RemoveSessionChannel(string sessionId)
+        {
+            RemoveSessionChannel(new UniqueId(sessionId));
+        }
+
+        void RemoveSessionChannel(UniqueId sessionId)
+        {
+            lock (ThisLock)
+            {
+                this.activeSessions.Remove(sessionId);
+            }
+            //SecurityTraceRecordHelper.TraceActiveSessionRemoved(sessionId, this.Uri);
+        }
+
+
+        public Task OnCloseAsync(TimeSpan timeout)
+        {
+            throw new NotImplementedException();
+        }
+
+        public Task OnOpenAsync(TimeSpan timeout)
+        {
+            if (this.sessionProtocolFactory == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.SecuritySessionProtocolFactoryShouldBeSetBeforeThisOperation)));
+            }
+            if (this.standardsManager == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.SecurityStandardsManagerNotSet, this.GetType())));
+            }
+            if (this.issuedTokenParameters == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.IssuedSecurityTokenParametersNotSet, this.GetType())));
+            }
+            if (this.maximumKeyRenewalInterval < this.keyRolloverInterval)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.KeyRolloverGreaterThanKeyRenewal)));
+            }
+            if (this.securityServiceDispatcher == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.SecurityChannelListenerNotSet, this.GetType())));
+            }
+            //if (this.settingsLifetimeManager == null)
+            //{
+            //    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.SecuritySettingsLifetimeManagerNotSet, this.GetType())));
+            //}
+
+            //  this.messageVersion = this.channelBuilder.Binding.MessageVersion;
+            this.listenUri = this.securityServiceDispatcher.BaseAddress;
+            TimeoutHelper timeoutHelper = new TimeoutHelper(timeout);
+            this.pendingSessions1 = new Dictionary<UniqueId, SecurityContextSecurityToken>();
+            this.pendingSessions2 = new Dictionary<UniqueId, SecurityContextSecurityToken>();
+            if (this.inactivityTimeout < TimeSpan.MaxValue)
+            {
+                this.inactivityTimer = new IOThreadTimer(new Action<object>(this.OnTimer), this, false);
+                this.inactivityTimer.Set(this.inactivityTimeout);
+            }
+            this.ConfigureSessionSecurityProtocolFactory();
+            this.sessionProtocolFactory.OpenAsync(timeoutHelper.RemainingTime());
+            SetupSessionTokenAuthenticatorAsync();
+            ((IIssuanceSecurityTokenAuthenticator)this.sessionTokenAuthenticator).IssuedSecurityTokenHandler = this.OnTokenIssued;
+            ((IIssuanceSecurityTokenAuthenticator)this.sessionTokenAuthenticator).RenewedSecurityTokenHandler = this.OnTokenRenewed;
+            this.acceptNewWork = true;
+            SecurityUtils.OpenTokenAuthenticatorIfRequiredAsync(this.sessionTokenAuthenticator, timeoutHelper.GetCancellationToken());
+            if (this.sessionTokenAuthenticator is SecuritySessionSecurityTokenAuthenticator)
+            {
+                this.SecurityServiceDispatcher.SecurityAuthChannelDispatcher =
+                     ((SecuritySessionSecurityTokenAuthenticator)this.sessionTokenAuthenticator).
+                     RequestSecurityTokenListener.InitializeServiceHost();
+            }
+            SecuritySessionSecurityTokenAuthenticator securityAuth = (SecuritySessionSecurityTokenAuthenticator)this.sessionTokenAuthenticator;
+            return Task.CompletedTask;
+        }
+
+        //        class SessionInitiationMessageHandler
+        //        {
+        //          //  static AsyncCallback receiveCallback = Fx.ThunkCallback(new AsyncCallback(ReceiveCallback));
+        //           // IServerReliableChannelBinder channelBinder;
+        //            SecuritySessionServerSettings settings;
+        //            SecurityContextSecurityToken sessionToken;
+        //            bool processedInitiation = false;
+
+        //            public SessionInitiationMessageHandler(/*IServerReliableChannelBinder channelBinder,*/ SecuritySessionServerSettings settings, SecurityContextSecurityToken sessionToken)
+        //            {
+        //              //  this.channelBinder = channelBinder;
+        //                this.settings = settings;
+        //                this.sessionToken = sessionToken;
+        //            }
+
+        //            //public IAsyncResult BeginReceive(TimeSpan timeout)
+        //            //{
+        //            //    return this.channelBinder.BeginTryReceive(timeout, receiveCallback, this);
+        //            //}
+
+        //            public void ProcessMessage(IAsyncResult result)
+        //            {
+        //                bool threwException = false;
+        //                try
+        //                {
+        //                    RequestContext requestContext;
+        //                    if (!this.channelBinder.EndTryReceive(result, out requestContext))
+        //                    {
+        //                        // we should never have timed out since the receive was called with an Infinite timeout
+        //                        // if we did then do a BeginReceive and return
+        //                        this.BeginReceive(TimeSpan.MaxValue);
+        //                        return;
+        //                    }
+
+        //                    if (requestContext == null)
+        //                    {
+        //                        return;
+        //                    }
+
+        //                    Message message = requestContext.RequestMessage;
+        //                    lock (this.settings.ThisLock)
+        //                    {
+        //                        if (this.settings.communicationObject.State != CommunicationState.Opened)
+        //                        {
+        //                            ((IDisposable)requestContext).Dispose();
+        //                            return;
+        //                        }
+        //                        if (this.processedInitiation)
+        //                        {
+        //                            return;
+        //                        }
+        //                        this.processedInitiation = true;
+        //                    }
+        //                    if (!this.settings.RemovePendingSession(this.sessionToken.ContextId))
+        //                    {
+        //                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new CommunicationException(SR.Format(SR.SecuritySessionNotPending, this.sessionToken.ContextId)));
+        //                    }
+        //                    if (this.settings.channelAcceptor is SecuritySessionChannelAcceptor<IReplySessionChannel>)
+        //                    {
+        //                        SecuritySessionChannelAcceptor<IReplySessionChannel> replyAcceptor = ((SecuritySessionChannelAcceptor<IReplySessionChannel>)this.settings.channelAcceptor);
+        //                        SecurityReplySessionChannel replySessionChannel = new SecurityReplySessionChannel(this.settings,
+        //                            this.channelBinder,
+        //                            sessionToken,
+        //                            replyAcceptor.ListenerSecurityState,
+        //                            this.settings.SettingsLifetimeManager);
+        //                        settings.AddSessionChannel(this.sessionToken.ContextId, replySessionChannel);
+        //                        replySessionChannel.StartReceiving(requestContext);
+        //                        replyAcceptor.EnqueueAndDispatch(replySessionChannel);
+        //                    }
+        //                    else if (this.settings.channelAcceptor is SecuritySessionChannelAcceptor<IDuplexSessionChannel>)
+        //                    {
+        //                        SecuritySessionChannelAcceptor<IDuplexSessionChannel> duplexAcceptor = ((SecuritySessionChannelAcceptor<IDuplexSessionChannel>)this.settings.channelAcceptor);
+        //                        ServerSecurityDuplexSessionChannel duplexSessionChannel = new ServerSecurityDuplexSessionChannel(this.settings,
+        //                            this.channelBinder,
+        //                            sessionToken,
+        //                            duplexAcceptor.ListenerSecurityState,
+        //                            this.settings.SettingsLifetimeManager);
+        //                        settings.AddSessionChannel(this.sessionToken.ContextId, duplexSessionChannel);
+        //                        duplexSessionChannel.StartReceiving(requestContext);
+        //                        duplexAcceptor.EnqueueAndDispatch(duplexSessionChannel);
+        //                    }
+        //                    else
+        //                    {
+        //                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new EndpointNotFoundException(SR.Format(SR.SecuritySessionListenerNotFound, message.Headers.Action)));
+        //                    }
+        //                }
+        //#pragma warning suppress 56500 // covered by FxCOP
+        //                catch (Exception e)
+        //                {
+        //                    threwException = true;
+        //                    if (Fx.IsFatal(e))
+        //                    {
+        //                        throw;
+        //                    }
+        //                    DiagnosticUtility.TraceHandledException(e, TraceEventType.Information);
+        //                }
+        //                finally
+        //                {
+        //                    if (threwException)
+        //                    {
+        //                        this.channelBinder.Abort();
+        //                    }
+        //                }
+        //            }
+
+        //            //static void ReceiveCallback(IAsyncResult result)
+        //            //{
+        //            //    ((SessionInitiationMessageHandler)result.AsyncState).ProcessMessage(result);
+        //            //}
+        //        }
+
+        interface IInputQueueChannelAcceptor
+        {
+            int PendingCount { get; }
+        }
+
+
+
+
+    }
+    interface IServerSecuritySessionChannel
+    {
+        void RenewSessionToken(SecurityContextSecurityToken newToken, SecurityContextSecurityToken supportingToken);
+    }
+
+    abstract class ServerSecuritySessionChannel //: ChannelBase, IServerSecuritySessionChannel
+    {
+        FaultCode renewFaultCode;
+        FaultReason renewFaultReason;
+        FaultCode sessionAbortedFaultCode;
+        FaultReason sessionAbortedFaultReason;
+
+        // Double-checked locking pattern requires volatile for read/write synchronization
+        volatile bool areFaultCodesInitialized;
+        IServerReliableChannelBinder channelBinder;
+        SecurityProtocol securityProtocol;
+        // This is used to sign outgoing messages
+        SecurityContextSecurityToken currentSessionToken;
+        UniqueId sessionId;
+        // These are renewed tokens that have not been used as yet
+        List<SecurityContextSecurityToken> futureSessionTokens;
+        SecuritySessionServerSettings settings;
+        RequestContext initialRequestContext;
+        volatile bool isInputClosed;
+        // ThreadNeutralSemaphore receiveLock;
+        MessageVersion messageVersion;
+        SecurityListenerSettingsLifetimeManager settingsLifetimeManager;
+        volatile bool hasSecurityStateReference;
+
+        protected ServerSecuritySessionChannel(SecuritySessionServerSettings settings,
+            // IServerReliableChannelBinder channelBinder,
+            SecurityContextSecurityToken sessionToken,
+            object listenerSecurityProtocolState,
+            SecurityListenerSettingsLifetimeManager settingsLifetimeManager)
+        // : base(settings.securityServiceDispatcher)
+        {
+            this.settings = settings;
+            // this.channelBinder = channelBinder;
+            this.messageVersion = settings.MessageVersion;
+           // this.channelBinder.Faulted += this.OnInnerFaulted;
+            this.securityProtocol = this.Settings.SessionProtocolFactory.CreateSecurityProtocol(null, null, listenerSecurityProtocolState, true, TimeSpan.Zero);
+            if (!(this.securityProtocol is IAcceptorSecuritySessionProtocol))
+            {
+                Fx.Assert("Security protocol must be IAcceptorSecuritySessionProtocol.");
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.ProtocolMisMatch, "IAcceptorSecuritySessionProtocol", this.GetType().ToString())));
+            }
+            this.currentSessionToken = sessionToken;
+            this.sessionId = sessionToken.ContextId;
+            this.futureSessionTokens = new List<SecurityContextSecurityToken>(1);
+            ((IAcceptorSecuritySessionProtocol)this.securityProtocol).SetOutgoingSessionToken(sessionToken);
+            ((IAcceptorSecuritySessionProtocol)this.securityProtocol).SetSessionTokenAuthenticator(this.sessionId, this.settings.SessionTokenAuthenticator, this.settings.SessionTokenResolver);
+            this.settingsLifetimeManager = settingsLifetimeManager;
+            // this.receiveLock = new ThreadNeutralSemaphore(1);
+        }
+
+        protected SecuritySessionServerSettings Settings
+        {
+            get
+            {
+                return this.settings;
+            }
+        }
+
+        protected virtual bool CanDoSecurityCorrelation
+        {
+            get
+            {
+                return false;
+            }
+        }
+
+        //internal IServerReliableChannelBinder ChannelBinder
+        //{
+        //    get
+        //    {
+        //        return this.channelBinder;
+        //    }
+        //}
+
+        internal TimeSpan InternalSendTimeout
+        {
+            get
+            {
+                return ServiceDefaults.SendTimeout;
+            }
+        }
+
+        public EndpointAddress LocalAddress
+        {
+            get
+            {
+                return this.channelBinder.LocalAddress;
+            }
+        }
+
+        public object ThisLock { get { return this.Settings.ThisLock; } }
+
+        public CommunicationState State { get { return this.Settings.WrapperCommunicationObj.State; } }
+
+        public Task OpenAsync(TimeSpan timeout)
+        {
+            this.securityProtocol.OnOpenAsync(timeout);
+            if (this.CanDoSecurityCorrelation)
+            {
+                ((IAcceptorSecuritySessionProtocol)this.securityProtocol).ReturnCorrelationState = true;
+
+            }
+            lock (ThisLock)
+            {
+                // if an abort happened concurrently with the open, then return
+                if (this.State == CommunicationState.Closed || this.State == CommunicationState.Closing)
+                {
+                    return Task.CompletedTask;
+                }
+                this.settingsLifetimeManager.AddReference();
+                this.hasSecurityStateReference = true;
+            }
+            return Task.CompletedTask;
+        }
+
+
+        //protected override IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state)
+        //{
+        //    OnOpen(timeout);
+        //    return new CompletedAsyncResult(callback, state);
+        //}
+
+        //protected override void OnEndOpen(IAsyncResult result)
+        //{
+        //    CompletedAsyncResult.End(result);
+        //}
+
+        protected virtual void AbortCore()
+        {
+            if (this.channelBinder != null)
+            {
+                this.channelBinder.Abort();
+            }
+            if (this.securityProtocol != null)
+            {
+                TimeoutHelper timeout = new TimeoutHelper(TimeSpan.Zero);
+                this.securityProtocol.OnCloseAsync(timeout.RemainingTime());
+            }
+            this.Settings.SessionTokenCache.RemoveAllContexts(this.currentSessionToken.ContextId);
+            bool abortLifetimeManager = false;
+            lock (ThisLock)
+            {
+                if (hasSecurityStateReference)
+                {
+                    abortLifetimeManager = true;
+                    hasSecurityStateReference = false;
+                }
+            }
+            if (abortLifetimeManager)
+            {
+                this.settingsLifetimeManager.Abort();
+            }
+        }
+
+        protected virtual void CloseCore(CancellationToken token)
+        {
+            try
+            {
+                if (this.channelBinder != null)
+                {
+                    this.channelBinder.CloseAsync(TimeSpan.Zero);
+                }
+                if (this.securityProtocol != null)
+                {
+                    this.securityProtocol.OnCloseAsync(TimeSpan.Zero);
+                }
+                bool closeLifetimeManager = false;
+                lock (ThisLock)
+                {
+                    if (hasSecurityStateReference)
+                    {
+                        closeLifetimeManager = true;
+                        hasSecurityStateReference = false;
+                    }
+                }
+                if (closeLifetimeManager)
+                {
+                    // this.settingsLifetimeManager.CloseAs(timeoutHelper.RemainingTime());
+                }
+            }
+            catch (CommunicationObjectAbortedException)
+            {
+                if (this.State != CommunicationState.Closed)
+                {
+                    throw;
+                }
+                // a parallel thread aborted the channel. Ignore the exception
+            }
+
+            this.Settings.SessionTokenCache.RemoveAllContexts(this.currentSessionToken.ContextId);
+        }
+
+        //protected virtual IAsyncResult BeginCloseCore(TimeSpan timeout, AsyncCallback callback, object state)
+        //{
+        //    return new CloseCoreAsyncResult(this, timeout, callback, state);
+        //}
+
+        //protected virtual void EndCloseCore(IAsyncResult result)
+        //{
+        //    CloseCoreAsyncResult.End(result);
+        //}
+
+        protected abstract void OnCloseMessageReceived(RequestContext requestContext, Message message, SecurityProtocolCorrelationState correlationState, CancellationToken token);
+
+        protected abstract void OnCloseResponseMessageReceived(RequestContext requestContext, Message message, SecurityProtocolCorrelationState correlationState, TimeSpan timeout);
+
+        //public void RenewSessionToken(SecurityContextSecurityToken newToken, SecurityContextSecurityToken supportingToken)
+        //{
+        //    ThrowIfClosedOrNotOpen();
+        //    // enforce that the token being renewed is the current session token
+        //    lock (ThisLock)
+        //    {
+        //        if (supportingToken.ContextId != this.currentSessionToken.ContextId || supportingToken.KeyGeneration != this.currentSessionToken.KeyGeneration)
+        //        {
+        //            throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new MessageSecurityException(SR.Format(SR.CurrentSessionTokenNotRenewed, supportingToken.KeyGeneration, this.currentSessionToken.KeyGeneration)));
+        //        }
+        //        if (this.futureSessionTokens.Count == this.Settings.MaximumPendingKeysPerSession)
+        //        {
+        //            throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new MessageSecurityException(SR.Format(SR.TooManyPendingSessionKeys)));
+        //        }
+        //        this.futureSessionTokens.Add(newToken);
+        //    }
+        //    SecurityTraceRecordHelper.TraceNewServerSessionKeyIssued(newToken, supportingToken, GetLocalUri());
+        //}
+
+        protected Uri GetLocalUri()
+        {
+            if (this.channelBinder.LocalAddress == null)
+                return null;
+            else
+                return this.channelBinder.LocalAddress.Uri;
+        }
+
+        void OnInnerFaulted(IReliableChannelBinder sender, Exception exception)
+        {
+            this.OnFaulted(exception);
+        }
+
+        SecurityContextSecurityToken GetSessionToken(SecurityMessageProperty securityProperty)
+        {
+            SecurityContextSecurityToken sct = (securityProperty.ProtectionToken != null) ? securityProperty.ProtectionToken.SecurityToken as SecurityContextSecurityToken : null;
+            if (sct != null && sct.ContextId == this.sessionId)
+            {
+                return sct;
+            }
+            if (securityProperty.HasIncomingSupportingTokens)
+            {
+                for (int i = 0; i < securityProperty.IncomingSupportingTokens.Count; ++i)
+                {
+                    if (securityProperty.IncomingSupportingTokens[i].SecurityTokenAttachmentMode == SecurityTokenAttachmentMode.Endorsing)
+                    {
+                        sct = (securityProperty.IncomingSupportingTokens[i].SecurityToken as SecurityContextSecurityToken);
+                        if (sct != null && sct.ContextId == this.sessionId)
+                        {
+                            return sct;
+                        }
+                    }
+                }
+            }
+            return null;
+        }
+
+        bool CheckIncomingToken(RequestContext requestContext, Message message, SecurityProtocolCorrelationState correlationState, TimeSpan timeout)
+        {
+            SecurityMessageProperty securityProperty = message.Properties.Security;
+            // this is guaranteed to be non-null and matches the session ID since the binding checked it
+            SecurityContextSecurityToken incomingToken = GetSessionToken(securityProperty);
+            if (incomingToken == null)
+            {
+                throw TraceUtility.ThrowHelperWarning(new MessageSecurityException(SR.Format(SR.NoSessionTokenPresentInMessage)), message);
+            }
+            // the incoming token's key should have been issued within keyRenewalPeriod time in the past
+            // if not, send back a renewal fault. However if this is a session close message then its ok to not require the client 
+            // to renew the key in order to send the close.
+            if (incomingToken.KeyExpirationTime < DateTime.UtcNow &&
+                message.Headers.Action != this.settings.SecurityStandardsManager.SecureConversationDriver.CloseAction.Value)
+            {
+                if (this.settings.CanRenewSession)
+                {
+                    SendRenewFault(requestContext, correlationState, timeout);
+                    return false;
+                }
+                else
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new Exception(SR.Format(SR.SecurityContextKeyExpired, incomingToken.ContextId, incomingToken.KeyGeneration)));
+                }
+            }
+            // this is a valid token. If it corresponds to a newly issued session token, make it the current
+            // session token.
+            lock (ThisLock)
+            {
+                if (this.futureSessionTokens.Count > 0 && incomingToken.KeyGeneration != this.currentSessionToken.KeyGeneration)
+                {
+                    bool changedCurrentSessionToken = false;
+                    for (int i = 0; i < this.futureSessionTokens.Count; ++i)
+                    {
+                        if (futureSessionTokens[i].KeyGeneration == incomingToken.KeyGeneration)
+                        {
+                            // let the current token expire after KeyRollover time interval
+                            DateTime keyRolloverTime = TimeoutHelper.Add(DateTime.UtcNow, this.settings.KeyRolloverInterval);
+                            this.settings.SessionTokenCache.UpdateContextCachingTime(this.currentSessionToken, keyRolloverTime);
+                            this.currentSessionToken = futureSessionTokens[i];
+                            futureSessionTokens.RemoveAt(i);
+                            ((IAcceptorSecuritySessionProtocol)this.securityProtocol).SetOutgoingSessionToken(this.currentSessionToken);
+                            changedCurrentSessionToken = true;
+                            break;
+                        }
+                    }
+                    if (changedCurrentSessionToken)
+                    {
+                        // SecurityTraceRecordHelper.TraceServerSessionKeyUpdated(this.currentSessionToken, GetLocalUri());
+                        // remove all renewed tokens that will never be used.
+                        for (int i = 0; i < futureSessionTokens.Count; ++i)
+                        {
+                            this.Settings.SessionTokenCache.RemoveContext(futureSessionTokens[i].ContextId, futureSessionTokens[i].KeyGeneration);
+                        }
+                        this.futureSessionTokens.Clear();
+                    }
+                }
+            }
+
+            return true;
+        }
+
+        //public void StartReceiving(RequestContext initialRequestContext)
+        //{
+        //    if (this.initialRequestContext != null)
+        //    {
+        //        Fx.Assert("The initial request context was already specified.");
+        //        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.AttemptToCreateMultipleRequestContext)));
+        //    }
+        //    this.initialRequestContext = initialRequestContext;
+        //}
+
+        public RequestContext ReceiveRequest(RequestContext initialRequestContext)
+        {
+            return this.ReceiveRequest(ServiceDefaults.ReceiveTimeout, initialRequestContext);
+        }
+
+        public RequestContext ReceiveRequest(TimeSpan timeout, RequestContext initialRequestContext)
+        {
+            this.initialRequestContext = initialRequestContext;
+            RequestContext requestContext;
+            if (this.TryReceiveRequest(timeout, out requestContext))
+            {
+                return requestContext;
+            }
+            else
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new TimeoutException());
+            }
+        }
+
+        //public IAsyncResult BeginReceiveRequest(AsyncCallback callback, object state)
+        //{
+        //    return this.BeginReceiveRequest(this.DefaultReceiveTimeout, callback, state);
+        //}
+
+        //public IAsyncResult BeginReceiveRequest(TimeSpan timeout, AsyncCallback callback, object state)
+        //{
+        //    return this.BeginTryReceiveRequest(timeout, callback, state);
+        //}
+
+        //public RequestContext EndReceiveRequest(IAsyncResult result)
+        //{
+        //    RequestContext requestContext;
+        //    if (this.EndTryReceiveRequest(result, out requestContext))
+        //    {
+        //        return requestContext;
+        //    }
+        //    else
+        //    {
+        //        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new TimeoutException());
+        //    }
+        //}
+
+        //public IAsyncResult BeginTryReceiveRequest(TimeSpan timeout, AsyncCallback callback, object state)
+        //{
+        //    return new ReceiveRequestAsyncResult(this, timeout, callback, state);
+        //}
+
+        //public bool EndTryReceiveRequest(IAsyncResult result, out RequestContext requestContext)
+        //{
+        //    return ReceiveRequestAsyncResult.EndAsRequestContext(result, out requestContext);
+        //}
+
+        public bool TryReceiveRequest(TimeSpan timeout, out RequestContext requestContext)
+        {
+            ThrowIfFaulted();
+            TimeoutHelper timeoutHelper = new TimeoutHelper(timeout);
+            try
+            {
+                while (true)
+                {
+                    if (isInputClosed || this.State == CommunicationState.Faulted)
+                    {
+                        break;
+                    }
+
+                    // schedule another Receive if the timeout has not been reached
+                    if (timeoutHelper.RemainingTime() == TimeSpan.Zero)
+                    {
+                        requestContext = null;
+                        return false;
+                    }
+
+                    RequestContext innerRequestContext;
+                    if (initialRequestContext != null)
+                    {
+                        innerRequestContext = initialRequestContext;
+                        initialRequestContext = null;
+                    }
+                    else
+                    {
+                        //if (!channelBinder.TryReceive(timeoutHelper.RemainingTime(), out innerRequestContext))
+                        //{
+                        requestContext = null;
+                        return false;
+                        // }
+                    }
+                    if (innerRequestContext == null)
+                    {
+                        // the channel could have been aborted or closed
+                        break;
+                    }
+                    if (this.isInputClosed && innerRequestContext.RequestMessage != null)
+                    {
+                        Message message = innerRequestContext.RequestMessage;
+                        try
+                        {
+                            ProtocolException error = ProtocolException.ReceiveShutdownReturnedNonNull(message);
+                            throw TraceUtility.ThrowHelperWarning(error, message);
+                        }
+                        finally
+                        {
+                            message.Close();
+                            innerRequestContext.Abort();
+                        }
+                    }
+                    SecurityProtocolCorrelationState correlationState = null;
+                    bool isSecurityProcessingFailure;
+                    Message requestMessage = ProcessRequestContext(innerRequestContext, timeoutHelper.RemainingTime(), out correlationState, out isSecurityProcessingFailure);
+                    if (requestMessage != null)
+                    {
+
+                        requestContext = new SecuritySessionRequestContext(innerRequestContext, requestMessage, correlationState, this);
+                        return true;
+                    }
+                }
+            }
+            finally
+            {
+                // this.receiveLock.Exit();
+            }
+            ThrowIfFaulted();
+            requestContext = null;
+            return true;
+        }
+
+        private void ThrowIfFaulted()
+        {
+            this.Settings.WrapperCommunicationObj.ThrowIfFaulted();
+        }
+
+        //public Message Receive()
+        //{
+        //    return this.Receive(this.DefaultReceiveTimeout);
+        //}
+
+        //public Message Receive(TimeSpan timeout)
+        //{
+        //    Message message;
+        //    if (this.TryReceive(timeout, out message))
+        //    {
+        //        return message;
+        //    }
+        //    else
+        //    {
+        //        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new TimeoutException());
+        //    }
+        //}
+
+        //public IAsyncResult BeginReceive(AsyncCallback callback, object state)
+        //{
+        //    return this.BeginReceive(this.DefaultReceiveTimeout, callback, state);
+        //}
+
+        //public IAsyncResult BeginReceive(TimeSpan timeout, AsyncCallback callback, object state)
+        //{
+        //    return this.BeginTryReceive(timeout, callback, state);
+        //}
+
+        //public Message EndReceive(IAsyncResult result)
+        //{
+        //    Message message;
+        //    if (this.EndTryReceive(result, out message))
+        //    {
+        //        return message;
+        //    }
+        //    else
+        //    {
+        //        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new TimeoutException());
+        //    }
+        //}
+
+        //public IAsyncResult BeginTryReceive(TimeSpan timeout, AsyncCallback callback, object state)
+        //{
+        //    return new ReceiveRequestAsyncResult(this, timeout, callback, state);
+        //}
+
+        //public bool EndTryReceive(IAsyncResult result, out Message message)
+        //{
+        //    return ReceiveRequestAsyncResult.EndAsMessage(result, out message);
+        //}
+
+        //public bool TryReceive(TimeSpan timeout, out Message message)
+        //{
+        //    TimeoutHelper timeoutHelper = new TimeoutHelper(timeout);
+        //    RequestContext requestContext;
+
+        //    if (this.TryReceiveRequest(timeoutHelper.RemainingTime(), out requestContext))
+        //    {
+        //        if (requestContext != null)
+        //        {
+        //            message = requestContext.RequestMessage;
+        //            try
+        //            {
+        //                requestContext.Close(timeoutHelper.RemainingTime());
+        //            }
+        //            catch (TimeoutException e)
+        //            {
+        //                DiagnosticUtility.TraceHandledException(e, System.Diagnostics.TraceEventType.Information);
+        //            }
+        //        }
+        //        else
+        //        {
+        //            message = null;
+        //        }
+        //        return true;
+        //    }
+        //    else
+        //    {
+        //        message = null;
+        //        return false;
+        //    }
+        //}
+
+        //public override T GetProperty<T>()
+        //{
+        //    if (typeof(T) == typeof(FaultConverter) && (this.channelBinder != null))
+        //    {
+        //        return new SecurityChannelFaultConverter(this.channelBinder.Channel) as T;
+        //    }
+
+        //    T result = base.GetProperty<T>();
+        //    if ((result == null) && (channelBinder != null) && (channelBinder.Channel != null))
+        //    {
+        //        result = channelBinder.Channel.GetProperty<T>();
+        //    }
+
+        //    return result;
+        //}
+
+        void SendFaultIfRequired(Exception e, Message unverifiedMessage, RequestContext requestContext, TimeSpan timeout)
+        {
+            try
+            {
+                // return if the underlying channel does not implement IDuplexSession or IReply
+                if (!(this.channelBinder.Channel is IReplyChannel) && !(this.channelBinder.Channel is IDuplexSessionChannel))
+                {
+                    return;
+                }
+
+                MessageFault fault = SecurityUtils.CreateSecurityMessageFault(e, this.securityProtocol.SecurityProtocolFactory.StandardsManager);
+                if (fault == null)
+                {
+                    return;
+                }
+                TimeoutHelper timeoutHelper = new TimeoutHelper(timeout);
+                try
+                {
+                    using (Message faultMessage = Message.CreateMessage(unverifiedMessage.Version, fault, unverifiedMessage.Version.Addressing.DefaultFaultAction))
+                    {
+                        //  if (unverifiedMessage.Headers.MessageId != null)
+                        //      faultMessage. InitializeReply(unverifiedMessage);
+                        requestContext.ReplyAsync(faultMessage, timeoutHelper.GetCancellationToken());
+                        requestContext.CloseAsync(timeoutHelper.GetCancellationToken());
+                    }
+                }
+                catch (CommunicationException ex)
+                {
+                    DiagnosticUtility.TraceHandledException(ex, TraceEventType.Information);
+                }
+                catch (TimeoutException ex)
+                {
+                    //if (TD.CloseTimeoutIsEnabled())
+                    //{
+                    //    TD.CloseTimeout(e.Message);
+                    //}
+                    DiagnosticUtility.TraceHandledException(ex, TraceEventType.Information);
+                }
+            }
+            finally
+            {
+                unverifiedMessage.Close();
+                requestContext.Abort();
+            }
+        }
+
+        bool ShouldWrapException(Exception e)
+        {
+            return ((e is FormatException) || (e is XmlException));
+        }
+
+        Message ProcessRequestContext(RequestContext requestContext, TimeSpan timeout, out SecurityProtocolCorrelationState correlationState, out bool isSecurityProcessingFailure)
+        {
+            correlationState = null;
+            isSecurityProcessingFailure = false;
+            if (requestContext == null)
+            {
+                return null;
+            }
+
+            Message result = null;
+            Message message = requestContext.RequestMessage;
+            bool cleanupContextState = true;
+            try
+            {
+                TimeoutHelper timeoutHelper = new TimeoutHelper(timeout);
+                Message unverifiedMessage = message;
+                Exception securityException = null;
+                try
+                {
+                    correlationState = VerifyIncomingMessage(ref message, timeoutHelper.RemainingTime());
+                    // message.Properties.Security
+                }
+                catch (MessageSecurityException e)
+                {
+                    isSecurityProcessingFailure = true;
+                    securityException = e;
+                }
+                if (securityException != null)
+                {
+                    // SendFaultIfRequired closes the unverified message and context
+                    SendFaultIfRequired(securityException, unverifiedMessage, requestContext, timeoutHelper.RemainingTime());
+                    cleanupContextState = false;
+                    return null;
+                }
+                else if (CheckIncomingToken(requestContext, message, correlationState, timeoutHelper.RemainingTime()))
+                {
+                    if (message.Headers.Action == this.Settings.SecurityStandardsManager.SecureConversationDriver.CloseAction.Value)
+                    {
+                        //  SecurityTraceRecordHelper.TraceServerSessionCloseReceived(this.currentSessionToken, GetLocalUri());
+                        this.isInputClosed = true;
+                        // OnCloseMessageReceived is responsible for closing the message and requestContext if required.
+                        this.OnCloseMessageReceived(requestContext, message, correlationState, timeoutHelper.GetCancellationToken());
+                        correlationState = null;
+                    }
+                    else if (message.Headers.Action == this.Settings.SecurityStandardsManager.SecureConversationDriver.CloseResponseAction.Value)
+                    {
+                        // SecurityTraceRecordHelper.TraceServerSessionCloseResponseReceived(this.currentSessionToken, GetLocalUri());
+                        this.isInputClosed = true;
+                        // OnCloseResponseMessageReceived is responsible for closing the message and requestContext if required.
+                        this.OnCloseResponseMessageReceived(requestContext, message, correlationState, timeoutHelper.RemainingTime());
+                        correlationState = null;
+                    }
+                    else
+                    {
+                        result = message;
+                    }
+                    cleanupContextState = false;
+                }
+            }
+#pragma warning suppress 56500 // covered by FxCOP
+            catch (Exception e)
+            {
+                if ((e is CommunicationException) || (e is TimeoutException) || (Fx.IsFatal(e)) || !ShouldWrapException(e))
+                {
+                    throw;
+                }
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new MessageSecurityException(SR.Format(SR.MessageSecurityVerificationFailed), e));
+            }
+            finally
+            {
+                if (cleanupContextState)
+                {
+                    if (requestContext.RequestMessage != null)
+                    {
+                        requestContext.RequestMessage.Close();
+                    }
+                    requestContext.Abort();
+                }
+            }
+
+            return result;
+        }
+
+        internal void CheckOutgoingToken()
+        {
+            lock (ThisLock)
+            {
+                if (this.currentSessionToken.KeyExpirationTime < DateTime.UtcNow)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new Exception(SR.Format(SR.SecuritySessionKeyIsStale)));
+                }
+            }
+        }
+
+        internal void SecureApplicationMessage(ref Message message, CancellationToken token, SecurityProtocolCorrelationState correlationState)
+        {
+            ThrowIfFaulted();
+            ThrowIfClosedOrNotOpen();
+            CheckOutgoingToken();
+            Task<Message> appLiedMessage = this.securityProtocol.SecureOutgoingMessageAsync(message, token);
+            message = appLiedMessage.GetAwaiter().GetResult();
+        }
+
+        private void ThrowIfClosedOrNotOpen()
+        {
+            //throw new NotImplementedException();
+        }
+
+        internal SecurityProtocolCorrelationState VerifyIncomingMessage(ref Message message, TimeSpan timeout)
+        {
+            return this.securityProtocol.VerifyIncomingMessage(ref message, timeout, null);
+        }
+
+        void PrepareReply(Message request, Message reply)
+        {
+            if (request.Headers.ReplyTo != null)
+            {
+                request.Headers.ReplyTo.ApplyTo(reply);
+            }
+            else if (request.Headers.From != null)
+            {
+                request.Headers.From.ApplyTo(reply);
+            }
+            if (request.Headers.MessageId != null)
+            {
+                reply.Headers.RelatesTo = request.Headers.MessageId;
+            }
+            //TraceUtility.CopyActivity(request, reply);
+            //if (TraceUtility.PropagateUserActivity || TraceUtility.ShouldPropagateActivity)
+            //{
+            //    TraceUtility.AddActivityHeader(reply);
+            //}
+        }
+
+        protected void InitializeFaultCodesIfRequired()
+        {
+            if (!areFaultCodesInitialized)
+            {
+                lock (ThisLock)
+                {
+                    if (!areFaultCodesInitialized)
+                    {
+                        SecurityStandardsManager standardsManager = this.securityProtocol.SecurityProtocolFactory.StandardsManager;
+                        SecureConversationDriver scDriver = standardsManager.SecureConversationDriver;
+                        renewFaultCode = FaultCode.CreateSenderFaultCode(scDriver.RenewNeededFaultCode.Value, scDriver.Namespace.Value);
+                        renewFaultReason = new FaultReason(SR.Format(SR.SecurityRenewFaultReason), System.Globalization.CultureInfo.InvariantCulture);
+                        sessionAbortedFaultCode = FaultCode.CreateSenderFaultCode(DotNetSecurityStrings.SecuritySessionAbortedFault, DotNetSecurityStrings.Namespace);
+                        sessionAbortedFaultReason = new FaultReason(SR.Format(SR.SecuritySessionAbortedFaultReason), System.Globalization.CultureInfo.InvariantCulture);
+                        areFaultCodesInitialized = true;
+                    }
+                }
+            }
+        }
+
+        void SendRenewFault(RequestContext requestContext, SecurityProtocolCorrelationState correlationState, TimeSpan timeout)
+        {
+            Message message = requestContext.RequestMessage;
+            try
+            {
+                InitializeFaultCodesIfRequired();
+                MessageFault renewFault = MessageFault.CreateFault(renewFaultCode, renewFaultReason);
+                Message response;
+                if (message.Headers.MessageId != null)
+                {
+                    response = Message.CreateMessage(message.Version, renewFault, DotNetSecurityStrings.SecuritySessionFaultAction);
+                    response.InitializeReply(message);
+                }
+                else
+                {
+                    response = Message.CreateMessage(message.Version, renewFault, DotNetSecurityStrings.SecuritySessionFaultAction);
+                }
+                try
+                {
+                    PrepareReply(message, response);
+                    TimeoutHelper timeoutHelper = new TimeoutHelper(timeout);
+                    Task<Message> msg = this.securityProtocol.SecureOutgoingMessageAsync(response, timeoutHelper.GetCancellationToken());
+                    response = msg.GetAwaiter().GetResult();
+                    response.Properties.AllowOutputBatching = false;
+                    SendMessage(requestContext, response, timeoutHelper.GetCancellationToken());
+                }
+                finally
+                {
+                    response.Close();
+                }
+                //  SecurityTraceRecordHelper.TraceSessionRenewalFaultSent(this.currentSessionToken, GetLocalUri(), message);
+            }
+            catch (CommunicationException e)
+            {
+                //SecurityTraceRecordHelper.TraceRenewFaultSendFailure(this.currentSessionToken, GetLocalUri(), e);
+            }
+            catch (TimeoutException e)
+            {
+                // SecurityTraceRecordHelper.TraceRenewFaultSendFailure(this.currentSessionToken, GetLocalUri(), e);
+            }
+        }
+
+        Message ProcessCloseRequest(Message request)
+        {
+            RequestSecurityToken rst;
+            XmlDictionaryReader bodyReader = request.GetReaderAtBodyContents();
+            using (bodyReader)
+            {
+                rst = this.Settings.SecurityStandardsManager.TrustDriver.CreateRequestSecurityToken(bodyReader);
+                request.ReadFromBodyContentsToEnd(bodyReader);
+            }
+            if (rst.RequestType != null && rst.RequestType != this.Settings.SecurityStandardsManager.TrustDriver.RequestTypeClose)
+            {
+                throw TraceUtility.ThrowHelperWarning(new MessageSecurityException(SR.Format(SR.InvalidRstRequestType, rst.RequestType)), request);
+            }
+            if (rst.CloseTarget == null)
+            {
+                throw TraceUtility.ThrowHelperWarning(new MessageSecurityException(SR.Format(SR.NoCloseTargetSpecified)), request);
+            }
+            SecurityContextKeyIdentifierClause sctSkiClause = rst.CloseTarget as SecurityContextKeyIdentifierClause;
+            if (sctSkiClause == null || !SecuritySessionSecurityTokenAuthenticator.DoesSkiClauseMatchSigningToken(sctSkiClause, request))
+            {
+                throw TraceUtility.ThrowHelperWarning(new MessageSecurityException(SR.Format(SR.BadCloseTarget, rst.CloseTarget)), request);
+            }
+            RequestSecurityTokenResponse rstr = new RequestSecurityTokenResponse(this.Settings.SecurityStandardsManager);
+            rstr.Context = rst.Context;
+            rstr.IsRequestedTokenClosed = true;
+            rstr.MakeReadOnly();
+            BodyWriter bodyWriter = rstr;
+            if (this.Settings.SecurityStandardsManager.MessageSecurityVersion.TrustVersion == TrustVersion.WSTrust13)
+            {
+                List<RequestSecurityTokenResponse> rstrList = new List<RequestSecurityTokenResponse>(1);
+                rstrList.Add(rstr);
+                RequestSecurityTokenResponseCollection rstrc = new RequestSecurityTokenResponseCollection(rstrList, this.Settings.SecurityStandardsManager);
+                bodyWriter = rstrc;
+            }
+            Message response = Message.CreateMessage(request.Version, ActionHeader.Create(this.Settings.SecurityStandardsManager.SecureConversationDriver.CloseResponseAction, request.Version.Addressing), bodyWriter);
+            PrepareReply(request, response);
+            return response;
+        }
+
+        internal Message CreateCloseResponse(Message message, SecurityProtocolCorrelationState correlationState, CancellationToken token)
+        {
+            using (message)
+            {
+                Message response = this.ProcessCloseRequest(message);
+                this.securityProtocol.SecureOutgoingMessageAsync(response, token, correlationState);
+                response.Properties.AllowOutputBatching = false;
+                return response;
+            }
+        }
+
+        internal void TraceSessionClosedResponseSuccess()
+        {
+            // SecurityTraceRecordHelper.TraceSessionClosedResponseSent(this.currentSessionToken, GetLocalUri());
+        }
+
+        internal void TraceSessionClosedResponseFailure(Exception e)
+        {
+            // SecurityTraceRecordHelper.TraceSessionClosedResponseSendFailure(this.currentSessionToken, GetLocalUri(), e);
+        }
+
+        internal void TraceSessionClosedSuccess()
+        {
+            //  SecurityTraceRecordHelper.TraceSessionClosedSent(this.currentSessionToken, GetLocalUri());
+        }
+
+        internal void TraceSessionClosedFailure(Exception e)
+        {
+            //  SecurityTraceRecordHelper.TraceSessionCloseSendFailure(this.currentSessionToken, GetLocalUri(), e);
+        }
+
+        // SendCloseResponse closes the message and underlying context if the operation completes successfully
+        protected void SendCloseResponse(RequestContext requestContext, Message closeResponse, CancellationToken token)
+        {
+            try
+            {
+                using (closeResponse)
+                {
+                    SendMessage(requestContext, closeResponse, token);
+                }
+                TraceSessionClosedResponseSuccess();
+            }
+            catch (CommunicationException e)
+            {
+                TraceSessionClosedResponseFailure(e);
+            }
+            catch (TimeoutException e)
+            {
+                TraceSessionClosedResponseFailure(e);
+            }
+        }
+
+        //// BeginSendCloseResponse closes the message and underlying context if the operation completes successfully
+        //internal IAsyncResult BeginSendCloseResponse(RequestContext requestContext, Message closeResponse, TimeSpan timeout, AsyncCallback callback, object state)
+        //{
+        //    try
+        //    {
+        //        TimeoutHelper timeoutHelper = new TimeoutHelper(timeout);
+        //        return this.BeginSendMessage(requestContext, closeResponse, timeoutHelper.RemainingTime(), callback, state);
+        //    }
+        //    catch (CommunicationException e)
+        //    {
+        //        TraceSessionClosedResponseFailure(e);
+        //    }
+        //    catch (TimeoutException e)
+        //    {
+        //        TraceSessionClosedResponseFailure(e);
+        //    }
+        //    return new CompletedAsyncResult(callback, state);
+        //}
+
+        //// EndSendCloseResponse closes the message and underlying context if the operation completes successfully
+        //internal void EndSendCloseResponse(IAsyncResult result)
+        //{
+        //    if (result is CompletedAsyncResult)
+        //    {
+        //        CompletedAsyncResult.End(result);
+        //        return;
+        //    }
+        //    try
+        //    {
+        //        this.EndSendMessage(result);
+        //    }
+        //    catch (CommunicationException e)
+        //    {
+        //        TraceSessionClosedResponseFailure(e);
+        //    }
+        //    catch (TimeoutException e)
+        //    {
+        //        TraceSessionClosedResponseFailure(e);
+        //    }
+        //}
+
+        internal Message CreateCloseMessage(CancellationToken token)
+        {
+            RequestSecurityToken rst = new RequestSecurityToken(this.Settings.SecurityStandardsManager);
+            rst.RequestType = this.Settings.SecurityStandardsManager.TrustDriver.RequestTypeClose;
+            rst.CloseTarget = this.Settings.IssuedSecurityTokenParameters.CreateKeyIdentifierClause(this.currentSessionToken, SecurityTokenReferenceStyle.External);
+            rst.MakeReadOnly();
+            Message closeMessage = Message.CreateMessage(this.messageVersion, ActionHeader.Create(this.Settings.SecurityStandardsManager.SecureConversationDriver.CloseAction, this.messageVersion.Addressing), rst);
+            RequestReplyCorrelator.PrepareRequest(closeMessage);
+            if (this.LocalAddress != null)
+            {
+                closeMessage.Headers.ReplyTo = this.LocalAddress;
+            }
+            else
+            {
+                if (closeMessage.Version.Addressing == AddressingVersion.WSAddressing10)
+                {
+                    closeMessage.Headers.ReplyTo = null;
+                }
+                else if (closeMessage.Version.Addressing == AddressingVersion.WSAddressingAugust2004)
+                {
+                    closeMessage.Headers.ReplyTo = EndpointAddress.AnonymousAddress;
+                }
+                else
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(
+                        new ProtocolException(SR.Format(SR.AddressingVersionNotSupported, closeMessage.Version.Addressing)));
+                }
+            }
+            this.securityProtocol.SecureOutgoingMessageAsync(closeMessage, token);
+            closeMessage.Properties.AllowOutputBatching = false;
+            return closeMessage;
+        }
+
+        protected void SendClose(CancellationToken token)
+        {
+            try
+            {
+                using (Message closeMessage = CreateCloseMessage(token))
+                {
+                    SendMessage(null, closeMessage, token);
+                }
+                TraceSessionClosedSuccess();
+            }
+            catch (CommunicationException e)
+            {
+                TraceSessionClosedFailure(e);
+            }
+            catch (TimeoutException e)
+            {
+                TraceSessionClosedFailure(e);
+            }
+        }
+
+
+
+        protected void SendMessage(RequestContext requestContext, Message message, CancellationToken token)
+        {
+
+            if (requestContext != null)
+            {
+                requestContext.ReplyAsync(message, token);
+                requestContext.CloseAsync(token);
+            }
+        }
+
+        internal void OnFaulted(Exception ex)
+        {
+            this.Settings.WrapperCommunicationObj.Fault(ex);
+        }
+    }
+
+    abstract class ServerSecuritySimplexSessionChannel : ServerSecuritySessionChannel
+    {
+        SoapSecurityInputSession session;
+        bool receivedClose;
+        bool canSendCloseResponse;
+        bool sentCloseResponse;
+        RequestContext closeRequestContext;
+        Message closeResponse;
+        // InterruptibleWaitObject inputSessionClosedHandle = new InterruptibleWaitObject(false);
+
+        public ServerSecuritySimplexSessionChannel(
+            SecuritySessionServerSettings settings,
+            //  IServerReliableChannelBinder channelBinder,
+            SecurityContextSecurityToken sessionToken,
+            object listenerSecurityState, SecurityListenerSettingsLifetimeManager settingsLifetimeManager)
+            : base(settings,
+                  //  channelBinder, 
+                  sessionToken, listenerSecurityState, settingsLifetimeManager)
+        {
+            this.session = new SoapSecurityInputSession(sessionToken, settings, this);
+        }
+
+        public IInputSession Session
+        {
+            get
+            {
+                return this.session;
+            }
+        }
+
+        void CleanupPendingCloseState()
+        {
+            lock (ThisLock)
+            {
+                if (this.closeResponse != null)
+                {
+                    this.closeResponse.Close();
+                    this.closeResponse = null;
+                }
+                if (this.closeRequestContext != null)
+                {
+                    this.closeRequestContext.Abort();
+                    this.closeRequestContext = null;
+                }
+            }
+        }
+
+        protected override void AbortCore()
+        {
+            base.AbortCore();
+            this.Settings.RemoveSessionChannel(this.session.Id);
+            CleanupPendingCloseState();
+        }
+
+        protected override void CloseCore(CancellationToken token)
+        {
+            // send a close response if one was not sent yet
+            bool wasAborted = SendCloseResponseOnCloseIfRequired(token);
+            if (wasAborted)
+            {
+                return;
+            }
+
+            //bool wasInputSessionClosed = this.WaitForInputSessionClose(token, out wasAborted);
+            //if (wasAborted)
+            //{
+            //    return;
+            //}
+            //if (!wasInputSessionClosed)
+            //{
+            //    throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new TimeoutException(SR.Format(SR.ServiceSecurityCloseTimeout, timeoutHelper.OriginalTimeout)));
+            //}
+            //else
+            //{
+            base.CloseCore(token);
+            this.Settings.RemoveSessionChannel(this.session.Id);
+            // }
+        }
+
+        bool ShouldSendCloseResponseOnClose(out RequestContext pendingCloseRequestContext, out Message pendingCloseResponse)
+        {
+            bool sendCloseResponse = false;
+            lock (ThisLock)
+            {
+                this.canSendCloseResponse = true;
+                if (!this.sentCloseResponse && this.receivedClose && this.closeResponse != null)
+                {
+                    this.sentCloseResponse = true;
+                    sendCloseResponse = true;
+                    pendingCloseRequestContext = this.closeRequestContext;
+                    pendingCloseResponse = this.closeResponse;
+                    this.closeResponse = null;
+                    this.closeRequestContext = null;
+                }
+                else
+                {
+                    canSendCloseResponse = false;
+                    pendingCloseRequestContext = null;
+                    pendingCloseResponse = null;
+                }
+            }
+            return sendCloseResponse;
+        }
+
+        bool SendCloseResponseOnCloseIfRequired(CancellationToken token)
+        {
+            bool aborted = false;
+            RequestContext pendingCloseRequestContext;
+            Message pendingCloseResponse;
+            bool sendCloseResponse = ShouldSendCloseResponseOnClose(out pendingCloseRequestContext, out pendingCloseResponse);
+            bool cleanupCloseState = true;
+            if (sendCloseResponse)
+            {
+                try
+                {
+                    this.SendCloseResponse(pendingCloseRequestContext, pendingCloseResponse, token);
+                    // this.inputSessionClosedHandle.Set();
+                    cleanupCloseState = false;
+                }
+                catch (CommunicationObjectAbortedException)
+                {
+                    if (this.State != CommunicationState.Closed)
+                    {
+                        throw;
+                    }
+                    aborted = true;
+                }
+                finally
+                {
+                    if (cleanupCloseState)
+                    {
+                        if (pendingCloseResponse != null)
+                        {
+                            pendingCloseResponse.Close();
+                        }
+                        if (pendingCloseRequestContext != null)
+                        {
+                            pendingCloseRequestContext.Abort();
+                        }
+                    }
+                }
+            }
+
+            return aborted;
+        }
+
+        //bool WaitForInputSessionClose(TimeSpan timeout, out bool wasAborted)
+        //{
+        //    Message message;
+        //    TimeoutHelper timeoutHelper = new TimeoutHelper(timeout);
+        //    wasAborted = false;
+        //    try
+        //    {
+        //        if (this.TryReceive(timeoutHelper.RemainingTime(), out message))
+        //        {
+        //            if (message != null)
+        //            {
+        //                using (message)
+        //                {
+        //                    ProtocolException error = ProtocolException.ReceiveShutdownReturnedNonNull(message);
+        //                    throw TraceUtility.ThrowHelperWarning(error, message);
+        //                }
+        //            }
+        //            return this.inputSessionClosedHandle.Wait(timeoutHelper.RemainingTime(), false);
+        //        }
+        //    }
+        //    catch (CommunicationObjectAbortedException)
+        //    {
+        //        if (this.State != CommunicationState.Closed)
+        //        {
+        //            throw;
+        //        }
+        //        wasAborted = true;
+        //    }
+        //    return false;
+        //}
+
+        protected override void OnCloseResponseMessageReceived(RequestContext requestContext, Message message, SecurityProtocolCorrelationState correlationState, TimeSpan timeout)
+        {
+            // we dont expect a close-response for non-duplex security session
+            message.Close();
+            requestContext.Abort();
+            this.Fault(new ProtocolException(SR.Format(SR.UnexpectedSecuritySessionCloseResponse)));
+        }
+
+        private void Fault(ProtocolException protocolException)
+        {
+            this.AbortCore();
+            //    this.inputSessionClosedHandle.Fault(this);
+            base.OnFaulted(protocolException);
+
+
+        }
+
+        protected override void OnCloseMessageReceived(RequestContext requestContext, Message message, SecurityProtocolCorrelationState correlationState, CancellationToken token)
+        {
+            if (this.State == CommunicationState.Created)
+            {
+                Fx.Assert("ServerSecuritySimplexSessionChannel.OnCloseMessageReceived (this.State == Created)");
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.ServerReceivedCloseMessageStateIsCreated, this.GetType().ToString())));
+            }
+
+            if (SendCloseResponseOnCloseReceivedIfRequired(requestContext, message, correlationState, token))
+            {
+                //this.inputSessionClosedHandle.Set();
+            }
+        }
+
+        bool SendCloseResponseOnCloseReceivedIfRequired(RequestContext requestContext, Message message, SecurityProtocolCorrelationState correlationState, CancellationToken token)
+        {
+            bool sendCloseResponse = false;
+            //  ServiceModelActivity activity = DiagnosticUtility.ShouldUseActivity ? TraceUtility.ExtractActivity(message) : null;
+            bool cleanupContext = true;
+            try
+            {
+                Message localCloseResponse = null;
+                lock (ThisLock)
+                {
+                    if (!this.receivedClose)
+                    {
+                        this.receivedClose = true;
+                        localCloseResponse = CreateCloseResponse(message, correlationState, token);
+                        if (canSendCloseResponse)
+                        {
+                            this.sentCloseResponse = true;
+                            sendCloseResponse = true;
+                        }
+                        else
+                        {
+                            // save the close requestContext to reply later
+                            this.closeRequestContext = requestContext;
+                            this.closeResponse = localCloseResponse;
+                            cleanupContext = false;
+                        }
+                    }
+                }
+                if (sendCloseResponse)
+                {
+                    this.SendCloseResponse(requestContext, localCloseResponse, token);
+                    cleanupContext = false;
+                }
+                else if (cleanupContext)
+                {
+                    requestContext.CloseAsync(token);
+                    cleanupContext = false;
+                }
+                return sendCloseResponse;
+            }
+            finally
+            {
+                message.Close();
+                if (cleanupContext)
+                {
+                    requestContext.Abort();
+                }
+                //if (DiagnosticUtility.ShouldUseActivity && (activity != null))
+                //{
+                //    activity.Stop();
+                //}
+            }
+        }
+
+        protected class SoapSecurityInputSession : ISecureConversationSession, IInputSession
+        {
+            ServerSecuritySessionChannel channel;
+            UniqueId securityContextTokenId;
+            EndpointIdentity remoteIdentity;
+            SecurityKeyIdentifierClause sessionTokenIdentifier;
+            SecurityStandardsManager standardsManager;
+
+            public SoapSecurityInputSession(SecurityContextSecurityToken sessionToken,
+                SecuritySessionServerSettings settings, ServerSecuritySessionChannel channel)
+            {
+                this.channel = channel;
+                this.securityContextTokenId = sessionToken.ContextId;
+                Claim identityClaim = SecurityUtils.GetPrimaryIdentityClaim(sessionToken.AuthorizationPolicies);
+                if (identityClaim != null)
+                {
+                    this.remoteIdentity = EndpointIdentity.CreateIdentity(identityClaim);
+                }
+                this.sessionTokenIdentifier = settings.IssuedSecurityTokenParameters.CreateKeyIdentifierClause(sessionToken, SecurityTokenReferenceStyle.External);
+                this.standardsManager = settings.SessionProtocolFactory.StandardsManager;
+            }
+
+            public string Id
+            {
+                get
+                {
+                    return this.securityContextTokenId.ToString();
+                }
+            }
+
+            public EndpointIdentity RemoteIdentity
+            {
+                get
+                {
+                    return this.remoteIdentity;
+                }
+            }
+
+            public void WriteSessionTokenIdentifier(XmlDictionaryWriter writer)
+            {
+                this.standardsManager.SecurityTokenSerializer.WriteKeyIdentifierClause(writer, this.sessionTokenIdentifier);
+            }
+
+            public bool TryReadSessionTokenIdentifier(XmlReader reader)
+            {
+                if (!this.standardsManager.SecurityTokenSerializer.CanReadKeyIdentifierClause(reader))
+                {
+                    return false;
+                }
+                SecurityContextKeyIdentifierClause incomingTokenIdentifier = this.standardsManager.SecurityTokenSerializer.ReadKeyIdentifierClause(reader) as SecurityContextKeyIdentifierClause;
+                return incomingTokenIdentifier != null && incomingTokenIdentifier.Matches(this.securityContextTokenId, null);
+            }
+        }
+
+
+        public class SecurityReplySessionChannel : ServerSecuritySimplexSessionChannel, IReplySessionChannel
+        {
+            public SecurityReplySessionChannel(
+                SecuritySessionServerSettings settings,
+                //  IServerReliableChannelBinder channelBinder,
+                SecurityContextSecurityToken sessionToken,
+                object listenerSecurityState, SecurityListenerSettingsLifetimeManager settingsLifetimeManager)
+                : base(settings,
+                      // channelBinder,
+                      sessionToken, listenerSecurityState, settingsLifetimeManager)
+            {
+            }
+
+            protected override bool CanDoSecurityCorrelation
+            {
+                get
+                {
+                    return true;
+                }
+            }
+
+            public IServiceChannelDispatcher ChannelDispatcher { get => throw new NotImplementedException(); set => throw new NotImplementedException(); }
+
+            public event EventHandler Closed;
+            public event EventHandler Closing;
+            public event EventHandler Faulted;
+            public event EventHandler Opened;
+            public event EventHandler Opening;
+
+
+            public T GetProperty<T>() where T : class
+            {
+                throw new NotImplementedException();
+            }
+
+            public void Abort()
+            {
+                base.AbortCore();
+            }
+
+            public Task CloseAsync()
+            {
+                throw new NotImplementedException();
+            }
+
+            public Task CloseAsync(CancellationToken token)
+            {
+                base.CloseCore(token);
+                return Task.CompletedTask;
+            }
+
+            public Task OpenAsync()
+            {
+                throw new NotImplementedException();
+            }
+
+            public Task OpenAsync(CancellationToken token)
+            {
+                TimeoutHelper openTimeOut = new TimeoutHelper(ServiceDefaults.OpenTimeout);
+                Task openTask = base.OpenAsync(openTimeOut.RemainingTime());
+                openTask.GetAwaiter().GetResult();
+                return Task.CompletedTask;
+            }
+        }
+
+
+
+
+    }
+    class SecuritySessionRequestContext : RequestContextBase
+    {
+        RequestContext requestContext;
+        ServerSecuritySessionChannel channel;
+        SecurityProtocolCorrelationState correlationState;
+
+        public SecuritySessionRequestContext(RequestContext requestContext, Message requestMessage, SecurityProtocolCorrelationState correlationState, ServerSecuritySessionChannel channel)
+            : base(requestMessage, ServiceDefaults.CloseTimeout, ServiceDefaults.SendTimeout)
+        {
+            this.requestContext = requestContext;
+            this.correlationState = correlationState;
+            this.channel = channel;
+        }
+
+
+
+        protected override void OnAbort()
+        {
+            this.requestContext.Abort();
+        }
+
+        protected override Task OnCloseAsync(CancellationToken token)
+        {
+            return this.requestContext.CloseAsync(token);
+        }
+
+        protected override Task OnReplyAsync(Message message, CancellationToken token)
+        {
+            if (message != null)
+            {
+                this.channel.SecureApplicationMessage(ref message, token, correlationState);
+                //this.securityProtocol.SecureOutgoingMessageAsync(message);
+                return this.requestContext.ReplyAsync(message);
+            }
+            else
+            {
+                return Task.CompletedTask;
+            }
+        }
+
+
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityStandardsManager.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityStandardsManager.cs
new file mode 100644
index 0000000..f8b7b8e
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityStandardsManager.cs
@@ -0,0 +1,145 @@
+using CoreWCF.Channels;
+using CoreWCF.Description;
+using CoreWCF.Security.Tokens;
+using CoreWCF.IdentityModel.Selectors;
+using CoreWCF.IdentityModel.Tokens;
+using System.Xml;
+using System.Runtime.CompilerServices;
+using CoreWCF;
+using CoreWCF.Security;
+using CoreWCF.IdentityModel;
+using System;
+
+namespace CoreWCF.Security
+{
+    public class SecurityStandardsManager
+    {
+        private static SecurityStandardsManager s_instance;
+        private readonly SecurityTokenSerializer _tokenSerializer;
+        private WSSecurityTokenSerializer _wsSecurityTokenSerializer;
+        readonly TrustDriver trustDriver;
+
+        [MethodImpl(MethodImplOptions.NoInlining)]
+        public SecurityStandardsManager()
+            : this(WSSecurityTokenSerializer.DefaultInstance)
+        {
+        }
+
+        public SecurityStandardsManager(SecurityTokenSerializer tokenSerializer)
+            : this(MessageSecurityVersion.WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11, tokenSerializer)
+        {
+        }
+
+        public SecurityStandardsManager(MessageSecurityVersion messageSecurityVersion, SecurityTokenSerializer tokenSerializer)
+        {
+            MessageSecurityVersion = messageSecurityVersion ?? throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException(nameof(messageSecurityVersion)));
+            _tokenSerializer = tokenSerializer ?? throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(tokenSerializer));
+            if (messageSecurityVersion.SecureConversationVersion == SecureConversationVersion.WSSecureConversation13)
+            {
+                
+                 SecureConversationDriver = new WSSecureConversationDec2005.DriverDec2005();
+            }
+            else
+            {
+                SecureConversationDriver = new WSSecureConversationFeb2005.DriverFeb2005();
+            }
+
+            if (SecurityVersion == SecurityVersion.WSSecurity10 || SecurityVersion == SecurityVersion.WSSecurity11)
+            {
+                IdManager = WSSecurityJan2004.IdManager.Instance;
+            }
+            else
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(messageSecurityVersion), SR.MessageSecurityVersionOutOfRange));
+            }
+
+            WSUtilitySpecificationVersion = WSUtilitySpecificationVersion.Default;
+            if (messageSecurityVersion.MessageSecurityTokenVersion.TrustVersion == TrustVersion.WSTrust13)
+                this.trustDriver = new WSTrustDec2005.DriverDec2005(this);
+            else
+                this.trustDriver = new WSTrustFeb2005.DriverFeb2005(this);
+        }
+
+        public static SecurityStandardsManager DefaultInstance
+        {
+            get
+            {
+                if (s_instance == null)
+                {
+                    s_instance = new SecurityStandardsManager();
+                }
+
+                return s_instance;
+            }
+        }
+
+        public SecurityVersion SecurityVersion
+        {
+            get { return MessageSecurityVersion == null ? null : MessageSecurityVersion.SecurityVersion; }
+        }
+
+        public MessageSecurityVersion MessageSecurityVersion { get; }
+
+        internal SecurityTokenSerializer SecurityTokenSerializer
+        {
+            get { return _tokenSerializer; }
+        }
+
+        internal WSUtilitySpecificationVersion WSUtilitySpecificationVersion { get; }
+
+        internal SignatureTargetIdManager IdManager { get; }
+
+        internal SecureConversationDriver SecureConversationDriver { get; }
+
+        internal TrustDriver TrustDriver { get { return trustDriver; } }
+
+        private WSSecurityTokenSerializer WSSecurityTokenSerializer
+        {
+            get
+            {
+                if (_wsSecurityTokenSerializer == null)
+                {
+                    WSSecurityTokenSerializer wsSecurityTokenSerializer = _tokenSerializer as WSSecurityTokenSerializer;
+                    if (wsSecurityTokenSerializer == null)
+                    {
+                        wsSecurityTokenSerializer = new WSSecurityTokenSerializer(SecurityVersion);
+                    }
+
+                    _wsSecurityTokenSerializer = wsSecurityTokenSerializer;
+                }
+
+                return _wsSecurityTokenSerializer;
+            }
+        }
+
+        internal bool TryCreateKeyIdentifierClauseFromTokenXml(XmlElement element, SecurityTokenReferenceStyle tokenReferenceStyle, out SecurityKeyIdentifierClause securityKeyIdentifierClause)
+        {
+            return WSSecurityTokenSerializer.TryCreateKeyIdentifierClauseFromTokenXml(element, tokenReferenceStyle, out securityKeyIdentifierClause);
+        }
+
+
+        internal SecurityKeyIdentifierClause CreateKeyIdentifierClauseFromTokenXml(XmlElement element, SecurityTokenReferenceStyle tokenReferenceStyle)
+        {
+            return WSSecurityTokenSerializer.CreateKeyIdentifierClauseFromTokenXml(element, tokenReferenceStyle);
+        }
+
+        internal SendSecurityHeader CreateSendSecurityHeader(Message message,
+            string actor, bool mustUnderstand, bool relay,
+            SecurityAlgorithmSuite algorithmSuite, MessageDirection direction)
+        {
+            return SecurityVersion.CreateSendSecurityHeader(message, actor, mustUnderstand, relay, this, algorithmSuite, direction);
+        }
+
+        internal ReceiveSecurityHeader TryCreateReceiveSecurityHeader(Message message,
+            string actor,
+            SecurityAlgorithmSuite algorithmSuite, MessageDirection direction)
+        {
+            return SecurityVersion.TryCreateReceiveSecurityHeader(message, actor, this, algorithmSuite, direction);
+        }
+
+        internal bool DoesMessageContainSecurityHeader(Message message)
+        {
+            return SecurityVersion.DoesMessageContainSecurityHeader(message);
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityStateEncoder.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityStateEncoder.cs
new file mode 100644
index 0000000..63c1f6c
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityStateEncoder.cs
@@ -0,0 +1,15 @@
+namespace CoreWCF.Security
+{
+    // The rationale for making abstract methods protected instead of public is following:
+    // 1. No scenarios for making them public.
+    // 2. Reduction of threat area (other assemblies on the channel can't call these methods other than through reflection).
+    // 3. Reduction of test area (feature is testable only through other high-level features).
+    public abstract class SecurityStateEncoder
+    {
+        protected SecurityStateEncoder() { }
+
+        protected internal abstract byte[] DecodeSecurityState(byte[] data);
+        protected internal abstract byte[] EncodeSecurityState(byte[] data);
+    }
+}
+
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityTimestamp.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityTimestamp.cs
new file mode 100644
index 0000000..a3d1a5a
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityTimestamp.cs
@@ -0,0 +1,195 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Text;
+using System.Globalization;
+using System.Runtime;
+using CoreWCF.Runtime;
+using System.Xml;
+
+namespace CoreWCF.Security
+{
+    sealed class SecurityTimestamp
+    {
+        const string DefaultFormat = "yyyy-MM-ddTHH:mm:ss.fffZ";
+        //                            012345678901234567890123
+
+        internal static readonly TimeSpan defaultTimeToLive = SecurityProtocolFactory.defaultTimestampValidityDuration;
+        char[] computedCreationTimeUtc;
+        char[] computedExpiryTimeUtc;
+        DateTime creationTimeUtc;
+        DateTime expiryTimeUtc;
+        readonly string id;
+        readonly string digestAlgorithm;
+        readonly byte[] digest;
+
+        public SecurityTimestamp(DateTime creationTimeUtc, DateTime expiryTimeUtc, string id)
+            : this(creationTimeUtc, expiryTimeUtc, id, null, null)
+        {
+        }
+
+        internal SecurityTimestamp(DateTime creationTimeUtc, DateTime expiryTimeUtc, string id, string digestAlgorithm, byte[] digest)
+        {
+            Fx.Assert(creationTimeUtc.Kind == DateTimeKind.Utc, "creation time must be in UTC");
+            Fx.Assert(expiryTimeUtc.Kind == DateTimeKind.Utc, "expiry time must be in UTC");
+
+            if (creationTimeUtc > expiryTimeUtc)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new ArgumentOutOfRangeException("recordedExpiryTime", SR.Format(SR.CreationTimeUtcIsAfterExpiryTime)));
+            }
+
+            this.creationTimeUtc = creationTimeUtc;
+            this.expiryTimeUtc = expiryTimeUtc;
+            this.id = id;
+
+            this.digestAlgorithm = digestAlgorithm;
+            this.digest = digest;
+        }
+
+        public DateTime CreationTimeUtc
+        {
+            get
+            {
+                return this.creationTimeUtc;
+            }
+        }
+
+        public DateTime ExpiryTimeUtc
+        {
+            get
+            {
+                return this.expiryTimeUtc;
+            }
+        }
+
+        public string Id
+        {
+            get
+            {
+                return this.id;
+            }
+        }
+
+        public string DigestAlgorithm
+        {
+            get
+            {
+                return this.digestAlgorithm;
+            }
+        }
+
+        internal byte[] GetDigest()
+        {
+            return this.digest;
+        }
+
+        internal char[] GetCreationTimeChars()
+        {
+            if (this.computedCreationTimeUtc == null)
+            {
+                this.computedCreationTimeUtc = ToChars(ref this.creationTimeUtc);
+            }
+            return this.computedCreationTimeUtc;
+        }
+
+        internal char[] GetExpiryTimeChars()
+        {
+            if (this.computedExpiryTimeUtc == null)
+            {
+                this.computedExpiryTimeUtc = ToChars(ref this.expiryTimeUtc);
+            }
+            return this.computedExpiryTimeUtc;
+        }
+
+        static char[] ToChars(ref DateTime utcTime)
+        {
+            char[] buffer = new char[DefaultFormat.Length];
+            int offset = 0;
+
+            ToChars(utcTime.Year, buffer, ref offset, 4);
+            buffer[offset++] = '-';
+
+            ToChars(utcTime.Month, buffer, ref offset, 2);
+            buffer[offset++] = '-';
+
+            ToChars(utcTime.Day, buffer, ref offset, 2);
+            buffer[offset++] = 'T';
+
+            ToChars(utcTime.Hour, buffer, ref offset, 2);
+            buffer[offset++] = ':';
+
+            ToChars(utcTime.Minute, buffer, ref offset, 2);
+            buffer[offset++] = ':';
+
+            ToChars(utcTime.Second, buffer, ref offset, 2);
+            buffer[offset++] = '.';
+
+            ToChars(utcTime.Millisecond, buffer, ref offset, 3);
+            buffer[offset++] = 'Z';
+
+            return buffer;
+        }
+
+        static void ToChars(int n, char[] buffer, ref int offset, int count)
+        {
+            for (int i = offset + count - 1; i >= offset; i--)
+            {
+                buffer[i] = (char)('0' + (n % 10));
+                n /= 10;
+            }
+            Fx.Assert(n == 0, "Overflow in encoding timestamp field");
+            offset += count;
+        }
+
+        public override string ToString()
+        {
+            return string.Format(
+                CultureInfo.InvariantCulture,
+                "SecurityTimestamp: Id={0}, CreationTimeUtc={1}, ExpirationTimeUtc={2}",
+                this.Id,
+                XmlConvert.ToString(this.CreationTimeUtc, XmlDateTimeSerializationMode.RoundtripKind),
+                XmlConvert.ToString(this.ExpiryTimeUtc, XmlDateTimeSerializationMode.RoundtripKind));
+        }
+
+        /// <summary>
+        /// Internal method that checks if the timestamp is fresh with respect to the
+        /// timeToLive and allowedClockSkew values passed in.
+        /// Throws if the timestamp is stale.
+        /// </summary>
+        /// <param name="timeToLive"></param>
+        /// <param name="allowedClockSkew"></param>
+        internal void ValidateRangeAndFreshness(TimeSpan timeToLive, TimeSpan allowedClockSkew)
+        {
+            // Check that the creation time is less than expiry time
+            if (this.CreationTimeUtc >= this.ExpiryTimeUtc)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new MessageSecurityException(SR.Format(SR.TimeStampHasCreationAheadOfExpiry, this.CreationTimeUtc.ToString(DefaultFormat, CultureInfo.CurrentCulture), this.ExpiryTimeUtc.ToString(DefaultFormat, CultureInfo.CurrentCulture))));
+            }
+
+            ValidateFreshness(timeToLive, allowedClockSkew);
+        }
+
+        internal void ValidateFreshness(TimeSpan timeToLive, TimeSpan allowedClockSkew)
+        {
+            DateTime now = DateTime.UtcNow;
+            // check that the message has not expired
+            if (this.ExpiryTimeUtc <= TimeoutHelper.Subtract(now, allowedClockSkew))
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new MessageSecurityException(SR.Format(SR.TimeStampHasExpiryTimeInPast, this.ExpiryTimeUtc.ToString(DefaultFormat, CultureInfo.CurrentCulture), now.ToString(DefaultFormat, CultureInfo.CurrentCulture), allowedClockSkew)));
+            }
+
+            // check that creation time is not in the future (modulo clock skew)
+            if (this.CreationTimeUtc >= TimeoutHelper.Add(now, allowedClockSkew))
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new MessageSecurityException(SR.Format(SR.TimeStampHasCreationTimeInFuture, this.CreationTimeUtc.ToString(DefaultFormat, CultureInfo.CurrentCulture), now.ToString(DefaultFormat, CultureInfo.CurrentCulture), allowedClockSkew)));
+            }
+
+            // check that the creation time is not more than timeToLive in the past
+            if (this.CreationTimeUtc <= TimeoutHelper.Subtract(now, TimeoutHelper.Add(timeToLive, allowedClockSkew)))
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new MessageSecurityException(SR.Format(SR.TimeStampWasCreatedTooLongAgo, this.CreationTimeUtc.ToString(DefaultFormat, CultureInfo.CurrentCulture), now.ToString(DefaultFormat, CultureInfo.CurrentCulture), timeToLive, allowedClockSkew)));
+            }
+
+            // this is a fresh timestamp
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityTokenAttachmentMode.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityTokenAttachmentMode.cs
new file mode 100644
index 0000000..23844bd
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityTokenAttachmentMode.cs
@@ -0,0 +1,66 @@
+using System.ComponentModel;
+using System;
+namespace CoreWCF.Security
+{
+
+    public enum SecurityTokenAttachmentMode
+    {
+        Signed,
+        Endorsing,
+        SignedEndorsing,
+        SignedEncrypted
+    }
+
+    static class SecurityTokenAttachmentModeHelper
+    {
+        internal static bool IsDefined(SecurityTokenAttachmentMode value)
+        {
+            return value == SecurityTokenAttachmentMode.Endorsing
+                || value == SecurityTokenAttachmentMode.Signed
+                || value == SecurityTokenAttachmentMode.SignedEncrypted
+                || value == SecurityTokenAttachmentMode.SignedEndorsing;
+        }
+
+        internal static void Validate(SecurityTokenAttachmentMode value)
+        {
+            if (!IsDefined(value))
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidEnumArgumentException("value", (int)value,
+                    typeof(SecurityTokenAttachmentMode)));
+            }
+        }
+
+        internal static void Categorize(SecurityTokenAttachmentMode value,
+            out bool isBasic, out bool isSignedButNotBasic, out ReceiveSecurityHeaderBindingModes mode)
+        {
+
+            SecurityTokenAttachmentModeHelper.Validate(value);
+
+            switch (value)
+            {
+                case SecurityTokenAttachmentMode.Endorsing:
+                    isBasic = false;
+                    isSignedButNotBasic = false;
+                    mode = ReceiveSecurityHeaderBindingModes.Endorsing;
+                    break;
+                case SecurityTokenAttachmentMode.Signed:
+                    isBasic = false;
+                    isSignedButNotBasic = true;
+                    mode = ReceiveSecurityHeaderBindingModes.Signed;
+                    break;
+                case SecurityTokenAttachmentMode.SignedEncrypted:
+                    isBasic = true;
+                    isSignedButNotBasic = false;
+                    mode = ReceiveSecurityHeaderBindingModes.Basic;
+                    break;
+                case SecurityTokenAttachmentMode.SignedEndorsing:
+                    isBasic = false;
+                    isSignedButNotBasic = true;
+                    mode = ReceiveSecurityHeaderBindingModes.SignedEndorsing;
+                    break;
+                default:
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("value"));
+            }
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityTokenSpecification.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityTokenSpecification.cs
index a5e56f1..bcfe208 100644
--- a/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityTokenSpecification.cs
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityTokenSpecification.cs
@@ -7,7 +7,7 @@ using System.Text;
 
 namespace CoreWCF.Security
 {
-    internal class SecurityTokenSpecification
+    public class SecurityTokenSpecification
     {
         SecurityToken token;
         ReadOnlyCollection<IAuthorizationPolicy> tokenPolicies;
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityUtils.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityUtils.cs
index a6e9588..a1c5f78 100644
--- a/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityUtils.cs
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityUtils.cs
@@ -19,6 +19,12 @@ using CoreWCF.Channels;
 using System.DirectoryServices.ActiveDirectory;
 using CoreWCF.Runtime;
 using System.Collections.Generic;
+using CoreWCF.IdentityModel;
+using System.Security.Authentication.ExtendedProtection;
+using System.Xml;
+using CoreWCF.Dispatcher;
+using System.Xml.Serialization;
+using CoreWCF.Security.Tokens;
 
 namespace CoreWCF.Security
 {
@@ -99,12 +105,39 @@ namespace CoreWCF.Security
             }
         }
     }
+    internal class ServiceModelDictionaryManager
+    {
+        static DictionaryManager dictionaryManager;
+
+        public static DictionaryManager Instance
+        {
+            get
+            {
+                if (dictionaryManager == null)
+                    dictionaryManager = new DictionaryManager((ServiceModelDictionary) BinaryMessageEncoderFactory.XmlDictionary);
+
+                return dictionaryManager;
+            }
+        }
+    }
 
     internal class SecurityUtils
     {
         public const string Principal = "Principal";
         public const string Identities = "Identities";
+
+        internal static byte[] ReadContentAsBase64(XmlDictionaryReader reader, long maxBufferSize)
+        {
+            throw new NotImplementedException();
+        }
+
         static bool computedDomain;
+
+        internal static byte[] EncryptKey(SecurityToken wrappingToken, string wrappingAlgorithm, byte[] keyToWrap)
+        {
+            throw new NotImplementedException();
+        }
+
         static string currentDomain;
         static IIdentity anonymousIdentity;
         static X509SecurityTokenAuthenticator nonValidatingX509Authenticator;
@@ -133,6 +166,23 @@ namespace CoreWCF.Security
             }
         }
 
+        public static DateTime MinUtcDateTime 
+        { get
+            { return new DateTime(DateTime.MinValue.Ticks + TimeSpan.TicksPerDay, DateTimeKind.Utc); } 
+        }
+        public static DateTime MaxUtcDateTime {
+            get
+            {
+                // + and -  TimeSpan.TicksPerDay is to compensate the DateTime.ParseExact (to localtime) overflow.
+                return new DateTime(DateTime.MaxValue.Ticks - TimeSpan.TicksPerDay, DateTimeKind.Utc);
+            }
+        }
+
+        internal static ReadOnlyCollection<SecurityKey> CreateSymmetricSecurityKeys(byte[] keyToWrap)
+        {
+            throw new NotImplementedException();
+        }
+
         internal static IIdentity CreateIdentity(string name)
         {
             return new GenericIdentity(name);
@@ -353,6 +403,204 @@ namespace CoreWCF.Security
             return canDoKeyExchange;
         }
 
+        internal static MessageFault CreateSecurityMessageFault(Exception e, SecurityStandardsManager standardsManager)
+        {
+            throw new NotImplementedException();
+        }
+
+        internal static string GenerateId()
+        {
+            return SecurityUniqueId.Create().Value;
+        }
+
+        internal static byte[] GenerateDerivedKey(SecurityToken tokenToDerive, string derivationAlgorithm, byte[] label, byte[] nonce,
+    int keySize, int offset)
+        {
+            SymmetricSecurityKey symmetricSecurityKey = SecurityUtils.GetSecurityKey<SymmetricSecurityKey>(tokenToDerive);
+            if (symmetricSecurityKey == null || !symmetricSecurityKey.IsSupportedAlgorithm(derivationAlgorithm))
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new MessageSecurityException(SR.Format(SR.CannotFindMatchingCrypto, derivationAlgorithm)));
+            }
+            return symmetricSecurityKey.GenerateDerivedKey(derivationAlgorithm, label, nonce, keySize, offset);
+        }
+       public static bool TryCreateKeyFromIntrinsicKeyClause(SecurityKeyIdentifierClause keyIdentifierClause, SecurityTokenResolver resolver, out SecurityKey key)
+        {
+            key = null;
+            if (keyIdentifierClause.CanCreateKey)
+            {
+                key = keyIdentifierClause.CreateKey();
+                return true;
+            }
+            if (keyIdentifierClause is EncryptedKeyIdentifierClause)
+            {
+                EncryptedKeyIdentifierClause keyClause = (EncryptedKeyIdentifierClause)keyIdentifierClause;
+                // PreSharp Bug: Parameter 'keyClause' to this public method must be validated: A null-dereference can occur here.
+#pragma warning suppress 56506 // keyClause will not be null due to the if condition above.
+                for (int i = 0; i < keyClause.EncryptingKeyIdentifier.Count; i++)
+                {
+                    SecurityKey unwrappingSecurityKey = null;
+                    //TODO
+                 /*   if (resolver.TryResolveSecurityKey(keyClause.EncryptingKeyIdentifier[i], out unwrappingSecurityKey))
+                    {
+                        byte[] wrappedKey = keyClause.GetEncryptedKey();
+                        string wrappingAlgorithm = keyClause.EncryptionMethod;
+                        byte[] unwrappedKey = unwrappingSecurityKey.DecryptKey(wrappingAlgorithm, wrappedKey);
+                        key = new InMemorySymmetricSecurityKey(unwrappedKey, false);
+                        return true;
+                    }*/
+                }
+            }
+            return false;
+        }
+
+        internal static bool HasSymmetricSecurityKey(SecurityToken sourceEncryptionToken)
+        {
+            return GetSecurityKey<SymmetricSecurityKey>(sourceEncryptionToken) != null;
+        }
+
+        internal static byte[] CloneBuffer(byte[] buffer)
+        {
+            byte[] copy = Fx.AllocateByteArray(buffer.Length);
+            Buffer.BlockCopy(buffer, 0, copy, 0, buffer.Length);
+            return copy;
+        }
+        internal static bool IsSupportedAlgorithm(string algorithm, SecurityToken token)
+        {
+            if (token.SecurityKeys == null)
+            {
+                return false;
+            }
+            for (int i = 0; i < token.SecurityKeys.Count; ++i)
+            {
+                if (token.SecurityKeys[i].IsSupportedAlgorithm(algorithm))
+                {
+                    return true;
+                }
+            }
+            return false;
+        }
+        internal static T GetSecurityKey<T>(SecurityToken token)
+    where T : SecurityKey
+        {
+            T result = null;
+            if (token.SecurityKeys != null)
+            {
+                for (int i = 0; i < token.SecurityKeys.Count; ++i)
+                {
+                    T temp = (token.SecurityKeys[i] as T);
+                    if (temp != null)
+                    {
+                        if (result != null)
+                        {
+                            throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new MessageSecurityException(SR.Format(SR.MultipleMatchingCryptosFound, typeof(T).ToString())));
+                        }
+                        else
+                        {
+                            result = temp;
+                        }
+                    }
+                }
+            }
+            return result;
+        }
+
+        internal static bool TryCreateX509CertificateFromRawData(byte[] rawData, out X509Certificate2 certificate)
+        {
+            throw new NotImplementedException();
+        }
+
+        internal static string GetKeyDerivationAlgorithm(SecureConversationVersion version)
+        {
+            string derivationAlgorithm = null;
+            if (version == SecureConversationVersion.WSSecureConversationFeb2005)
+            {
+                derivationAlgorithm = SecurityAlgorithms.Psha1KeyDerivation;
+            }
+            else if (version == SecureConversationVersion.WSSecureConversation13)
+            {
+                derivationAlgorithm = SecurityAlgorithms.Psha1KeyDerivationDec2005;
+            }
+            else
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new NotSupportedException());
+            }
+
+            return derivationAlgorithm;
+        }
+
+        internal static ReadOnlyCollection<IAuthorizationPolicy> CloneAuthorizationPoliciesIfNecessary(ReadOnlyCollection<IAuthorizationPolicy> authorizationPolicies)
+        {
+            if (authorizationPolicies != null && authorizationPolicies.Count > 0)
+            {
+                bool clone = false;
+                for (int i = 0; i < authorizationPolicies.Count; ++i)
+                {
+                    UnconditionalPolicy policy = authorizationPolicies[i] as UnconditionalPolicy;
+                    if (policy != null && policy.IsDisposable)
+                    {
+                        clone = true;
+                        break;
+                    }
+                }
+                if (clone)
+                {
+                    List<IAuthorizationPolicy> ret = new List<IAuthorizationPolicy>(authorizationPolicies.Count);
+                    for (int i = 0; i < authorizationPolicies.Count; ++i)
+                    {
+                        UnconditionalPolicy policy = authorizationPolicies[i] as UnconditionalPolicy;
+                        if (policy != null)
+                        {
+                            ret.Add(policy.Clone());
+                        }
+                        else
+                        {
+                            ret.Add(authorizationPolicies[i]);
+                        }
+                    }
+                    return ret.AsReadOnly();
+                }
+            }
+            return authorizationPolicies;
+        }
+        public static void DisposeAuthorizationPoliciesIfNecessary(ReadOnlyCollection<IAuthorizationPolicy> authorizationPolicies)
+        {
+            if (authorizationPolicies != null && authorizationPolicies.Count > 0)
+            {
+                for (int i = 0; i < authorizationPolicies.Count; ++i)
+                {
+                    DisposeIfNecessary(authorizationPolicies[i] as UnconditionalPolicy);
+                }
+            }
+        }
+
+        public static void DisposeIfNecessary(IDisposable obj)
+        {
+            if (obj != null)
+            {
+                obj.Dispose();
+            }
+        }
+
+        public static ChannelBinding GetChannelBindingFromMessage(Message message)
+        {
+            if (message == null)
+            {
+                return null;
+            }
+
+            ChannelBindingMessageProperty channelBindingMessageProperty = null;
+            ChannelBindingMessageProperty.TryGet(message, out channelBindingMessageProperty);
+            ChannelBinding channelBinding = null;
+
+            if (channelBindingMessageProperty != null)
+            {
+                channelBinding = channelBindingMessageProperty.ChannelBinding;
+            }
+
+            return channelBinding;
+        }
+
+
         internal static NetworkCredential GetNetworkCredentialsCopy(NetworkCredential networkCredential)
         {
             NetworkCredential result;
@@ -367,6 +615,11 @@ namespace CoreWCF.Security
             return result;
         }
 
+        internal static void CloseTokenAuthenticatorIfRequired(SecurityTokenAuthenticator tokenAuthenticator, TimeSpan timeSpan)
+        {
+            throw new NotImplementedException();
+        }
+
         static class NetworkCredentialHelper
         {
             static internal bool IsNullOrEmpty(NetworkCredential credential)
@@ -476,6 +729,11 @@ namespace CoreWCF.Security
             }
         }
 
+        internal static UniqueId GenerateUniqueId()
+        {
+            return new UniqueId();
+        }
+
         // This is the workaround, Since store.Certificates returns a full collection
         // of certs in store.  These are holding native resources.
         internal static void ResetAllCertificates(X509Certificate2Collection certificates)
@@ -489,6 +747,11 @@ namespace CoreWCF.Security
             }
         }
 
+        internal static void ErasePasswordInUsernameTokenIfPresent(SecurityMessageProperty bootstrapMessageProperty)
+        {
+            throw new NotImplementedException();
+        }
+
         internal static void ResetCertificate(X509Certificate2 certificate)
         {
             certificate.Reset();
@@ -534,6 +797,10 @@ namespace CoreWCF.Security
                 }
             }
         }
+        internal static Task OpenTokenAuthenticatorIfRequiredAsync(SecurityTokenAuthenticator tokenAuthenticator, CancellationToken token)
+        {
+           return OpenCommunicationObjectAsync(tokenAuthenticator as ICommunicationObject , token) ;
+        }
 
         internal static Task OpenTokenProviderIfRequiredAsync(SecurityTokenProvider tokenProvider, CancellationToken token)
         {
@@ -555,10 +822,6 @@ namespace CoreWCF.Security
             CloseCommunicationObjectAsync(tokenProvider, true, CancellationToken.None).GetAwaiter().GetResult();
         }
 
-        internal static Task OpenTokenAuthenticatorIfRequiredAsync(SecurityTokenAuthenticator tokenAuthenticator, CancellationToken token)
-        {
-            return OpenCommunicationObjectAsync(tokenAuthenticator as ICommunicationObject, token);
-        }
 
         internal static Task CloseTokenAuthenticatorIfRequiredAsync(SecurityTokenAuthenticator tokenAuthenticator, CancellationToken token)
         {
@@ -659,5 +922,92 @@ namespace CoreWCF.Security
             policies.Add(new UnconditionalPolicy(SecurityUtils.CreateIdentity(principalName), new DefaultClaimSet(ClaimSet.Anonymous, claims)));
             return policies.AsReadOnly();
         }
+
+        internal static void OpenTokenProviderIfRequired(SecurityTokenProvider provider, TimeSpan timeout)
+        {
+            throw new NotImplementedException();
+        }
+        public static SecurityBindingElement GetIssuerSecurityBindingElement(ServiceModelSecurityTokenRequirement requirement)
+        {
+            SecurityBindingElement bindingElement = requirement.SecureConversationSecurityBindingElement;
+            if (bindingElement != null)
+            {
+                return bindingElement;
+            }
+
+            Binding binding = requirement.IssuerBinding;
+            if (binding == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgument(SR.Format(SR.IssuerBindingNotPresentInTokenRequirement, requirement));
+            }
+            BindingElementCollection bindingElements = binding.CreateBindingElements();
+            return bindingElements.Find<SecurityBindingElement>();
+        }
+
+        internal static SecurityStandardsManager CreateSecurityStandardsManager(MessageSecurityVersion securityVersion, SecurityTokenManager tokenManager)
+        {
+            SecurityTokenSerializer tokenSerializer = tokenManager.CreateSecurityTokenSerializer(securityVersion.SecurityTokenVersion);
+            return new SecurityStandardsManager(securityVersion, tokenSerializer);
+        }
+
+        internal static SecurityStandardsManager CreateSecurityStandardsManager(SecurityTokenRequirement requirement, SecurityTokenManager tokenManager)
+        {
+            MessageSecurityTokenVersion securityVersion = (MessageSecurityTokenVersion)requirement.GetProperty<MessageSecurityTokenVersion>(ServiceModelSecurityTokenRequirement.MessageSecurityVersionProperty);
+            if (securityVersion == MessageSecurityTokenVersion.WSSecurity10WSTrustFebruary2005WSSecureConversationFebruary2005BasicSecurityProfile10)
+                return CreateSecurityStandardsManager(MessageSecurityVersion.WSSecurity10WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11BasicSecurityProfile10, tokenManager);
+            else if (securityVersion == MessageSecurityTokenVersion.WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005)
+                return CreateSecurityStandardsManager(MessageSecurityVersion.WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11, tokenManager);
+            else if (securityVersion == MessageSecurityTokenVersion.WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005BasicSecurityProfile10)
+                return CreateSecurityStandardsManager(MessageSecurityVersion.WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11BasicSecurityProfile10, tokenManager);
+            else if (securityVersion == MessageSecurityTokenVersion.WSSecurity10WSTrust13WSSecureConversation13BasicSecurityProfile10)
+                return CreateSecurityStandardsManager(MessageSecurityVersion.WSSecurity10WSTrust13WSSecureConversation13WSSecurityPolicy12BasicSecurityProfile10, tokenManager);
+            else if (securityVersion == MessageSecurityTokenVersion.WSSecurity11WSTrust13WSSecureConversation13)
+                return CreateSecurityStandardsManager(MessageSecurityVersion.WSSecurity11WSTrust13WSSecureConversation13WSSecurityPolicy12, tokenManager);
+            else if (securityVersion == MessageSecurityTokenVersion.WSSecurity11WSTrust13WSSecureConversation13BasicSecurityProfile10)
+                return CreateSecurityStandardsManager(MessageSecurityVersion.WSSecurity11WSTrust13WSSecureConversation13WSSecurityPolicy12BasicSecurityProfile10, tokenManager);
+            else
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new NotSupportedException());
+        }
+
+        internal static SecurityStandardsManager CreateSecurityStandardsManager(MessageSecurityVersion messageSecurityVersion, SecurityTokenSerializer securityTokenSerializer)
+        {
+            if (messageSecurityVersion == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException("securityVersion"));
+            }
+            if (securityTokenSerializer == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("securityTokenSerializer");
+            }
+            return new SecurityStandardsManager(messageSecurityVersion, securityTokenSerializer);
+        }
+
+        internal static void MatchRstWithEndpointFilter(Message request, IMessageFilterTable<EndpointAddress> endpointFilterTable, Uri listenUri)
+        {
+            if (endpointFilterTable == null)
+            {
+                return;
+            }
+            Collection<EndpointAddress> result = new Collection<EndpointAddress>();
+            if (!endpointFilterTable.GetMatchingValues(request, result))
+            {
+                throw new SecurityNegotiationException(SR.Format(SR.RequestSecurityTokenDoesNotMatchEndpointFilters, listenUri)); 
+            }
+        }
+
+        internal static bool IsEqual(byte[] rawData1, byte[] rawData2)
+        {
+            throw new NotImplementedException();
+        }
+
+        internal static bool IsCurrentlyTimeEffective(DateTime effectiveTime, DateTime expirationTime, TimeSpan maxClockSkew)
+        {
+            DateTime curEffectiveTime = (effectiveTime < DateTime.MinValue.Add(maxClockSkew)) ? effectiveTime : effectiveTime.Subtract(maxClockSkew);
+            DateTime curExpirationTime = (expirationTime > DateTime.MaxValue.Subtract(maxClockSkew)) ? expirationTime : expirationTime.Add(maxClockSkew);
+            DateTime curTime = DateTime.UtcNow;
+
+            return (curEffectiveTime.ToUniversalTime() <= curTime) && (curTime < curExpirationTime.ToUniversalTime());
+
+        }
     }
 }
\ No newline at end of file
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityVerifiedMessage.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityVerifiedMessage.cs
new file mode 100644
index 0000000..7ceae45
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityVerifiedMessage.cs
@@ -0,0 +1,579 @@
+using System.Diagnostics;
+using System.IO;
+using System.Runtime;
+using CoreWCF.Runtime;
+using CoreWCF;
+using CoreWCF.Channels;
+using CoreWCF.Diagnostics;
+using System.Xml;
+using System;
+namespace CoreWCF.Security
+{
+
+
+    sealed class SecurityVerifiedMessage : DelegatingMessage
+    {
+        byte[] decryptedBuffer;
+        XmlDictionaryReader cachedDecryptedBodyContentReader;
+        XmlAttributeHolder[] envelopeAttributes;
+        XmlAttributeHolder[] headerAttributes;
+        XmlAttributeHolder[] bodyAttributes;
+        string envelopePrefix;
+        bool bodyDecrypted;
+        BodyState state = BodyState.Created;
+        string bodyPrefix;
+        bool isDecryptedBodyStatusDetermined;
+        bool isDecryptedBodyFault;
+        bool isDecryptedBodyEmpty;
+        XmlDictionaryReader cachedReaderAtSecurityHeader;
+        readonly ReceiveSecurityHeader securityHeader;
+        XmlBuffer messageBuffer;
+        bool canDelegateCreateBufferedCopyToInnerMessage;
+
+        public SecurityVerifiedMessage(Message messageToProcess, ReceiveSecurityHeader securityHeader)
+            : base(messageToProcess)
+        {
+            this.securityHeader = securityHeader;
+            if (securityHeader.RequireMessageProtection)
+            {
+                XmlDictionaryReader messageReader;
+                BufferedMessage bufferedMessage = this.InnerMessage as BufferedMessage;
+                if (bufferedMessage != null && this.Headers.ContainsOnlyBufferedMessageHeaders)
+                {
+                    messageReader = bufferedMessage.GetMessageReader();
+                }
+                else
+                {
+                    this.messageBuffer = new XmlBuffer(int.MaxValue);
+                    XmlDictionaryWriter writer = this.messageBuffer.OpenSection(this.securityHeader.ReaderQuotas);
+                    this.InnerMessage.WriteMessage(writer);
+                    this.messageBuffer.CloseSection();
+                    this.messageBuffer.Close();
+                    messageReader = this.messageBuffer.GetReader(0);
+                }
+                MoveToSecurityHeader(messageReader, securityHeader.HeaderIndex, true);
+                this.cachedReaderAtSecurityHeader = messageReader;
+                this.state = BodyState.Buffered;
+            }
+            else
+            {
+                this.envelopeAttributes = XmlAttributeHolder.emptyArray;
+                this.headerAttributes = XmlAttributeHolder.emptyArray;
+                this.bodyAttributes = XmlAttributeHolder.emptyArray;
+                this.canDelegateCreateBufferedCopyToInnerMessage = true;
+            }
+        }
+
+        public override bool IsEmpty
+        {
+            get
+            {
+                if (this.IsDisposed)
+                {
+                    // PreSharp Bug: Property get methods should not throw exceptions.
+                    #pragma warning suppress 56503
+                    throw TraceUtility.ThrowHelperError(CreateMessageDisposedException(), this);
+                }
+                if (!this.bodyDecrypted)
+                {
+                    return this.InnerMessage.IsEmpty;
+                }
+                
+                EnsureDecryptedBodyStatusDetermined();
+
+                return this.isDecryptedBodyEmpty;
+            }
+        }
+
+        public override bool IsFault
+        {
+            get
+            {
+                if (this.IsDisposed)
+                {
+                    // PreSharp Bug: Property get methods should not throw exceptions.
+                    #pragma warning suppress 56503
+                    throw TraceUtility.ThrowHelperError(CreateMessageDisposedException(), this);
+                }
+                if (!this.bodyDecrypted)
+                {
+                    return this.InnerMessage.IsFault;
+                }
+
+                EnsureDecryptedBodyStatusDetermined();
+
+                return this.isDecryptedBodyFault;
+            }
+        }
+
+        internal byte[] PrimarySignatureValue
+        {
+            get { return this.securityHeader.PrimarySignatureValue; }
+        }
+
+        internal ReceiveSecurityHeader ReceivedSecurityHeader
+        {
+            get { return this.securityHeader; }
+        }
+
+        Exception CreateBadStateException(string operation)
+        {
+            return new InvalidOperationException(SR.Format(SR.MessageBodyOperationNotValidInBodyState,
+                operation, this.state));
+        }
+
+        public XmlDictionaryReader CreateFullBodyReader()
+        {
+            switch (this.state)
+            {
+                case BodyState.Buffered:
+                    return CreateFullBodyReaderFromBufferedState();
+                case BodyState.Decrypted:
+                    return CreateFullBodyReaderFromDecryptedState();
+                default:
+                    throw TraceUtility.ThrowHelperError(CreateBadStateException("CreateFullBodyReader"), this);
+            }
+        }
+
+        XmlDictionaryReader CreateFullBodyReaderFromBufferedState()
+        {
+            if (this.messageBuffer != null)
+            {
+                XmlDictionaryReader reader = this.messageBuffer.GetReader(0);
+                MoveToBody(reader);
+                return reader;
+            }
+            else
+            {
+                return ((BufferedMessage) this.InnerMessage).GetBufferedReaderAtBody();
+            }
+        }
+
+        XmlDictionaryReader CreateFullBodyReaderFromDecryptedState()
+        {
+            XmlDictionaryReader reader = XmlDictionaryReader.CreateTextReader(this.decryptedBuffer, 0, this.decryptedBuffer.Length, this.securityHeader.ReaderQuotas);
+            MoveToBody(reader);
+            return reader;
+        }
+
+        void EnsureDecryptedBodyStatusDetermined()
+        {
+            if (!this.isDecryptedBodyStatusDetermined)
+            {
+                XmlDictionaryReader reader = CreateFullBodyReader();
+                if (Message.ReadStartBody(reader, this.InnerMessage.Version.Envelope, out this.isDecryptedBodyFault, out this.isDecryptedBodyEmpty))
+                {
+                    this.cachedDecryptedBodyContentReader = reader;
+                }
+                else
+                {
+                    reader.Close();
+                }
+                this.isDecryptedBodyStatusDetermined = true;
+            }
+        }
+
+        public XmlAttributeHolder[] GetEnvelopeAttributes()
+        {
+            return this.envelopeAttributes;
+        }
+
+        public XmlAttributeHolder[] GetHeaderAttributes()
+        {
+            return this.headerAttributes;
+        }
+
+        XmlDictionaryReader GetReaderAtEnvelope()
+        {
+            if (this.messageBuffer != null)
+            {
+                return this.messageBuffer.GetReader(0);
+            }
+            else
+            {
+                return ((BufferedMessage) this.InnerMessage).GetMessageReader();
+            }
+        }
+
+        public XmlDictionaryReader GetReaderAtFirstHeader()
+        {
+            XmlDictionaryReader reader = GetReaderAtEnvelope();
+            MoveToHeaderBlock(reader, false);
+            reader.ReadStartElement();
+            return reader;
+        }
+
+        public XmlDictionaryReader GetReaderAtSecurityHeader()
+        {
+            if (this.cachedReaderAtSecurityHeader != null)
+            {
+                XmlDictionaryReader result = this.cachedReaderAtSecurityHeader;
+                this.cachedReaderAtSecurityHeader = null;
+                return result;
+            }
+            return this.Headers.GetReaderAtHeader(this.securityHeader.HeaderIndex);
+        }
+
+        void MoveToBody(XmlDictionaryReader reader)
+        {
+            if (reader.NodeType != XmlNodeType.Element)
+            {
+                reader.MoveToContent();
+            }
+            reader.ReadStartElement();
+            if (reader.IsStartElement(XD.MessageDictionary.Header, this.Version.Envelope.DictionaryNamespace))
+            {
+                reader.Skip();
+            }
+            if (reader.NodeType != XmlNodeType.Element)
+            {
+                reader.MoveToContent();
+            }
+        }
+
+        void MoveToHeaderBlock(XmlDictionaryReader reader, bool captureAttributes)
+        {
+            if (reader.NodeType != XmlNodeType.Element)
+            {
+                reader.MoveToContent();
+            }
+            if (captureAttributes)
+            {
+                this.envelopePrefix = reader.Prefix;
+                this.envelopeAttributes = XmlAttributeHolder.ReadAttributes(reader);
+            }
+            reader.ReadStartElement();
+            reader.MoveToStartElement(XD.MessageDictionary.Header, this.Version.Envelope.DictionaryNamespace);
+            if (captureAttributes)
+            {
+                this.headerAttributes = XmlAttributeHolder.ReadAttributes(reader);
+            }
+        }
+
+        void MoveToSecurityHeader(XmlDictionaryReader reader, int headerIndex, bool captureAttributes)
+        {
+            MoveToHeaderBlock(reader, captureAttributes);
+            reader.ReadStartElement();
+            while (true)
+            {
+                if (reader.NodeType != XmlNodeType.Element)
+                {
+                    reader.MoveToContent();
+                }
+                if (headerIndex == 0)
+                {
+                    break;
+                }
+                reader.Skip();
+                headerIndex--;
+            }
+        }
+
+        protected override void OnBodyToString(XmlDictionaryWriter writer)
+        {
+            if (this.state == BodyState.Created)
+            {
+                base.OnBodyToString(writer);
+            }
+            else
+            {
+                OnWriteBodyContents(writer);
+            }
+        }
+
+        protected override void OnClose()
+        {
+            
+            if (this.cachedDecryptedBodyContentReader != null)
+            {
+                try
+                {
+                    this.cachedDecryptedBodyContentReader.Close();
+                }
+                catch (System.IO.IOException exception)
+                {
+                    //
+                    // We only want to catch and log the I/O exception here 
+                    // assuming reader only throw those exceptions  
+                    //
+                    DiagnosticUtility.TraceHandledException(exception, TraceEventType.Warning);
+                }
+                finally 
+                {
+                    this.cachedDecryptedBodyContentReader = null;
+                }
+            }
+
+            if (this.cachedReaderAtSecurityHeader != null)
+            {
+                try
+                {
+                    this.cachedReaderAtSecurityHeader.Close();
+                }
+                catch (System.IO.IOException exception)
+                {
+                    //
+                    // We only want to catch and log the I/O exception here 
+                    // assuming reader only throw those exceptions  
+                    //
+                    DiagnosticUtility.TraceHandledException(exception, TraceEventType.Warning);
+                }
+                finally 
+                {
+                    this.cachedReaderAtSecurityHeader = null;
+                }
+            }
+
+            this.messageBuffer = null;
+            this.decryptedBuffer = null;
+            this.state = BodyState.Disposed;
+            this.InnerMessage.Close();  
+        }
+
+        protected override XmlDictionaryReader OnGetReaderAtBodyContents()
+        {
+            if (this.state == BodyState.Created)
+            {
+                return this.InnerMessage.GetReaderAtBodyContents();
+            }
+            if (this.bodyDecrypted)
+            {
+                EnsureDecryptedBodyStatusDetermined();
+            }
+            if (this.cachedDecryptedBodyContentReader != null)
+            {
+                XmlDictionaryReader result = this.cachedDecryptedBodyContentReader;
+                this.cachedDecryptedBodyContentReader = null;
+                return result;
+            }
+            else
+            {
+                XmlDictionaryReader reader = CreateFullBodyReader();
+                reader.ReadStartElement();
+                reader.MoveToContent();
+                return reader;
+            }
+        }
+
+        protected override MessageBuffer OnCreateBufferedCopy(int maxBufferSize)
+        {
+            if (this.canDelegateCreateBufferedCopyToInnerMessage && this.InnerMessage is BufferedMessage)
+            {
+                return this.InnerMessage.CreateBufferedCopy(maxBufferSize);
+            }
+            else
+            {
+                return base.OnCreateBufferedCopy(maxBufferSize);
+            }
+        }
+
+        internal void OnMessageProtectionPassComplete(bool atLeastOneHeaderOrBodyEncrypted)
+        {
+            this.canDelegateCreateBufferedCopyToInnerMessage = !atLeastOneHeaderOrBodyEncrypted;
+        }
+
+        internal void OnUnencryptedPart(string name, string ns)
+        {
+            if (ns == null)
+            {
+                throw TraceUtility.ThrowHelperError(new MessageSecurityException(SR.Format(SR.RequiredMessagePartNotEncrypted, name)), this);
+            }
+            else
+            {
+                throw TraceUtility.ThrowHelperError(new MessageSecurityException(SR.Format(SR.RequiredMessagePartNotEncryptedNs, name, ns)), this);
+            }
+        }
+
+        internal void OnUnsignedPart(string name, string ns)
+        {
+            if (ns == null)
+            {
+                throw TraceUtility.ThrowHelperError(new MessageSecurityException(SR.Format(SR.RequiredMessagePartNotSigned, name)), this);
+            }
+            else
+            {
+                throw TraceUtility.ThrowHelperError(new MessageSecurityException(SR.Format(SR.RequiredMessagePartNotSignedNs, name, ns)), this);
+            }
+        }
+
+        protected override void OnWriteStartBody(XmlDictionaryWriter writer)
+        {
+            if (this.state == BodyState.Created)
+            {
+                this.InnerMessage.WriteStartBody(writer);
+                return;
+            }
+
+            XmlDictionaryReader reader = CreateFullBodyReader();
+            reader.MoveToContent();
+            writer.WriteStartElement(reader.Prefix, reader.LocalName, reader.NamespaceURI);
+            writer.WriteAttributes(reader, false);
+            reader.Close();
+        }
+
+        protected override void OnWriteBodyContents(XmlDictionaryWriter writer)
+        {
+            if (this.state == BodyState.Created)
+            {
+                this.InnerMessage.WriteBodyContents(writer);
+                return;
+            }
+
+            XmlDictionaryReader reader = CreateFullBodyReader();
+            reader.ReadStartElement();
+            while (reader.NodeType != XmlNodeType.EndElement)
+                writer.WriteNode(reader, false);
+            reader.ReadEndElement();
+            reader.Close();
+        }
+
+        public void SetBodyPrefixAndAttributes(XmlDictionaryReader bodyReader)
+        {
+            this.bodyPrefix = bodyReader.Prefix;
+            this.bodyAttributes = XmlAttributeHolder.ReadAttributes(bodyReader);
+        }
+
+        public void SetDecryptedBody(byte[] decryptedBodyContent)
+        {
+            if (this.state != BodyState.Buffered)
+            {
+                throw TraceUtility.ThrowHelperError(CreateBadStateException("SetDecryptedBody"), this);
+            }
+
+            MemoryStream stream = new MemoryStream();
+            XmlDictionaryWriter writer = XmlDictionaryWriter.CreateTextWriter(stream);
+
+            writer.WriteStartElement(this.envelopePrefix, XD.MessageDictionary.Envelope, this.Version.Envelope.DictionaryNamespace);
+            XmlAttributeHolder.WriteAttributes(this.envelopeAttributes, writer);
+
+            writer.WriteStartElement(this.bodyPrefix, XD.MessageDictionary.Body, this.Version.Envelope.DictionaryNamespace);
+            XmlAttributeHolder.WriteAttributes(this.bodyAttributes, writer);
+            writer.WriteString(" "); // ensure non-empty element
+            writer.WriteEndElement();
+            writer.WriteEndElement();
+            writer.Flush();
+
+            this.decryptedBuffer = ContextImportHelper.SpliceBuffers(decryptedBodyContent, stream.GetBuffer(), (int) stream.Length, 2);
+
+            this.bodyDecrypted = true;
+            this.state = BodyState.Decrypted;
+        }
+
+        enum BodyState
+        {
+            Created,
+            Buffered,
+            Decrypted,
+            Disposed,
+        }
+    }
+
+    // Adding wrapping tags using a writer is a temporary feature to
+    // support interop with a partner.  Eventually, the serialization
+    // team will add a feature to XmlUTF8TextReader to directly
+    // support the addition of outer namespaces before creating a
+    // Reader.  This roundabout way of supporting context-sensitive
+    // decryption can then be removed.
+    static class ContextImportHelper
+    {
+        internal static XmlDictionaryReader CreateSplicedReader(byte[] decryptedBuffer,
+            XmlAttributeHolder[] outerContext1, XmlAttributeHolder[] outerContext2, XmlAttributeHolder[] outerContext3, XmlDictionaryReaderQuotas quotas)
+        {
+            const string wrapper1 = "x";
+            const string wrapper2 = "y";
+            const string wrapper3 = "z";
+            const int wrappingDepth = 3;
+
+            MemoryStream stream = new MemoryStream();
+            XmlDictionaryWriter writer = XmlDictionaryWriter.CreateTextWriter(stream);
+            writer.WriteStartElement(wrapper1);
+            WriteNamespaceDeclarations(outerContext1, writer);
+            writer.WriteStartElement(wrapper2);
+            WriteNamespaceDeclarations(outerContext2, writer);
+            writer.WriteStartElement(wrapper3);
+            WriteNamespaceDeclarations(outerContext3, writer);
+            writer.WriteString(" "); // ensure non-empty element
+            writer.WriteEndElement();
+            writer.WriteEndElement();
+            writer.WriteEndElement();
+            writer.Flush();
+
+            byte[] splicedBuffer = SpliceBuffers(decryptedBuffer, stream.GetBuffer(), (int) stream.Length, wrappingDepth);
+            XmlDictionaryReader reader = XmlDictionaryReader.CreateTextReader(splicedBuffer, quotas);
+            reader.ReadStartElement(wrapper1);
+            reader.ReadStartElement(wrapper2);
+            reader.ReadStartElement(wrapper3);
+            if (reader.NodeType != XmlNodeType.Element)
+            {
+                reader.MoveToContent();
+            }
+            return reader;
+        }
+
+        internal static string GetPrefixIfNamespaceDeclaration(string prefix, string localName)
+        {
+            if (prefix == "xmlns")
+            {
+                return localName;
+            }
+            if (prefix.Length == 0 && localName == "xmlns")
+            {
+                return string.Empty;
+            }
+            return null;
+        }
+
+        static bool IsNamespaceDeclaration(string prefix, string localName)
+        {
+            return GetPrefixIfNamespaceDeclaration(prefix, localName) != null;
+        }
+
+        internal static byte[] SpliceBuffers(byte[] middle, byte[] wrapper, int wrapperLength, int wrappingDepth)
+        {
+            const byte openChar = (byte) '<';
+            int openCharsFound = 0;
+            int openCharIndex;
+            for (openCharIndex = wrapperLength - 1; openCharIndex >= 0; openCharIndex--)
+            {
+                if (wrapper[openCharIndex] == openChar)
+                {
+                    openCharsFound++;
+                    if (openCharsFound == wrappingDepth)
+                    {
+                        break;
+                    }
+                }
+            }
+
+            Fx.Assert(openCharIndex > 0, "");
+
+            byte[] splicedBuffer = Fx.AllocateByteArray(checked(middle.Length + wrapperLength - 1));
+            int offset = 0;
+            int count = openCharIndex - 1;
+            Buffer.BlockCopy(wrapper, 0, splicedBuffer, offset, count);
+            offset += count;
+            count = middle.Length;
+            Buffer.BlockCopy(middle, 0, splicedBuffer, offset, count);
+            offset += count;
+            count = wrapperLength - openCharIndex;
+            Buffer.BlockCopy(wrapper, openCharIndex, splicedBuffer, offset, count);
+
+            return splicedBuffer;
+        }
+
+        static void WriteNamespaceDeclarations(XmlAttributeHolder[] attributes, XmlWriter writer)
+        {
+            if (attributes != null)
+            {
+                for (int i = 0; i < attributes.Length; i++)
+                {
+                    XmlAttributeHolder a = attributes[i];
+                    if (IsNamespaceDeclaration(a.Prefix, a.LocalName))
+                    {
+                        a.WriteTo(writer);
+                    }
+                }
+            }
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityVersion.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityVersion.cs
index 736ca51..73a143c 100644
--- a/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityVersion.cs
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityVersion.cs
@@ -1,7 +1,10 @@
-﻿using System;
+﻿using CoreWCF.Channels;
+using CoreWCF.Description;
+using System;
 using System.Collections.Generic;
 using System.Text;
 using System.Xml;
+using ISignatureValueSecurityElement = CoreWCF.IdentityModel.ISignatureValueSecurityElement;
 
 namespace CoreWCF.Security
 {
@@ -29,6 +32,11 @@ namespace CoreWCF.Security
         {
             get;
         }
+        public static SecurityVersion WSSecurity10
+        {
+            get { return SecurityVersion10.Instance; }
+        }
+
 
         public static SecurityVersion WSSecurity11
         {
@@ -39,7 +47,75 @@ namespace CoreWCF.Security
         {
             get { return WSSecurity11; }
         }
+        internal abstract ReceiveSecurityHeader CreateReceiveSecurityHeader(Message message,
+            string actor, bool mustUnderstand, bool relay,
+            SecurityStandardsManager standardsManager,
+            SecurityAlgorithmSuite algorithmSuite,
+            MessageDirection direction,
+            int headerIndex);
+
+        internal abstract SendSecurityHeader CreateSendSecurityHeader(Message message,
+            string actor, bool mustUnderstand, bool relay,
+            SecurityStandardsManager standardsManager,
+            SecurityAlgorithmSuite algorithmSuite,
+            MessageDirection direction);
+
+        internal bool DoesMessageContainSecurityHeader(Message message)
+        {
+            return message.Headers.FindHeader(this.HeaderName.Value, this.HeaderNamespace.Value) >= 0;
+        }
+
+        internal int FindIndexOfSecurityHeader(Message message, string[] actors)
+        {
+            return message.Headers.FindHeader(this.HeaderName.Value, this.HeaderNamespace.Value, actors);
 
+        }
+
+        internal virtual bool IsReaderAtSignatureConfirmation(XmlDictionaryReader reader)
+        {
+            return false;
+        }
+
+        // The security always look for Empty soap role.  If not found, we will also look for Ultimate actors (next incl).
+        // In the future, till we support intermediary scenario, we should refactor this api to do not take actor parameter.
+        internal ReceiveSecurityHeader TryCreateReceiveSecurityHeader(Message message,
+            string actor,
+            SecurityStandardsManager standardsManager,
+            SecurityAlgorithmSuite algorithmSuite, MessageDirection direction)
+        {
+            int headerIndex = message.Headers.FindHeader(this.HeaderName.Value, this.HeaderNamespace.Value, actor);
+            if (headerIndex < 0 && String.IsNullOrEmpty(actor))
+            {
+                headerIndex = message.Headers.FindHeader(this.HeaderName.Value, this.HeaderNamespace.Value, message.Version.Envelope.UltimateDestinationActorValues);
+            }
+
+            if (headerIndex < 0)
+            {
+                return null;
+            }
+            MessageHeaderInfo headerInfo = message.Headers[headerIndex];
+            return CreateReceiveSecurityHeader(message,
+                headerInfo.Actor, headerInfo.MustUnderstand, headerInfo.Relay,
+                standardsManager, algorithmSuite,
+                direction, headerIndex);
+        }
+
+        internal virtual void WriteSignatureConfirmation(XmlDictionaryWriter writer, string id, byte[] signatureConfirmation)
+        {
+            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(
+                SR.Format(SR.SignatureConfirmationNotSupported)));
+        }
+
+        internal void WriteStartHeader(XmlDictionaryWriter writer)
+        {
+            writer.WriteStartElement(this.HeaderPrefix.Value, this.HeaderName, this.HeaderNamespace);
+        }
+
+        internal virtual ISignatureValueSecurityElement ReadSignatureConfirmation(XmlDictionaryReader reader)
+        {
+            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(
+                SR.Format(SR.SignatureConfirmationNotSupported)));
+        }
         class SecurityVersion10 : SecurityVersion
         {
             static readonly SecurityVersion10 instance = new SecurityVersion10();
@@ -54,6 +130,34 @@ namespace CoreWCF.Security
                 get { return instance; }
             }
 
+            internal override SendSecurityHeader CreateSendSecurityHeader(Message message,
+                string actor, bool mustUnderstand, bool relay,
+                SecurityStandardsManager standardsManager,
+                SecurityAlgorithmSuite algorithmSuite,
+                MessageDirection direction)
+            {
+                return new WSSecurityOneDotZeroSendSecurityHeader(message, actor, mustUnderstand, relay, standardsManager, algorithmSuite, direction);
+            }
+
+            internal override ReceiveSecurityHeader CreateReceiveSecurityHeader(Message message,
+                string actor, bool mustUnderstand, bool relay,
+                SecurityStandardsManager standardsManager,
+                SecurityAlgorithmSuite algorithmSuite,
+                MessageDirection direction,
+                int headerIndex)
+            {
+                return new WSSecurityOneDotZeroReceiveSecurityHeader(
+                    message,
+                    actor, mustUnderstand, relay,
+                    standardsManager,
+                    algorithmSuite, headerIndex, direction);
+            }
+
+            public override string ToString()
+            {
+                return "WSSecurity10";
+            }
+
             internal override XmlDictionaryString FailedAuthenticationFaultCode => XD.SecurityJan2004Dictionary.FailedAuthenticationFaultCode;
 
             internal override XmlDictionaryString InvalidSecurityFaultCode => XD.SecurityJan2004Dictionary.InvalidSecurityFaultCode;
@@ -63,7 +167,8 @@ namespace CoreWCF.Security
         {
             static readonly SecurityVersion11 instance = new SecurityVersion11();
 
-            SecurityVersion11() : base()
+            SecurityVersion11()
+                : base()
             {
             }
 
@@ -71,6 +176,76 @@ namespace CoreWCF.Security
             {
                 get { return instance; }
             }
+
+            internal  bool SupportsSignatureConfirmation
+            {
+                get { return true; }
+            }
+
+            internal override ReceiveSecurityHeader CreateReceiveSecurityHeader(Message message,
+                string actor, bool mustUnderstand, bool relay,
+                SecurityStandardsManager standardsManager,
+                SecurityAlgorithmSuite algorithmSuite,
+                MessageDirection direction,
+                int headerIndex)
+            {
+                return new WSSecurityOneDotOneReceiveSecurityHeader(
+                    message,
+                    actor, mustUnderstand, relay,
+                    standardsManager,
+                    algorithmSuite, headerIndex, direction);
+            }
+
+            internal override SendSecurityHeader CreateSendSecurityHeader(Message message,
+                string actor, bool mustUnderstand, bool relay,
+                SecurityStandardsManager standardsManager,
+                SecurityAlgorithmSuite algorithmSuite, MessageDirection direction)
+            {
+                return new WSSecurityOneDotOneSendSecurityHeader(message, actor, mustUnderstand, relay, standardsManager, algorithmSuite, direction);
+            }
+
+            internal override bool IsReaderAtSignatureConfirmation(XmlDictionaryReader reader)
+            {
+                return reader.IsStartElement(XD.SecurityXXX2005Dictionary.SignatureConfirmation, XD.SecurityXXX2005Dictionary.Namespace);
+            }
+
+            
+            internal override ISignatureValueSecurityElement ReadSignatureConfirmation(XmlDictionaryReader reader)
+            {
+                reader.MoveToStartElement(XD.SecurityXXX2005Dictionary.SignatureConfirmation, XD.SecurityXXX2005Dictionary.Namespace);
+                bool isEmptyElement = reader.IsEmptyElement;
+                string id = XmlHelper.GetRequiredNonEmptyAttribute(reader, XD.UtilityDictionary.IdAttribute, XD.UtilityDictionary.Namespace);
+                byte[] signatureValue = XmlHelper.GetRequiredBase64Attribute(reader, XD.SecurityXXX2005Dictionary.ValueAttribute, null);
+                reader.ReadStartElement();
+                if (!isEmptyElement)
+                {
+                    reader.ReadEndElement();
+                }
+                return new SignatureConfirmationElement(id, signatureValue, this);
+            }
+
+            internal override void WriteSignatureConfirmation(XmlDictionaryWriter writer, string id, byte[] signature)
+            {
+                if (id == null)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("id");
+                }
+                if (signature == null)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("signature");
+                }
+                writer.WriteStartElement(XD.SecurityXXX2005Dictionary.Prefix.Value, XD.SecurityXXX2005Dictionary.SignatureConfirmation, XD.SecurityXXX2005Dictionary.Namespace);
+                writer.WriteAttributeString(XD.UtilityDictionary.Prefix.Value, XD.UtilityDictionary.IdAttribute, XD.UtilityDictionary.Namespace, id);
+                writer.WriteStartAttribute(XD.SecurityXXX2005Dictionary.ValueAttribute, null);
+                writer.WriteBase64(signature, 0, signature.Length);
+                writer.WriteEndAttribute();
+                writer.WriteEndElement();
+            }
+
+            public override string ToString()
+            {
+                return "WSSecurity11";
+            }
         }
     }
 }
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/SendSecurityHeader.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/SendSecurityHeader.cs
new file mode 100644
index 0000000..23924ab
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/SendSecurityHeader.cs
@@ -0,0 +1,1080 @@
+using System.Collections.Generic;
+using CoreWCF.Channels;
+using CoreWCF;
+using CoreWCF.Description;
+using System.Collections.ObjectModel;
+using System.Diagnostics;
+using System.IO;
+using CoreWCF.IdentityModel.Tokens;
+using CoreWCF.IdentityModel.Selectors;
+using System.Security.Cryptography;
+using System;
+using CoreWCF.Security.Tokens;
+using System.Xml;
+using CoreWCF.Diagnostics;
+
+using DictionaryManager = CoreWCF.IdentityModel.DictionaryManager;
+using ISecurityElement = CoreWCF.IdentityModel.ISecurityElement;
+using ISignatureValueSecurityElement = CoreWCF.IdentityModel.ISignatureValueSecurityElement;
+using IPrefixGenerator = CoreWCF.IdentityModel.IPrefixGenerator;
+using CoreWCF.IdentityModel;
+
+namespace CoreWCF.Security
+{
+   abstract class SendSecurityHeader : SecurityHeader, IMessageHeaderWithSharedNamespace
+    {
+        bool basicTokenEncrypted;
+        SendSecurityHeaderElementContainer elementContainer;
+        bool primarySignatureDone;
+        bool encryptSignature;
+        SignatureConfirmations signatureValuesGenerated;
+        SignatureConfirmations signatureConfirmationsToSend;
+        int idCounter;
+        string idPrefix;
+        bool hasSignedTokens;
+        bool hasEncryptedTokens;
+        MessagePartSpecification signatureParts;
+        MessagePartSpecification encryptionParts;  
+        SecurityTokenParameters signingTokenParameters;
+        SecurityTokenParameters encryptingTokenParameters;
+        List<SecurityToken> basicTokens = null;
+        List<SecurityTokenParameters> basicSupportingTokenParameters = null;
+        List<SecurityTokenParameters> endorsingTokenParameters = null;
+        List<SecurityTokenParameters> signedEndorsingTokenParameters = null;
+        List<SecurityTokenParameters> signedTokenParameters = null;
+        SecurityToken encryptingToken;
+        bool skipKeyInfoForEncryption;
+        byte[] primarySignatureValue = null;
+        bool shouldProtectTokens;
+        BufferManager bufferManager;
+
+        bool shouldSignToHeader = false;
+
+        SecurityProtocolCorrelationState correlationState;
+        bool signThenEncrypt = true;
+        static readonly string[] ids = new string[] { "_0", "_1", "_2", "_3", "_4", "_5", "_6", "_7", "_8", "_9" };
+
+        protected SendSecurityHeader(Message message, string actor, bool mustUnderstand, bool relay,
+            SecurityStandardsManager standardsManager,
+            SecurityAlgorithmSuite algorithmSuite, 
+            MessageDirection transferDirection)
+            : base(message, actor, mustUnderstand, relay, standardsManager, algorithmSuite, transferDirection)
+        {
+            this.elementContainer = new SendSecurityHeaderElementContainer();
+        }
+
+        public SendSecurityHeaderElementContainer ElementContainer
+        {
+            get { return this.elementContainer; }
+        }
+
+        public SecurityProtocolCorrelationState CorrelationState
+        {
+            get { return this.correlationState; }
+            set
+            {
+                ThrowIfProcessingStarted();
+                this.correlationState = value;
+            }
+        }
+
+        public BufferManager StreamBufferManager
+        {
+            get
+            {
+                if (this.bufferManager == null)
+                {
+                    this.bufferManager = BufferManager.CreateBufferManager(0, int.MaxValue);
+                }
+
+                return this.bufferManager;
+            }
+            set
+            {
+                this.bufferManager = value;
+            }
+        }
+
+        public MessagePartSpecification EncryptionParts
+        {
+            get { return this.encryptionParts; }
+            set
+            {
+                ThrowIfProcessingStarted();
+                if (value == null)
+                {
+                    throw TraceUtility.ThrowHelperError(new ArgumentNullException("value"), this.Message);
+                }
+                if (!value.IsReadOnly)
+                {
+                    throw TraceUtility.ThrowHelperError(new InvalidOperationException(
+                        SR.Format(SR.MessagePartSpecificationMustBeImmutable)), this.Message);
+                }
+                this.encryptionParts = value;
+            }
+        }
+
+        public bool EncryptPrimarySignature
+        {
+            get { return this.encryptSignature; }
+            set
+            {
+                ThrowIfProcessingStarted();
+                this.encryptSignature = value;
+            }
+        }
+
+        internal byte[] PrimarySignatureValue
+        {
+            get { return this.primarySignatureValue; }
+        }
+
+        protected internal SecurityTokenParameters SigningTokenParameters
+        {
+            get { return this.signingTokenParameters; }
+        }
+
+        protected bool ShouldSignToHeader
+        {
+            get { return this.shouldSignToHeader; }
+        }
+
+        public string IdPrefix
+        {
+            get { return this.idPrefix; }
+            set
+            {
+                ThrowIfProcessingStarted();
+                this.idPrefix = string.IsNullOrEmpty(value) || value == "_" ? null : value;
+            }
+        }
+
+        public override string Name
+        {
+            get { return this.StandardsManager.SecurityVersion.HeaderName.Value; }
+        }
+
+        public override string Namespace
+        {
+            get { return this.StandardsManager.SecurityVersion.HeaderNamespace.Value; }
+        }
+
+        protected SecurityAppliedMessage SecurityAppliedMessage
+        {
+            get { return (SecurityAppliedMessage) this.Message; }
+        }
+
+        public bool SignThenEncrypt
+        {
+            get { return this.signThenEncrypt; }
+            set
+            {
+                ThrowIfProcessingStarted();
+                this.signThenEncrypt = value;
+            }
+        }
+
+        public bool ShouldProtectTokens
+        {
+            get { return this.shouldProtectTokens; }
+            set
+            {
+                ThrowIfProcessingStarted();
+                this.shouldProtectTokens = value;
+            }
+        }
+
+        public MessagePartSpecification SignatureParts
+        {
+            get { return this.signatureParts; }
+            set
+            {
+                ThrowIfProcessingStarted();
+                if (value == null)
+                {
+                    throw TraceUtility.ThrowHelperError(new ArgumentNullException("value"), this.Message);
+                }
+                if (!value.IsReadOnly)
+                {
+                    throw TraceUtility.ThrowHelperError(new InvalidOperationException(
+                        SR.Format(SR.MessagePartSpecificationMustBeImmutable)), this.Message);
+                }
+                this.signatureParts = value;
+            }
+        }
+
+        public SecurityTimestamp Timestamp
+        {
+            get { return this.elementContainer.Timestamp; }
+        }
+
+        public bool HasSignedTokens
+        {
+            get
+            {
+                return this.hasSignedTokens;
+            }
+        }
+
+        public bool HasEncryptedTokens
+        {
+            get
+            {
+                return this.hasEncryptedTokens;
+            }
+        }
+
+        public void AddPrerequisiteToken(SecurityToken token)
+        {
+            ThrowIfProcessingStarted();
+            if (token == null)
+            {
+                throw TraceUtility.ThrowHelperError(new Exception("token"), this.Message);
+            }
+            this.elementContainer.PrerequisiteToken = token;
+        }
+
+        void AddParameters(ref List<SecurityTokenParameters> list, SecurityTokenParameters item)
+        {
+            if (list == null)
+            {
+                list = new List<SecurityTokenParameters>();
+            }
+            list.Add(item);
+        }
+
+        public abstract void ApplyBodySecurity(XmlDictionaryWriter writer, IPrefixGenerator prefixGenerator);
+
+        public abstract void ApplySecurityAndWriteHeaders(MessageHeaders headers, XmlDictionaryWriter writer, IPrefixGenerator prefixGenerator);
+
+        protected virtual bool HasSignedEncryptedMessagePart
+        {
+            get { return false; }
+        }
+
+        public void SetSigningToken(SecurityToken token, SecurityTokenParameters tokenParameters)
+        {
+            ThrowIfProcessingStarted();
+            if ((token == null && tokenParameters != null) || (token != null && tokenParameters == null))
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.TokenMustBeNullWhenTokenParametersAre)));
+            }
+            this.elementContainer.SourceSigningToken = token;
+            this.signingTokenParameters = tokenParameters;
+        }
+
+        public void SetEncryptionToken(SecurityToken token, SecurityTokenParameters tokenParameters)
+        {
+            ThrowIfProcessingStarted();
+            if ((token == null && tokenParameters != null) || (token != null && tokenParameters == null))
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.TokenMustBeNullWhenTokenParametersAre)));
+            }
+            this.elementContainer.SourceEncryptionToken = token;
+            this.encryptingTokenParameters = tokenParameters;
+        }
+
+
+        public void AddBasicSupportingToken(SecurityToken token, SecurityTokenParameters parameters)
+        {
+            if (token == null)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("token");
+            if (parameters == null)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("parameters");
+            ThrowIfProcessingStarted();
+            SendSecurityHeaderElement tokenElement = new SendSecurityHeaderElement(token.Id, new TokenElement(token, this.StandardsManager));
+            tokenElement.MarkedForEncryption = true;
+            this.elementContainer.AddBasicSupportingToken(tokenElement);
+            hasEncryptedTokens = true;
+            hasSignedTokens = true;
+            this.AddParameters(ref this.basicSupportingTokenParameters, parameters);
+            if (this.basicTokens == null)
+            {
+                this.basicTokens = new List<SecurityToken>();
+            }
+
+            //  We maintain a list of the basic tokens for the SignThenEncrypt case as we will 
+            //  need this token to write STR entry on OnWriteHeaderContents. 
+            this.basicTokens.Add(token);
+
+        }
+
+        public void AddEndorsingSupportingToken(SecurityToken token, SecurityTokenParameters parameters)
+        {
+            if (token == null)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("token");
+            if (parameters == null)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("parameters");
+            ThrowIfProcessingStarted();
+            this.elementContainer.AddEndorsingSupportingToken(token);
+            // The ProviderBackedSecurityToken was added for the ChannelBindingToken (CBT) effort for win7.  
+            // We can assume the key is of type symmetric key.
+            //
+            // Asking for the key type from the token will cause the ProviderBackedSecurityToken 
+            // to attempt to resolve the token and the nego will start.  
+            //
+            // We don't want that.  
+            // We want to defer the nego until after the CBT is available in SecurityAppliedMessage.OnWriteMessage.
+            //TODO 
+            //if (!(token is ProviderBackedSecurityToken))
+            //{
+            //    this.shouldSignToHeader |= (!this.RequireMessageProtection) && (SecurityUtils.GetSecurityKey<AsymmetricSecurityKey>(token) != null);
+            //}
+            this.AddParameters(ref this.endorsingTokenParameters, parameters);
+        }
+
+        public void AddSignedEndorsingSupportingToken(SecurityToken token, SecurityTokenParameters parameters)
+        {
+            if (token == null)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("token");
+            if (parameters == null)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("parameters");
+            ThrowIfProcessingStarted();
+            this.elementContainer.AddSignedEndorsingSupportingToken(token);
+            hasSignedTokens = true;
+            this.shouldSignToHeader |= (!this.RequireMessageProtection) && (SecurityUtils.GetSecurityKey<AsymmetricSecurityKey>(token) != null);            
+            this.AddParameters(ref this.signedEndorsingTokenParameters, parameters);
+        }
+
+        public void AddSignedSupportingToken(SecurityToken token, SecurityTokenParameters parameters)
+        {
+            if (token == null)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("token");
+            if (parameters == null)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("parameters");
+            ThrowIfProcessingStarted();
+            this.elementContainer.AddSignedSupportingToken(token);
+            hasSignedTokens = true;
+            this.AddParameters(ref this.signedTokenParameters, parameters);
+        }
+
+        public void AddSignatureConfirmations(SignatureConfirmations confirmations)
+        {
+            ThrowIfProcessingStarted();
+            this.signatureConfirmationsToSend = confirmations;
+        }
+
+        public void AddTimestamp(TimeSpan timestampValidityDuration)
+        {
+            DateTime now = DateTime.UtcNow;
+            string id = this.RequireMessageProtection ? SecurityUtils.GenerateId() : GenerateId();
+            AddTimestamp(new SecurityTimestamp(now, now + timestampValidityDuration, id));
+        }
+
+        public void AddTimestamp(SecurityTimestamp timestamp)
+        {
+            ThrowIfProcessingStarted();
+            if (this.elementContainer.Timestamp != null)
+            {
+                throw TraceUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.TimestampAlreadySetForSecurityHeader)), this.Message);
+            }
+            if (timestamp == null)
+            {
+                throw TraceUtility.ThrowHelperArgumentNull("timestamp", this.Message);
+            }
+
+            this.elementContainer.Timestamp = timestamp;
+        }
+
+        protected virtual ISignatureValueSecurityElement[] CreateSignatureConfirmationElements(SignatureConfirmations signatureConfirmations)
+        {
+            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(
+                SR.Format(SR.SignatureConfirmationNotSupported)));
+        }
+
+        void StartEncryption()
+        {
+            if (this.elementContainer.SourceEncryptionToken == null)
+            {
+                return;
+            }
+            // determine the key identifier clause to use for the source
+            SecurityTokenReferenceStyle sourceEncryptingKeyReferenceStyle = GetTokenReferenceStyle(this.encryptingTokenParameters);
+            bool encryptionTokenSerialized = sourceEncryptingKeyReferenceStyle == SecurityTokenReferenceStyle.Internal;
+            SecurityKeyIdentifierClause sourceEncryptingKeyIdentifierClause = this.encryptingTokenParameters.CreateKeyIdentifierClause(this.elementContainer.SourceEncryptionToken, sourceEncryptingKeyReferenceStyle);
+            if (sourceEncryptingKeyIdentifierClause == null)
+            {
+                throw TraceUtility.ThrowHelperError(new MessageSecurityException(SR.Format(SR.TokenManagerCannotCreateTokenReference)), this.Message);
+            }
+            SecurityToken sourceToken;
+            SecurityKeyIdentifierClause sourceTokenIdentifierClause;
+
+            // if the source token cannot do symmetric crypto, create a wrapped key
+            if (!SecurityUtils.HasSymmetricSecurityKey(elementContainer.SourceEncryptionToken))
+            {
+                int keyLength = Math.Max(128, this.AlgorithmSuite.DefaultSymmetricKeyLength);
+                CryptoHelper.ValidateSymmetricKeyLength(keyLength, this.AlgorithmSuite);
+                byte[] key = new byte[keyLength / 8];
+                CryptoHelper.FillRandomBytes(key);
+                string keyWrapAlgorithm;
+                XmlDictionaryString keyWrapAlgorithmDictionaryString;
+                this.AlgorithmSuite.GetKeyWrapAlgorithm(elementContainer.SourceEncryptionToken, out keyWrapAlgorithm, out keyWrapAlgorithmDictionaryString);
+                WrappedKeySecurityToken wrappedKey = new WrappedKeySecurityToken(GenerateId(), key, keyWrapAlgorithm, keyWrapAlgorithmDictionaryString,
+                    elementContainer.SourceEncryptionToken, new SecurityKeyIdentifier(sourceEncryptingKeyIdentifierClause));
+                elementContainer.WrappedEncryptionToken = wrappedKey;
+                sourceToken = wrappedKey;
+                sourceTokenIdentifierClause = new LocalIdKeyIdentifierClause(wrappedKey.Id, wrappedKey.GetType());
+                encryptionTokenSerialized = true;
+            }
+            else
+            {
+                sourceToken = elementContainer.SourceEncryptionToken;
+                sourceTokenIdentifierClause = sourceEncryptingKeyIdentifierClause;
+            }
+
+            // determine if a key needs to be derived
+            SecurityKeyIdentifierClause encryptingKeyIdentifierClause;
+            // determine if a token needs to be derived
+            if (this.encryptingTokenParameters.RequireDerivedKeys)
+            {
+                string derivationAlgorithm = this.AlgorithmSuite.GetEncryptionKeyDerivationAlgorithm(sourceToken, this.StandardsManager.MessageSecurityVersion.SecureConversationVersion);
+                string expectedDerivationAlgorithm = SecurityUtils.GetKeyDerivationAlgorithm(this.StandardsManager.MessageSecurityVersion.SecureConversationVersion);
+                if (derivationAlgorithm == expectedDerivationAlgorithm)
+                {
+                    DerivedKeySecurityToken derivedEncryptingToken = new DerivedKeySecurityToken(-1, 0,
+                        this.AlgorithmSuite.GetEncryptionKeyDerivationLength(sourceToken, this.StandardsManager.MessageSecurityVersion.SecureConversationVersion), null, DerivedKeySecurityToken.DefaultNonceLength, sourceToken, sourceTokenIdentifierClause, derivationAlgorithm, GenerateId());
+                    this.encryptingToken = this.elementContainer.DerivedEncryptionToken = derivedEncryptingToken;
+                    encryptingKeyIdentifierClause = new LocalIdKeyIdentifierClause(derivedEncryptingToken.Id, derivedEncryptingToken.GetType());
+                }
+                else
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new NotSupportedException(SR.Format(SR.UnsupportedCryptoAlgorithm, derivationAlgorithm)));
+                }
+            }
+            else
+            {
+                this.encryptingToken = sourceToken;
+                encryptingKeyIdentifierClause = sourceTokenIdentifierClause;
+            }
+
+            this.skipKeyInfoForEncryption = encryptionTokenSerialized && this.EncryptedKeyContainsReferenceList && (this.encryptingToken is WrappedKeySecurityToken) && this.signThenEncrypt;
+            SecurityKeyIdentifier identifier;
+            if (this.skipKeyInfoForEncryption)
+            {
+                identifier = null;
+            }
+            else
+            {
+                identifier = new SecurityKeyIdentifier(encryptingKeyIdentifierClause);
+            }
+
+            StartEncryptionCore(this.encryptingToken, identifier);
+        }
+
+        void CompleteEncryption()
+        {
+            ISecurityElement referenceList = CompleteEncryptionCore(
+                elementContainer.PrimarySignature,
+                elementContainer.GetBasicSupportingTokens(),
+                elementContainer.GetSignatureConfirmations(),
+                elementContainer.GetEndorsingSignatures());
+
+            if (referenceList == null)
+            {
+                // null out all the encryption fields since there is no encryption needed
+                this.elementContainer.SourceEncryptionToken = null;
+                this.elementContainer.WrappedEncryptionToken = null;
+                this.elementContainer.DerivedEncryptionToken = null;
+                return;
+            }
+
+            if (this.skipKeyInfoForEncryption)
+            {
+                WrappedKeySecurityToken wrappedKeyToken = this.encryptingToken as WrappedKeySecurityToken;
+                wrappedKeyToken.EnsureEncryptedKeySetUp();
+                wrappedKeyToken.EncryptedKey.ReferenceList = (ReferenceList) referenceList;
+            }
+            else
+            {
+                this.elementContainer.ReferenceList = referenceList;
+            }
+            basicTokenEncrypted = true;
+        }
+
+        internal void StartSecurityApplication()
+        {
+            if (this.SignThenEncrypt)
+            {
+                StartSignature();
+                StartEncryption();
+            }
+            else
+            {
+                StartEncryption();
+                StartSignature();
+            }
+        }
+
+        internal void CompleteSecurityApplication()
+        {
+            if (this.SignThenEncrypt)
+            {
+                CompleteSignature();
+                SignWithSupportingTokens();
+                CompleteEncryption();
+            }
+            else
+            {
+                CompleteEncryption();
+                CompleteSignature();
+                SignWithSupportingTokens();
+            }
+
+            if (this.correlationState != null)
+            {
+                this.correlationState.SignatureConfirmations = GetSignatureValues();
+            }
+        }
+
+        public void RemoveSignatureEncryptionIfAppropriate()
+        {
+            if (this.SignThenEncrypt && 
+                this.EncryptPrimarySignature && 
+                (this.SecurityAppliedMessage.BodyProtectionMode != MessagePartProtectionMode.SignThenEncrypt) &&
+                (this.basicSupportingTokenParameters == null || this.basicSupportingTokenParameters.Count == 0) &&
+                (this.signatureConfirmationsToSend == null || this.signatureConfirmationsToSend.Count == 0 || !this.signatureConfirmationsToSend.IsMarkedForEncryption) &&
+                !this.HasSignedEncryptedMessagePart)
+            {
+                this.encryptSignature = false;
+            }
+        }
+
+        public string GenerateId()
+        {
+            int id = this.idCounter++;
+
+            if (this.idPrefix != null)
+            {
+                return this.idPrefix + id;
+            }
+
+            if (id < ids.Length)
+            {
+                return ids[id];
+            }
+            else
+            {
+                return "_" + id;
+            }
+        }
+
+        SignatureConfirmations GetSignatureValues()
+        {
+            return this.signatureValuesGenerated;
+        }
+
+        protected override void OnWriteStartHeader(XmlDictionaryWriter writer, MessageVersion messageVersion)
+        {
+            this.StandardsManager.SecurityVersion.WriteStartHeader(writer);
+            WriteHeaderAttributes(writer, messageVersion);
+        }
+
+        internal static bool ShouldSerializeToken(SecurityTokenParameters parameters, MessageDirection transferDirection)
+        {
+            switch (parameters.InclusionMode)
+            {
+                case SecurityTokenInclusionMode.AlwaysToInitiator:
+                    return (transferDirection == MessageDirection.Output);
+                case SecurityTokenInclusionMode.Once:
+                case SecurityTokenInclusionMode.AlwaysToRecipient:
+                    return (transferDirection == MessageDirection.Input);
+                case SecurityTokenInclusionMode.Never:
+                    return false;
+                default:
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new NotSupportedException(SR.Format(SR.UnsupportedTokenInclusionMode, parameters.InclusionMode)));
+            }
+        }
+
+        protected override void OnWriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion)
+        {
+            if (this.basicSupportingTokenParameters != null && this.basicSupportingTokenParameters.Count > 0 
+                && this.RequireMessageProtection && !basicTokenEncrypted)
+            {
+                throw TraceUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.BasicTokenCannotBeWrittenWithoutEncryption)), this.Message);
+            }
+
+            if (this.elementContainer.Timestamp != null && this.Layout != SecurityHeaderLayout.LaxTimestampLast)
+            {
+                this.StandardsManager.WSUtilitySpecificationVersion.WriteTimestamp(writer, this.elementContainer.Timestamp);
+            }
+            if (elementContainer.PrerequisiteToken != null)
+            {
+                this.StandardsManager.SecurityTokenSerializer.WriteToken(writer, elementContainer.PrerequisiteToken);
+            }
+            if (elementContainer.SourceSigningToken != null)
+            {
+                if (ShouldSerializeToken(this.signingTokenParameters, this.MessageDirection))
+                {
+                    this.StandardsManager.SecurityTokenSerializer.WriteToken(writer, elementContainer.SourceSigningToken);
+
+                    // Implement Protect token 
+                    // NOTE: The spec says sign the primary token if it is not included in the message. But we currently are not supporting it
+                    // as we do not support STR-Transform for external references. Hence we can not sign the token which is external ie not in the message.
+                    // This only affects the messages from service to client where 
+                    // 1. allowSerializedSigningTokenOnReply is false.
+                    // 2. SymmetricSecurityBindingElement with IssuedTokens binding where the issued token has a symmetric key.
+
+                    if (this.ShouldProtectTokens)
+                    {
+                        this.WriteSecurityTokenReferencyEntry(writer, elementContainer.SourceSigningToken, this.signingTokenParameters);
+                    }
+                }
+            }
+            if (elementContainer.DerivedSigningToken != null)
+            {
+                this.StandardsManager.SecurityTokenSerializer.WriteToken(writer, elementContainer.DerivedSigningToken);
+            }
+            if (elementContainer.SourceEncryptionToken != null && elementContainer.SourceEncryptionToken != elementContainer.SourceSigningToken && ShouldSerializeToken(encryptingTokenParameters, this.MessageDirection))
+            {
+                this.StandardsManager.SecurityTokenSerializer.WriteToken(writer, elementContainer.SourceEncryptionToken);
+            }
+            if (elementContainer.WrappedEncryptionToken != null)
+            {
+                this.StandardsManager.SecurityTokenSerializer.WriteToken(writer, elementContainer.WrappedEncryptionToken);
+            }
+            if (elementContainer.DerivedEncryptionToken != null)
+            {
+                this.StandardsManager.SecurityTokenSerializer.WriteToken(writer, elementContainer.DerivedEncryptionToken); 
+            }
+            if (this.SignThenEncrypt)
+            {
+                if (elementContainer.ReferenceList != null)
+                {
+                    elementContainer.ReferenceList.WriteTo(writer, ServiceModelDictionaryManager.Instance);
+                }
+            }
+          
+            SecurityToken[] signedTokens = elementContainer.GetSignedSupportingTokens();
+            if (signedTokens != null)
+            {
+                for (int i = 0; i < signedTokens.Length; ++i)
+                {
+                    this.StandardsManager.SecurityTokenSerializer.WriteToken(writer, signedTokens[i]);
+                    this.WriteSecurityTokenReferencyEntry(writer, signedTokens[i], this.signedTokenParameters[i]);
+                }
+            }
+            SendSecurityHeaderElement[] basicTokensXml = elementContainer.GetBasicSupportingTokens();
+            if (basicTokensXml != null)
+            {
+                for (int i = 0; i < basicTokensXml.Length; ++i)
+                {
+                    basicTokensXml[i].Item.WriteTo(writer, ServiceModelDictionaryManager.Instance);
+                    if (this.SignThenEncrypt)
+                    {
+                        this.WriteSecurityTokenReferencyEntry(writer, this.basicTokens[i], this.basicSupportingTokenParameters[i]);
+                    }
+                }
+            }
+            SecurityToken[] endorsingTokens = elementContainer.GetEndorsingSupportingTokens();
+            if (endorsingTokens != null)
+            {
+                for (int i = 0; i < endorsingTokens.Length; ++i)
+                {
+                    if (ShouldSerializeToken(endorsingTokenParameters[i], this.MessageDirection))
+                    {
+                        this.StandardsManager.SecurityTokenSerializer.WriteToken(writer, endorsingTokens[i]);
+                    }
+                }
+            }
+            SecurityToken[] endorsingDerivedTokens = elementContainer.GetEndorsingDerivedSupportingTokens();
+            if (endorsingDerivedTokens != null)
+            {
+                for (int i = 0; i < endorsingDerivedTokens.Length; ++i)
+                {
+                    this.StandardsManager.SecurityTokenSerializer.WriteToken(writer, endorsingDerivedTokens[i]);
+                }
+            }
+            SecurityToken[] signedEndorsingTokens = elementContainer.GetSignedEndorsingSupportingTokens();
+            if (signedEndorsingTokens != null)
+            {
+                for (int i = 0; i < signedEndorsingTokens.Length; ++i)
+                {
+                    this.StandardsManager.SecurityTokenSerializer.WriteToken(writer, signedEndorsingTokens[i]);
+                    this.WriteSecurityTokenReferencyEntry(writer, signedEndorsingTokens[i], this.signedEndorsingTokenParameters[i]);
+                }
+            }
+            SecurityToken[] signedEndorsingDerivedTokens = elementContainer.GetSignedEndorsingDerivedSupportingTokens();
+            if (signedEndorsingDerivedTokens != null)
+            {
+                for (int i = 0; i < signedEndorsingDerivedTokens.Length; ++i)
+                {
+                    this.StandardsManager.SecurityTokenSerializer.WriteToken(writer, signedEndorsingDerivedTokens[i]);
+                }
+            }
+            SendSecurityHeaderElement[] signatureConfirmations = elementContainer.GetSignatureConfirmations();
+            if (signatureConfirmations != null)
+            {
+                for (int i = 0; i < signatureConfirmations.Length; ++i)
+                {
+                    signatureConfirmations[i].Item.WriteTo(writer, ServiceModelDictionaryManager.Instance);
+                }
+            }
+            if (elementContainer.PrimarySignature != null && elementContainer.PrimarySignature.Item != null)
+            {
+                elementContainer.PrimarySignature.Item.WriteTo(writer, ServiceModelDictionaryManager.Instance);
+            }
+            SendSecurityHeaderElement[] endorsingSignatures = elementContainer.GetEndorsingSignatures();
+            if (endorsingSignatures != null)
+            {
+                for (int i = 0; i < endorsingSignatures.Length; ++i)
+                {
+                    endorsingSignatures[i].Item.WriteTo(writer, ServiceModelDictionaryManager.Instance);
+                }
+            }
+            if (!this.SignThenEncrypt)
+            {
+                if (elementContainer.ReferenceList != null)
+                {
+                    elementContainer.ReferenceList.WriteTo(writer, ServiceModelDictionaryManager.Instance);
+                }
+            }
+            if (this.elementContainer.Timestamp != null && this.Layout == SecurityHeaderLayout.LaxTimestampLast)
+            {
+                this.StandardsManager.WSUtilitySpecificationVersion.WriteTimestamp(writer, this.elementContainer.Timestamp);
+            }
+        }
+
+        protected abstract void WriteSecurityTokenReferencyEntry(XmlDictionaryWriter writer, SecurityToken securityToken, SecurityTokenParameters securityTokenParameters);
+
+        public Message SetupExecution()
+        {
+            ThrowIfProcessingStarted();
+            SetProcessingStarted();
+
+            bool signBody = false;
+            if (this.elementContainer.SourceSigningToken != null)
+            {
+                if (this.signatureParts == null)
+                {
+                    throw TraceUtility.ThrowHelperError(new ArgumentNullException("SignatureParts"), this.Message);
+                }
+                signBody = this.signatureParts.IsBodyIncluded;
+            }
+
+            bool encryptBody = false;
+            if (this.elementContainer.SourceEncryptionToken != null)
+            {
+                if (this.encryptionParts == null)
+                {
+                    throw TraceUtility.ThrowHelperError(new ArgumentNullException("EncryptionParts"), this.Message);
+                }
+                encryptBody = this.encryptionParts.IsBodyIncluded;
+            }
+
+            SecurityAppliedMessage message = new SecurityAppliedMessage(this.Message, this, signBody, encryptBody);
+            this.Message = message;
+            return message;
+        }
+
+        protected internal SecurityTokenReferenceStyle GetTokenReferenceStyle(SecurityTokenParameters parameters)
+        {
+            return (ShouldSerializeToken(parameters, this.MessageDirection)) ? SecurityTokenReferenceStyle.Internal : SecurityTokenReferenceStyle.External;
+        }
+
+        void StartSignature()
+        {
+            if (this.elementContainer.SourceSigningToken == null)
+            {
+                return;
+            }
+
+            // determine the key identifier clause to use for the source
+            SecurityTokenReferenceStyle sourceSigningKeyReferenceStyle = GetTokenReferenceStyle(this.signingTokenParameters);
+            SecurityKeyIdentifierClause sourceSigningKeyIdentifierClause = this.signingTokenParameters.CreateKeyIdentifierClause(this.elementContainer.SourceSigningToken, sourceSigningKeyReferenceStyle);
+            if (sourceSigningKeyIdentifierClause == null)
+            {
+                throw TraceUtility.ThrowHelperError(new MessageSecurityException(SR.Format(SR.TokenManagerCannotCreateTokenReference)), this.Message);
+            }
+
+            SecurityToken signingToken;
+            SecurityKeyIdentifierClause signingKeyIdentifierClause;
+
+            // determine if a token needs to be derived
+            if (this.signingTokenParameters.RequireDerivedKeys && !this.signingTokenParameters.HasAsymmetricKey)
+            {
+                string derivationAlgorithm = this.AlgorithmSuite.GetSignatureKeyDerivationAlgorithm(this.elementContainer.SourceSigningToken, this.StandardsManager.MessageSecurityVersion.SecureConversationVersion);
+                string expectedDerivationAlgorithm = SecurityUtils.GetKeyDerivationAlgorithm(this.StandardsManager.MessageSecurityVersion.SecureConversationVersion);
+                if (derivationAlgorithm == expectedDerivationAlgorithm)
+                {
+                    DerivedKeySecurityToken derivedSigningToken = new DerivedKeySecurityToken(-1, 0, this.AlgorithmSuite.GetSignatureKeyDerivationLength(this.elementContainer.SourceSigningToken, this.StandardsManager.MessageSecurityVersion.SecureConversationVersion), null, DerivedKeySecurityToken.DefaultNonceLength, this.elementContainer.SourceSigningToken,
+                        sourceSigningKeyIdentifierClause, derivationAlgorithm, GenerateId());
+                    signingToken = this.elementContainer.DerivedSigningToken = derivedSigningToken;
+                    signingKeyIdentifierClause = new LocalIdKeyIdentifierClause(signingToken.Id, signingToken.GetType());
+                }
+                else
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new NotSupportedException(SR.Format(SR.UnsupportedCryptoAlgorithm, derivationAlgorithm)));
+                }
+            }
+            else
+            {
+                signingToken = elementContainer.SourceSigningToken;
+                signingKeyIdentifierClause = sourceSigningKeyIdentifierClause;
+            }
+
+            SecurityKeyIdentifier signingKeyIdentifier = new SecurityKeyIdentifier(signingKeyIdentifierClause);
+            
+            if (signatureConfirmationsToSend != null && signatureConfirmationsToSend.Count > 0)
+            {
+                ISecurityElement[] signatureConfirmationElements;
+                signatureConfirmationElements = CreateSignatureConfirmationElements(signatureConfirmationsToSend);
+                for (int i = 0; i < signatureConfirmationElements.Length; ++i)
+                {
+                    SendSecurityHeaderElement sigConfElement = new SendSecurityHeaderElement(signatureConfirmationElements[i].Id, signatureConfirmationElements[i]);
+                    sigConfElement.MarkedForEncryption = signatureConfirmationsToSend.IsMarkedForEncryption;
+                    this.elementContainer.AddSignatureConfirmation(sigConfElement);
+                }
+            }
+
+            bool generateTargettablePrimarySignature = ((this.endorsingTokenParameters != null) || (this.signedEndorsingTokenParameters != null));
+            this.StartPrimarySignatureCore(signingToken, signingKeyIdentifier, this.signatureParts, generateTargettablePrimarySignature);
+        }
+
+        void CompleteSignature()
+        {
+            ISignatureValueSecurityElement signedXml = this.CompletePrimarySignatureCore(
+                elementContainer.GetSignatureConfirmations(), elementContainer.GetSignedEndorsingSupportingTokens(), 
+                elementContainer.GetSignedSupportingTokens(), elementContainer.GetBasicSupportingTokens(), true);
+            if (signedXml == null)
+            {
+                return;
+            }
+            this.elementContainer.PrimarySignature = new SendSecurityHeaderElement(signedXml.Id, signedXml);
+            this.elementContainer.PrimarySignature.MarkedForEncryption = this.encryptSignature;
+            AddGeneratedSignatureValue(signedXml.GetSignatureValue(), this.EncryptPrimarySignature);
+            this.primarySignatureDone = true;
+            this.primarySignatureValue = signedXml.GetSignatureValue();
+        }
+
+        protected abstract void StartPrimarySignatureCore(SecurityToken token, SecurityKeyIdentifier identifier, MessagePartSpecification signatureParts, bool generateTargettablePrimarySignature);
+
+        protected abstract ISignatureValueSecurityElement CompletePrimarySignatureCore(SendSecurityHeaderElement[] signatureConfirmations,
+           SecurityToken[] signedEndorsingTokens, SecurityToken[] signedTokens, SendSecurityHeaderElement[] basicTokens, bool isPrimarySignature);
+
+
+        protected abstract ISignatureValueSecurityElement CreateSupportingSignature(SecurityToken token, SecurityKeyIdentifier identifier);
+
+        protected abstract ISignatureValueSecurityElement CreateSupportingSignature(SecurityToken token, SecurityKeyIdentifier identifier, ISecurityElement primarySignature);
+
+        protected abstract void StartEncryptionCore(SecurityToken token, SecurityKeyIdentifier keyIdentifier);
+
+        protected abstract ISecurityElement CompleteEncryptionCore(SendSecurityHeaderElement primarySignature, 
+            SendSecurityHeaderElement[] basicTokens, SendSecurityHeaderElement[] signatureConfirmations, SendSecurityHeaderElement[] endorsingSignatures);
+
+        void SignWithSupportingToken(SecurityToken token, SecurityKeyIdentifierClause identifierClause)
+        {
+            if (token == null)
+            {
+                throw TraceUtility.ThrowHelperArgumentNull("token", this.Message);
+            }
+            if (identifierClause == null)
+            {
+                throw TraceUtility.ThrowHelperError(new MessageSecurityException(SR.Format(SR.TokenManagerCannotCreateTokenReference)), this.Message);
+            }
+            if (!this.RequireMessageProtection)
+            {
+                if (this.elementContainer.Timestamp == null)
+                {
+                    throw TraceUtility.ThrowHelperError(new InvalidOperationException(
+                        SR.Format(SR.SigningWithoutPrimarySignatureRequiresTimestamp)), this.Message);
+                }
+            }
+            else
+            {
+                if (!this.primarySignatureDone)
+                {
+                    throw TraceUtility.ThrowHelperError(new InvalidOperationException(
+                        SR.Format(SR.PrimarySignatureMustBeComputedBeforeSupportingTokenSignatures)), this.Message);
+                }
+                if (this.elementContainer.PrimarySignature.Item == null)
+                {
+                    throw TraceUtility.ThrowHelperError(new InvalidOperationException(
+                        SR.Format(SR.SupportingTokenSignaturesNotExpected)), this.Message);
+                }
+            }
+
+            SecurityKeyIdentifier identifier = new SecurityKeyIdentifier(identifierClause);
+            ISignatureValueSecurityElement supportingSignature;
+            if (!this.RequireMessageProtection)
+            {
+                supportingSignature = CreateSupportingSignature(token, identifier);
+            }
+            else
+            {
+                supportingSignature = CreateSupportingSignature(token, identifier, elementContainer.PrimarySignature.Item);
+            }
+            AddGeneratedSignatureValue(supportingSignature.GetSignatureValue(), encryptSignature);
+            SendSecurityHeaderElement supportingSignatureElement = new SendSecurityHeaderElement(supportingSignature.Id, supportingSignature);
+            supportingSignatureElement.MarkedForEncryption = encryptSignature;
+            this.elementContainer.AddEndorsingSignature(supportingSignatureElement);
+        }
+
+        void SignWithSupportingTokens()
+        {
+            SecurityToken[] endorsingTokens = this.elementContainer.GetEndorsingSupportingTokens();
+            if (endorsingTokens != null)
+            {
+                for (int i = 0; i < endorsingTokens.Length; ++i)
+                {
+                    SecurityToken source = endorsingTokens[i];
+                    SecurityKeyIdentifierClause sourceKeyClause = endorsingTokenParameters[i].CreateKeyIdentifierClause(source, GetTokenReferenceStyle(endorsingTokenParameters[i]));
+                    if (sourceKeyClause == null)
+                    {
+                        throw TraceUtility.ThrowHelperError(new MessageSecurityException(SR.Format(SR.TokenManagerCannotCreateTokenReference)), this.Message);
+                    }
+                    SecurityToken signingToken;
+                    SecurityKeyIdentifierClause signingKeyClause;
+                    if (endorsingTokenParameters[i].RequireDerivedKeys && !endorsingTokenParameters[i].HasAsymmetricKey)
+                    {
+                        string derivationAlgorithm = SecurityUtils.GetKeyDerivationAlgorithm(this.StandardsManager.MessageSecurityVersion.SecureConversationVersion);
+                        DerivedKeySecurityToken dkt = new DerivedKeySecurityToken(-1, 0, 
+                            this.AlgorithmSuite.GetSignatureKeyDerivationLength(source, this.StandardsManager.MessageSecurityVersion.SecureConversationVersion), null,
+                            DerivedKeySecurityToken.DefaultNonceLength, source, sourceKeyClause, derivationAlgorithm, GenerateId());
+                        signingToken = dkt;
+                        signingKeyClause = new LocalIdKeyIdentifierClause(dkt.Id, dkt.GetType());
+                        this.elementContainer.AddEndorsingDerivedSupportingToken(dkt);
+                    }
+                    else
+                    {
+                        signingToken = source;
+                        signingKeyClause = sourceKeyClause;
+                    }
+                    SignWithSupportingToken(signingToken, signingKeyClause);
+                }
+            }
+            SecurityToken[] signedEndorsingSupportingTokens = this.elementContainer.GetSignedEndorsingSupportingTokens();
+            if (signedEndorsingSupportingTokens != null)
+            {
+                for (int i = 0; i < signedEndorsingSupportingTokens.Length; ++i)
+                {
+                    SecurityToken source = signedEndorsingSupportingTokens[i];
+                    SecurityKeyIdentifierClause sourceKeyClause = signedEndorsingTokenParameters[i].CreateKeyIdentifierClause(source, GetTokenReferenceStyle(signedEndorsingTokenParameters[i]));
+                    if (sourceKeyClause == null)
+                    {
+                        throw TraceUtility.ThrowHelperError(new MessageSecurityException(SR.Format(SR.TokenManagerCannotCreateTokenReference)), this.Message);
+                    }
+                    SecurityToken signingToken;
+                    SecurityKeyIdentifierClause signingKeyClause;
+                    if (signedEndorsingTokenParameters[i].RequireDerivedKeys && !signedEndorsingTokenParameters[i].HasAsymmetricKey)
+                    {
+                        string derivationAlgorithm = SecurityUtils.GetKeyDerivationAlgorithm(this.StandardsManager.MessageSecurityVersion.SecureConversationVersion);
+                        DerivedKeySecurityToken dkt = new DerivedKeySecurityToken(-1, 0, 
+                            this.AlgorithmSuite.GetSignatureKeyDerivationLength(source, this.StandardsManager.MessageSecurityVersion.SecureConversationVersion), null,
+                            DerivedKeySecurityToken.DefaultNonceLength, source, sourceKeyClause, derivationAlgorithm, GenerateId());
+                        signingToken = dkt;
+                        signingKeyClause = new LocalIdKeyIdentifierClause(dkt.Id, dkt.GetType());
+                        this.elementContainer.AddSignedEndorsingDerivedSupportingToken(dkt);
+                    }
+                    else
+                    {
+                        signingToken = source;
+                        signingKeyClause = sourceKeyClause;
+                    }
+                    SignWithSupportingToken(signingToken, signingKeyClause);
+                }
+            }
+        }
+
+        protected bool ShouldUseStrTransformForToken(SecurityToken securityToken, int position, SecurityTokenAttachmentMode mode, out SecurityKeyIdentifierClause keyIdentifierClause)
+        {
+            /*
+               IssuedSecurityTokenParameters tokenParams = null;
+               keyIdentifierClause = null;
+
+               switch (mode)
+               {
+                   case SecurityTokenAttachmentMode.SignedEndorsing:
+                       tokenParams = this.signedEndorsingTokenParameters[position] as IssuedSecurityTokenParameters;
+                       break;
+                   case SecurityTokenAttachmentMode.Signed:
+                       tokenParams = this.signedTokenParameters[position] as IssuedSecurityTokenParameters;
+                       break;
+                   case SecurityTokenAttachmentMode.SignedEncrypted:
+                       tokenParams = this.basicSupportingTokenParameters[position] as IssuedSecurityTokenParameters;
+                       break;
+                   default:
+                       return false;
+               }
+
+               if (tokenParams != null && tokenParams.UseStrTransform)
+               {
+                   keyIdentifierClause = tokenParams.CreateKeyIdentifierClause(securityToken, GetTokenReferenceStyle(tokenParams));
+                   if (keyIdentifierClause == null)
+                   {
+                       throw TraceUtility.ThrowHelperError(new MessageSecurityException(SR.Format(SR.TokenManagerCannotCreateTokenReference)), this.Message);
+                   }
+
+                   return true;
+               }
+
+               return false;*/
+            throw new NotImplementedException();
+        }
+
+        XmlDictionaryString IMessageHeaderWithSharedNamespace.SharedNamespace
+        {
+            get { return XD.UtilityDictionary.Namespace; }
+        }
+
+        XmlDictionaryString IMessageHeaderWithSharedNamespace.SharedPrefix
+        {
+            get { return XD.UtilityDictionary.Prefix; }
+        }
+
+        void AddGeneratedSignatureValue(byte[] signatureValue, bool wasEncrypted)
+        {
+            // cache outgoing signatures only on the client side
+            if (this.MaintainSignatureConfirmationState && (this.signatureConfirmationsToSend == null))
+            {
+                if (this.signatureValuesGenerated == null)
+                {
+                    this.signatureValuesGenerated = new SignatureConfirmations();
+                }
+                this.signatureValuesGenerated.AddConfirmation(signatureValue, wasEncrypted);
+            }
+        }
+    }
+
+    class TokenElement : ISecurityElement
+    {
+        SecurityStandardsManager standardsManager;
+        SecurityToken token;
+
+        public TokenElement(SecurityToken token, SecurityStandardsManager standardsManager)
+        {
+            this.token = token;
+            this.standardsManager = standardsManager;
+        }
+
+        public override bool Equals(object item)
+        {
+            TokenElement element = item as TokenElement;
+            return (element != null && this.token == element.token && this.standardsManager == element.standardsManager);
+        }
+
+        public override int GetHashCode()
+        {
+            return token.GetHashCode() ^ standardsManager.GetHashCode();
+        }
+
+        public bool HasId
+        {
+            get { return true; }
+        }
+
+        public string Id
+        {
+            get { return token.Id; }
+        }
+
+        public SecurityToken Token
+        {
+            get { return token; }
+        }
+
+        public void WriteTo(XmlDictionaryWriter writer, DictionaryManager dictionaryManager)
+        {
+            standardsManager.SecurityTokenSerializer.WriteToken(writer, token);
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/SendSecurityHeaderElement.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/SendSecurityHeaderElement.cs
new file mode 100644
index 0000000..16d3c17
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/SendSecurityHeaderElement.cs
@@ -0,0 +1,52 @@
+using CoreWCF.IdentityModel.Claims;
+using CoreWCF;
+using CoreWCF.IdentityModel.Policy;
+using CoreWCF.Security.Tokens;
+using System.Xml;
+
+using ISecurityElement = CoreWCF.IdentityModel.ISecurityElement;
+
+namespace CoreWCF.Security
+{
+
+    class SendSecurityHeaderElement
+    {
+        string id;
+        ISecurityElement item;
+        bool markedForEncryption;
+
+        public SendSecurityHeaderElement(string id, ISecurityElement item)
+        {
+            this.id = id;
+            this.item = item;
+            markedForEncryption = false;
+        }
+
+        public string Id
+        {
+            get { return this.id; }
+        }
+
+        public ISecurityElement Item
+        {
+            get { return this.item; }
+        }
+
+        public bool MarkedForEncryption
+        {
+            get { return this.markedForEncryption; }
+            set { this.markedForEncryption = value; }
+        }
+
+        public bool IsSameItem(ISecurityElement item)
+        {
+            return this.item == item || this.item.Equals(item);
+        }
+
+        public void Replace(string id, ISecurityElement item)
+        {
+            this.item = item;
+            this.id = id;
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/SendSecurityHeaderElementContainer.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/SendSecurityHeaderElementContainer.cs
new file mode 100644
index 0000000..e9ed028
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/SendSecurityHeaderElementContainer.cs
@@ -0,0 +1,156 @@
+using CoreWCF.IdentityModel.Claims;
+using CoreWCF;
+using CoreWCF.IdentityModel.Policy;
+using CoreWCF.IdentityModel.Tokens;
+using CoreWCF.Security.Tokens;
+using System.Xml;
+using System.Collections.Generic;
+
+using ISecurityElement = CoreWCF.IdentityModel.ISecurityElement;
+using CoreWCF.IdentityModel;
+
+namespace CoreWCF.Security
+{
+
+    class SendSecurityHeaderElementContainer
+    {
+        List<SecurityToken> signedSupportingTokens = null;
+        List<SendSecurityHeaderElement> basicSupportingTokens = null;
+        List<SecurityToken> endorsingSupportingTokens = null;
+        List<SecurityToken> endorsingDerivedSupportingTokens = null;
+        List<SecurityToken> signedEndorsingSupportingTokens = null;
+        List<SecurityToken> signedEndorsingDerivedSupportingTokens = null;
+        List<SendSecurityHeaderElement> signatureConfirmations = null;
+        List<SendSecurityHeaderElement> endorsingSignatures = null;
+        Dictionary<SecurityToken, SecurityKeyIdentifierClause> securityTokenMappedToIdentifierClause = null;
+
+        public SecurityTimestamp Timestamp;
+        public SecurityToken PrerequisiteToken;
+        public SecurityToken SourceSigningToken;
+        public SecurityToken DerivedSigningToken;
+        public SecurityToken SourceEncryptionToken;
+        public SecurityToken WrappedEncryptionToken;
+        public SecurityToken DerivedEncryptionToken;
+        public ISecurityElement ReferenceList;
+        public SendSecurityHeaderElement PrimarySignature;
+
+        void Add<T>(ref List<T> list, T item)
+        {
+            if (list == null)
+            {
+                list = new List<T>();
+            }
+            list.Add(item);
+        }
+
+        public SecurityToken[] GetSignedSupportingTokens()
+        {
+            return (this.signedSupportingTokens != null) ? this.signedSupportingTokens.ToArray() : null;
+        }
+
+        public void AddSignedSupportingToken(SecurityToken token)
+        {
+            Add<SecurityToken>(ref this.signedSupportingTokens, token);
+        }
+
+        public List<SecurityToken> EndorsingSupportingTokens
+        {
+            get { return this.endorsingSupportingTokens; }
+        }
+
+        public SendSecurityHeaderElement[] GetBasicSupportingTokens()
+        {
+            return (this.basicSupportingTokens != null) ? this.basicSupportingTokens.ToArray() : null;
+        }
+
+        public void AddBasicSupportingToken(SendSecurityHeaderElement tokenElement)
+        {
+            Add<SendSecurityHeaderElement>(ref this.basicSupportingTokens, tokenElement);
+        }
+
+        public SecurityToken[] GetSignedEndorsingSupportingTokens()
+        {
+            return (this.signedEndorsingSupportingTokens != null) ? this.signedEndorsingSupportingTokens.ToArray() : null;
+        }
+
+        public void AddSignedEndorsingSupportingToken(SecurityToken token)
+        {
+            Add<SecurityToken>(ref this.signedEndorsingSupportingTokens, token);
+        }
+
+        public SecurityToken[] GetSignedEndorsingDerivedSupportingTokens()
+        {
+            return (this.signedEndorsingDerivedSupportingTokens != null) ? this.signedEndorsingDerivedSupportingTokens.ToArray() : null;
+        }
+
+        public void AddSignedEndorsingDerivedSupportingToken(SecurityToken token)
+        {
+            Add<SecurityToken>(ref this.signedEndorsingDerivedSupportingTokens, token);
+        }
+
+        public SecurityToken[] GetEndorsingSupportingTokens()
+        {
+            return (this.endorsingSupportingTokens != null) ? this.endorsingSupportingTokens.ToArray() : null;
+        }
+
+        public void AddEndorsingSupportingToken(SecurityToken token)
+        {
+            Add<SecurityToken>(ref this.endorsingSupportingTokens, token);
+        }
+
+        public SecurityToken[] GetEndorsingDerivedSupportingTokens()
+        {
+            return (this.endorsingDerivedSupportingTokens != null) ? this.endorsingDerivedSupportingTokens.ToArray() : null;
+        }
+
+        public void AddEndorsingDerivedSupportingToken(SecurityToken token)
+        {
+            Add<SecurityToken>(ref this.endorsingDerivedSupportingTokens, token);
+        }
+
+        public SendSecurityHeaderElement[] GetSignatureConfirmations()
+        {
+            return (this.signatureConfirmations != null) ? this.signatureConfirmations.ToArray() : null;
+        }
+
+        public void AddSignatureConfirmation(SendSecurityHeaderElement confirmation)
+        {
+            Add<SendSecurityHeaderElement>(ref this.signatureConfirmations, confirmation);
+        }
+
+        public SendSecurityHeaderElement[] GetEndorsingSignatures()
+        {
+            return (this.endorsingSignatures != null) ? this.endorsingSignatures.ToArray() : null;
+        }
+
+        public void AddEndorsingSignature(SendSecurityHeaderElement signature)
+        {
+            Add<SendSecurityHeaderElement>(ref this.endorsingSignatures, signature);
+        }
+
+        public void MapSecurityTokenToStrClause(SecurityToken securityToken, SecurityKeyIdentifierClause keyIdentifierClause)
+        {
+            if (this.securityTokenMappedToIdentifierClause == null)
+            {
+                this.securityTokenMappedToIdentifierClause = new Dictionary<SecurityToken, SecurityKeyIdentifierClause>();
+            }
+
+            if (!this.securityTokenMappedToIdentifierClause.ContainsKey(securityToken))
+            {
+                this.securityTokenMappedToIdentifierClause.Add(securityToken, keyIdentifierClause);
+            }
+        }
+
+        public bool TryGetIdentifierClauseFromSecurityToken(SecurityToken securityToken, out SecurityKeyIdentifierClause keyIdentifierClause)
+        {
+            keyIdentifierClause = null;
+            if (securityToken == null
+                || this.securityTokenMappedToIdentifierClause == null
+                || !this.securityTokenMappedToIdentifierClause.TryGetValue(securityToken, out keyIdentifierClause))
+            {
+                return false;
+            }
+            return true;
+        }       
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/ServiceCredentialsSecurityTokenManager.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/ServiceCredentialsSecurityTokenManager.cs
index 47ead14..f3dc053 100644
--- a/src/CoreWCF.Primitives/src/CoreWCF/Security/ServiceCredentialsSecurityTokenManager.cs
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/ServiceCredentialsSecurityTokenManager.cs
@@ -7,6 +7,7 @@ using System;
 using System.Collections.Generic;
 using System.Net;
 using System.Text;
+using CoreWCF.Dispatcher;
 
 namespace CoreWCF.Security
 {
@@ -34,75 +35,80 @@ namespace CoreWCF.Security
             {
                 throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(version));
             }
-
-            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new NotSupportedException(SR.Format(SR.SecurityTokenManagerCannotCreateSerializerForVersion, version)));
+            MessageSecurityTokenVersion wsVersion = version as MessageSecurityTokenVersion;
+            if (wsVersion != null)
+            {
+                SamlSerializer samlSerializer = null;
+                //TODO check the need
+                //if (parent.IssuedTokenAuthentication != null)
+                //    samlSerializer = parent.IssuedTokenAuthentication.SamlSerializer;
+                //else
+                //    samlSerializer = new SamlSerializer();
+
+                return new WSSecurityTokenSerializer(wsVersion.SecurityVersion, wsVersion.TrustVersion, wsVersion.SecureConversationVersion, wsVersion.EmitBspRequiredAttributes, samlSerializer, parent.SecureConversationAuthentication.SecurityStateEncoder, parent.SecureConversationAuthentication.SecurityContextClaimTypes);
+            }
+            else
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new NotSupportedException(SR.Format(SR.SecurityTokenManagerCannotCreateSerializerForVersion, version)));
+            }
         }
 
-        //protected SecurityTokenAuthenticator CreateSecureConversationTokenAuthenticator(RecipientServiceModelSecurityTokenRequirement recipientRequirement, bool preserveBootstrapTokens, out SecurityTokenResolver sctResolver)
-        //{
-        //    SecurityBindingElement securityBindingElement = recipientRequirement.SecurityBindingElement;
-        //    if (securityBindingElement == null)
-        //    {
-        //        throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgument(SR.Format(SR.TokenAuthenticatorRequiresSecurityBindingElement, recipientRequirement));
-        //    }
-        //    bool isCookieMode = !recipientRequirement.SupportSecurityContextCancellation;
-        //    LocalServiceSecuritySettings localServiceSettings = securityBindingElement.LocalServiceSettings;
-        //    IMessageFilterTable<EndpointAddress> endpointFilterTable = recipientRequirement.GetPropertyOrDefault<IMessageFilterTable<EndpointAddress>>(ServiceModelSecurityTokenRequirement.EndpointFilterTableProperty, null);
-
-        //    if (!isCookieMode)
-        //    {
-        //        sctResolver = new SecurityContextSecurityTokenResolver(Int32.MaxValue, false);
-
-        //        // remember this authenticator for future reference
-        //        SecuritySessionSecurityTokenAuthenticator authenticator = new SecuritySessionSecurityTokenAuthenticator();
-        //        authenticator.BootstrapSecurityBindingElement = SecurityUtils.GetIssuerSecurityBindingElement(recipientRequirement);
-        //        authenticator.IssuedSecurityTokenParameters = recipientRequirement.GetProperty<SecurityTokenParameters>(ServiceModelSecurityTokenRequirement.IssuedSecurityTokenParametersProperty);
-        //        authenticator.IssuedTokenCache = (ISecurityContextSecurityTokenCache)sctResolver;
-        //        authenticator.IssuerBindingContext = recipientRequirement.GetProperty<BindingContext>(ServiceModelSecurityTokenRequirement.IssuerBindingContextProperty);
-        //        authenticator.KeyEntropyMode = securityBindingElement.KeyEntropyMode;
-        //        authenticator.ListenUri = recipientRequirement.ListenUri;
-        //        authenticator.SecurityAlgorithmSuite = recipientRequirement.SecurityAlgorithmSuite;
-        //        authenticator.SessionTokenLifetime = TimeSpan.MaxValue;
-        //        authenticator.KeyRenewalInterval = securityBindingElement.LocalServiceSettings.SessionKeyRenewalInterval;
-        //        authenticator.StandardsManager = SecurityUtils.CreateSecurityStandardsManager(recipientRequirement, this);
-        //        authenticator.EndpointFilterTable = endpointFilterTable;
-        //        authenticator.MaximumConcurrentNegotiations = localServiceSettings.MaxStatefulNegotiations;
-        //        authenticator.NegotiationTimeout = localServiceSettings.NegotiationTimeout;
-        //        authenticator.PreserveBootstrapTokens = preserveBootstrapTokens;
-        //        return authenticator;
-        //    }
-        //    else
-        //    {
-        //        sctResolver = new SecurityContextSecurityTokenResolver(localServiceSettings.MaxCachedCookies, true, localServiceSettings.MaxClockSkew);
-
-        //        AcceleratedTokenAuthenticator authenticator = new AcceleratedTokenAuthenticator();
-        //        authenticator.BootstrapSecurityBindingElement = SecurityUtils.GetIssuerSecurityBindingElement(recipientRequirement);
-        //        authenticator.KeyEntropyMode = securityBindingElement.KeyEntropyMode;
-        //        authenticator.EncryptStateInServiceToken = true;
-        //        authenticator.IssuedSecurityTokenParameters = recipientRequirement.GetProperty<SecurityTokenParameters>(ServiceModelSecurityTokenRequirement.IssuedSecurityTokenParametersProperty);
-        //        authenticator.IssuedTokenCache = (ISecurityContextSecurityTokenCache)sctResolver;
-        //        authenticator.IssuerBindingContext = recipientRequirement.GetProperty<BindingContext>(ServiceModelSecurityTokenRequirement.IssuerBindingContextProperty);
-        //        authenticator.ListenUri = recipientRequirement.ListenUri;
-        //        authenticator.SecurityAlgorithmSuite = recipientRequirement.SecurityAlgorithmSuite;
-        //        authenticator.StandardsManager = SecurityUtils.CreateSecurityStandardsManager(recipientRequirement, this);
-        //        authenticator.SecurityStateEncoder = parent.SecureConversationAuthentication.SecurityStateEncoder;
-        //        authenticator.KnownTypes = parent.SecureConversationAuthentication.SecurityContextClaimTypes;
-        //        authenticator.PreserveBootstrapTokens = preserveBootstrapTokens;
-
-        //        // local security quotas
-        //        authenticator.MaximumCachedNegotiationState = localServiceSettings.MaxStatefulNegotiations;
-        //        authenticator.NegotiationTimeout = localServiceSettings.NegotiationTimeout;
-        //        authenticator.ServiceTokenLifetime = localServiceSettings.IssuedCookieLifetime;
-        //        authenticator.MaximumConcurrentNegotiations = localServiceSettings.MaxStatefulNegotiations;
-
-        //        // audit settings
-        //        authenticator.AuditLogLocation = recipientRequirement.AuditLogLocation;
-        //        authenticator.SuppressAuditFailure = recipientRequirement.SuppressAuditFailure;
-        //        authenticator.MessageAuthenticationAuditLevel = recipientRequirement.MessageAuthenticationAuditLevel;
-        //        authenticator.EndpointFilterTable = endpointFilterTable;
-        //        return authenticator;
-        //    }
-        //}
+        protected SecurityTokenAuthenticator CreateSecureConversationTokenAuthenticator(RecipientServiceModelSecurityTokenRequirement recipientRequirement, bool preserveBootstrapTokens, out SecurityTokenResolver sctResolver)
+        {
+            SecurityBindingElement securityBindingElement = recipientRequirement.SecurityBindingElement;
+            if (securityBindingElement == null)
+                throw CoreWCF.DiagnosticUtility.ExceptionUtility.ThrowHelperArgument(SR.Format("TokenAuthenticatorRequiresSecurityBindingElement", (object)recipientRequirement));
+            bool flag = !recipientRequirement.SupportSecurityContextCancellation;
+            LocalServiceSecuritySettings localServiceSettings = securityBindingElement.LocalServiceSettings;
+            IMessageFilterTable<EndpointAddress> propertyOrDefault = recipientRequirement.GetPropertyOrDefault<IMessageFilterTable<EndpointAddress>>(ServiceModelSecurityTokenRequirement.EndpointFilterTableProperty, (IMessageFilterTable<EndpointAddress>)null);
+            if (!flag)
+            {
+                sctResolver = (SecurityTokenResolver)new SecurityContextSecurityTokenResolver(int.MaxValue, false);
+                return (SecurityTokenAuthenticator)new SecuritySessionSecurityTokenAuthenticator()
+                {
+                    BootstrapSecurityBindingElement = SecurityUtils.GetIssuerSecurityBindingElement((ServiceModelSecurityTokenRequirement)recipientRequirement),
+                    IssuedSecurityTokenParameters = recipientRequirement.GetProperty<SecurityTokenParameters>(ServiceModelSecurityTokenRequirement.IssuedSecurityTokenParametersProperty),
+                    IssuedTokenCache = (ISecurityContextSecurityTokenCache)sctResolver,
+                    IssuerBindingContext = recipientRequirement.GetProperty<BindingContext>(ServiceModelSecurityTokenRequirement.IssuerBindingContextProperty),
+                    KeyEntropyMode = securityBindingElement.KeyEntropyMode,
+                    ListenUri = recipientRequirement.ListenUri,
+                    SecurityAlgorithmSuite = recipientRequirement.SecurityAlgorithmSuite,
+                    SessionTokenLifetime = TimeSpan.MaxValue,
+                    KeyRenewalInterval = securityBindingElement.LocalServiceSettings.SessionKeyRenewalInterval,
+                    StandardsManager = SecurityUtils.CreateSecurityStandardsManager((SecurityTokenRequirement)recipientRequirement, (SecurityTokenManager)this),
+                    EndpointFilterTable = propertyOrDefault,
+                    MaximumConcurrentNegotiations = localServiceSettings.MaxStatefulNegotiations,
+                    NegotiationTimeout = localServiceSettings.NegotiationTimeout,
+                    PreserveBootstrapTokens = preserveBootstrapTokens
+                };
+            }
+            throw new NotImplementedException();
+            /* TODO later
+            sctResolver = (SecurityTokenResolver)new SecurityContextSecurityTokenResolver(localServiceSettings.MaxCachedCookies, true, localServiceSettings.MaxClockSkew);
+            AcceleratedTokenAuthenticator tokenAuthenticator = new AcceleratedTokenAuthenticator();
+            tokenAuthenticator.BootstrapSecurityBindingElement = SecurityUtils.GetIssuerSecurityBindingElement((ServiceModelSecurityTokenRequirement)recipientRequirement);
+            tokenAuthenticator.KeyEntropyMode = securityBindingElement.KeyEntropyMode;
+            tokenAuthenticator.EncryptStateInServiceToken = true;
+            tokenAuthenticator.IssuedSecurityTokenParameters = recipientRequirement.GetProperty<SecurityTokenParameters>(ServiceModelSecurityTokenRequirement.IssuedSecurityTokenParametersProperty);
+            tokenAuthenticator.IssuedTokenCache = (ISecurityContextSecurityTokenCache)sctResolver;
+            tokenAuthenticator.IssuerBindingContext = recipientRequirement.GetProperty<BindingContext>(ServiceModelSecurityTokenRequirement.IssuerBindingContextProperty);
+            tokenAuthenticator.ListenUri = recipientRequirement.ListenUri;
+            tokenAuthenticator.SecurityAlgorithmSuite = recipientRequirement.SecurityAlgorithmSuite;
+            tokenAuthenticator.StandardsManager = SecurityUtils.CreateSecurityStandardsManager((SecurityTokenRequirement)recipientRequirement, (SecurityTokenManager)this);
+            tokenAuthenticator.SecurityStateEncoder = this.parent.SecureConversationAuthentication.SecurityStateEncoder;
+            tokenAuthenticator.KnownTypes = (IList<System.Type>)this.parent.SecureConversationAuthentication.SecurityContextClaimTypes;
+            tokenAuthenticator.PreserveBootstrapTokens = preserveBootstrapTokens;
+            tokenAuthenticator.MaximumCachedNegotiationState = localServiceSettings.MaxStatefulNegotiations;
+            tokenAuthenticator.NegotiationTimeout = localServiceSettings.NegotiationTimeout;
+            tokenAuthenticator.ServiceTokenLifetime = localServiceSettings.IssuedCookieLifetime;
+            tokenAuthenticator.MaximumConcurrentNegotiations = localServiceSettings.MaxStatefulNegotiations;
+            tokenAuthenticator.AuditLogLocation = recipientRequirement.AuditLogLocation;
+            tokenAuthenticator.SuppressAuditFailure = recipientRequirement.SuppressAuditFailure;
+            tokenAuthenticator.MessageAuthenticationAuditLevel = recipientRequirement.MessageAuthenticationAuditLevel;
+            tokenAuthenticator.EndpointFilterTable = propertyOrDefault;
+            return (SecurityTokenAuthenticator)tokenAuthenticator;*/
+           
+        }
 
         SecurityTokenAuthenticator CreateSpnegoSecurityTokenAuthenticator(RecipientServiceModelSecurityTokenRequirement recipientRequirement, out SecurityTokenResolver sctResolver)
         {
@@ -372,8 +378,9 @@ namespace CoreWCF.Security
             }
             else if (tokenType == ServiceModelSecurityTokenTypes.SecureConversation)
             {
-                throw new PlatformNotSupportedException("SecureConversation");
-                //result = CreateSecureConversationTokenAuthenticator(recipientRequirement, false, out outOfBandTokenResolver);
+               
+                result = CreateSecureConversationTokenAuthenticator(recipientRequirement, false, out outOfBandTokenResolver);
+
             }
             else if ((tokenType == SecurityTokenTypes.Saml)
                 || (tokenType == SecurityXXX2005Strings.SamlTokenType)
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/SessionSymmetricMessageSecurityProtocolFactory.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/SessionSymmetricMessageSecurityProtocolFactory.cs
new file mode 100644
index 0000000..6327625
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/SessionSymmetricMessageSecurityProtocolFactory.cs
@@ -0,0 +1,154 @@
+using CoreWCF.IdentityModel.Tokens;
+using CoreWCF.Channels;
+using CoreWCF;
+using CoreWCF.IdentityModel.Selectors;
+using CoreWCF.Security.Tokens;
+using CoreWCF.IdentityModel;
+using System;
+
+namespace CoreWCF.Security
+{
+    //TODO implement next phase
+    //class SessionSymmetricMessageSecurityProtocolFactory : MessageSecurityProtocolFactory
+    //{
+    //    SecurityTokenParameters securityTokenParameters;
+    //    SessionDerivedKeySecurityTokenParameters derivedKeyTokenParameters;
+
+    //    public SessionSymmetricMessageSecurityProtocolFactory()
+    //        : base()
+    //    {
+    //    }
+
+    //    public SecurityTokenParameters SecurityTokenParameters
+    //    {
+    //        get
+    //        {
+    //            return this.securityTokenParameters;
+    //        }
+    //        set
+    //        {
+    //            ThrowIfImmutable();
+    //            this.securityTokenParameters = value;
+    //        }
+    //    }
+
+    //    public override EndpointIdentity GetIdentityOfSelf()
+    //    {
+    //        if (this.SecurityTokenManager is IEndpointIdentityProvider)
+    //        {
+    //            SecurityTokenRequirement requirement = CreateRecipientSecurityTokenRequirement();
+    //            this.SecurityTokenParameters.InitializeSecurityTokenRequirement(requirement);
+    //            return ((IEndpointIdentityProvider)this.SecurityTokenManager).GetIdentityOfSelf(requirement);
+    //        }
+    //        else
+    //        {
+    //            return base.GetIdentityOfSelf();
+    //        }
+    //    }
+
+    //    protected override SecurityProtocol OnCreateSecurityProtocol(EndpointAddress target, Uri via, object listenerSecurityState, TimeSpan timeout)
+    //    {
+    //        if (this.ActAsInitiator)
+    //        {
+    //            return new InitiatorSessionSymmetricMessageSecurityProtocol(this, target, via);
+    //        }
+    //        else
+    //        {
+    //            return new AcceptorSessionSymmetricMessageSecurityProtocol(this, null);
+    //        }
+    //    }
+
+    //    public override void OnOpen(TimeSpan timeout)
+    //    {
+    //        if (this.SecurityTokenParameters == null)
+    //        {
+    //            OnPropertySettingsError("SecurityTokenParameters", true);
+    //        }
+    //        if (this.SecurityTokenParameters.RequireDerivedKeys)
+    //        {
+    //            this.ExpectKeyDerivation = true;
+    //            this.derivedKeyTokenParameters = new SessionDerivedKeySecurityTokenParameters(this.ActAsInitiator);
+    //        }
+    //        base.OnOpen(timeout);
+    //    }
+
+    //    internal SecurityTokenParameters GetTokenParameters()
+    //    {
+    //        if (this.derivedKeyTokenParameters != null)
+    //        {
+    //            return this.derivedKeyTokenParameters;
+    //        }
+    //        else
+    //        {
+    //            return this.securityTokenParameters;
+    //        }
+    //    }
+    //}
+
+    internal class SessionDerivedKeySecurityTokenParameters : SecurityTokenParameters
+    {
+        bool actAsInitiator;
+
+        protected SessionDerivedKeySecurityTokenParameters(SessionDerivedKeySecurityTokenParameters other)
+            : base(other)
+        {
+            this.actAsInitiator = other.actAsInitiator;
+        }
+
+        public SessionDerivedKeySecurityTokenParameters(bool actAsInitiator)
+            : base()
+        {
+            this.actAsInitiator = actAsInitiator;
+            this.InclusionMode = actAsInitiator ? SecurityTokenInclusionMode.AlwaysToRecipient : SecurityTokenInclusionMode.AlwaysToInitiator;
+            base.RequireDerivedKeys = false;
+        }
+
+        internal protected override bool SupportsClientAuthentication { get { return false; } }
+        internal protected override bool SupportsServerAuthentication { get { return false; } }
+        internal protected override bool SupportsClientWindowsIdentity { get { return false; } }
+
+        internal protected override bool HasAsymmetricKey { get { return false; } }
+
+        protected override SecurityTokenParameters CloneCore()
+        {
+            return new SessionDerivedKeySecurityTokenParameters(this);
+        }
+
+        internal protected override SecurityKeyIdentifierClause CreateKeyIdentifierClause(SecurityToken token, SecurityTokenReferenceStyle referenceStyle)
+        {
+            if (referenceStyle == SecurityTokenReferenceStyle.Internal)
+            {
+                return token.CreateKeyIdentifierClause<LocalIdKeyIdentifierClause>();
+            }
+            else
+            {
+                return null;
+            }
+        }
+
+        internal protected override bool MatchesKeyIdentifierClause(SecurityToken token, SecurityKeyIdentifierClause keyIdentifierClause, SecurityTokenReferenceStyle referenceStyle)
+        {
+            if (referenceStyle == SecurityTokenReferenceStyle.Internal)
+            {
+                LocalIdKeyIdentifierClause localClause = keyIdentifierClause as LocalIdKeyIdentifierClause;
+                if (localClause == null)
+                {
+                    return false;
+                }
+                else
+                {
+                    return (localClause.LocalId == token.Id);
+                }
+            }
+            else
+            {
+                return false;
+            }
+        }
+
+        protected internal override void InitializeSecurityTokenRequirement(SecurityTokenRequirement requirement)
+        {
+            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new NotSupportedException());
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/SessionSymmetricTransportSecurityProtocolFactory.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/SessionSymmetricTransportSecurityProtocolFactory.cs
new file mode 100644
index 0000000..4089cad
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/SessionSymmetricTransportSecurityProtocolFactory.cs
@@ -0,0 +1,79 @@
+using CoreWCF.Security.Tokens;
+using CoreWCF;
+using System;
+using CoreWCF.Security;
+
+namespace CoreWCF.Security
+{
+    class SessionSymmetricTransportSecurityProtocolFactory : TransportSecurityProtocolFactory
+    {
+        SecurityTokenParameters securityTokenParameters;
+        SessionDerivedKeySecurityTokenParameters derivedKeyTokenParameters;
+
+        public SessionSymmetricTransportSecurityProtocolFactory()
+            : base()
+        {
+        }
+
+        public override bool SupportsReplayDetection
+        {
+            get
+            {
+                return true;
+            }
+        }
+
+        public SecurityTokenParameters SecurityTokenParameters
+        {
+            get
+            {
+                return this.securityTokenParameters;
+            }
+            set
+            {
+                ThrowIfImmutable();
+                this.securityTokenParameters = value;
+            }
+        }
+
+        internal override SecurityProtocol OnCreateSecurityProtocol(EndpointAddress target, Uri via, object listenerSecurityState, TimeSpan timeout)
+        {
+            if (this.ActAsInitiator)
+            {
+                throw new NotImplementedException(""); // Not needed for server side
+               // return new InitiatorSessionSymmetricTransportSecurityProtocol(this, target, via);
+            }
+            else
+            {
+                if (this.SecurityTokenParameters == null)
+                {
+                    OnPropertySettingsError("SecurityTokenParameters", true);
+                }
+                if (this.SecurityTokenParameters.RequireDerivedKeys)
+                {
+                    this.ExpectKeyDerivation = true;
+                    this.derivedKeyTokenParameters = new SessionDerivedKeySecurityTokenParameters(this.ActAsInitiator);
+                }
+                return new AcceptorSessionSymmetricTransportSecurityProtocol(this);
+            }
+        }
+
+        //public override void OnOpen(TimeSpan timeout)
+        //{
+        //    base.OnOpen(timeout);
+           
+        //}
+
+        internal SecurityTokenParameters GetTokenParameters()
+        {
+            if (this.derivedKeyTokenParameters != null)
+            {
+                return this.derivedKeyTokenParameters;
+            }
+            else
+            {
+                return this.securityTokenParameters;
+            }
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/SignatureConfirmationElement.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/SignatureConfirmationElement.cs
new file mode 100644
index 0000000..0e21b77
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/SignatureConfirmationElement.cs
@@ -0,0 +1,51 @@
+
+
+namespace CoreWCF.Security
+{
+    using System.Xml;
+
+    using ISignatureValueSecurityElement = CoreWCF.IdentityModel.ISignatureValueSecurityElement;
+    using DictionaryManager = CoreWCF.IdentityModel.DictionaryManager;
+
+    class SignatureConfirmationElement : ISignatureValueSecurityElement
+    {
+        SecurityVersion version;
+        string id;
+        byte[] signatureValue;
+
+        public SignatureConfirmationElement(string id, byte[] signatureValue, SecurityVersion version)
+        {
+            if (id == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("id");
+            }
+            if (signatureValue == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("signatureValue");
+            }
+            this.id = id;
+            this.signatureValue = signatureValue;
+            this.version = version;
+        }
+
+        public bool HasId
+        {
+            get { return true; }
+        }
+
+        public string Id
+        {
+            get { return this.id; }
+        }
+
+        public byte[] GetSignatureValue()
+        {
+            return this.signatureValue;
+        }
+
+        public void WriteTo(XmlDictionaryWriter writer, DictionaryManager dictionaryManager)
+        {
+            this.version.WriteSignatureConfirmation(writer, this.id, this.signatureValue);
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/SignatureConfirmations.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/SignatureConfirmations.cs
new file mode 100644
index 0000000..31a060f
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/SignatureConfirmations.cs
@@ -0,0 +1,62 @@
+using System;
+
+namespace CoreWCF.Security
+{
+
+    class SignatureConfirmations
+    {
+        SignatureConfirmation[] confirmations;
+        int length;
+        bool encrypted;
+
+        struct SignatureConfirmation
+        {
+            public byte[] value;
+
+            public SignatureConfirmation(byte[] value)
+            {
+                this.value = value;
+            }
+        }
+
+        public SignatureConfirmations()
+        {
+            confirmations = new SignatureConfirmation[1];
+            length = 0;
+        }
+
+        public int Count
+        {
+            get { return length; }
+        }
+
+        public void AddConfirmation(byte[] value, bool encrypted)
+        {
+            if (confirmations.Length == length)
+            {
+                SignatureConfirmation[] newConfirmations = new SignatureConfirmation[length * 2];
+                Array.Copy(confirmations, 0, newConfirmations, 0, length);
+                confirmations = newConfirmations;
+            }
+            confirmations[length] = new SignatureConfirmation(value);
+            ++length;
+            this.encrypted |= encrypted;
+        }
+
+        public void GetConfirmation(int index, out byte[] value, out bool encrypted)
+        {
+            if (index < 0 || index >= length)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("index", SR.Format(SR.ValueMustBeInRange, 0, length)));
+            }
+
+            value = confirmations[index].value;
+            encrypted = this.encrypted;
+        }
+
+        public bool IsMarkedForEncryption
+        {
+            get { return this.encrypted; }
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/SignatureTargetIdManager.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/SignatureTargetIdManager.cs
new file mode 100644
index 0000000..3c1c287
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/SignatureTargetIdManager.cs
@@ -0,0 +1,21 @@
+
+
+using System.Xml;
+
+namespace CoreWCF.Security
+{
+    internal abstract class SignatureTargetIdManager
+    {
+        protected SignatureTargetIdManager()
+        {
+        }
+
+        public abstract string DefaultIdNamespacePrefix { get; }
+
+        public abstract string DefaultIdNamespaceUri { get; }
+
+        public abstract string ExtractId(XmlDictionaryReader reader);
+
+        public abstract void WriteIdAttribute(XmlDictionaryWriter writer, string id);
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/StrictModeSecurityHeaderElementInferenceEngine.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/StrictModeSecurityHeaderElementInferenceEngine.cs
new file mode 100644
index 0000000..e8e9633
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/StrictModeSecurityHeaderElementInferenceEngine.cs
@@ -0,0 +1,47 @@
+using CoreWCF.Security.Tokens;
+using System.Xml;
+
+namespace CoreWCF.Security
+{
+
+    sealed class StrictModeSecurityHeaderElementInferenceEngine : SecurityHeaderElementInferenceEngine
+    {
+        static StrictModeSecurityHeaderElementInferenceEngine instance = new StrictModeSecurityHeaderElementInferenceEngine();
+
+        StrictModeSecurityHeaderElementInferenceEngine() { }
+
+        internal static StrictModeSecurityHeaderElementInferenceEngine Instance
+        {
+            get { return instance; }
+        }
+
+        public override void ExecuteProcessingPasses(ReceiveSecurityHeader securityHeader, XmlDictionaryReader reader)
+        {
+            securityHeader.ExecuteFullPass(reader);
+        }
+
+
+        //TODO (check)
+        //public override void MarkElements(ReceiveSecurityHeaderElementManager elementManager, bool messageSecurityMode)
+        //{
+        //    bool primarySignatureFound = false;
+        //    for (int position = 0; position < elementManager.Count; position++)
+        //    {
+        //        ReceiveSecurityHeaderEntry entry;
+        //        elementManager.GetElementEntry(position, out entry);
+        //        if (entry.elementCategory == ReceiveSecurityHeaderElementCategory.Signature)
+        //        {
+        //            if (!messageSecurityMode || primarySignatureFound)
+        //            {
+        //                elementManager.SetBindingMode(position, ReceiveSecurityHeaderBindingModes.Endorsing);
+        //            }
+        //            else
+        //            {
+        //                elementManager.SetBindingMode(position, ReceiveSecurityHeaderBindingModes.Primary);
+        //                primarySignatureFound = true;
+        //            }
+        //        }
+        //    }
+        //}
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/SupportingTokenAuthenticatorSpecification.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/SupportingTokenAuthenticatorSpecification.cs
new file mode 100644
index 0000000..9e32c2d
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/SupportingTokenAuthenticatorSpecification.cs
@@ -0,0 +1,66 @@
+using CoreWCF.IdentityModel.Selectors;
+using CoreWCF;
+using CoreWCF.Security.Tokens;
+
+namespace CoreWCF.Security
+{
+   public class SupportingTokenAuthenticatorSpecification
+    {
+        SecurityTokenAttachmentMode tokenAttachmentMode;
+        SecurityTokenAuthenticator tokenAuthenticator;
+        SecurityTokenResolver tokenResolver;
+        SecurityTokenParameters tokenParameters;
+        bool isTokenOptional;
+
+        public SupportingTokenAuthenticatorSpecification(SecurityTokenAuthenticator tokenAuthenticator, SecurityTokenResolver securityTokenResolver, SecurityTokenAttachmentMode attachmentMode, SecurityTokenParameters tokenParameters)
+            : this(tokenAuthenticator, securityTokenResolver, attachmentMode, tokenParameters, false)
+        {
+        }
+
+        internal SupportingTokenAuthenticatorSpecification(SecurityTokenAuthenticator tokenAuthenticator, SecurityTokenResolver securityTokenResolver, SecurityTokenAttachmentMode attachmentMode, SecurityTokenParameters tokenParameters, bool isTokenOptional)
+        {
+            if (tokenAuthenticator == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("tokenAuthenticator");
+            }
+            
+            SecurityTokenAttachmentModeHelper.Validate(attachmentMode);
+
+            if (tokenParameters == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("tokenParameters");
+            }
+            this.tokenAuthenticator = tokenAuthenticator;
+            this.tokenResolver = securityTokenResolver;
+            this.tokenAttachmentMode = attachmentMode;
+            this.tokenParameters = tokenParameters;
+            this.isTokenOptional = isTokenOptional;
+        }
+
+        public SecurityTokenAuthenticator TokenAuthenticator
+        {
+            get { return this.tokenAuthenticator; }
+        }
+
+        public SecurityTokenResolver TokenResolver
+        {
+            get { return this.tokenResolver; }
+        }
+
+        public SecurityTokenAttachmentMode SecurityTokenAttachmentMode
+        {
+            get { return this.tokenAttachmentMode; }
+        }
+
+        public SecurityTokenParameters TokenParameters
+        {
+            get { return this.tokenParameters; }
+        }
+
+        internal bool IsTokenOptional
+        {
+            get { return this.isTokenOptional; }
+            set { this.isTokenOptional = value; }
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/SupportingTokenProviderSpecification.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/SupportingTokenProviderSpecification.cs
new file mode 100644
index 0000000..09ba0bb
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/SupportingTokenProviderSpecification.cs
@@ -0,0 +1,46 @@
+using CoreWCF.IdentityModel.Selectors;
+using CoreWCF;
+using CoreWCF.Security.Tokens;
+
+
+namespace CoreWCF.Security
+{
+
+   public class SupportingTokenProviderSpecification
+    {
+        SecurityTokenAttachmentMode tokenAttachmentMode;
+        SecurityTokenProvider tokenProvider;
+        SecurityTokenParameters tokenParameters;
+
+        public SupportingTokenProviderSpecification(SecurityTokenProvider tokenProvider, SecurityTokenAttachmentMode attachmentMode, SecurityTokenParameters tokenParameters)
+        {
+            if (tokenProvider == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("tokenProvider");
+            }
+            SecurityTokenAttachmentModeHelper.Validate(attachmentMode);
+            if (tokenParameters == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("tokenParameters");
+            }
+            this.tokenProvider = tokenProvider;
+            this.tokenAttachmentMode = attachmentMode;
+            this.tokenParameters = tokenParameters;
+        }
+
+        public SecurityTokenProvider TokenProvider
+        {
+            get { return this.tokenProvider; }
+        }
+
+        public SecurityTokenAttachmentMode SecurityTokenAttachmentMode
+        {
+            get { return this.tokenAttachmentMode; }
+        }
+
+        public SecurityTokenParameters TokenParameters
+        {
+            get { return this.tokenParameters; }
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/SupportingTokenSpecification.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/SupportingTokenSpecification.cs
new file mode 100644
index 0000000..1660f37
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/SupportingTokenSpecification.cs
@@ -0,0 +1,36 @@
+using System.Collections.ObjectModel;
+using CoreWCF;
+using CoreWCF.IdentityModel.Policy;
+using CoreWCF.IdentityModel.Tokens;
+using CoreWCF.Security.Tokens;
+
+namespace CoreWCF.Security
+{
+    public class SupportingTokenSpecification : SecurityTokenSpecification
+    {
+        SecurityTokenAttachmentMode tokenAttachmentMode;
+        SecurityTokenParameters tokenParameters;
+
+        public SupportingTokenSpecification(SecurityToken token, ReadOnlyCollection<IAuthorizationPolicy> tokenPolicies, SecurityTokenAttachmentMode attachmentMode)
+            : this(token, tokenPolicies, attachmentMode, null)
+        { }
+
+        public SupportingTokenSpecification(SecurityToken token, ReadOnlyCollection<IAuthorizationPolicy> tokenPolicies, SecurityTokenAttachmentMode attachmentMode, SecurityTokenParameters tokenParameters)
+            : base(token, tokenPolicies)
+        {
+            SecurityTokenAttachmentModeHelper.Validate(attachmentMode);
+            this.tokenAttachmentMode = attachmentMode;
+            this.tokenParameters = tokenParameters;
+        }
+
+        public SecurityTokenAttachmentMode SecurityTokenAttachmentMode
+        {
+            get { return this.tokenAttachmentMode; }
+        }
+
+        internal SecurityTokenParameters SecurityTokenParameters
+        {
+            get { return this.tokenParameters; }
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/TimeBoundedCache.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/TimeBoundedCache.cs
new file mode 100644
index 0000000..c9a971d
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/TimeBoundedCache.cs
@@ -0,0 +1,514 @@
+namespace CoreWCF.Security 
+{
+    using System;
+    using System.Collections;
+    using System.Collections.Generic;
+    using CoreWCF.Runtime;
+    using CoreWCF;
+    using CoreWCF.Channels;
+    using System.Threading;
+
+    // NOTE: this class does minimum argument checking as it is all internal 
+    class TimeBoundedCache 
+    {
+        static Action<object> purgeCallback;
+        ReaderWriterLock cacheLock;
+        Hashtable entries;
+        // if there are less than lowWaterMark entries, no purging is done
+        int lowWaterMark;
+        int maxCacheItems;
+        DateTime nextPurgeTimeUtc;
+        TimeSpan purgeInterval;
+        PurgingMode purgingMode;
+        IOThreadTimer purgingTimer;
+        bool doRemoveNotification;
+
+        protected TimeBoundedCache(int lowWaterMark, int maxCacheItems, IEqualityComparer keyComparer, PurgingMode purgingMode, TimeSpan purgeInterval, bool doRemoveNotification)
+        {
+            this.entries = new Hashtable(keyComparer);
+            this.cacheLock = new ReaderWriterLock();
+            this.lowWaterMark = lowWaterMark;
+            this.maxCacheItems = maxCacheItems;
+            this.purgingMode = purgingMode;
+            this.purgeInterval = purgeInterval;
+            this.doRemoveNotification = doRemoveNotification;
+            this.nextPurgeTimeUtc = DateTime.UtcNow.Add(this.purgeInterval);
+        }
+        
+        public int Count
+        {
+            get
+            {
+                return this.entries.Count;
+            }
+        }
+
+        static Action<object> PurgeCallback
+        {
+            get
+            {
+                if (purgeCallback == null)
+                {
+                    purgeCallback = new Action<object>(PurgeCallbackStatic);
+                }
+                return purgeCallback;
+            }
+        }
+
+        protected int Capacity
+        {
+            get
+            {
+                return this.maxCacheItems;
+            }
+        }
+
+        protected Hashtable Entries
+        {
+            get
+            {
+                return this.entries;
+            }
+        }
+
+        protected ReaderWriterLock CacheLock
+        {
+            get
+            {
+                return this.cacheLock;
+            }
+        }
+
+        protected bool TryAddItem(object key, object item, DateTime expirationTime, bool replaceExistingEntry)
+        {
+            return this.TryAddItem(key, new ExpirableItem(item, expirationTime), replaceExistingEntry);
+        }
+
+        void CancelTimerIfNeeded()
+        {
+            if (this.Count == 0 && this.purgingTimer != null)
+            {
+                this.purgingTimer.Cancel();
+                this.purgingTimer = null;
+            }
+        }
+
+        void StartTimerIfNeeded()
+        {
+            if (this.purgingMode != PurgingMode.TimerBasedPurge)
+            {
+                return;
+            }
+            if (this.purgingTimer == null)
+            {
+                this.purgingTimer = new IOThreadTimer(PurgeCallback, this, false);
+                this.purgingTimer.Set(this.purgeInterval);
+            }
+        }
+
+        protected bool TryAddItem(object key, IExpirableItem item, bool replaceExistingEntry)
+        {
+            bool lockHeld = false;
+            try
+            {
+                try { }
+                finally
+                {
+                    this.cacheLock.AcquireWriterLock(-1);
+                    lockHeld = true;
+                }
+                PurgeIfNeeded();
+                EnforceQuota();
+                IExpirableItem currentItem = this.entries[key] as IExpirableItem;
+                if (currentItem == null || IsExpired(currentItem))
+                {
+                    this.entries[key] = item;
+                }
+                else if (!replaceExistingEntry)
+                {
+                    return false;
+                }
+                else
+                {
+                    this.entries[key] = item;
+                }
+                if (currentItem != null && doRemoveNotification)
+                {
+                    this.OnRemove(ExtractItem(currentItem));
+                }
+                StartTimerIfNeeded();
+                return true;
+            }
+            finally
+            {
+                if (lockHeld)
+                {
+                    this.cacheLock.ReleaseWriterLock();
+                }
+            }
+        }
+
+        protected bool TryReplaceItem(object key, object item, DateTime expirationTime)
+        {
+            bool lockHeld = false;
+            try
+            {
+                try { }
+                finally
+                {
+                    this.cacheLock.AcquireWriterLock(-1);
+                    lockHeld = true;
+                }
+                PurgeIfNeeded();
+                EnforceQuota();
+                IExpirableItem currentItem = this.entries[key] as IExpirableItem;
+                if (currentItem == null || IsExpired(currentItem))
+                {
+                    return false;
+                }
+                else
+                {
+                    this.entries[key] = new ExpirableItem(item, expirationTime);
+                    if (currentItem != null && doRemoveNotification)
+                    {
+                        this.OnRemove(ExtractItem(currentItem));
+                    }
+                    StartTimerIfNeeded();
+                    return true;
+                }
+            }
+            finally
+            {
+                if (lockHeld)
+                {
+                    this.cacheLock.ReleaseWriterLock();
+                }
+            }
+        }
+
+        protected void ClearItems()
+        {
+            bool lockHeld = false;
+            try
+            {
+                try { }
+                finally
+                {
+                    this.cacheLock.AcquireWriterLock(-1);
+                    lockHeld = true;
+                }
+
+                int count = this.entries.Count;
+                if (doRemoveNotification)
+                {
+                    foreach (IExpirableItem item in this.entries.Values)
+                    {
+                        OnRemove(ExtractItem(item));
+                    }
+                }
+                this.entries.Clear();
+                CancelTimerIfNeeded();
+            }
+            finally
+            {
+                if (lockHeld)
+                {
+                    this.cacheLock.ReleaseWriterLock();
+                }
+            }
+        }
+
+        protected object GetItem(object key)
+        {
+            bool lockHeld = false;
+            try
+            {
+                try { }
+                finally
+                {
+                    this.cacheLock.AcquireReaderLock(-1);
+                    lockHeld = true;
+                }
+                IExpirableItem item = this.entries[key] as IExpirableItem;
+                if (item == null)
+                {
+                    return null;
+                }
+                else if (IsExpired(item))
+                {
+                    // this is a stale item
+                    return null;
+                }
+                else
+                {
+                    return ExtractItem(item);
+                }
+            }
+            finally
+            {
+                if (lockHeld)
+                {
+                    this.cacheLock.ReleaseReaderLock();
+                }
+            }
+        }
+
+        protected virtual ArrayList OnQuotaReached(Hashtable cacheTable)
+        {
+            this.ThrowQuotaReachedException();
+            return null;
+        }
+
+        protected virtual void OnRemove(object item)
+        {
+        }
+
+        protected bool TryRemoveItem(object key)
+        {
+            bool lockHeld = false;
+            try
+            {
+                try { }
+                finally
+                {
+                    this.cacheLock.AcquireWriterLock(-1);
+                    lockHeld = true;
+                }
+                PurgeIfNeeded();
+                IExpirableItem currentItem = this.entries[key] as IExpirableItem;
+                bool result = (currentItem != null) && !IsExpired(currentItem);
+                if (currentItem != null)
+                {
+                    this.entries.Remove(key);
+                    if (doRemoveNotification)
+                    {
+                        this.OnRemove(ExtractItem(currentItem));
+                    }
+                    CancelTimerIfNeeded();
+                }
+                return result;
+            }
+            finally
+            {
+                if (lockHeld)
+                {
+                    this.cacheLock.ReleaseWriterLock();
+                }
+            }
+        }
+
+
+        void EnforceQuota()
+        {
+            if (!(this.cacheLock.IsWriterLockHeld == true))
+            {
+                // we failfast here because if we don't have the lock we could corrupt the cache
+                Fx.Assert("Cache write lock is not held.");
+                DiagnosticUtility.FailFast("Cache write lock is not held.");
+            }
+            if (this.Count >= this.maxCacheItems)
+            {
+                ArrayList keysToBeRemoved;
+                keysToBeRemoved = this.OnQuotaReached(this.entries);
+                if (keysToBeRemoved != null)
+                {
+                    for (int i = 0; i < keysToBeRemoved.Count; ++i)
+                    {
+                        this.entries.Remove(keysToBeRemoved[i]);
+                    }
+                    
+                }
+                CancelTimerIfNeeded();
+                if (this.Count >= this.maxCacheItems)
+                {
+                    this.ThrowQuotaReachedException();
+                }
+            }
+        }
+
+        protected object ExtractItem(IExpirableItem val)
+        {
+            ExpirableItem wrapper = (val as ExpirableItem);
+            if (wrapper != null)
+            {
+                return wrapper.Item;
+            }
+            else
+            {
+                return val;
+            }
+        }
+
+        bool IsExpired(IExpirableItem item)
+        {
+            Fx.Assert(item.ExpirationTime == DateTime.MaxValue || item.ExpirationTime.Kind == DateTimeKind.Utc, "");
+            return (item.ExpirationTime <= DateTime.UtcNow);
+        }
+
+        bool ShouldPurge()
+        {
+            if (this.Count >= this.maxCacheItems)
+            {
+                return true;
+            }
+            else if (this.purgingMode == PurgingMode.AccessBasedPurge && DateTime.UtcNow > this.nextPurgeTimeUtc && this.Count > this.lowWaterMark)
+            {
+                return true;
+            }
+            else 
+            {
+                return false;
+            }
+        }
+
+        void PurgeIfNeeded()
+        {
+            if (!(this.cacheLock.IsWriterLockHeld == true))
+            {
+                // we failfast here because if we don't have the lock we could corrupt the cache
+                Fx.Assert("Cache write lock is not held.");
+                DiagnosticUtility.FailFast("Cache write lock is not held.");
+            }
+            if (ShouldPurge())
+            {
+                PurgeStaleItems();
+            }
+        }
+
+        /// <summary>
+        /// This method must be called from within a writer lock
+        /// </summary>
+        void PurgeStaleItems()
+        {
+            if (!(this.cacheLock.IsWriterLockHeld == true))
+            {
+                // we failfast here because if we don't have the lock we could corrupt the cache
+                Fx.Assert("Cache write lock is not held.");
+                DiagnosticUtility.FailFast("Cache write lock is not held.");
+            }
+            ArrayList expiredItems = new ArrayList();
+            foreach (object key in this.entries.Keys)
+            {
+                IExpirableItem item = this.entries[key] as IExpirableItem;
+                if (IsExpired(item))
+                {
+                    // this is a stale item. Remove!
+                    this.OnRemove(ExtractItem(item));
+                    expiredItems.Add(key);
+                }
+            }
+            for (int i = 0; i < expiredItems.Count; ++i)
+            {
+                this.entries.Remove(expiredItems[i]);
+            }
+            CancelTimerIfNeeded();
+            this.nextPurgeTimeUtc = DateTime.UtcNow.Add(this.purgeInterval);
+        }
+
+        void ThrowQuotaReachedException()
+        {
+            string message = SR.Format(SR.CacheQuotaReached, this.maxCacheItems);
+            Exception inner = new QuotaExceededException(message);
+            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new CommunicationException(message, inner));
+        }
+
+        static void PurgeCallbackStatic(object state)
+        {
+            TimeBoundedCache self = (TimeBoundedCache)state;
+
+            bool lockHeld = false;
+            try
+            {
+                try { }
+                finally
+                {
+                    self.cacheLock.AcquireWriterLock(-1);
+                    lockHeld = true;
+                }
+
+                if (self.purgingTimer == null)
+                {
+                    return;
+                }
+                self.PurgeStaleItems();
+                if (self.Count > 0 && self.purgingTimer != null)
+                {
+                    self.purgingTimer.Set(self.purgeInterval);
+                }
+            }
+            finally
+            {
+                if (lockHeld)
+                {
+                    self.cacheLock.ReleaseWriterLock();
+                }
+            }
+        }
+
+        internal interface IExpirableItem
+        {
+            DateTime ExpirationTime { get; }
+        }
+
+        internal class ExpirableItemComparer : IComparer<IExpirableItem>
+        {
+            static ExpirableItemComparer instance;
+
+            public static ExpirableItemComparer Default
+            {
+                get
+                {
+                    if (instance == null)
+                    {
+                        instance = new ExpirableItemComparer();
+                    }
+                    return instance;
+                }
+            }
+
+            // positive, if item1 will expire before item2. 
+            public int Compare(IExpirableItem item1, IExpirableItem item2)
+            {
+                if (ReferenceEquals(item1, item2))
+                {
+                    return 0;
+                }
+                Fx.Assert(item1.ExpirationTime.Kind == item2.ExpirationTime.Kind, "");
+                if (item1.ExpirationTime < item2.ExpirationTime)
+                {
+                    return 1;
+                }
+                else if (item1.ExpirationTime > item2.ExpirationTime)
+                {
+                    return -1;
+                }
+                else
+                {
+                    return 0;
+                }
+            }
+        }
+
+        internal sealed class ExpirableItem : IExpirableItem
+        {
+            DateTime expirationTime;
+            object item;
+
+            public ExpirableItem(object item, DateTime expirationTime)
+            {
+                this.item = item;
+                Fx.Assert( expirationTime == DateTime.MaxValue || expirationTime.Kind == DateTimeKind.Utc, "");
+                this.expirationTime = expirationTime;
+            }
+
+            public DateTime ExpirationTime { get { return this.expirationTime; } }
+            public object Item { get { return this.item; } }
+        }
+    }
+
+    enum PurgingMode
+    {
+        TimerBasedPurge,
+        AccessBasedPurge
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/Tokens/BinarySecretSecurityToken.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/Tokens/BinarySecretSecurityToken.cs
new file mode 100644
index 0000000..d549f66
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/Tokens/BinarySecretSecurityToken.cs
@@ -0,0 +1,92 @@
+using System.Collections.ObjectModel;
+using CoreWCF.IdentityModel;
+using CoreWCF.IdentityModel.Tokens;
+using System.Runtime.CompilerServices;
+using System;
+
+namespace CoreWCF.Security.Tokens
+{
+
+    public class BinarySecretSecurityToken : SecurityToken
+    {
+        private string _id;
+        private DateTime _effectiveTime;
+        private byte[] _key;
+        private ReadOnlyCollection<SecurityKey> _securityKeys;
+
+        public BinarySecretSecurityToken(int keySizeInBits)
+            : this(SecurityUniqueId.Create().Value, keySizeInBits)
+        {
+        }
+
+        public BinarySecretSecurityToken(string id, int keySizeInBits)
+            : this(id, keySizeInBits, true)
+        {
+        }
+
+        public BinarySecretSecurityToken(byte[] key)
+            : this(SecurityUniqueId.Create().Value, key)
+        {
+        }
+
+        public BinarySecretSecurityToken(string id, byte[] key)
+            : this(id, key, true)
+        {
+        }
+
+        protected BinarySecretSecurityToken(string id, int keySizeInBits, bool allowCrypto)
+        {
+            throw new NotImplementedException();
+        }
+
+        protected BinarySecretSecurityToken(string id, byte[] key, bool allowCrypto)
+        {
+            if (key == null)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("key");
+
+            _id = id;
+            _effectiveTime = DateTime.UtcNow;
+            _key = new byte[key.Length];
+            Buffer.BlockCopy(key, 0, _key, 0, key.Length);
+            if (allowCrypto)
+            {
+                _securityKeys = SecurityUtils.CreateSymmetricSecurityKeys(_key);
+            }
+            else
+            {
+                _securityKeys = EmptyReadOnlyCollection<SecurityKey>.Instance;
+            }
+        }
+
+        public override string Id
+        {
+            get { return _id; }
+        }
+
+        public override DateTime ValidFrom
+        {
+            get { return _effectiveTime; }
+        }
+
+        public override DateTime ValidTo
+        {
+            // Never expire
+            get { return DateTime.MaxValue; }
+        }
+
+        public int KeySize
+        {
+            get { return (_key.Length * 8); }
+        }
+
+        public override ReadOnlyCollection<SecurityKey> SecurityKeys
+        {
+            get { return _securityKeys; }
+        }
+
+        public byte[] GetKeyBytes()
+        {
+            return SecurityUtils.CloneBuffer(_key);
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/Tokens/BufferedGenericXmlSecurityToken.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/Tokens/BufferedGenericXmlSecurityToken.cs
new file mode 100644
index 0000000..36e5418
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/Tokens/BufferedGenericXmlSecurityToken.cs
@@ -0,0 +1,29 @@
+﻿using System.Collections.ObjectModel;
+using CoreWCF.IdentityModel.Policy;
+using CoreWCF.IdentityModel.Tokens;
+using System.Xml;
+using System;
+using CoreWCF.IdentityModel;
+
+namespace CoreWCF.Security.Tokens
+{
+    internal class BufferedGenericXmlSecurityToken : GenericXmlSecurityToken
+    {
+        public BufferedGenericXmlSecurityToken(
+            XmlElement tokenXml,
+            SecurityToken proofToken,
+            DateTime effectiveTime,
+            DateTime expirationTime,
+            SecurityKeyIdentifierClause internalTokenReference,
+            SecurityKeyIdentifierClause externalTokenReference,
+            ReadOnlyCollection<IAuthorizationPolicy> authorizationPolicies,
+            IdentityModel.XmlBuffer tokenXmlBuffer
+            )
+            : base(tokenXml, proofToken, effectiveTime, expirationTime, internalTokenReference, externalTokenReference, authorizationPolicies)
+        {
+            TokenXmlBuffer = tokenXmlBuffer;
+        }
+
+        public IdentityModel.XmlBuffer TokenXmlBuffer { get; }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/Tokens/DerivedKeySecurityTokenStub.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/Tokens/DerivedKeySecurityTokenStub.cs
new file mode 100644
index 0000000..bfa9720
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/Tokens/DerivedKeySecurityTokenStub.cs
@@ -0,0 +1,70 @@
+﻿using CoreWCF.IdentityModel;
+using CoreWCF.IdentityModel.Tokens;
+using System;
+using System.Collections.Generic;
+using System.Collections.ObjectModel;
+using System.Text;
+
+namespace CoreWCF.Security.Tokens
+{
+    sealed class DerivedKeySecurityTokenStub : SecurityToken
+    {
+        string id;
+        string derivationAlgorithm;
+        string label;
+        int length;
+        byte[] nonce;
+        int offset;
+        int generation;
+        SecurityKeyIdentifierClause tokenToDeriveIdentifier;
+
+        public DerivedKeySecurityTokenStub(int generation, int offset, int length,
+            string label, byte[] nonce,
+            SecurityKeyIdentifierClause tokenToDeriveIdentifier, string derivationAlgorithm, string id)
+        {
+            this.id = id;
+            this.generation = generation;
+            this.offset = offset;
+            this.length = length;
+            this.label = label;
+            this.nonce = nonce;
+            this.tokenToDeriveIdentifier = tokenToDeriveIdentifier;
+            this.derivationAlgorithm = derivationAlgorithm;
+        }
+
+        public override string Id
+        {
+            get { return this.id; }
+        }
+
+        public override DateTime ValidFrom
+        {
+#pragma warning suppress 56503 // Property does not make sense for Derived Key tokens.
+            get { throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new NotImplementedException()); }
+        }
+
+        public override DateTime ValidTo
+        {
+#pragma warning suppress 56503 // Property does not make sense for Derived Key tokens.
+            get { throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new NotImplementedException()); }
+        }
+
+        public override ReadOnlyCollection<SecurityKey> SecurityKeys
+        {
+            get { return null; }
+        }
+
+        public SecurityKeyIdentifierClause TokenToDeriveIdentifier
+        {
+            get { return this.tokenToDeriveIdentifier; }
+        }
+
+        public DerivedKeySecurityToken CreateToken(SecurityToken tokenToDerive, int maxKeyLength)
+        {
+            DerivedKeySecurityToken result = new DerivedKeySecurityToken(this.generation, this.offset, this.length,
+                this.label, this.nonce, tokenToDerive, this.tokenToDeriveIdentifier, this.derivationAlgorithm, this.Id);
+            result.InitializeDerivedKey(maxKeyLength);
+            return result;
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/Tokens/IIssuanceSecurityTokenAuthenticator.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/Tokens/IIssuanceSecurityTokenAuthenticator.cs
new file mode 100644
index 0000000..f068fa9
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/Tokens/IIssuanceSecurityTokenAuthenticator.cs
@@ -0,0 +1,18 @@
+using System;
+using System.Xml;
+using CoreWCF.IdentityModel.Tokens;
+
+namespace CoreWCF.Security.Tokens
+{
+
+
+    public delegate void IssuedSecurityTokenHandler(SecurityToken issuedToken, EndpointAddress tokenRequestor);
+    public delegate void RenewedSecurityTokenHandler(SecurityToken newSecurityToken, SecurityToken oldSecurityToken);
+
+    public interface IIssuanceSecurityTokenAuthenticator
+    {
+        IssuedSecurityTokenHandler IssuedSecurityTokenHandler { get; set; }
+        RenewedSecurityTokenHandler RenewedSecurityTokenHandler { get; set; }
+    }
+
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/Tokens/ISecurityContextSecurityTokenCache.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/Tokens/ISecurityContextSecurityTokenCache.cs
new file mode 100644
index 0000000..bdf429c
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/Tokens/ISecurityContextSecurityTokenCache.cs
@@ -0,0 +1,19 @@
+
+namespace CoreWCF.Security.Tokens
+{
+    using System;
+    using System.Xml;
+    using System.Collections.ObjectModel;
+
+    public interface ISecurityContextSecurityTokenCache 
+    {
+        void AddContext(SecurityContextSecurityToken token);
+        bool TryAddContext(SecurityContextSecurityToken token);
+        void ClearContexts();
+        void RemoveContext(UniqueId contextId, UniqueId generation);
+        void RemoveAllContexts(UniqueId contextId);
+        SecurityContextSecurityToken GetContext(UniqueId contextId, UniqueId generation);
+        Collection<SecurityContextSecurityToken> GetAllContexts(UniqueId contextId);
+        void UpdateContextCachingTime(SecurityContextSecurityToken context, DateTime expirationTime);
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/Tokens/InitiatorServiceModelSecurityTokenRequirement.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/Tokens/InitiatorServiceModelSecurityTokenRequirement.cs
index 3872da8..fae1e31 100644
--- a/src/CoreWCF.Primitives/src/CoreWCF/Security/Tokens/InitiatorServiceModelSecurityTokenRequirement.cs
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/Tokens/InitiatorServiceModelSecurityTokenRequirement.cs
@@ -4,7 +4,7 @@ using System.Text;
 
 namespace CoreWCF.Security.Tokens
 {
-    internal sealed class InitiatorServiceModelSecurityTokenRequirement : ServiceModelSecurityTokenRequirement
+    public sealed class InitiatorServiceModelSecurityTokenRequirement : ServiceModelSecurityTokenRequirement
     {
         //WebHeaderCollection webHeaderCollection;
 
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/Tokens/ProviderBackedSecurityToken.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/Tokens/ProviderBackedSecurityToken.cs
new file mode 100644
index 0000000..9d891e7
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/Tokens/ProviderBackedSecurityToken.cs
@@ -0,0 +1,154 @@
+using System;
+using System.Collections.Generic;
+using CoreWCF.IdentityModel.Selectors;
+using CoreWCF.IdentityModel.Tokens;
+using CoreWCF.Runtime;
+using System.Security.Cryptography;
+using System.Security.Authentication.ExtendedProtection;
+using CoreWCF.Diagnostics;
+
+namespace CoreWCF.Security.Tokens
+{
+    /// <summary>
+    /// The ProviderBackedSecurityToken was added for the ChannelBindingToken work for Win7.  
+    /// It is used to delay the resolution of a token until it is needed.  
+    /// For the CBT, this delay is necessary as the CBT is not available until SecurityAppliedMessage.OnWriteMessage is called.
+    /// The CBT binds a token to the 
+    /// </summary>
+    internal class ProviderBackedSecurityToken : SecurityToken
+    {
+        SecurityTokenProvider _tokenProvider;
+
+        // Double-checked locking pattern requires volatile for read/write synchronization
+        volatile SecurityToken _securityToken;
+        TimeSpan _timeout;
+        ChannelBinding _channelBinding;
+
+        object _lock;
+
+        /// <summary>
+        /// Constructor to create an instance of this class.
+        /// </summary>
+        /// <param name="securityToken">SecurityToken that represents the SecurityTokenElement element.</param>
+        public ProviderBackedSecurityToken( SecurityTokenProvider tokenProvider, TimeSpan timeout )
+        {
+            _lock = new object();
+
+            if ( tokenProvider == null )
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException("tokenProvider"));
+            }
+
+            _tokenProvider = tokenProvider;
+            _timeout = timeout;
+        }
+
+        public SecurityTokenProvider TokenProvider
+        {
+            get { return _tokenProvider; }
+        }
+
+        public ChannelBinding ChannelBinding
+        {
+            set { _channelBinding = value; }
+        }
+
+        void ResolveSecurityToken()
+        {
+            throw new NotImplementedException();
+            //TODO
+            //if ( _securityToken == null )
+            //{
+            //    lock ( _lock )
+            //    {
+            //        if ( _securityToken == null )
+            //        {
+                        
+            //            ClientCredentialsSecurityTokenManager.KerberosSecurityTokenProviderWrapper kerbTokenProvider = _tokenProvider 
+            //                                            as ClientCredentialsSecurityTokenManager.KerberosSecurityTokenProviderWrapper;
+            //            if (kerbTokenProvider != null)
+            //            {
+            //                _securityToken = kerbTokenProvider.GetToken((new TimeoutHelper(_timeout)).RemainingTime(), _channelBinding);
+            //            }
+            //            else
+            //            {
+            //                _securityToken = _tokenProvider.GetToken((new TimeoutHelper(_timeout)).RemainingTime());
+            //            }
+            //        }
+            //    }
+            //}
+
+            //if ( _securityToken == null )
+            //{
+            //    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError( new SecurityTokenException( SR.Format( SR.SecurityTokenNotResolved, _tokenProvider.GetType().ToString() ) ) );
+            //}
+
+            //return;
+        }
+
+        public SecurityToken Token
+        {
+            get
+            {
+                if ( _securityToken == null )
+                {
+                    ResolveSecurityToken();
+                }
+
+                return _securityToken;
+            }
+        }
+
+        public override string Id
+        {
+            get
+            {
+                if ( _securityToken == null )
+                {
+                    ResolveSecurityToken();
+                }
+
+                return _securityToken.Id;
+            }
+        }
+
+        public override System.Collections.ObjectModel.ReadOnlyCollection<SecurityKey> SecurityKeys
+        {
+            get
+            {
+                if ( _securityToken == null )
+                {
+                    ResolveSecurityToken();
+                }
+
+                return _securityToken.SecurityKeys;
+            }   
+        }
+
+        public override DateTime ValidFrom
+        {
+            get
+            {
+                if ( _securityToken == null )
+                {
+                    ResolveSecurityToken();
+                }
+
+                return _securityToken.ValidFrom;
+            }
+        }
+
+        public override DateTime ValidTo
+        {
+            get
+            {
+                if ( _securityToken == null )
+                {
+                    ResolveSecurityToken();
+                }
+
+                return _securityToken.ValidTo;
+            }   
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/Tokens/RecipientServiceModelSecurityTokenRequirement.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/Tokens/RecipientServiceModelSecurityTokenRequirement.cs
index 373cd84..e0e725e 100644
--- a/src/CoreWCF.Primitives/src/CoreWCF/Security/Tokens/RecipientServiceModelSecurityTokenRequirement.cs
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/Tokens/RecipientServiceModelSecurityTokenRequirement.cs
@@ -4,7 +4,7 @@ using System.Text;
 
 namespace CoreWCF.Security.Tokens
 {
-    internal sealed class RecipientServiceModelSecurityTokenRequirement : ServiceModelSecurityTokenRequirement
+    public sealed class RecipientServiceModelSecurityTokenRequirement : ServiceModelSecurityTokenRequirement
     {
         public RecipientServiceModelSecurityTokenRequirement()
             : base()
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/Tokens/SecureConversationSecurityTokenParameters.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/Tokens/SecureConversationSecurityTokenParameters.cs
new file mode 100644
index 0000000..a88bc6b
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/Tokens/SecureConversationSecurityTokenParameters.cs
@@ -0,0 +1,223 @@
+using CoreWCF.IdentityModel.Tokens;
+using CoreWCF.Channels;
+using CoreWCF.IdentityModel.Selectors;
+using CoreWCF;
+using CoreWCF.Security;
+
+using System.Text;
+using System.Globalization;
+using System;
+using CoreWCF.IdentityModel;
+
+namespace CoreWCF.Security.Tokens
+{
+    public class SecureConversationSecurityTokenParameters : SecurityTokenParameters
+    {
+        internal const bool defaultRequireCancellation = true;
+        internal const bool defaultCanRenewSession = true;
+
+        SecurityBindingElement bootstrapSecurityBindingElement;
+        ChannelProtectionRequirements bootstrapProtectionRequirements;
+        bool requireCancellation;
+        bool canRenewSession = defaultCanRenewSession;
+        BindingContext issuerBindingContext;
+
+        protected SecureConversationSecurityTokenParameters(SecureConversationSecurityTokenParameters other)
+            : base(other)
+        {
+            this.requireCancellation = other.requireCancellation;
+            this.canRenewSession = other.canRenewSession;
+            if (other.bootstrapSecurityBindingElement != null)
+                this.bootstrapSecurityBindingElement = (SecurityBindingElement)other.bootstrapSecurityBindingElement.Clone();
+            if (other.bootstrapProtectionRequirements != null)
+                this.bootstrapProtectionRequirements = new ChannelProtectionRequirements(other.bootstrapProtectionRequirements);
+            if (other.issuerBindingContext != null)
+                this.issuerBindingContext = other.issuerBindingContext.Clone();
+        }
+
+        public SecureConversationSecurityTokenParameters()
+            : this(null, defaultRequireCancellation, null)
+        {
+            // empty
+        }
+
+        public SecureConversationSecurityTokenParameters(SecurityBindingElement bootstrapSecurityBindingElement)
+            : this(bootstrapSecurityBindingElement, defaultRequireCancellation, null)
+        {
+            // empty
+        }
+
+        public SecureConversationSecurityTokenParameters(SecurityBindingElement bootstrapSecurityBindingElement, bool requireCancellation)
+            : this(bootstrapSecurityBindingElement, requireCancellation, true)
+        {
+            // empty
+        }
+
+        public SecureConversationSecurityTokenParameters(SecurityBindingElement bootstrapSecurityBindingElement, bool requireCancellation, bool canRenewSession)
+            : this(bootstrapSecurityBindingElement, requireCancellation, canRenewSession, null)
+        {
+            // empty
+        }
+
+        public SecureConversationSecurityTokenParameters(SecurityBindingElement bootstrapSecurityBindingElement, bool requireCancellation, ChannelProtectionRequirements bootstrapProtectionRequirements)
+            : this(bootstrapSecurityBindingElement, requireCancellation, defaultCanRenewSession, null)
+        {
+            // empty
+        }
+
+        public SecureConversationSecurityTokenParameters(SecurityBindingElement bootstrapSecurityBindingElement, bool requireCancellation, bool canRenewSession, ChannelProtectionRequirements bootstrapProtectionRequirements)
+            : base()
+        {
+            this.bootstrapSecurityBindingElement = bootstrapSecurityBindingElement;
+            this.canRenewSession = canRenewSession;
+            if (bootstrapProtectionRequirements != null)
+                this.bootstrapProtectionRequirements = new ChannelProtectionRequirements(bootstrapProtectionRequirements);
+            else
+            {
+                this.bootstrapProtectionRequirements = new ChannelProtectionRequirements();
+                this.bootstrapProtectionRequirements.IncomingEncryptionParts.AddParts(new MessagePartSpecification(true));
+                this.bootstrapProtectionRequirements.IncomingSignatureParts.AddParts(new MessagePartSpecification(true));
+                this.bootstrapProtectionRequirements.OutgoingEncryptionParts.AddParts(new MessagePartSpecification(true));
+                this.bootstrapProtectionRequirements.OutgoingSignatureParts.AddParts(new MessagePartSpecification(true));
+            }
+            this.requireCancellation = requireCancellation;
+        }
+
+        internal protected override bool HasAsymmetricKey { get { return false; } }
+
+        public SecurityBindingElement BootstrapSecurityBindingElement
+        {
+            get
+            {
+                return this.bootstrapSecurityBindingElement;
+            }
+            set
+            {
+                this.bootstrapSecurityBindingElement = value;
+            }
+        }
+
+        public ChannelProtectionRequirements BootstrapProtectionRequirements
+        {
+            get
+            {
+                return this.bootstrapProtectionRequirements;
+            }
+        }
+
+        internal BindingContext IssuerBindingContext
+        {
+            get
+            {
+                return this.issuerBindingContext;
+            }
+            set
+            {
+                if (value != null)
+                {
+                    value = value.Clone();
+                }
+                this.issuerBindingContext = value;
+            }
+        }
+
+        ISecurityCapabilities BootstrapSecurityCapabilities
+        {
+            get
+            {
+                return this.bootstrapSecurityBindingElement.GetIndividualProperty<ISecurityCapabilities>();
+            }
+        }
+
+        public bool RequireCancellation
+        {
+            get
+            {
+                return this.requireCancellation;
+            }
+            set
+            {
+                this.requireCancellation = value;
+            }
+        }
+
+        public bool CanRenewSession
+        {
+            get
+            {
+                return this.canRenewSession;
+            }
+            set
+            {
+                this.canRenewSession = value;
+            }
+        }
+
+        internal protected override bool SupportsClientAuthentication
+        {
+            get
+            {
+                return this.BootstrapSecurityCapabilities == null ? false : this.BootstrapSecurityCapabilities.SupportsClientAuthentication;
+            }
+        }
+
+        internal protected override bool SupportsServerAuthentication
+        {
+            get
+            {
+                return this.BootstrapSecurityCapabilities == null ? false : this.BootstrapSecurityCapabilities.SupportsServerAuthentication;
+            }
+        }
+
+        internal protected override bool SupportsClientWindowsIdentity
+        {
+            get
+            {
+                return this.BootstrapSecurityCapabilities == null ? false : this.BootstrapSecurityCapabilities.SupportsClientWindowsIdentity;
+            }
+        }
+
+        protected override SecurityTokenParameters CloneCore()
+        {
+            return new SecureConversationSecurityTokenParameters(this);
+        }
+
+        internal protected override SecurityKeyIdentifierClause CreateKeyIdentifierClause(SecurityToken token, SecurityTokenReferenceStyle referenceStyle)
+        {
+            if (token is GenericXmlSecurityToken)
+                return base.CreateGenericXmlTokenKeyIdentifierClause(token, referenceStyle);
+            else
+                return this.CreateKeyIdentifierClause<SecurityContextKeyIdentifierClause, LocalIdKeyIdentifierClause>(token, referenceStyle);
+        }
+
+        protected internal override void InitializeSecurityTokenRequirement(SecurityTokenRequirement requirement)
+        {
+            requirement.TokenType = ServiceModelSecurityTokenTypes.SecureConversation;
+            requirement.KeyType = SecurityKeyType.SymmetricKey;
+            requirement.RequireCryptographicToken = true;
+            requirement.Properties[ServiceModelSecurityTokenRequirement.SupportSecurityContextCancellationProperty] = this.RequireCancellation;
+            requirement.Properties[ServiceModelSecurityTokenRequirement.SecureConversationSecurityBindingElementProperty] = this.BootstrapSecurityBindingElement;
+            requirement.Properties[ServiceModelSecurityTokenRequirement.IssuerBindingContextProperty] = this.IssuerBindingContext.Clone();
+            requirement.Properties[ServiceModelSecurityTokenRequirement.IssuedSecurityTokenParametersProperty] = this.Clone();
+        }
+
+        public override string ToString()
+        {
+            StringBuilder sb = new StringBuilder();
+            sb.AppendLine(base.ToString());
+
+            sb.AppendLine(String.Format(CultureInfo.InvariantCulture, "RequireCancellation: {0}", this.requireCancellation.ToString()));
+            if (this.bootstrapSecurityBindingElement == null)
+            {
+                sb.AppendLine(String.Format(CultureInfo.InvariantCulture, "BootstrapSecurityBindingElement: null"));
+            }
+            else
+            {
+                sb.AppendLine(String.Format(CultureInfo.InvariantCulture, "BootstrapSecurityBindingElement:"));
+                sb.AppendLine("  " + this.BootstrapSecurityBindingElement.ToString().Trim().Replace("\n", "\n  "));
+            }
+
+            return sb.ToString().Trim();
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/Tokens/SecurityContextSecurityToken.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/Tokens/SecurityContextSecurityToken.cs
new file mode 100644
index 0000000..3001476
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/Tokens/SecurityContextSecurityToken.cs
@@ -0,0 +1,352 @@
+using System;
+using System.Collections.Generic;
+using System.Collections.ObjectModel;
+using System.Globalization;
+using CoreWCF.IdentityModel.Policy;
+using CoreWCF.IdentityModel.Tokens;
+using System.Xml;
+using CoreWCF.IdentityModel;
+
+namespace CoreWCF.Security.Tokens
+{
+
+    public class SecurityContextSecurityToken : SecurityToken, IDisposable , TimeBoundedCache.IExpirableItem
+    {
+        byte[] cookieBlob;
+        UniqueId contextId = null;
+        UniqueId keyGeneration = null;
+        DateTime keyEffectiveTime;
+        DateTime keyExpirationTime;
+        DateTime tokenEffectiveTime;
+        DateTime tokenExpirationTime;
+        bool isCookieMode = false;
+        byte[] key;
+        string keyString;
+        ReadOnlyCollection<IAuthorizationPolicy> authorizationPolicies;
+        ReadOnlyCollection<SecurityKey> securityKeys;
+        string id;
+        SecurityMessageProperty bootstrapMessageProperty;
+        bool disposed = false;
+
+        public SecurityContextSecurityToken(UniqueId contextId, byte[] key, DateTime validFrom, DateTime validTo)
+            : this(contextId, SecurityUtils.GenerateId(), key, validFrom, validTo)
+        { }
+
+        public SecurityContextSecurityToken(UniqueId contextId, string id, byte[] key, DateTime validFrom, DateTime validTo)
+            : this(contextId, id, key, validFrom, validTo, null)
+        { }
+
+        public SecurityContextSecurityToken(UniqueId contextId, string id, byte[] key, DateTime validFrom, DateTime validTo, ReadOnlyCollection<IAuthorizationPolicy> authorizationPolicies)
+            : base()
+        {
+            this.id = id;
+            this.Initialize(contextId, key, validFrom, validTo, authorizationPolicies, false, null, validFrom, validTo);
+        }
+
+        public SecurityContextSecurityToken(UniqueId contextId, string id, byte[] key, DateTime validFrom, DateTime validTo, UniqueId keyGeneration, DateTime keyEffectiveTime, DateTime keyExpirationTime, ReadOnlyCollection<IAuthorizationPolicy> authorizationPolicies)
+            : base()
+        {
+            this.id = id;
+            this.Initialize(contextId, key, validFrom, validTo, authorizationPolicies, false, keyGeneration, keyEffectiveTime, keyExpirationTime);
+        }
+
+        internal SecurityContextSecurityToken(SecurityContextSecurityToken sourceToken, string id)
+            : this(sourceToken, id, sourceToken.key, sourceToken.keyGeneration, sourceToken.keyEffectiveTime, sourceToken.keyExpirationTime, sourceToken.AuthorizationPolicies)
+        {
+        }
+
+        internal SecurityContextSecurityToken(SecurityContextSecurityToken sourceToken, string id, byte[] key, UniqueId keyGeneration, DateTime keyEffectiveTime, DateTime keyExpirationTime, ReadOnlyCollection<IAuthorizationPolicy> authorizationPolicies)
+            : base()
+        {
+            this.id = id;
+            this.Initialize(sourceToken.contextId, key, sourceToken.ValidFrom, sourceToken.ValidTo, authorizationPolicies, sourceToken.isCookieMode, keyGeneration, keyEffectiveTime, keyExpirationTime);
+            this.cookieBlob = sourceToken.cookieBlob;
+            this.bootstrapMessageProperty = (sourceToken.bootstrapMessageProperty == null) ? null : (SecurityMessageProperty)sourceToken.BootstrapMessageProperty.CreateCopy();
+        }
+
+        internal SecurityContextSecurityToken(UniqueId contextId, string id, byte[] key, DateTime validFrom, DateTime validTo, ReadOnlyCollection<IAuthorizationPolicy> authorizationPolicies, bool isCookieMode, byte[] cookieBlob)
+            : this(contextId, id, key, validFrom, validTo, authorizationPolicies, isCookieMode, cookieBlob, null, validFrom, validTo)
+        {
+        }
+
+        internal SecurityContextSecurityToken(UniqueId contextId, string id, byte[] key, DateTime validFrom, DateTime validTo, ReadOnlyCollection<IAuthorizationPolicy> authorizationPolicies, bool isCookieMode, byte[] cookieBlob,
+            UniqueId keyGeneration, DateTime keyEffectiveTime, DateTime keyExpirationTime)
+            : base()
+        {
+            this.id = id;
+            this.Initialize(contextId, key, validFrom, validTo, authorizationPolicies, isCookieMode, keyGeneration, keyEffectiveTime, keyExpirationTime);
+            this.cookieBlob = cookieBlob;
+        }
+
+        SecurityContextSecurityToken(SecurityContextSecurityToken from)
+        {
+            ReadOnlyCollection<IAuthorizationPolicy> authorizationPolicies = SecurityUtils.CloneAuthorizationPoliciesIfNecessary(from.authorizationPolicies);
+            this.id = from.id;
+            this.Initialize(from.contextId, from.key, from.tokenEffectiveTime, from.tokenExpirationTime, authorizationPolicies, from.isCookieMode, from.keyGeneration, from.keyEffectiveTime, from.keyExpirationTime);
+            this.cookieBlob = from.cookieBlob;
+            this.bootstrapMessageProperty = (from.bootstrapMessageProperty == null) ? null : (SecurityMessageProperty)from.BootstrapMessageProperty.CreateCopy();
+        }
+
+        /// <summary>
+        /// Gets or Sets the SecurityMessageProperty extracted from 
+        /// the Bootstrap message. This will contain the original tokens
+        /// that the client used to Authenticate with the service. By 
+        /// default, this is turned off. To turn this feature on, add a custom 
+        /// ServiceCredentialsSecurityTokenManager and override  
+        /// CreateSecurityTokenManager. Create the SecurityContextToken Authenticator by calling 
+        /// ServiceCredentialsSecurityTokenManager.CreateSecureConversationTokenAuthenticator
+        /// with 'preserveBootstrapTokens' parameter to true. 
+        /// If there are any UserNameSecurityToken in the bootstrap message, the password in
+        /// these tokens will be removed. When 'Cookie' mode SCT is enabled the BootstrapMessageProperty
+        /// is not preserved in the Cookie. To preserve the bootstrap tokens in the CookieMode case
+        /// write a custom Serializer and serialize the property as part of the cookie.
+        /// </summary>
+        public SecurityMessageProperty BootstrapMessageProperty
+        {
+            get
+            {
+                return this.bootstrapMessageProperty;
+            }
+            set
+            {
+                this.bootstrapMessageProperty = value;
+            }
+        }
+
+        public override string Id
+        {
+            get { return this.id; }
+        }
+
+        public UniqueId ContextId
+        {
+            get
+            {
+                return this.contextId;
+            }
+        }
+
+        public UniqueId KeyGeneration
+        {
+            get
+            {
+                return this.keyGeneration;
+            }
+        }
+
+        public DateTime KeyEffectiveTime
+        {
+            get 
+            { 
+                return this.keyEffectiveTime; 
+            }
+        }
+
+        public DateTime KeyExpirationTime
+        {
+            get 
+            { 
+                return this.keyExpirationTime; 
+            }
+        }
+
+        public ReadOnlyCollection<IAuthorizationPolicy> AuthorizationPolicies
+        {
+            get
+            {
+                ThrowIfDisposed();
+                return this.authorizationPolicies;
+            }
+            
+            internal set
+            {
+                this.authorizationPolicies = value;
+            }
+        }
+
+        public override ReadOnlyCollection<SecurityKey> SecurityKeys
+        {
+            get
+            {
+                return this.securityKeys;
+            }
+        }
+
+        public override DateTime ValidFrom
+        {
+            get { return this.tokenEffectiveTime; }
+        }
+
+        public override DateTime ValidTo
+        {
+            get { return this.tokenExpirationTime; }
+        }
+
+        internal byte[] CookieBlob
+        {
+            get
+            {
+                return this.cookieBlob;
+            }
+        }
+
+        /// <summary>
+        /// This is set by the issuer when creating the SCT to be sent in the RSTR
+        /// The SecurityContextTokenManager examines this property to determine how to write
+        /// out the SCT
+        /// This field is set to true when the issuer reads in a cookie mode SCT
+        /// </summary>
+        public bool IsCookieMode
+        {
+            get
+            {
+                return this.isCookieMode;
+            }
+        }
+
+        DateTime TimeBoundedCache.IExpirableItem.ExpirationTime
+        {
+            get
+            {
+                return this.ValidTo;
+            }
+        }
+
+        internal string GetBase64KeyString()
+        {
+            if (this.keyString == null)
+            {
+                this.keyString = Convert.ToBase64String(this.key);
+            }
+            return this.keyString;
+        }
+
+        internal byte[] GetKeyBytes()
+        {
+            byte[] retval = new byte[this.key.Length];
+            Buffer.BlockCopy(this.key, 0, retval, 0, this.key.Length);
+            return retval;
+        }
+
+        public override string ToString()
+        {
+            return String.Format(CultureInfo.CurrentCulture, "SecurityContextSecurityToken(Identifier='{0}', KeyGeneration='{1}')", this.contextId, this.keyGeneration);
+        }
+
+        void Initialize(UniqueId contextId, byte[] key, DateTime validFrom, DateTime validTo, ReadOnlyCollection<IAuthorizationPolicy> authorizationPolicies, bool isCookieMode,
+            UniqueId keyGeneration, DateTime keyEffectiveTime, DateTime keyExpirationTime)
+        {
+            if (contextId == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("contextId");
+            }
+
+            if (key == null || key.Length == 0)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("key");
+            }
+
+            DateTime tokenEffectiveTimeUtc = validFrom.ToUniversalTime();
+            DateTime tokenExpirationTimeUtc = validTo.ToUniversalTime();
+            if (tokenEffectiveTimeUtc > tokenExpirationTimeUtc)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgument("validFrom", SR.Format(SR.EffectiveGreaterThanExpiration));
+            }
+            this.tokenEffectiveTime = tokenEffectiveTimeUtc;
+            this.tokenExpirationTime = tokenExpirationTimeUtc;
+
+            this.keyEffectiveTime = keyEffectiveTime.ToUniversalTime();
+            this.keyExpirationTime = keyExpirationTime.ToUniversalTime();
+            if (this.keyEffectiveTime > this.keyExpirationTime)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgument("keyEffectiveTime", SR.Format(SR.EffectiveGreaterThanExpiration));
+            }
+            if ((this.keyEffectiveTime < tokenEffectiveTimeUtc) || (this.keyExpirationTime > tokenExpirationTimeUtc))
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgument(SR.Format(SR.KeyLifetimeNotWithinTokenLifetime));
+            }
+
+            this.key = new byte[key.Length];
+            Buffer.BlockCopy(key, 0, this.key, 0, key.Length);
+            this.contextId = contextId;
+            this.keyGeneration = keyGeneration;
+            this.authorizationPolicies = authorizationPolicies ?? EmptyReadOnlyCollection<IAuthorizationPolicy>.Instance;
+            List<SecurityKey> temp = new List<SecurityKey>(1);
+            temp.Add(new InMemorySymmetricSecurityKey(this.key, false));
+            this.securityKeys = temp.AsReadOnly();
+            this.isCookieMode = isCookieMode;
+        }
+
+        public override bool CanCreateKeyIdentifierClause<T>()
+        {
+            if (typeof(T) == typeof(SecurityContextKeyIdentifierClause))
+                return true;
+
+            return base.CanCreateKeyIdentifierClause<T>();
+        }
+
+        public override T CreateKeyIdentifierClause<T>()
+        {
+            if (typeof(T) == typeof(SecurityContextKeyIdentifierClause))
+                return new SecurityContextKeyIdentifierClause(this.contextId, this.keyGeneration) as T;
+
+            return base.CreateKeyIdentifierClause<T>();
+        }
+
+        public override bool MatchesKeyIdentifierClause(SecurityKeyIdentifierClause keyIdentifierClause)
+        {
+            SecurityContextKeyIdentifierClause sctKeyIdentifierClause = keyIdentifierClause as SecurityContextKeyIdentifierClause;
+            if (sctKeyIdentifierClause != null)
+                return sctKeyIdentifierClause.Matches(this.contextId, this.keyGeneration);
+
+            return base.MatchesKeyIdentifierClause(keyIdentifierClause);
+        }
+
+        /*
+        public static SecurityContextSecurityToken CreateCookieSecurityContextToken(UniqueId contextId, string id, byte[] key,
+            DateTime validFrom, DateTime validTo, ReadOnlyCollection<IAuthorizationPolicy> authorizationPolicies, SecurityStateEncoder securityStateEncoder)
+        {
+            return CreateCookieSecurityContextToken(contextId, id, key, validFrom, validTo, null, validFrom, validTo, authorizationPolicies, securityStateEncoder);
+        }
+
+
+        public static SecurityContextSecurityToken CreateCookieSecurityContextToken(UniqueId contextId, string id, byte[] key,
+            DateTime validFrom, DateTime validTo, UniqueId keyGeneration, DateTime keyEffectiveTime,
+            DateTime keyExpirationTime, ReadOnlyCollection<IAuthorizationPolicy> authorizationPolicies, SecurityStateEncoder securityStateEncoder)
+        {
+            SecurityContextCookieSerializer cookieSerializer = new SecurityContextCookieSerializer(securityStateEncoder, null);
+            byte[] cookieBlob = cookieSerializer.CreateCookieFromSecurityContext(contextId, id, key, validFrom, validTo, keyGeneration,
+                                keyEffectiveTime, keyExpirationTime, authorizationPolicies);
+
+            return new SecurityContextSecurityToken(contextId, id, key, validFrom, validTo,
+                authorizationPolicies, true, cookieBlob, keyGeneration, keyEffectiveTime, keyExpirationTime);
+        }*/
+
+        internal SecurityContextSecurityToken Clone()
+        {
+            ThrowIfDisposed();
+            return new SecurityContextSecurityToken(this);
+        }
+
+        public void Dispose()
+        {
+            if (!this.disposed)
+            {
+                this.disposed = true;
+                SecurityUtils.DisposeAuthorizationPoliciesIfNecessary(this.authorizationPolicies);
+                if (this.bootstrapMessageProperty != null)
+                {
+                    this.bootstrapMessageProperty.Dispose();
+                }
+            }
+        }
+
+        void ThrowIfDisposed()
+        {
+            if (this.disposed)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ObjectDisposedException(this.GetType().FullName));
+            }
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/Tokens/SecurityContextSecurityTokenParameters.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/Tokens/SecurityContextSecurityTokenParameters.cs
new file mode 100644
index 0000000..da15846
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/Tokens/SecurityContextSecurityTokenParameters.cs
@@ -0,0 +1,47 @@
+
+namespace CoreWCF.Security.Tokens
+{
+    using CoreWCF.IdentityModel.Selectors;
+    using CoreWCF;
+    using CoreWCF.IdentityModel.Tokens;
+    using CoreWCF.Security;
+    using CoreWCF.IdentityModel;
+
+    class SecurityContextSecurityTokenParameters : SecurityTokenParameters
+    {
+        protected SecurityContextSecurityTokenParameters(SecurityContextSecurityTokenParameters other)
+            : base(other)
+        {
+            // empty
+        }
+
+        public SecurityContextSecurityTokenParameters()
+            : base()
+        {
+            this.InclusionMode = SecurityTokenInclusionMode.AlwaysToRecipient;
+        }
+
+        internal protected override bool SupportsClientAuthentication { get { return true; } }
+        internal protected override bool SupportsServerAuthentication { get { return true; } }
+        internal protected override bool SupportsClientWindowsIdentity { get { return true; } }
+
+        internal protected override bool HasAsymmetricKey { get { return false; } }
+
+        protected override SecurityTokenParameters CloneCore()
+        {
+            return new SecurityContextSecurityTokenParameters(this);
+        }
+
+        internal protected override SecurityKeyIdentifierClause CreateKeyIdentifierClause(SecurityToken token, SecurityTokenReferenceStyle referenceStyle)
+        {
+            return base.CreateKeyIdentifierClause<SecurityContextKeyIdentifierClause, LocalIdKeyIdentifierClause>(token, referenceStyle);
+        }
+
+        protected internal override void InitializeSecurityTokenRequirement(SecurityTokenRequirement requirement)
+        {
+            requirement.TokenType = ServiceModelSecurityTokenTypes.SecurityContext;
+            requirement.KeyType = SecurityKeyType.SymmetricKey;
+            requirement.RequireCryptographicToken = true;
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/Tokens/SecurityContextSecurityTokenResolver.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/Tokens/SecurityContextSecurityTokenResolver.cs
new file mode 100644
index 0000000..62fc9b7
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/Tokens/SecurityContextSecurityTokenResolver.cs
@@ -0,0 +1,151 @@
+using System.Xml;
+using CoreWCF;
+using System.Collections.ObjectModel;
+using CoreWCF.IdentityModel.Selectors;
+using CoreWCF.IdentityModel.Tokens;
+using System;
+using CoreWCF.IdentityModel;
+
+namespace CoreWCF.Security.Tokens
+{
+
+
+    public class SecurityContextSecurityTokenResolver : SecurityTokenResolver, ISecurityContextSecurityTokenCache
+    {
+        SecurityContextTokenCache tokenCache;
+        bool removeOldestTokensOnCacheFull;
+        int capacity;
+        TimeSpan clockSkew = SecurityProtocolFactory.defaultMaxClockSkew;
+
+        public SecurityContextSecurityTokenResolver( int securityContextCacheCapacity, bool removeOldestTokensOnCacheFull )
+            : this( securityContextCacheCapacity, removeOldestTokensOnCacheFull, SecurityProtocolFactory.defaultMaxClockSkew )
+        {
+        }
+
+        public SecurityContextSecurityTokenResolver(int securityContextCacheCapacity, bool removeOldestTokensOnCacheFull, TimeSpan clockSkew)
+        {
+            if (securityContextCacheCapacity <= 0)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("securityContextCacheCapacity", SR.Format(SR.ValueMustBeGreaterThanZero)));
+            }
+
+            if ( clockSkew < TimeSpan.Zero )
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError( new ArgumentOutOfRangeException( "clockSkew", SR.Format( SR.TimeSpanCannotBeLessThanTimeSpanZero ) ) );
+            }
+
+            this.capacity = securityContextCacheCapacity;
+            this.removeOldestTokensOnCacheFull = removeOldestTokensOnCacheFull;
+            this.clockSkew = clockSkew;
+            this.tokenCache = new SecurityContextTokenCache(this.capacity, this.removeOldestTokensOnCacheFull, clockSkew);
+        }
+
+        public int SecurityContextTokenCacheCapacity
+        {
+            get
+            {
+                return this.capacity;
+            }
+        }
+
+        public TimeSpan ClockSkew
+        {
+            get
+            {
+                return this.clockSkew;
+            }
+        }
+
+        public bool RemoveOldestTokensOnCacheFull
+        {
+            get
+            {
+                return this.removeOldestTokensOnCacheFull;
+            }
+        }
+
+        public void AddContext(SecurityContextSecurityToken token)
+        {
+            this.tokenCache.AddContext(token);
+        }
+        
+        public bool TryAddContext(SecurityContextSecurityToken token)
+        {
+            return this.tokenCache.TryAddContext(token);
+        }
+
+
+        public void ClearContexts()
+        {
+            this.tokenCache.ClearContexts();
+        }
+
+        public void RemoveContext(UniqueId contextId, UniqueId generation)
+        {
+            this.tokenCache.RemoveContext(contextId, generation, false);
+        }
+
+        public void RemoveAllContexts(UniqueId contextId)
+        {
+            this.tokenCache.RemoveAllContexts(contextId);
+        }
+
+        public SecurityContextSecurityToken GetContext(UniqueId contextId, UniqueId generation)
+        {
+            return this.tokenCache.GetContext(contextId, generation);
+        }
+
+        public Collection<SecurityContextSecurityToken> GetAllContexts(UniqueId contextId)
+        {
+            return this.tokenCache.GetAllContexts(contextId);
+        }
+
+        public void UpdateContextCachingTime(SecurityContextSecurityToken context, DateTime expirationTime)
+        {
+            this.tokenCache.UpdateContextCachingTime(context, expirationTime);
+        }
+
+        protected override bool TryResolveTokenCore(SecurityKeyIdentifierClause keyIdentifierClause, out SecurityToken token)
+        {
+            SecurityContextKeyIdentifierClause sctSkiClause = keyIdentifierClause as SecurityContextKeyIdentifierClause;
+            if (sctSkiClause != null)
+            {
+                token = this.tokenCache.GetContext(sctSkiClause.ContextId, sctSkiClause.Generation);
+            }
+            else
+            {
+                token = null;
+            }
+            return (token != null);
+        }
+
+        protected override bool TryResolveSecurityKeyCore(SecurityKeyIdentifierClause keyIdentifierClause, out SecurityKey key)
+        {
+            SecurityToken sct;
+            if (TryResolveTokenCore(keyIdentifierClause, out sct))
+            {
+                key = ((SecurityContextSecurityToken)sct).SecurityKeys[0];
+                return true;
+            }
+            else
+            {
+                key = null;
+                return false;
+            }
+        }
+
+        protected override bool TryResolveTokenCore(SecurityKeyIdentifier keyIdentifier, out SecurityToken token)
+        {
+            SecurityContextKeyIdentifierClause sctSkiClause;
+            if (keyIdentifier.TryFind<SecurityContextKeyIdentifierClause>(out sctSkiClause))
+            {
+                return TryResolveToken(sctSkiClause, out token);
+            }
+            else
+            {
+                token = null;
+                return false;
+            }
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/Tokens/SecurityTokenInclusionMode.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/Tokens/SecurityTokenInclusionMode.cs
new file mode 100644
index 0000000..a9dcc0d
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/Tokens/SecurityTokenInclusionMode.cs
@@ -0,0 +1,34 @@
+namespace CoreWCF.Security.Tokens
+{
+    using CoreWCF;
+    using System.ComponentModel;
+
+    public enum SecurityTokenInclusionMode
+    {
+        AlwaysToRecipient = 0,
+        Never = 1,
+        Once = 2,
+        AlwaysToInitiator = 3
+    }
+
+    static class SecurityTokenInclusionModeHelper
+    {
+        public static bool IsDefined(SecurityTokenInclusionMode value)
+        {
+            return (value == SecurityTokenInclusionMode.AlwaysToInitiator
+            || value == SecurityTokenInclusionMode.AlwaysToRecipient
+            || value == SecurityTokenInclusionMode.Never
+            || value == SecurityTokenInclusionMode.Once);
+        }
+
+        public static void Validate(SecurityTokenInclusionMode value)
+        {
+            if (!IsDefined(value))
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidEnumArgumentException("value", (int)value,
+                    typeof(SecurityTokenInclusionMode)));
+            }
+        }
+
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/Tokens/SecurityTokenParameters.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/Tokens/SecurityTokenParameters.cs
new file mode 100644
index 0000000..afc373d
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/Tokens/SecurityTokenParameters.cs
@@ -0,0 +1,202 @@
+namespace CoreWCF.Security.Tokens
+{
+    using CoreWCF.Security;
+    using CoreWCF.Channels;
+    using CoreWCF;
+    using System.Text;
+    using System.Globalization;
+    using CoreWCF.IdentityModel.Selectors;
+    using CoreWCF.IdentityModel.Tokens;
+    using CoreWCF.IdentityModel;
+    using System;
+
+    public abstract class SecurityTokenParameters
+    {
+        internal const SecurityTokenInclusionMode defaultInclusionMode = SecurityTokenInclusionMode.AlwaysToRecipient;
+        internal const SecurityTokenReferenceStyle defaultReferenceStyle = SecurityTokenReferenceStyle.Internal;
+        internal const bool defaultRequireDerivedKeys = true;
+
+        SecurityTokenInclusionMode inclusionMode = defaultInclusionMode;
+        SecurityTokenReferenceStyle referenceStyle = defaultReferenceStyle;
+        bool requireDerivedKeys = defaultRequireDerivedKeys;
+
+        protected SecurityTokenParameters(SecurityTokenParameters other)
+        {
+            if (other == null)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("other");
+
+            this.requireDerivedKeys = other.requireDerivedKeys;
+            this.inclusionMode = other.inclusionMode;
+            this.referenceStyle = other.referenceStyle;
+        }
+
+        protected SecurityTokenParameters()
+        {
+            // empty
+        }
+
+        internal protected abstract bool HasAsymmetricKey { get; }
+
+        public SecurityTokenInclusionMode InclusionMode
+        {
+            get
+            {
+                return this.inclusionMode;
+            }
+            set
+            {
+                SecurityTokenInclusionModeHelper.Validate(value);
+                this.inclusionMode = value;
+            }
+        }
+
+        public SecurityTokenReferenceStyle ReferenceStyle
+        {
+            get
+            {
+                return this.referenceStyle;
+            }
+            set
+            {
+                TokenReferenceStyleHelper.Validate(value);
+                this.referenceStyle = value;
+            }
+        }
+
+        public bool RequireDerivedKeys
+        {
+            get
+            {
+                return this.requireDerivedKeys;
+            }
+            set
+            {
+                this.requireDerivedKeys = value;
+            }
+        }
+
+        internal protected abstract bool SupportsClientAuthentication { get; }
+        internal protected abstract bool SupportsServerAuthentication { get; }
+        internal protected abstract bool SupportsClientWindowsIdentity { get; }
+
+        public SecurityTokenParameters Clone()
+        {
+            SecurityTokenParameters result = this.CloneCore();
+
+            if (result == null)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.SecurityTokenParametersCloneInvalidResult, this.GetType().ToString())));
+
+            return result;
+        }
+
+        protected abstract SecurityTokenParameters CloneCore();
+
+        internal protected abstract SecurityKeyIdentifierClause CreateKeyIdentifierClause(SecurityToken token, SecurityTokenReferenceStyle referenceStyle);
+
+        internal protected abstract void InitializeSecurityTokenRequirement(SecurityTokenRequirement requirement);
+
+        internal SecurityKeyIdentifierClause CreateKeyIdentifierClause<TExternalClause, TInternalClause>(SecurityToken token, SecurityTokenReferenceStyle referenceStyle)
+            where TExternalClause : SecurityKeyIdentifierClause
+            where TInternalClause : SecurityKeyIdentifierClause
+        {
+            if (token == null)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("token");
+
+            SecurityKeyIdentifierClause result;
+
+            switch (referenceStyle)
+            {
+                default:
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new NotSupportedException(
+                        SR.Format(SR.TokenDoesNotSupportKeyIdentifierClauseCreation, token.GetType().Name, referenceStyle)));
+                case SecurityTokenReferenceStyle.External:
+                    result = token.CreateKeyIdentifierClause<TExternalClause>();
+                    break;
+                case SecurityTokenReferenceStyle.Internal:
+                    result = token.CreateKeyIdentifierClause<TInternalClause>();
+                    break;
+            }
+
+            return result;
+        }
+
+        internal SecurityKeyIdentifierClause CreateGenericXmlTokenKeyIdentifierClause(SecurityToken token, SecurityTokenReferenceStyle referenceStyle)
+        {
+            GenericXmlSecurityToken xmlToken = token as GenericXmlSecurityToken;
+            if (xmlToken != null)
+            {
+                if (referenceStyle == SecurityTokenReferenceStyle.Internal && xmlToken.InternalTokenReference != null)
+                    return xmlToken.InternalTokenReference;
+
+                if (referenceStyle == SecurityTokenReferenceStyle.External && xmlToken.ExternalTokenReference != null)
+                    return xmlToken.ExternalTokenReference;
+            }
+
+            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new MessageSecurityException(SR.Format(SR.UnableToCreateTokenReference)));
+        }
+
+        internal protected virtual bool MatchesKeyIdentifierClause(SecurityToken token, SecurityKeyIdentifierClause keyIdentifierClause, SecurityTokenReferenceStyle referenceStyle)
+        {
+            if (token == null)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("token");
+
+            if (token is GenericXmlSecurityToken)
+            {
+                return MatchesGenericXmlTokenKeyIdentifierClause(token, keyIdentifierClause, referenceStyle);
+            }
+
+            bool result;
+
+            switch (referenceStyle)
+            {
+                default:
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new NotSupportedException(
+                        SR.Format(SR.TokenDoesNotSupportKeyIdentifierClauseCreation, token.GetType().Name, referenceStyle)));
+                case SecurityTokenReferenceStyle.External:
+                    if (keyIdentifierClause is LocalIdKeyIdentifierClause)
+                        result = false;
+                    else
+                        result = token.MatchesKeyIdentifierClause(keyIdentifierClause);
+                    break;
+                case SecurityTokenReferenceStyle.Internal:
+                    result = token.MatchesKeyIdentifierClause(keyIdentifierClause);
+                    break;
+            }
+
+            return result;
+        }
+
+        internal bool MatchesGenericXmlTokenKeyIdentifierClause(SecurityToken token, SecurityKeyIdentifierClause keyIdentifierClause, SecurityTokenReferenceStyle referenceStyle)
+        {
+            if (token == null)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("token");
+
+            bool result;
+
+            GenericXmlSecurityToken xmlToken = token as GenericXmlSecurityToken;
+
+            if (xmlToken == null)
+                result = false;
+            else if (referenceStyle == SecurityTokenReferenceStyle.External && xmlToken.ExternalTokenReference != null)
+                result = xmlToken.ExternalTokenReference.Matches(keyIdentifierClause);
+            else if (referenceStyle == SecurityTokenReferenceStyle.Internal)
+                result = xmlToken.MatchesKeyIdentifierClause(keyIdentifierClause);
+            else
+                result = false;
+
+            return result;
+        }
+
+        public override string ToString()
+        {
+            StringBuilder sb = new StringBuilder();
+
+            sb.AppendLine(String.Format(CultureInfo.InvariantCulture, "{0}:", this.GetType().ToString()));
+            sb.AppendLine(String.Format(CultureInfo.InvariantCulture, "InclusionMode: {0}", this.inclusionMode.ToString()));
+            sb.AppendLine(String.Format(CultureInfo.InvariantCulture, "ReferenceStyle: {0}", this.referenceStyle.ToString()));
+            sb.Append(String.Format(CultureInfo.InvariantCulture, "RequireDerivedKeys: {0}", this.requireDerivedKeys.ToString()));
+
+            return sb.ToString();
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/Tokens/SecurityTokenReferenceStyle.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/Tokens/SecurityTokenReferenceStyle.cs
new file mode 100644
index 0000000..6bfb34f
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/Tokens/SecurityTokenReferenceStyle.cs
@@ -0,0 +1,30 @@
+namespace CoreWCF.Security.Tokens
+{
+    using System;
+    using System.ComponentModel;
+
+    public enum SecurityTokenReferenceStyle
+    {
+        Internal = 0,
+        External = 1,
+    }
+
+    static class TokenReferenceStyleHelper
+    {
+        public static bool IsDefined(SecurityTokenReferenceStyle value)
+        {
+            return (value == SecurityTokenReferenceStyle.External || value == SecurityTokenReferenceStyle.Internal);
+        }
+
+        public static void Validate(SecurityTokenReferenceStyle value)
+        {
+            if (!IsDefined(value))
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidEnumArgumentException("value", (int)value,
+                    typeof(SecurityTokenReferenceStyle)));
+            }
+        }
+
+    }
+}
+
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/Tokens/ServiceModelSecurityTokenRequirement.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/Tokens/ServiceModelSecurityTokenRequirement.cs
index 42b7e3f..addf716 100644
--- a/src/CoreWCF.Primitives/src/CoreWCF/Security/Tokens/ServiceModelSecurityTokenRequirement.cs
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/Tokens/ServiceModelSecurityTokenRequirement.cs
@@ -7,7 +7,7 @@ using System.Text;
 
 namespace CoreWCF.Security.Tokens
 {
-    internal abstract class ServiceModelSecurityTokenRequirement : SecurityTokenRequirement
+    public abstract class ServiceModelSecurityTokenRequirement : SecurityTokenRequirement
     {
         protected const string Namespace = "http://schemas.microsoft.com/ws/2006/05/servicemodel/securitytokenrequirement";
         const string securityAlgorithmSuiteProperty = Namespace + "/SecurityAlgorithmSuite";
@@ -101,17 +101,17 @@ namespace CoreWCF.Security.Tokens
             }
         }
 
-        //public SecurityBindingElement SecurityBindingElement
-        //{
-        //    get
-        //    {
-        //        return GetPropertyOrDefault<SecurityBindingElement>(SecurityBindingElementProperty, null);
-        //    }
-        //    set
-        //    {
-        //        this.Properties[SecurityBindingElementProperty] = value;
-        //    }
-        //}
+        public SecurityBindingElement SecurityBindingElement
+        {
+            get
+            {
+                return GetPropertyOrDefault<SecurityBindingElement>(SecurityBindingElementProperty, null);
+            }
+            set
+            {
+                this.Properties[SecurityBindingElementProperty] = value;
+            }
+        }
 
         public EndpointAddress IssuerAddress
         {
@@ -137,42 +137,42 @@ namespace CoreWCF.Security.Tokens
             }
         }
 
-        //public SecurityBindingElement SecureConversationSecurityBindingElement
-        //{
-        //    get
-        //    {
-        //        return GetPropertyOrDefault<SecurityBindingElement>(SecureConversationSecurityBindingElementProperty, null);
-        //    }
-        //    set
-        //    {
-        //        this.Properties[SecureConversationSecurityBindingElementProperty] = value;
-        //    }
-        //}
-
-        //public SecurityTokenVersion MessageSecurityVersion
-        //{
-        //    get
-        //    {
-        //        return GetPropertyOrDefault<SecurityTokenVersion>(MessageSecurityVersionProperty, null);
-        //    }
-        //    set
-        //    {
-        //        this.Properties[MessageSecurityVersionProperty] = value;
-        //    }
-        //}
-
-        //internal MessageSecurityVersion DefaultMessageSecurityVersion
-        //{
-        //    get
-        //    {
-        //        MessageSecurityVersion messageSecurityVersion;
-        //        return (this.TryGetProperty<MessageSecurityVersion>(DefaultMessageSecurityVersionProperty, out messageSecurityVersion)) ? messageSecurityVersion : null;
-        //    }
-        //    set
-        //    {
-        //        this.Properties[DefaultMessageSecurityVersionProperty] = (object)value;
-        //    }
-        //}
+        public SecurityBindingElement SecureConversationSecurityBindingElement
+        {
+            get
+            {
+                return GetPropertyOrDefault<SecurityBindingElement>(SecureConversationSecurityBindingElementProperty, null);
+            }
+            set
+            {
+                this.Properties[SecureConversationSecurityBindingElementProperty] = value;
+            }
+        }
+
+        public SecurityTokenVersion MessageSecurityVersion
+        {
+            get
+            {
+                return GetPropertyOrDefault<SecurityTokenVersion>(MessageSecurityVersionProperty, null);
+            }
+            set
+            {
+                this.Properties[MessageSecurityVersionProperty] = value;
+            }
+        }
+
+        internal MessageSecurityVersion DefaultMessageSecurityVersion
+        {
+            get
+            {
+                MessageSecurityVersion messageSecurityVersion;
+                return (this.TryGetProperty<MessageSecurityVersion>(DefaultMessageSecurityVersionProperty, out messageSecurityVersion)) ? messageSecurityVersion : null;
+            }
+            set
+            {
+                this.Properties[DefaultMessageSecurityVersionProperty] = (object)value;
+            }
+        }
 
         public string TransportScheme
         {
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/Tokens/SupportingTokenParameters.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/Tokens/SupportingTokenParameters.cs
new file mode 100644
index 0000000..b251574
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/Tokens/SupportingTokenParameters.cs
@@ -0,0 +1,174 @@
+namespace CoreWCF.Security.Tokens
+{
+    using System.Collections.ObjectModel;
+    using System.Diagnostics;
+    using System.Globalization;
+    using System.Text;
+    using System;
+
+    public class SupportingTokenParameters
+    {
+        Collection<SecurityTokenParameters> signed = new Collection<SecurityTokenParameters>();
+        Collection<SecurityTokenParameters> signedEncrypted = new Collection<SecurityTokenParameters>();
+        Collection<SecurityTokenParameters> endorsing = new Collection<SecurityTokenParameters>();
+        Collection<SecurityTokenParameters> signedEndorsing = new Collection<SecurityTokenParameters>();
+
+        SupportingTokenParameters(SupportingTokenParameters other)
+        {
+            if (other == null)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("other");
+
+            foreach (SecurityTokenParameters p in other.signed)
+                this.signed.Add((SecurityTokenParameters)p.Clone());
+            foreach (SecurityTokenParameters p in other.signedEncrypted)
+                this.signedEncrypted.Add((SecurityTokenParameters)p.Clone());
+            foreach (SecurityTokenParameters p in other.endorsing)
+                this.endorsing.Add((SecurityTokenParameters)p.Clone());
+            foreach (SecurityTokenParameters p in other.signedEndorsing)
+                this.signedEndorsing.Add((SecurityTokenParameters)p.Clone());
+        }
+
+        public SupportingTokenParameters()
+        {
+            // empty
+        }
+
+        public Collection<SecurityTokenParameters> Endorsing
+        {
+            get
+            {
+                return this.endorsing;
+            }
+        }
+
+        public Collection<SecurityTokenParameters> SignedEndorsing
+        {
+            get
+            {
+                return this.signedEndorsing;
+            }
+        }
+
+        public Collection<SecurityTokenParameters> Signed
+        {
+            get
+            {
+                return this.signed;
+            }
+        }
+
+        public Collection<SecurityTokenParameters> SignedEncrypted
+        {
+            get
+            {
+                return this.signedEncrypted;
+            }
+        }
+
+        public void SetKeyDerivation(bool requireDerivedKeys)
+        {
+            foreach (SecurityTokenParameters t in this.endorsing)
+            {
+                if (t.HasAsymmetricKey)
+                {
+                    t.RequireDerivedKeys = false;
+                }
+                else
+                {
+                    t.RequireDerivedKeys = requireDerivedKeys;
+                }
+            }
+            foreach (SecurityTokenParameters t in this.signedEndorsing)
+            {
+                if (t.HasAsymmetricKey)
+                {
+                    t.RequireDerivedKeys = false;
+                }
+                else
+                {
+                    t.RequireDerivedKeys = requireDerivedKeys;
+                }
+            }
+        }
+
+        internal bool IsSetKeyDerivation(bool requireDerivedKeys)
+        {
+            foreach (SecurityTokenParameters t in this.endorsing)
+                if (t.RequireDerivedKeys != requireDerivedKeys)
+                    return false;
+
+            foreach (SecurityTokenParameters t in this.signedEndorsing)
+                if (t.RequireDerivedKeys != requireDerivedKeys)
+                    return false;
+            return true;
+        }
+
+        public override string ToString()
+        {
+            StringBuilder sb = new StringBuilder();
+            int k;
+
+            if (this.endorsing.Count == 0)
+                sb.AppendLine("No endorsing tokens.");
+            else
+                for (k = 0; k < this.endorsing.Count; k++)
+                {
+                    sb.AppendLine(String.Format(CultureInfo.InvariantCulture, "Endorsing[{0}]", k.ToString(CultureInfo.InvariantCulture)));
+                    sb.AppendLine("  " + this.endorsing[k].ToString().Trim().Replace("\n", "\n  "));
+                }
+
+            if (this.signed.Count == 0)
+                sb.AppendLine("No signed tokens.");
+            else
+                for (k = 0; k < this.signed.Count; k++)
+                {
+                    sb.AppendLine(String.Format(CultureInfo.InvariantCulture, "Signed[{0}]", k.ToString(CultureInfo.InvariantCulture)));
+                    sb.AppendLine("  " + this.signed[k].ToString().Trim().Replace("\n", "\n  "));
+                }
+
+            if (this.signedEncrypted.Count == 0)
+                sb.AppendLine("No signed encrypted tokens.");
+            else
+                for (k = 0; k < this.signedEncrypted.Count; k++)
+                {
+                    sb.AppendLine(String.Format(CultureInfo.InvariantCulture, "SignedEncrypted[{0}]", k.ToString(CultureInfo.InvariantCulture)));
+                    sb.AppendLine("  " + this.signedEncrypted[k].ToString().Trim().Replace("\n", "\n  "));
+                }
+
+            if (this.signedEndorsing.Count == 0)
+                sb.AppendLine("No signed endorsing tokens.");
+            else
+                for (k = 0; k < this.signedEndorsing.Count; k++)
+                {
+                    sb.AppendLine(String.Format(CultureInfo.InvariantCulture, "SignedEndorsing[{0}]", k.ToString(CultureInfo.InvariantCulture)));
+                    sb.AppendLine("  " + this.signedEndorsing[k].ToString().Trim().Replace("\n", "\n  "));
+                }
+
+            return sb.ToString().Trim();
+        }
+
+        public SupportingTokenParameters Clone()
+        {
+            SupportingTokenParameters parameters = this.CloneCore();
+           /* if (parameters == null || parameters.GetType() != this.GetType())
+            {
+                TraceUtility.TraceEvent(
+                    TraceEventType.Error, 
+                    TraceCode.Security, 
+                    SR.GetString(SR.CloneNotImplementedCorrectly, new object[] { this.GetType(), (parameters != null) ? parameters.ToString() : "null" }));
+            }*/
+
+            return parameters;
+        }
+
+        protected virtual SupportingTokenParameters CloneCore()
+        {
+            return new SupportingTokenParameters(this);
+        }
+
+        internal bool IsEmpty()
+        {
+            return signed.Count == 0 && signedEncrypted.Count == 0 && endorsing.Count == 0 && signedEndorsing.Count == 0;
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/Tokens/UserNameSecurityTokenParameters.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/Tokens/UserNameSecurityTokenParameters.cs
new file mode 100644
index 0000000..a360344
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/Tokens/UserNameSecurityTokenParameters.cs
@@ -0,0 +1,44 @@
+namespace CoreWCF.Security.Tokens
+{
+    using CoreWCF.IdentityModel.Selectors;
+    using CoreWCF;
+    using CoreWCF.IdentityModel.Tokens;
+    using CoreWCF.Security;
+    using CoreWCF.IdentityModel;
+
+    public class UserNameSecurityTokenParameters : SecurityTokenParameters
+    {
+        protected UserNameSecurityTokenParameters(UserNameSecurityTokenParameters other)
+            : base(other)
+        {
+            base.RequireDerivedKeys = false;
+        }
+
+        public UserNameSecurityTokenParameters()
+            : base()
+        {
+            base.RequireDerivedKeys = false;
+        }
+
+        internal protected override bool HasAsymmetricKey { get { return false; } }
+        internal protected override bool SupportsClientAuthentication { get { return true; } }
+        internal protected override bool SupportsServerAuthentication { get { return false; } }
+        internal protected override bool SupportsClientWindowsIdentity { get { return true; } }
+
+        protected override SecurityTokenParameters CloneCore()
+        {
+            return new UserNameSecurityTokenParameters(this);
+        }
+
+        internal protected override SecurityKeyIdentifierClause CreateKeyIdentifierClause(SecurityToken token, SecurityTokenReferenceStyle referenceStyle)
+        {
+            return this.CreateKeyIdentifierClause<SecurityKeyIdentifierClause, LocalIdKeyIdentifierClause>(token, referenceStyle);
+        }
+
+        protected internal override void InitializeSecurityTokenRequirement(SecurityTokenRequirement requirement)
+        {
+            requirement.TokenType = SecurityTokenTypes.UserName;
+            requirement.RequireCryptographicToken = false;
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/TransportSecurityProtocol.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/TransportSecurityProtocol.cs
new file mode 100644
index 0000000..0e7aba8
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/TransportSecurityProtocol.cs
@@ -0,0 +1,188 @@
+using System.Collections.Generic;
+using System.Collections.ObjectModel;
+using CoreWCF.IdentityModel.Policy;
+using CoreWCF.IdentityModel.Selectors;
+using CoreWCF.IdentityModel.Tokens;
+using System.Runtime;
+using CoreWCF.Runtime;
+using CoreWCF;
+using CoreWCF.Channels;
+using CoreWCF.Description;
+using System;
+using System.Threading.Tasks;
+using CoreWCF.IdentityModel;
+using System.Threading;
+
+namespace CoreWCF.Security
+{
+     class TransportSecurityProtocol : SecurityProtocol
+    {
+        public TransportSecurityProtocol(TransportSecurityProtocolFactory factory, EndpointAddress target, Uri via)
+            : base(factory, target, via)
+        {
+        }
+
+        public override async Task<Message> SecureOutgoingMessageAsync(Message message, CancellationToken token)
+        {
+            if (message == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(message));
+            }
+           
+            //TODO communication object
+          //  CommunicationObject.ThrowIfClosedOrNotOpen();
+            string actor = string.Empty; // message.Version.Envelope.UltimateDestinationActor;
+            try
+            {
+                if (SecurityProtocolFactory.ActAsInitiator)
+                {
+                    //serverside no need to worry
+                  //  message = await SecureOutgoingMessageAtInitiatorAsync(message, actor, timeout);
+                }
+                else
+                {
+                    message = await SecureOutgoingMessageAtResponderAsync(message, actor);
+                }
+                base.OnOutgoingMessageSecured(message);
+            }
+            catch
+            {
+                base.OnSecureOutgoingMessageFailure(message);
+                throw;
+            }
+            
+            return message;
+        }
+
+        protected virtual async Task<Message> SecureOutgoingMessageAtResponderAsync(Message message, string actor)
+        {
+            if (this.SecurityProtocolFactory.AddTimestamp && !this.SecurityProtocolFactory.SecurityBindingElement.EnableUnsecuredResponse)
+            {
+                SendSecurityHeader securityHeader = CreateSendSecurityHeaderForTransportProtocol(message, actor, this.SecurityProtocolFactory);
+                message = securityHeader.SetupExecution();
+            }
+            return message;
+        }
+
+        /*
+
+        protected virtual async Task<Message> SecureOutgoingMessageAtInitiatorAsync(Message message, string actor, TimeSpan timeout)
+        {
+            IList<SupportingTokenSpecification> supportingTokens = await TryGetSupportingTokensAsync(SecurityProtocolFactory, Target, Via, message, timeout);
+            SetUpDelayedSecurityExecution(ref message, actor, supportingTokens);
+            return message;
+        }
+
+        internal void SetUpDelayedSecurityExecution(ref Message message, string actor,
+            IList<SupportingTokenSpecification> supportingTokens)
+        {
+            SendSecurityHeader securityHeader = CreateSendSecurityHeaderForTransportProtocol(message, actor, SecurityProtocolFactory);
+            AddSupportingTokens(securityHeader, supportingTokens);
+            message = securityHeader.SetupExecution();
+        }*/
+
+        public sealed override void VerifyIncomingMessage(ref Message message, TimeSpan timeout)
+        {
+            if (message == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(message));
+            }
+            //CommunicationObject.ThrowIfClosedOrNotOpen();
+            try
+            {
+                VerifyIncomingMessageCore(ref message, timeout);
+            }
+            catch (MessageSecurityException e)
+            {
+                base.OnVerifyIncomingMessageFailure(message, e);
+                throw;
+            }
+            catch (Exception e)
+            {
+                // Always immediately rethrow fatal exceptions.
+                if (Fx.IsFatal(e))
+                {
+                    throw;
+                }
+
+                base.OnVerifyIncomingMessageFailure(message, e);
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new MessageSecurityException(SR.MessageSecurityVerificationFailed, e));
+            }
+        }
+
+        protected void AttachRecipientSecurityProperty(Message message, IList<SecurityToken> basicTokens, IList<SecurityToken> endorsingTokens,
+           IList<SecurityToken> signedEndorsingTokens, IList<SecurityToken> signedTokens, Dictionary<SecurityToken, ReadOnlyCollection<IAuthorizationPolicy>> tokenPoliciesMapping)
+        {
+            SecurityMessageProperty security = SecurityMessageProperty.GetOrCreate(message);
+            AddSupportingTokenSpecification(security, basicTokens, endorsingTokens, signedEndorsingTokens, signedTokens, tokenPoliciesMapping);
+            security.ServiceSecurityContext = new ServiceSecurityContext(security.GetInitiatorTokenAuthorizationPolicies());
+        }
+
+        protected virtual void VerifyIncomingMessageCore(ref Message message, TimeSpan timeout)
+        {
+            TransportSecurityProtocolFactory factory = (TransportSecurityProtocolFactory)this.SecurityProtocolFactory;
+            string actor = string.Empty; // message.Version.Envelope.UltimateDestinationActor;
+
+            ReceiveSecurityHeader securityHeader = factory.StandardsManager.TryCreateReceiveSecurityHeader(message, actor,
+                factory.IncomingAlgorithmSuite, (factory.ActAsInitiator) ? MessageDirection.Output : MessageDirection.Input);
+            bool expectBasicTokens;
+            bool expectEndorsingTokens;
+            bool expectSignedTokens;
+            IList<SupportingTokenAuthenticatorSpecification> supportingAuthenticators = factory.GetSupportingTokenAuthenticators(message.Headers.Action,
+                out expectSignedTokens, out expectBasicTokens, out expectEndorsingTokens);
+            if (securityHeader == null)
+            {
+                bool expectSupportingTokens = expectEndorsingTokens || expectSignedTokens || expectBasicTokens;
+                if ((factory.ActAsInitiator && (!factory.AddTimestamp || factory.SecurityBindingElement.EnableUnsecuredResponse))
+                    || (!factory.ActAsInitiator && !factory.AddTimestamp && !expectSupportingTokens))
+                {
+                    return;
+                }
+                else
+                {
+                    if (String.IsNullOrEmpty(actor))
+                        throw Diagnostics.TraceUtility.ThrowHelperError(new MessageSecurityException(
+                            SR.Format(SR.UnableToFindSecurityHeaderInMessageNoActor)), message);
+                    else
+                        throw Diagnostics.TraceUtility.ThrowHelperError(new MessageSecurityException(
+                            SR.Format(SR.UnableToFindSecurityHeaderInMessage, actor)), message);
+                }
+            }
+
+            securityHeader.RequireMessageProtection = false;
+            securityHeader.ExpectBasicTokens = expectBasicTokens;
+            securityHeader.ExpectSignedTokens = expectSignedTokens;
+            securityHeader.ExpectEndorsingTokens = expectEndorsingTokens;
+            securityHeader.MaxReceivedMessageSize = factory.SecurityBindingElement.MaxReceivedMessageSize;
+            securityHeader.ReaderQuotas = factory.SecurityBindingElement.ReaderQuotas;
+
+            // Due to compatibility, only honor this setting if this app setting is enabled
+           // if (ServiceModelAppSettings.UseConfiguredTransportSecurityHeaderLayout)
+           // {
+            //    securityHeader.Layout = factory.SecurityHeaderLayout;
+          //  }
+
+            TimeoutHelper timeoutHelper = new TimeoutHelper(timeout);
+            if (!factory.ActAsInitiator)
+            {
+                securityHeader.ConfigureTransportBindingServerReceiveHeader(supportingAuthenticators);
+                securityHeader.ConfigureOutOfBandTokenResolver(MergeOutOfBandResolvers(supportingAuthenticators, EmptyReadOnlyCollection<SecurityTokenResolver>.Instance));
+                if (factory.ExpectKeyDerivation)
+                {
+                    securityHeader.DerivedTokenAuthenticator = factory.DerivedKeyTokenAuthenticator;
+                }
+            }
+            securityHeader.ReplayDetectionEnabled = factory.DetectReplays;
+            securityHeader.SetTimeParameters(factory.NonceCache, factory.ReplayWindow, factory.MaxClockSkew);
+            securityHeader.Process(timeoutHelper.RemainingTime(), SecurityUtils.GetChannelBindingFromMessage(message), factory.ExtendedProtectionPolicy);
+            message = securityHeader.ProcessedMessage;
+            if (!factory.ActAsInitiator)
+            {
+                AttachRecipientSecurityProperty(message, securityHeader.BasicSupportingTokens, securityHeader.EndorsingSupportingTokens, securityHeader.SignedEndorsingSupportingTokens,
+                    securityHeader.SignedSupportingTokens, securityHeader.SecurityTokenAuthorizationPoliciesMapping);
+            }
+
+            base.OnIncomingMessageVerified(message);
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/TransportSecurityProtocolFactory.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/TransportSecurityProtocolFactory.cs
new file mode 100644
index 0000000..ed61e66
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/TransportSecurityProtocolFactory.cs
@@ -0,0 +1,37 @@
+﻿
+using System;
+
+namespace CoreWCF.Security
+{
+    internal class TransportSecurityProtocolFactory : SecurityProtocolFactory
+    {
+        public TransportSecurityProtocolFactory() : base()
+        {
+        }
+
+        internal TransportSecurityProtocolFactory(TransportSecurityProtocolFactory factory) : base(factory)
+        {
+        }
+
+        public override bool SupportsDuplex
+        {
+            get
+            {
+                return true;
+            }
+        }
+
+        public override bool SupportsReplayDetection
+        {
+            get
+            {
+                return false;
+            }
+        }
+
+        internal override SecurityProtocol OnCreateSecurityProtocol(EndpointAddress target, Uri via, object listenerSecurityState, TimeSpan timeout)
+        {
+            return new TransportSecurityProtocol(this, target, via);
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/TrustDriver.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/TrustDriver.cs
new file mode 100644
index 0000000..f6e6211
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/TrustDriver.cs
@@ -0,0 +1,184 @@
+
+
+namespace CoreWCF.Security
+{
+    using System;
+    using CoreWCF.Channels;
+    using CoreWCF;
+    using CoreWCF.Description;
+    using System.Collections.Generic;
+    using System.Collections.ObjectModel;
+    using System.Diagnostics;
+    using System.Runtime.Serialization;
+    using CoreWCF.IdentityModel.Claims;
+    using CoreWCF.IdentityModel.Policy;
+    using CoreWCF.IdentityModel.Selectors;
+    using CoreWCF.IdentityModel.Tokens;
+    using System.Security.Principal;
+    using System.Security.Cryptography;
+    using CoreWCF.Security.Tokens;
+
+    using System.Xml;
+
+    abstract class TrustDriver
+    {
+        // issued tokens control        
+        public virtual bool IsIssuedTokensSupported
+        {
+            get
+            {
+                return false;
+            }
+        }
+
+        // issued tokens feature        
+        public virtual string IssuedTokensHeaderName
+        {
+            get
+            {
+                // PreSharp Bug: Property get methods should not throw exceptions.
+#pragma warning suppress 56503
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.TrustDriverVersionDoesNotSupportIssuedTokens)));
+            }
+        }
+
+        // issued tokens feature        
+        public virtual string IssuedTokensHeaderNamespace
+        {
+            get
+            {
+                // PreSharp Bug: Property get methods should not throw exceptions.
+#pragma warning suppress 56503
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.TrustDriverVersionDoesNotSupportIssuedTokens)));
+            }
+        }
+
+        // session control
+        public virtual bool IsSessionSupported
+        {
+            get
+            {
+                return false;
+            }
+        }
+
+        public abstract XmlDictionaryString RequestSecurityTokenAction { get; }
+
+        public abstract XmlDictionaryString RequestSecurityTokenResponseAction { get; }
+
+        public abstract XmlDictionaryString RequestSecurityTokenResponseFinalAction { get; }
+
+        // session feature
+        public virtual string RequestTypeClose
+        {
+            get
+            {
+                // PreSharp Bug: Property get methods should not throw exceptions.
+#pragma warning suppress 56503
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.TrustDriverVersionDoesNotSupportSession)));
+            }
+        }
+
+        public abstract string RequestTypeIssue { get; }
+
+        // session feature
+        public virtual string RequestTypeRenew
+        {
+            get
+            {
+                // PreSharp Bug: Property get methods should not throw exceptions.
+#pragma warning suppress 56503
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.TrustDriverVersionDoesNotSupportSession)));
+            }
+        }
+
+        public abstract string ComputedKeyAlgorithm { get; }
+
+        public abstract SecurityStandardsManager StandardsManager { get; }
+
+        public abstract XmlDictionaryString Namespace { get; }
+
+        // RST specific method
+        public abstract RequestSecurityToken CreateRequestSecurityToken(XmlReader reader);
+
+        // RSTR specific method
+        public abstract RequestSecurityTokenResponse CreateRequestSecurityTokenResponse(XmlReader reader);
+
+        // RSTRC specific method
+        public abstract RequestSecurityTokenResponseCollection CreateRequestSecurityTokenResponseCollection(XmlReader xmlReader);
+
+        public abstract bool IsAtRequestSecurityTokenResponse(XmlReader reader);
+
+        public abstract bool IsAtRequestSecurityTokenResponseCollection(XmlReader reader);
+
+        public abstract bool IsRequestedSecurityTokenElement(string name, string nameSpace);
+
+        public abstract bool IsRequestedProofTokenElement(string name, string nameSpace);
+
+        public abstract T GetAppliesTo<T>(RequestSecurityToken rst, XmlObjectSerializer serializer);
+
+        public abstract T GetAppliesTo<T>(RequestSecurityTokenResponse rstr, XmlObjectSerializer serializer);
+
+        public abstract void GetAppliesToQName(RequestSecurityToken rst, out string localName, out string namespaceUri);
+
+        public abstract void GetAppliesToQName(RequestSecurityTokenResponse rstr, out string localName, out string namespaceUri);
+
+        public abstract bool IsAppliesTo(string localName, string namespaceUri);
+
+        // RSTR specific method
+        public abstract byte[] GetAuthenticator(RequestSecurityTokenResponse rstr);
+
+        // RST specific method
+        public abstract BinaryNegotiation GetBinaryNegotiation(RequestSecurityToken rst);
+
+        // RSTR specific method
+        public abstract BinaryNegotiation GetBinaryNegotiation(RequestSecurityTokenResponse rstr);
+
+        // RST specific method
+        public abstract SecurityToken GetEntropy(RequestSecurityToken rst, SecurityTokenResolver resolver);
+
+        // RSTR specific method
+        public abstract SecurityToken GetEntropy(RequestSecurityTokenResponse rstr, SecurityTokenResolver resolver);
+
+        // RSTR specific method
+        public abstract GenericXmlSecurityToken GetIssuedToken(RequestSecurityTokenResponse rstr, SecurityTokenResolver resolver, IList<SecurityTokenAuthenticator> allowedAuthenticators, SecurityKeyEntropyMode keyEntropyMode, byte[] requestorEntropy,
+            string expectedTokenType, ReadOnlyCollection<IAuthorizationPolicy> authorizationPolicies, int defaultKeySize, bool isBearerKeyType);
+
+        public abstract GenericXmlSecurityToken GetIssuedToken(RequestSecurityTokenResponse rstr, string expectedTokenType, ReadOnlyCollection<IAuthorizationPolicy> authorizationPolicies, RSA clientKey);
+
+        public abstract void OnRSTRorRSTRCMissingException();
+
+        // RST specific method
+        public abstract void WriteRequestSecurityToken(RequestSecurityToken rst, XmlWriter w);
+
+        // RSTR specific method
+        public abstract void WriteRequestSecurityTokenResponse(RequestSecurityTokenResponse rstr, XmlWriter w);
+
+        // RSTR Collection method
+        public abstract void WriteRequestSecurityTokenResponseCollection(RequestSecurityTokenResponseCollection rstrCollection, XmlWriter writer);
+
+        // Federation proxy creation
+      //  public abstract IChannelFactory<IRequestChannel> CreateFederationProxy(EndpointAddress address, Binding binding, KeyedByTypeCollection<IEndpointBehavior> channelBehaviors);
+        public abstract XmlElement CreateKeySizeElement(int keySize);
+        public abstract XmlElement CreateKeyTypeElement(SecurityKeyType keyType);
+        public abstract XmlElement CreateTokenTypeElement(string tokenTypeUri);
+        public abstract XmlElement CreateRequiredClaimsElement(IEnumerable<XmlElement> claimsList);
+        public abstract XmlElement CreateUseKeyElement(SecurityKeyIdentifier keyIdentifier, SecurityStandardsManager standardsManager);
+        public abstract XmlElement CreateSignWithElement(string signatureAlgorithm);
+        public abstract XmlElement CreateEncryptWithElement(string encryptionAlgorithm);
+        public abstract XmlElement CreateEncryptionAlgorithmElement(string encryptionAlgorithm);
+        public abstract XmlElement CreateCanonicalizationAlgorithmElement(string canonicalicationAlgorithm);
+        public abstract XmlElement CreateComputedKeyAlgorithmElement(string computedKeyAlgorithm);
+        public abstract Collection<XmlElement> ProcessUnknownRequestParameters(Collection<XmlElement> unknownRequestParameters, Collection<XmlElement> originalRequestParameters);
+        public abstract bool TryParseKeySizeElement(XmlElement element, out int keySize);
+        public abstract bool TryParseKeyTypeElement(XmlElement element, out SecurityKeyType keyType);
+        public abstract bool TryParseTokenTypeElement(XmlElement element, out string tokenType);
+        public abstract bool TryParseRequiredClaimsElement(XmlElement element, out Collection<XmlElement> requiredClaims);
+        // helper methods for the parsing standard binding elements
+        internal virtual bool IsSignWithElement(XmlElement element, out string signatureAlgorithm) { signatureAlgorithm = null; return false; }
+        internal virtual bool IsEncryptWithElement(XmlElement element, out string encryptWithAlgorithm) { encryptWithAlgorithm = null; return false; }
+        internal virtual bool IsEncryptionAlgorithmElement(XmlElement element, out string encryptionAlgorithm) { encryptionAlgorithm = null; return false; }
+        internal virtual bool IsCanonicalizationAlgorithmElement(XmlElement element, out string canonicalizationAlgorithm) { canonicalizationAlgorithm = null; return false; }
+        internal virtual bool IsKeyWrapAlgorithmElement(XmlElement element, out string keyWrapAlgorithm) { keyWrapAlgorithm = null; return false; }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/TrustVersion.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/TrustVersion.cs
new file mode 100644
index 0000000..86c9b5d
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/TrustVersion.cs
@@ -0,0 +1,87 @@
+using System;
+using System.Collections.Generic;
+using System.Text;
+using System.Xml;
+
+namespace CoreWCF.Security
+{
+    public abstract class TrustVersion
+    {
+        readonly XmlDictionaryString trustNamespace;
+        readonly XmlDictionaryString prefix;
+
+        internal TrustVersion(XmlDictionaryString ns, XmlDictionaryString prefix)
+        {
+            this.trustNamespace = ns;
+            this.prefix = prefix;
+        }
+
+        public XmlDictionaryString Namespace
+        {
+            get
+            {
+                return this.trustNamespace;
+            }
+        }
+
+        public XmlDictionaryString Prefix
+        {
+            get
+            {
+                return this.prefix;
+            }
+        }
+
+        public static TrustVersion Default
+        {
+            get { return WSTrustFeb2005; }
+        }
+
+        public static TrustVersion WSTrustFeb2005
+        {
+            get { return WSTrustVersionFeb2005.Instance; }
+        }
+
+        public static TrustVersion WSTrust13
+        {
+            get { return WSTrustVersion13.Instance; }
+        }
+
+        class WSTrustVersionFeb2005 : TrustVersion
+        {
+            static readonly WSTrustVersionFeb2005 instance = new WSTrustVersionFeb2005();
+
+            protected WSTrustVersionFeb2005()
+                : base(XD.TrustFeb2005Dictionary.Namespace, XD.TrustFeb2005Dictionary.Prefix)
+            {
+            }
+
+            public static TrustVersion Instance
+            {
+                get
+                {
+                    return instance;
+                }
+            }
+        }
+
+        class WSTrustVersion13 : TrustVersion
+        {
+            static readonly WSTrustVersion13 instance = new WSTrustVersion13();
+
+            protected WSTrustVersion13()
+                : base(DXD.TrustDec2005Dictionary.Namespace, DXD.TrustDec2005Dictionary.Prefix)
+            {
+            }
+
+            public static TrustVersion Instance
+            {
+                get
+                {
+                    return instance;
+                }
+            }
+        }
+
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/WSKeyInfoSerializer.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/WSKeyInfoSerializer.cs
new file mode 100644
index 0000000..394a7a0
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/WSKeyInfoSerializer.cs
@@ -0,0 +1,353 @@
+﻿
+
+using System.Collections.Generic;
+using CoreWCF.IdentityModel;
+using CoreWCF.IdentityModel.Selectors;
+using CoreWCF.IdentityModel.Tokens;
+using CoreWCF.Security.Tokens;
+using System.Xml;
+using CoreWCF.Security;
+using CoreWCF;
+using System;
+
+namespace CoreWCF.Security
+{
+
+    class WSKeyInfoSerializer : KeyInfoSerializer
+    {
+        static Func<KeyInfoSerializer, IEnumerable<SecurityTokenSerializer.SerializerEntries>> CreateAdditionalEntries(SecurityVersion securityVersion, SecureConversationVersion secureConversationVersion)
+        {
+            return (KeyInfoSerializer keyInfoSerializer) =>
+            {
+                List<SecurityTokenSerializer.SerializerEntries> serializerEntries = new List<SecurityTokenSerializer.SerializerEntries>();
+
+                if (securityVersion == SecurityVersion.WSSecurity10)
+                {
+                    serializerEntries.Add(new CoreWCF.IdentityModel.Tokens.WSSecurityJan2004(keyInfoSerializer));
+                }
+                else if (securityVersion == SecurityVersion.WSSecurity11)
+                {
+                    serializerEntries.Add(new CoreWCF.IdentityModel.Tokens.WSSecurityXXX2005(keyInfoSerializer));
+                }
+                else
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("securityVersion", SR.Format(SR.MessageSecurityVersionOutOfRange)));
+                }
+
+                if (secureConversationVersion == SecureConversationVersion.WSSecureConversationFeb2005)
+                {
+                    serializerEntries.Add(new WSSecureConversationFeb2005(keyInfoSerializer));
+                }
+                else if (secureConversationVersion == SecureConversationVersion.WSSecureConversation13)
+                {
+                    serializerEntries.Add(new WSSecureConversationDec2005(keyInfoSerializer));
+                }
+                else
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new NotSupportedException());
+                }
+
+                return serializerEntries;
+            };
+        }
+
+        public WSKeyInfoSerializer(bool emitBspRequiredAttributes, DictionaryManager dictionaryManager, TrustDictionary trustDictionary, SecurityTokenSerializer innerSecurityTokenSerializer, SecurityVersion securityVersion, SecureConversationVersion secureConversationVersion)
+            : base(emitBspRequiredAttributes, dictionaryManager, trustDictionary, innerSecurityTokenSerializer, CreateAdditionalEntries(securityVersion, secureConversationVersion))
+        {
+        }
+
+        #region WSSecureConversation classes
+
+       public abstract class WSSecureConversation : SecurityTokenSerializer.SerializerEntries
+        {
+            KeyInfoSerializer securityTokenSerializer;
+
+            protected WSSecureConversation(KeyInfoSerializer securityTokenSerializer)
+            {
+                this.securityTokenSerializer = securityTokenSerializer;
+            }
+
+            public KeyInfoSerializer SecurityTokenSerializer
+            {
+                get { return this.securityTokenSerializer; }
+            }
+
+            public abstract SecureConversationDictionary SerializerDictionary
+            {
+                get;
+            }
+
+            public virtual string DerivationAlgorithm
+            {
+                get { return SecurityAlgorithms.Psha1KeyDerivation; }
+            }
+
+            public override void PopulateTokenEntries(IList<TokenEntry> tokenEntryList)
+            {
+                if (tokenEntryList == null)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("tokenEntryList");
+                }
+                tokenEntryList.Add(new DerivedKeyTokenEntry(this));
+                tokenEntryList.Add(new SecurityContextTokenEntry(this));
+            }
+
+            protected abstract class SctStrEntry : StrEntry
+            {
+                WSSecureConversation parent;
+
+                public SctStrEntry(WSSecureConversation parent)
+                {
+                    this.parent = parent;
+                }
+
+                protected WSSecureConversation Parent
+                {
+                    get { return this.parent; }
+                }
+
+                public override Type GetTokenType(SecurityKeyIdentifierClause clause)
+                {
+                    return null;
+                }
+
+                public override string GetTokenTypeUri()
+                {
+                    return null;
+                }
+
+                public override bool CanReadClause(XmlDictionaryReader reader, string tokenType)
+                {
+                    if (tokenType != null && tokenType != parent.SerializerDictionary.SecurityContextTokenType.Value)
+                    {
+                        return false;
+                    }
+                    if (reader.IsStartElement(
+                        parent.SecurityTokenSerializer.DictionaryManager.SecurityJan2004Dictionary.Reference,
+                        parent.SecurityTokenSerializer.DictionaryManager.SecurityJan2004Dictionary.Namespace))
+                    {
+                        string valueType = reader.GetAttribute(parent.SecurityTokenSerializer.DictionaryManager.SecurityJan2004Dictionary.ValueType, null);
+                        if (valueType != null && valueType != parent.SerializerDictionary.SecurityContextTokenReferenceValueType.Value)
+                        {
+                            return false;
+                        }
+                        string uri = reader.GetAttribute(parent.SecurityTokenSerializer.DictionaryManager.SecurityJan2004Dictionary.URI, null);
+                        if (uri != null)
+                        {
+                            if (uri.Length > 0 && uri[0] != '#')
+                            {
+                                return true;
+                            }
+                        }
+                    }
+                    return false;
+                }
+
+                public override SecurityKeyIdentifierClause ReadClause(XmlDictionaryReader reader, byte[] derivationNonce, int derivationLength, string tokenType)
+                {
+                    System.Xml.UniqueId uri = XmlHelper.GetAttributeAsUniqueId(reader, XD.SecurityJan2004Dictionary.URI, null);
+                    System.Xml.UniqueId generation = ReadGeneration(reader);
+
+                    if (reader.IsEmptyElement)
+                    {
+                        reader.Read();
+                    }
+                    else
+                    {
+                        reader.ReadStartElement();
+                        while (reader.IsStartElement())
+                        {
+                            reader.Skip();
+                        }
+                        reader.ReadEndElement();
+                    }
+
+                    return new SecurityContextKeyIdentifierClause(uri, generation, derivationNonce, derivationLength);
+                }
+
+                protected abstract System.Xml.UniqueId ReadGeneration(XmlDictionaryReader reader);
+
+                public override bool SupportsCore(SecurityKeyIdentifierClause clause)
+                {
+                    return clause is SecurityContextKeyIdentifierClause;
+                }
+
+                public override void WriteContent(XmlDictionaryWriter writer, SecurityKeyIdentifierClause clause)
+                {
+                    SecurityContextKeyIdentifierClause sctClause = clause as SecurityContextKeyIdentifierClause;
+                    writer.WriteStartElement(XD.SecurityJan2004Dictionary.Prefix.Value, XD.SecurityJan2004Dictionary.Reference, XD.SecurityJan2004Dictionary.Namespace);
+                    XmlHelper.WriteAttributeStringAsUniqueId(writer, null, XD.SecurityJan2004Dictionary.URI, null, sctClause.ContextId);
+                    WriteGeneration(writer, sctClause);
+                    writer.WriteAttributeString(XD.SecurityJan2004Dictionary.ValueType, null, parent.SerializerDictionary.SecurityContextTokenReferenceValueType.Value);
+                    writer.WriteEndElement();
+                }
+
+                protected abstract void WriteGeneration(XmlDictionaryWriter writer, SecurityContextKeyIdentifierClause clause);
+            }
+
+            protected class SecurityContextTokenEntry : SecurityTokenSerializer.TokenEntry
+            {
+                WSSecureConversation parent;
+                Type[] tokenTypes;
+
+                public SecurityContextTokenEntry(WSSecureConversation parent)
+                {
+                    this.parent = parent;
+                }
+
+                protected WSSecureConversation Parent
+                {
+                    get { return this.parent; }
+                }
+
+                protected override XmlDictionaryString LocalName { get { return parent.SerializerDictionary.SecurityContextToken; } }
+                protected override XmlDictionaryString NamespaceUri { get { return parent.SerializerDictionary.Namespace; } }
+                protected override Type[] GetTokenTypesCore()
+                {
+                    if (tokenTypes == null)
+                        this.tokenTypes = new Type[] { typeof(SecurityContextSecurityToken) };
+
+                    return this.tokenTypes;
+                }
+                public override string TokenTypeUri { get { return parent.SerializerDictionary.SecurityContextTokenType.Value; } }
+                protected override string ValueTypeUri { get { return null; } }
+
+            }
+
+            protected class DerivedKeyTokenEntry : SecurityTokenSerializer.TokenEntry
+            {
+                public const string DefaultLabel = "WS-SecureConversation";
+
+                WSSecureConversation parent;
+                Type[] tokenTypes;
+
+                public DerivedKeyTokenEntry(WSSecureConversation parent)
+                {
+                    if (parent == null)
+                    {
+                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("parent");
+                    }
+                    this.parent = parent;
+                }
+
+                protected override XmlDictionaryString LocalName { get { return parent.SerializerDictionary.DerivedKeyToken; } }
+                protected override XmlDictionaryString NamespaceUri { get { return parent.SerializerDictionary.Namespace; } }
+                protected override Type[] GetTokenTypesCore()
+                {
+                    if (tokenTypes == null)
+                        this.tokenTypes = new Type[] { typeof(DerivedKeySecurityToken) };
+
+                    return this.tokenTypes;
+                }
+
+                public override string TokenTypeUri { get { return parent.SerializerDictionary.DerivedKeyTokenType.Value; } }
+                protected override string ValueTypeUri { get { return null; } }
+            }
+        }
+
+        class WSSecureConversationFeb2005 : WSSecureConversation
+        {
+            public WSSecureConversationFeb2005(KeyInfoSerializer securityTokenSerializer)
+                : base(securityTokenSerializer)
+            {
+            }
+
+            public override SecureConversationDictionary SerializerDictionary
+            {
+                get { return this.SecurityTokenSerializer.DictionaryManager.SecureConversationFeb2005Dictionary; }
+            }
+
+            public override void PopulateStrEntries(IList<StrEntry> strEntries)
+            {
+                strEntries.Add(new SctStrEntryFeb2005(this));
+            }
+
+            class SctStrEntryFeb2005 : SctStrEntry
+            {
+                public SctStrEntryFeb2005(WSSecureConversationFeb2005 parent)
+                    : base(parent)
+                {
+                }
+
+                protected override System.Xml.UniqueId ReadGeneration(XmlDictionaryReader reader)
+                {
+                    return XmlHelper.GetAttributeAsUniqueId(
+                        reader,
+                        this.Parent.SecurityTokenSerializer.DictionaryManager.SecureConversationDec2005Dictionary.Instance,
+                        this.Parent.SecurityTokenSerializer.DictionaryManager.SecureConversationFeb2005Dictionary.Namespace);
+                }
+
+                protected override void WriteGeneration(XmlDictionaryWriter writer, SecurityContextKeyIdentifierClause clause)
+                {
+                    // serialize the generation
+                    if (clause.Generation != null)
+                    {
+                        XmlHelper.WriteAttributeStringAsUniqueId(
+                            writer,
+                            this.Parent.SecurityTokenSerializer.DictionaryManager.SecureConversationFeb2005Dictionary.Prefix.Value,
+                            this.Parent.SecurityTokenSerializer.DictionaryManager.SecureConversationDec2005Dictionary.Instance,
+                            this.Parent.SecurityTokenSerializer.DictionaryManager.SecureConversationFeb2005Dictionary.Namespace,
+                            clause.Generation);
+                    }
+                }
+            }
+        }
+
+        class WSSecureConversationDec2005 : WSSecureConversation
+        {
+            public WSSecureConversationDec2005(KeyInfoSerializer securityTokenSerializer)
+                : base(securityTokenSerializer)
+            {
+            }
+
+            public override SecureConversationDictionary SerializerDictionary
+            {
+                get { return this.SecurityTokenSerializer.DictionaryManager.SecureConversationDec2005Dictionary; }
+            }
+
+            public override void PopulateStrEntries(IList<StrEntry> strEntries)
+            {
+                strEntries.Add(new SctStrEntryDec2005(this));
+            }
+
+            public override string DerivationAlgorithm
+            {
+                get
+                {
+                    return SecurityAlgorithms.Psha1KeyDerivationDec2005;
+                }
+            }
+
+            class SctStrEntryDec2005 : SctStrEntry
+            {
+                public SctStrEntryDec2005(WSSecureConversationDec2005 parent)
+                    : base(parent)
+                {
+                }
+
+                protected override System.Xml.UniqueId ReadGeneration(XmlDictionaryReader reader)
+                {
+                    return XmlHelper.GetAttributeAsUniqueId(reader, this.Parent.SecurityTokenSerializer.DictionaryManager.SecureConversationDec2005Dictionary.Instance,
+                        this.Parent.SecurityTokenSerializer.DictionaryManager.SecureConversationDec2005Dictionary.Namespace);
+                }
+
+                protected override void WriteGeneration(XmlDictionaryWriter writer, SecurityContextKeyIdentifierClause clause)
+                {
+                    // serialize the generation
+                    if (clause.Generation != null)
+                    {
+                        XmlHelper.WriteAttributeStringAsUniqueId(
+                            writer,
+                            this.Parent.SecurityTokenSerializer.DictionaryManager.SecureConversationDec2005Dictionary.Prefix.Value,
+                            this.Parent.SecurityTokenSerializer.DictionaryManager.SecureConversationDec2005Dictionary.Instance,
+                            this.Parent.SecurityTokenSerializer.DictionaryManager.SecureConversationDec2005Dictionary.Namespace,
+                            clause.Generation);
+                    }
+                }
+            }
+
+        }
+
+        #endregion
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/WSSecureConversation.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/WSSecureConversation.cs
new file mode 100644
index 0000000..41d9683
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/WSSecureConversation.cs
@@ -0,0 +1,589 @@
+//------------------------------------------------------------
+// Copyright (c) Microsoft Corporation.  All rights reserved.
+//------------------------------------------------------------
+
+namespace CoreWCF.Security
+{
+    using System;
+    using System.Collections.Generic;
+    using CoreWCF.IdentityModel.Selectors;
+    using CoreWCF.IdentityModel.Tokens;
+    using System.Runtime;
+    using CoreWCF;
+    using CoreWCF.Security.Tokens;
+    using System.Xml;
+    using StrEntry = WSSecurityTokenSerializer.StrEntry;
+    using TokenEntry = WSSecurityTokenSerializer.TokenEntry;
+    using CoreWCF.IdentityModel;
+    using CoreWCF.Runtime;
+
+    abstract class WSSecureConversation : WSSecurityTokenSerializer.SerializerEntries
+    {
+        WSSecurityTokenSerializer tokenSerializer;
+        DerivedKeyTokenEntry derivedKeyEntry;
+
+        protected WSSecureConversation(WSSecurityTokenSerializer tokenSerializer, int maxKeyDerivationOffset, int maxKeyDerivationLabelLength, int maxKeyDerivationNonceLength)
+        {
+            if (tokenSerializer == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("tokenSerializer");
+            }
+            this.tokenSerializer = tokenSerializer;
+            this.derivedKeyEntry = new DerivedKeyTokenEntry(this, maxKeyDerivationOffset, maxKeyDerivationLabelLength, maxKeyDerivationNonceLength);
+        }
+
+        public abstract SecureConversationDictionary SerializerDictionary
+        {
+            get;
+        }
+
+        public WSSecurityTokenSerializer WSSecurityTokenSerializer
+        {
+            get { return this.tokenSerializer; }
+        }
+
+        public override void PopulateTokenEntries(IList<TokenEntry> tokenEntryList)
+        {
+            if (tokenEntryList == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("tokenEntryList");
+            }
+            tokenEntryList.Add(this.derivedKeyEntry);
+        }
+
+        public virtual bool IsAtDerivedKeyToken(XmlDictionaryReader reader)
+        {
+            return this.derivedKeyEntry.CanReadTokenCore(reader);
+        }
+
+        public virtual void ReadDerivedKeyTokenParameters(XmlDictionaryReader reader, SecurityTokenResolver tokenResolver, out string id, out string derivationAlgorithm, out string label, out int length, out byte[] nonce, out int offset, out int generation, out SecurityKeyIdentifierClause tokenToDeriveIdentifier, out SecurityToken tokenToDerive)
+        {
+            this.derivedKeyEntry.ReadDerivedKeyTokenParameters(reader, tokenResolver, out id, out derivationAlgorithm, out label,
+                out length, out nonce, out offset, out generation, out tokenToDeriveIdentifier, out tokenToDerive);
+        }
+
+        public virtual SecurityToken CreateDerivedKeyToken(string id, string derivationAlgorithm, string label, int length, byte[] nonce, int offset, int generation, SecurityKeyIdentifierClause tokenToDeriveIdentifier, SecurityToken tokenToDerive)
+        {
+            return this.derivedKeyEntry.CreateDerivedKeyToken(id, derivationAlgorithm, label, length, nonce, offset, generation,
+                tokenToDeriveIdentifier, tokenToDerive);
+        }
+
+        public virtual string DerivationAlgorithm
+        {
+            get { return SecurityAlgorithms.Psha1KeyDerivation; }
+        }
+
+        protected class DerivedKeyTokenEntry : WSSecurityTokenSerializer.TokenEntry
+        {
+            public const string DefaultLabel = "WS-SecureConversation";
+
+            WSSecureConversation parent;
+            int maxKeyDerivationOffset;
+            int maxKeyDerivationLabelLength;
+            int maxKeyDerivationNonceLength;
+
+            public DerivedKeyTokenEntry(WSSecureConversation parent, int maxKeyDerivationOffset, int maxKeyDerivationLabelLength, int maxKeyDerivationNonceLength)
+            {
+                if (parent == null)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("parent");
+                }
+                this.parent = parent;
+                this.maxKeyDerivationOffset = maxKeyDerivationOffset;
+                this.maxKeyDerivationLabelLength = maxKeyDerivationLabelLength;
+                this.maxKeyDerivationNonceLength = maxKeyDerivationNonceLength;
+            }
+
+            protected override XmlDictionaryString LocalName { get { return parent.SerializerDictionary.DerivedKeyToken; } }
+            protected override XmlDictionaryString NamespaceUri { get { return parent.SerializerDictionary.Namespace; } }
+            protected override Type[] GetTokenTypesCore() { return new Type[] { typeof(DerivedKeySecurityToken) }; }
+            public override string TokenTypeUri { get { return parent.SerializerDictionary.DerivedKeyTokenType.Value; } }
+            protected override string ValueTypeUri { get { return null; } }
+
+            public override SecurityKeyIdentifierClause CreateKeyIdentifierClauseFromTokenXmlCore(XmlElement issuedTokenXml,
+                SecurityTokenReferenceStyle tokenReferenceStyle)
+            {
+                TokenReferenceStyleHelper.Validate(tokenReferenceStyle);
+
+                switch (tokenReferenceStyle)
+                {
+                    case SecurityTokenReferenceStyle.Internal:
+                        return CreateDirectReference(issuedTokenXml, UtilityStrings.IdAttribute, UtilityStrings.Namespace, typeof(DerivedKeySecurityToken));
+                    case SecurityTokenReferenceStyle.External:
+                        // DerivedKeys aren't referred to externally
+                        return null;
+                    default:
+                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("tokenReferenceStyle"));
+                }
+
+            }
+
+            // xml format
+            //<DerivedKeyToken wsu:Id="..." wsse:Algorithm="..."> id required, alg optional (curr disallowed)
+            //  <SecurityTokenReference>...</SecurityTokenReference> - required
+            //  <Properties>...</Properties> - disallowed (optional in spec, but we disallow it)
+            // choice begin - (schema requires a choice - we allow neither on read - we always write one)
+            //  <Generation>...</Generation> - optional
+            //  <Offset>...</Offset> - optional
+            // choice end
+            //  <Length>...</Length> - optional - default 32 on read (default specified in spec, not in schema - we always write it)
+            //  <Label>...</Label> - optional
+            //  <Nonce>...</Nonce> - required (optional in spec, but we require it)
+            //</DerivedKeyToken>
+            public virtual void ReadDerivedKeyTokenParameters(XmlDictionaryReader reader, SecurityTokenResolver tokenResolver, out string id, out string derivationAlgorithm, out string label, out int length, out byte[] nonce, out int offset, out int generation, out SecurityKeyIdentifierClause tokenToDeriveIdentifier, out SecurityToken tokenToDerive)
+            {
+                if (tokenResolver == null)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("tokenResolver");
+                }
+
+                id = reader.GetAttribute(CoreWCF.XD.UtilityDictionary.IdAttribute, CoreWCF.XD.UtilityDictionary.Namespace);
+
+                derivationAlgorithm = reader.GetAttribute(CoreWCF.XD.XmlSignatureDictionary.Algorithm, null);
+                if (derivationAlgorithm == null)
+                {
+                    derivationAlgorithm = parent.DerivationAlgorithm;
+                }
+
+                reader.ReadStartElement();
+
+                tokenToDeriveIdentifier = null;
+                tokenToDerive = null;
+
+                if (reader.IsStartElement(CoreWCF.XD.SecurityJan2004Dictionary.SecurityTokenReference, CoreWCF.XD.SecurityJan2004Dictionary.Namespace))
+                {
+                    tokenToDeriveIdentifier = parent.WSSecurityTokenSerializer.ReadKeyIdentifierClause(reader);
+                    tokenResolver.TryResolveToken(tokenToDeriveIdentifier, out tokenToDerive);
+                }
+                else
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new XmlException(SR.Format(SR.DerivedKeyTokenRequiresTokenReference)));
+                }
+
+                // no support for properties
+
+                generation = -1;
+                if (reader.IsStartElement(parent.SerializerDictionary.Generation, parent.SerializerDictionary.Namespace))
+                {
+                    reader.ReadStartElement();
+                    generation = reader.ReadContentAsInt();
+                    reader.ReadEndElement();
+                    if (generation < 0)
+                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new XmlException(SR.Format(SR.DerivedKeyInvalidGenerationSpecified, generation)));
+                }
+
+                offset = -1;
+                if (reader.IsStartElement(parent.SerializerDictionary.Offset, parent.SerializerDictionary.Namespace))
+                {
+                    reader.ReadStartElement();
+                    offset = reader.ReadContentAsInt();
+                    reader.ReadEndElement();
+                    if (offset < 0)
+                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new XmlException(SR.Format(SR.DerivedKeyInvalidOffsetSpecified, offset)));
+                }
+
+                length = DerivedKeySecurityToken.DefaultDerivedKeyLength;
+                if (reader.IsStartElement(parent.SerializerDictionary.Length, parent.SerializerDictionary.Namespace))
+                {
+                    reader.ReadStartElement();
+                    length = reader.ReadContentAsInt();
+                    reader.ReadEndElement();
+                }
+
+                if ((offset == -1) && (generation == -1))
+                    offset = 0;
+
+                // verify that the offset is not larger than the max allowed
+                DerivedKeySecurityToken.EnsureAcceptableOffset(offset, generation, length, this.maxKeyDerivationOffset);
+
+                label = null;
+                if (reader.IsStartElement(parent.SerializerDictionary.Label, parent.SerializerDictionary.Namespace))
+                {
+                    reader.ReadStartElement();
+                    label = reader.ReadString();
+                    reader.ReadEndElement();
+                }
+                if (label != null && label.Length > this.maxKeyDerivationLabelLength)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new MessageSecurityException(SR.Format(SR.DerivedKeyTokenLabelTooLong, label.Length, this.maxKeyDerivationLabelLength)));
+                }
+
+                nonce = null;
+                reader.ReadStartElement(parent.SerializerDictionary.Nonce, parent.SerializerDictionary.Namespace);
+                nonce = reader.ReadContentAsBase64();
+                reader.ReadEndElement();
+
+                if (nonce != null && nonce.Length > this.maxKeyDerivationNonceLength)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new MessageSecurityException(SR.Format(SR.DerivedKeyTokenNonceTooLong, nonce.Length, this.maxKeyDerivationNonceLength)));
+                }
+
+                reader.ReadEndElement();
+            }
+
+            public virtual SecurityToken CreateDerivedKeyToken(string id, string derivationAlgorithm, string label, int length, byte[] nonce, int offset, int generation, SecurityKeyIdentifierClause tokenToDeriveIdentifier, SecurityToken tokenToDerive)
+            {
+                if (tokenToDerive == null)
+                {
+                    return new DerivedKeySecurityTokenStub(generation, offset, length,
+                        label, nonce, tokenToDeriveIdentifier, derivationAlgorithm, id);
+                }
+                else
+                {
+                    return new DerivedKeySecurityToken(generation, offset, length,
+                        label, nonce, tokenToDerive, tokenToDeriveIdentifier, derivationAlgorithm, id);
+                }
+            }
+
+            public override SecurityToken ReadTokenCore(XmlDictionaryReader reader, SecurityTokenResolver tokenResolver)
+            {
+                string id;
+                string derivationAlgorithm;
+                string label;
+                int length;
+                byte[] nonce;
+                int offset;
+                int generation;
+                SecurityKeyIdentifierClause tokenToDeriveIdentifier;
+                SecurityToken tokenToDerive;
+                this.ReadDerivedKeyTokenParameters(reader, tokenResolver, out id, out derivationAlgorithm, out label, out length,
+                    out nonce, out offset, out generation, out tokenToDeriveIdentifier, out tokenToDerive);
+
+                return CreateDerivedKeyToken(id, derivationAlgorithm, label, length, nonce, offset, generation,
+                    tokenToDeriveIdentifier, tokenToDerive);
+            }
+
+            public override void WriteTokenCore(XmlDictionaryWriter writer, SecurityToken token)
+            {
+                DerivedKeySecurityToken derivedKeyToken = token as DerivedKeySecurityToken;
+                string serializerPrefix = parent.SerializerDictionary.Prefix.Value;
+
+                writer.WriteStartElement(serializerPrefix, parent.SerializerDictionary.DerivedKeyToken, parent.SerializerDictionary.Namespace);
+                if (derivedKeyToken.Id != null)
+                {
+                    writer.WriteAttributeString(CoreWCF.XD.UtilityDictionary.Prefix.Value, CoreWCF.XD.UtilityDictionary.IdAttribute, CoreWCF.XD.UtilityDictionary.Namespace, derivedKeyToken.Id);
+                }
+                if (derivedKeyToken.KeyDerivationAlgorithm != parent.DerivationAlgorithm)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new MessageSecurityException(SR.Format(SR.UnsupportedKeyDerivationAlgorithm, derivedKeyToken.KeyDerivationAlgorithm)));
+                }
+                parent.WSSecurityTokenSerializer.WriteKeyIdentifierClause(writer, derivedKeyToken.TokenToDeriveIdentifier);
+
+                // Don't support Properties element
+                if (derivedKeyToken.Generation > 0 || derivedKeyToken.Offset > 0 || derivedKeyToken.Length != 32)
+                {
+                    // this means they're both specified (offset must be gen * length) - we'll write generation
+                    if (derivedKeyToken.Generation >= 0 && derivedKeyToken.Offset >= 0)
+                    {
+                        writer.WriteStartElement(serializerPrefix, parent.SerializerDictionary.Generation, parent.SerializerDictionary.Namespace);
+                        writer.WriteValue(derivedKeyToken.Generation);
+                        writer.WriteEndElement();
+                    }
+                    else if (derivedKeyToken.Generation != -1)
+                    {
+                        writer.WriteStartElement(serializerPrefix, parent.SerializerDictionary.Generation, parent.SerializerDictionary.Namespace);
+                        writer.WriteValue(derivedKeyToken.Generation);
+                        writer.WriteEndElement();
+                    }
+                    else if (derivedKeyToken.Offset != -1)
+                    {
+                        writer.WriteStartElement(serializerPrefix, parent.SerializerDictionary.Offset, parent.SerializerDictionary.Namespace);
+                        writer.WriteValue(derivedKeyToken.Offset);
+                        writer.WriteEndElement();
+                    }
+
+                    if (derivedKeyToken.Length != 32)
+                    {
+                        writer.WriteStartElement(serializerPrefix, parent.SerializerDictionary.Length, parent.SerializerDictionary.Namespace);
+                        writer.WriteValue(derivedKeyToken.Length);
+                        writer.WriteEndElement();
+                    }
+                }
+
+                if (derivedKeyToken.Label != null)
+                {
+                    writer.WriteStartElement(serializerPrefix, parent.SerializerDictionary.Generation, parent.SerializerDictionary.Namespace);
+                    writer.WriteString(derivedKeyToken.Label);
+                    writer.WriteEndElement();
+                }
+                writer.WriteStartElement(serializerPrefix, parent.SerializerDictionary.Nonce, parent.SerializerDictionary.Namespace);
+                writer.WriteBase64(derivedKeyToken.Nonce, 0, derivedKeyToken.Nonce.Length);
+                writer.WriteEndElement();
+                writer.WriteEndElement();
+            }
+        }
+
+        protected abstract class SecurityContextTokenEntry : WSSecurityTokenSerializer.TokenEntry
+        {
+            WSSecureConversation parent;
+          //  SecurityContextCookieSerializer cookieSerializer;
+
+            public SecurityContextTokenEntry(WSSecureConversation parent, SecurityStateEncoder securityStateEncoder, IList<Type> knownClaimTypes)
+            {
+                this.parent = parent;
+             //   this.cookieSerializer = new SecurityContextCookieSerializer(securityStateEncoder, knownClaimTypes);
+            }
+
+            protected WSSecureConversation Parent
+            {
+                get { return this.parent; }
+            }
+
+            protected override XmlDictionaryString LocalName { get { return parent.SerializerDictionary.SecurityContextToken; } }
+            protected override XmlDictionaryString NamespaceUri { get { return parent.SerializerDictionary.Namespace; } }
+            protected override Type[] GetTokenTypesCore() { return new Type[] { typeof(SecurityContextSecurityToken) }; }
+            public override string TokenTypeUri { get { return parent.SerializerDictionary.SecurityContextTokenType.Value; } }
+            protected override string ValueTypeUri { get { return null; } }
+
+            public override SecurityKeyIdentifierClause CreateKeyIdentifierClauseFromTokenXmlCore(XmlElement issuedTokenXml,
+                SecurityTokenReferenceStyle tokenReferenceStyle)
+            {
+
+                TokenReferenceStyleHelper.Validate(tokenReferenceStyle);
+
+                switch (tokenReferenceStyle)
+                {
+                    case SecurityTokenReferenceStyle.Internal:
+                        return CreateDirectReference(issuedTokenXml, UtilityStrings.IdAttribute, UtilityStrings.Namespace, typeof(SecurityContextSecurityToken));
+                    case SecurityTokenReferenceStyle.External:
+                        UniqueId contextId = null;
+                        UniqueId generation = null;
+                        foreach (XmlNode node in issuedTokenXml.ChildNodes)
+                        {
+                            XmlElement element = node as XmlElement;
+                            if (element != null)
+                            {
+                                if (element.LocalName == parent.SerializerDictionary.Identifier.Value && element.NamespaceURI == parent.SerializerDictionary.Namespace.Value)
+                                {
+                                    contextId = XmlHelper.ReadTextElementAsUniqueId(element);
+                                }
+                                else if (CanReadGeneration(element))
+                                {
+                                    generation = ReadGeneration(element);
+                                }
+                            }
+                        }
+                        return new SecurityContextKeyIdentifierClause(contextId, generation);
+                    default:
+                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("tokenReferenceStyle"));
+                }
+            }
+
+            protected abstract bool CanReadGeneration(XmlDictionaryReader reader);
+            protected abstract bool CanReadGeneration(XmlElement element);
+            protected abstract UniqueId ReadGeneration(XmlDictionaryReader reader);
+            protected abstract UniqueId ReadGeneration(XmlElement element);
+
+            SecurityContextSecurityToken TryResolveSecurityContextToken(UniqueId contextId, UniqueId generation, string id, SecurityTokenResolver tokenResolver, out ISecurityContextSecurityTokenCache sctCache)
+            {
+                SecurityContextSecurityToken cachedSct = null;
+                sctCache = null;
+                if (tokenResolver is ISecurityContextSecurityTokenCache)
+                {
+                    sctCache = ((ISecurityContextSecurityTokenCache)tokenResolver);
+                    cachedSct = sctCache.GetContext(contextId, generation);
+                }
+                else if (tokenResolver is AggregateSecurityHeaderTokenResolver)
+                {
+                    // We will see if we have a ISecurityContextSecurityTokenCache in the 
+                    // AggregateTokenResolver. We will hold the reference to the first sctCache
+                    // we find.
+                    AggregateSecurityHeaderTokenResolver aggregateTokenResolve = tokenResolver as AggregateSecurityHeaderTokenResolver;
+                    for (int i = 0; i < aggregateTokenResolve.TokenResolvers.Count; ++i)
+                    {
+                        ISecurityContextSecurityTokenCache oobTokenResolver = aggregateTokenResolve.TokenResolvers[i] as ISecurityContextSecurityTokenCache;
+                        if (oobTokenResolver == null)
+                        {
+                            continue;
+                        }
+                        if (sctCache == null)
+                        {
+                            sctCache = oobTokenResolver;
+                        }
+                        cachedSct = oobTokenResolver.GetContext(contextId, generation);
+                        if (cachedSct != null)
+                        {
+                            break;
+                        }
+                    }
+                }
+                if (cachedSct == null)
+                {
+                    return null;
+                }
+                else if (cachedSct.Id == id)
+                {
+                    return cachedSct;
+                }
+                else
+                {
+                    return new SecurityContextSecurityToken(cachedSct, id);
+                }
+            }
+
+            public override SecurityToken ReadTokenCore(XmlDictionaryReader reader, SecurityTokenResolver tokenResolver)
+            {
+                UniqueId contextId = null;
+                byte[] encodedCookie = null;
+                UniqueId generation = null;
+                bool isCookieMode = false;
+
+                Fx.Assert(reader.NodeType == XmlNodeType.Element, "");
+
+                // check if there is an id
+                string id = reader.GetAttribute(CoreWCF.XD.UtilityDictionary.IdAttribute, CoreWCF.XD.UtilityDictionary.Namespace);
+
+                SecurityContextSecurityToken sct = null;
+
+                // There needs to be at least a contextId in here.
+                reader.ReadFullStartElement();
+                reader.MoveToStartElement(parent.SerializerDictionary.Identifier, parent.SerializerDictionary.Namespace);
+                contextId = reader.ReadElementContentAsUniqueId();
+                if (CanReadGeneration(reader))
+                {
+                    generation = ReadGeneration(reader);
+                }
+                if (reader.IsStartElement(parent.SerializerDictionary.Cookie, CoreWCF.XD.DotNetSecurityDictionary.Namespace))
+                {
+                    isCookieMode = true;
+                    ISecurityContextSecurityTokenCache sctCache;
+                    sct = TryResolveSecurityContextToken(contextId, generation, id, tokenResolver, out sctCache);
+                    if (sct == null)
+                    {
+                        encodedCookie = reader.ReadElementContentAsBase64();
+                        if (encodedCookie != null)
+                        {
+                            throw new NotImplementedException();
+                           // sct = cookieSerializer.CreateSecurityContextFromCookie(encodedCookie, contextId, generation, id, reader.Quotas);
+                            if (sctCache != null)
+                            {
+                                sctCache.AddContext(sct);
+                            }
+                        }
+                    }
+                    else
+                    {
+                        reader.Skip();
+                    }
+                }
+                reader.ReadEndElement();
+
+                if (contextId == null)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new MessageSecurityException(SR.Format(SR.NoSecurityContextIdentifier)));
+                }
+
+                if (sct == null && !isCookieMode)
+                {
+                    ISecurityContextSecurityTokenCache sctCache;
+                    sct = TryResolveSecurityContextToken(contextId, generation, id, tokenResolver, out sctCache);
+                }
+                if (sct == null)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new Exception(SR.Format(SR.SecurityContextNotRegistered, contextId, generation)));
+                }
+                return sct;
+            }
+
+            protected virtual void WriteGeneration(XmlDictionaryWriter writer, SecurityContextSecurityToken sct)
+            {
+            }
+
+            public override void WriteTokenCore(XmlDictionaryWriter writer, SecurityToken token)
+            {
+                SecurityContextSecurityToken sct = (token as SecurityContextSecurityToken);
+
+                // serialize the name and any wsu:Id attribute
+                writer.WriteStartElement(parent.SerializerDictionary.Prefix.Value, parent.SerializerDictionary.SecurityContextToken, parent.SerializerDictionary.Namespace);
+                if (sct.Id != null)
+                {
+                    writer.WriteAttributeString(CoreWCF.XD.UtilityDictionary.Prefix.Value, CoreWCF.XD.UtilityDictionary.IdAttribute, CoreWCF.XD.UtilityDictionary.Namespace, sct.Id);
+                }
+
+                // serialize the context id
+                writer.WriteStartElement(parent.SerializerDictionary.Prefix.Value, parent.SerializerDictionary.Identifier, parent.SerializerDictionary.Namespace);
+                XmlHelper.WriteStringAsUniqueId(writer, sct.ContextId);
+                writer.WriteEndElement();
+
+                WriteGeneration(writer, sct);
+
+                // if cookie-mode, then it must have a cookie
+                if (sct.IsCookieMode)
+                {
+                    if (sct.CookieBlob == null)
+                    {
+                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new MessageSecurityException(SR.Format(SR.NoCookieInSct)));
+                    }
+
+                    // if the token has a cookie, write it out
+                    writer.WriteStartElement(CoreWCF.XD.DotNetSecurityDictionary.Prefix.Value, parent.SerializerDictionary.Cookie, CoreWCF.XD.DotNetSecurityDictionary.Namespace);
+                    writer.WriteBase64(sct.CookieBlob, 0, sct.CookieBlob.Length);
+                    writer.WriteEndElement();
+                }
+
+                writer.WriteEndElement();
+            }
+        }
+
+        public abstract class Driver : SecureConversationDriver
+        {
+            public Driver()
+            {
+            }
+
+            protected abstract SecureConversationDictionary DriverDictionary
+            {
+                get;
+            }
+
+            public override XmlDictionaryString IssueAction
+            {
+                get
+                {
+                    return DriverDictionary.RequestSecurityContextIssuance;
+                }
+            }
+
+            public override XmlDictionaryString IssueResponseAction
+            {
+                get
+                {
+                    return DriverDictionary.RequestSecurityContextIssuanceResponse;
+                }
+            }
+
+            public override XmlDictionaryString RenewNeededFaultCode
+            {
+                get { return DriverDictionary.RenewNeededFaultCode; }
+            }
+
+            public override XmlDictionaryString BadContextTokenFaultCode
+            {
+                get { return DriverDictionary.BadContextTokenFaultCode; }
+            }
+
+            public override UniqueId GetSecurityContextTokenId(XmlDictionaryReader reader)
+            {
+                if (reader == null)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("reader");
+
+                reader.ReadStartElement(DriverDictionary.SecurityContextToken, DriverDictionary.Namespace);
+                UniqueId contextId = XmlHelper.ReadElementStringAsUniqueId(reader, DriverDictionary.Identifier, DriverDictionary.Namespace);
+                while (reader.IsStartElement())
+                {
+                    reader.Skip();
+                }
+                reader.ReadEndElement();
+                return contextId;
+            }
+
+            public override bool IsAtSecurityContextToken(XmlDictionaryReader reader)
+            {
+                if (reader == null)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("reader");
+
+                return reader.IsStartElement(DriverDictionary.SecurityContextToken, DriverDictionary.Namespace);
+            }
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/WSSecureConversationDec2005.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/WSSecureConversationDec2005.cs
new file mode 100644
index 0000000..db96dd5
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/WSSecureConversationDec2005.cs
@@ -0,0 +1,167 @@
+
+
+namespace CoreWCF.Security
+{
+    using System;
+    using CoreWCF;
+    using System.Collections;
+    using System.Collections.Generic;
+    using System.Diagnostics;
+    using System.Globalization;
+    using System.IO;
+    using System.Text;
+    using System.Threading;
+    using System.Xml;
+    using CoreWCF.IdentityModel.Claims;
+    using CoreWCF.IdentityModel.Policy;
+    using CoreWCF.IdentityModel.Tokens;
+    using System.Security.Cryptography.X509Certificates;
+// using HexBinary = System.Runtime.Remoting.Metadata.W3cXsd2001.SoapHexBinary;
+    using CoreWCF.Channels;
+    using CoreWCF.Security;
+    using CoreWCF.Security.Tokens;
+    using System.Runtime.Serialization;
+    using KeyIdentifierEntry = WSSecurityTokenSerializer.KeyIdentifierEntry;
+    using KeyIdentifierClauseEntry = WSSecurityTokenSerializer.KeyIdentifierClauseEntry;
+    using StrEntry = WSSecurityTokenSerializer.StrEntry;
+    using TokenEntry = WSSecurityTokenSerializer.TokenEntry;
+
+    class WSSecureConversationDec2005 : WSSecureConversation
+    {
+        SecurityStateEncoder securityStateEncoder;
+        IList<Type> knownClaimTypes;
+
+        public WSSecureConversationDec2005(WSSecurityTokenSerializer tokenSerializer, SecurityStateEncoder securityStateEncoder, IEnumerable<Type> knownTypes,
+            int maxKeyDerivationOffset, int maxKeyDerivationLabelLength, int maxKeyDerivationNonceLength)
+            : base(tokenSerializer, maxKeyDerivationOffset, maxKeyDerivationLabelLength, maxKeyDerivationNonceLength)
+        {
+            if (securityStateEncoder != null)
+            {
+                this.securityStateEncoder = securityStateEncoder;
+            }
+            else
+            {
+                this.securityStateEncoder = new DataProtectionSecurityStateEncoder();
+            }
+
+            this.knownClaimTypes = new List<Type>();
+            if (knownTypes != null)
+            {
+                // Clone this collection.
+                foreach (Type knownType in knownTypes)
+                {
+                    this.knownClaimTypes.Add(knownType);
+                }
+            }
+        }
+
+        public override SecureConversationDictionary SerializerDictionary
+        {
+            get { return DXD.SecureConversationDec2005Dictionary; }
+        }
+
+        public override void PopulateTokenEntries(IList<TokenEntry> tokenEntryList)
+        {
+            base.PopulateTokenEntries(tokenEntryList);
+            tokenEntryList.Add(new SecurityContextTokenEntryDec2005(this, this.securityStateEncoder, this.knownClaimTypes));
+        }
+
+        public override string DerivationAlgorithm
+        {
+            get
+            {
+                return SecurityAlgorithms.Psha1KeyDerivationDec2005;
+            }
+        }
+
+        class SecurityContextTokenEntryDec2005 : SecurityContextTokenEntry
+        {
+            public SecurityContextTokenEntryDec2005(WSSecureConversationDec2005 parent, SecurityStateEncoder securityStateEncoder, IList<Type> knownClaimTypes)
+                : base(parent, securityStateEncoder, knownClaimTypes)
+            {
+            }
+
+            protected override bool CanReadGeneration(XmlDictionaryReader reader)
+            {
+                return reader.IsStartElement(DXD.SecureConversationDec2005Dictionary.Instance, DXD.SecureConversationDec2005Dictionary.Namespace);
+            }
+
+            protected override bool CanReadGeneration(XmlElement element)
+            {
+                return (element.LocalName == DXD.SecureConversationDec2005Dictionary.Instance.Value &&
+                    element.NamespaceURI == DXD.SecureConversationDec2005Dictionary.Namespace.Value);
+            }
+
+            protected override UniqueId ReadGeneration(XmlDictionaryReader reader)
+            {
+                return reader.ReadElementContentAsUniqueId();
+            }
+
+            protected override UniqueId ReadGeneration(XmlElement element)
+            {
+                return XmlHelper.ReadTextElementAsUniqueId(element);
+            }
+
+            protected override void WriteGeneration(XmlDictionaryWriter writer, SecurityContextSecurityToken sct)
+            {
+                // serialize the generation
+                if (sct.KeyGeneration != null)
+                {
+                    writer.WriteStartElement(DXD.SecureConversationDec2005Dictionary.Prefix.Value,
+                        DXD.SecureConversationDec2005Dictionary.Instance,
+                        DXD.SecureConversationDec2005Dictionary.Namespace);
+                    XmlHelper.WriteStringAsUniqueId(writer, sct.KeyGeneration);
+                    writer.WriteEndElement();
+                }
+            }
+        }
+
+        public class DriverDec2005 : Driver
+        {
+            public DriverDec2005()
+            {
+            }
+
+            protected override SecureConversationDictionary DriverDictionary
+            {
+                get { return DXD.SecureConversationDec2005Dictionary; }
+            }
+
+            public override XmlDictionaryString CloseAction
+            {
+                get { return DXD.SecureConversationDec2005Dictionary.RequestSecurityContextClose; }
+            }
+
+            public override XmlDictionaryString CloseResponseAction
+            {
+                get { return DXD.SecureConversationDec2005Dictionary.RequestSecurityContextCloseResponse; }
+            }
+
+            public override bool IsSessionSupported
+            {
+                get { return true; }
+            }
+
+            public override XmlDictionaryString RenewAction
+            {
+                get { return DXD.SecureConversationDec2005Dictionary.RequestSecurityContextRenew; }
+            }
+
+            public override XmlDictionaryString RenewResponseAction
+            {
+                get { return DXD.SecureConversationDec2005Dictionary.RequestSecurityContextRenewResponse; }
+            }
+
+            public override XmlDictionaryString Namespace
+            {
+                get { return DXD.SecureConversationDec2005Dictionary.Namespace; }
+            }
+
+            public override string TokenTypeUri
+            {
+                get { return DXD.SecureConversationDec2005Dictionary.SecurityContextTokenType.Value; }
+            }
+        }
+    }
+}
+
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/WSSecureConversationFeb2005.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/WSSecureConversationFeb2005.cs
new file mode 100644
index 0000000..fea34a2
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/WSSecureConversationFeb2005.cs
@@ -0,0 +1,159 @@
+//------------------------------------------------------------
+// Copyright (c) Microsoft Corporation.  All rights reserved.
+//------------------------------------------------------------
+
+namespace CoreWCF.Security
+{
+    using System;
+    using CoreWCF;
+    using System.Collections;
+    using System.Collections.Generic;
+    using System.Diagnostics;
+    using System.Globalization;
+    using System.IO;
+    using System.Text;
+    using System.Threading;
+    using System.Xml;
+    using CoreWCF.IdentityModel.Claims;
+    using CoreWCF.IdentityModel.Policy;
+    using CoreWCF.IdentityModel.Tokens;
+    using System.Security.Cryptography.X509Certificates;
+   // using HexBinary = System.Runtime.Remoting.Metadata.W3cXsd2001.SoapHexBinary;
+    using CoreWCF.Channels;
+    using CoreWCF.Security;
+    using CoreWCF.Security.Tokens;
+    using System.Runtime.Serialization;
+    using KeyIdentifierEntry = WSSecurityTokenSerializer.KeyIdentifierEntry;
+    using KeyIdentifierClauseEntry = WSSecurityTokenSerializer.KeyIdentifierClauseEntry;
+    using StrEntry = WSSecurityTokenSerializer.StrEntry;
+    using TokenEntry = WSSecurityTokenSerializer.TokenEntry;
+    
+    class WSSecureConversationFeb2005 : WSSecureConversation
+    {
+        SecurityStateEncoder securityStateEncoder;
+        IList<Type> knownClaimTypes;
+
+        public WSSecureConversationFeb2005(WSSecurityTokenSerializer tokenSerializer, SecurityStateEncoder securityStateEncoder, IEnumerable<Type> knownTypes,
+            int maxKeyDerivationOffset, int maxKeyDerivationLabelLength, int maxKeyDerivationNonceLength)
+            : base(tokenSerializer, maxKeyDerivationOffset, maxKeyDerivationLabelLength, maxKeyDerivationNonceLength)
+        {
+            if (securityStateEncoder != null)
+            {
+                this.securityStateEncoder = securityStateEncoder;
+            }
+            else
+            {
+                this.securityStateEncoder = new DataProtectionSecurityStateEncoder();
+            }
+
+            this.knownClaimTypes = new List<Type>();
+            if (knownTypes != null)
+            {
+                // Clone this collection.
+                foreach (Type knownType in knownTypes)
+                {
+                    this.knownClaimTypes.Add(knownType);
+                }
+            }
+        }
+
+        public override SecureConversationDictionary SerializerDictionary
+        {
+            get { return XD.SecureConversationFeb2005Dictionary; }
+        }
+        
+        public override void PopulateTokenEntries(IList<TokenEntry> tokenEntryList)
+        {
+            base.PopulateTokenEntries(tokenEntryList);
+            tokenEntryList.Add(new SecurityContextTokenEntryFeb2005(this, this.securityStateEncoder, this.knownClaimTypes));
+        }
+
+        class SecurityContextTokenEntryFeb2005 : SecurityContextTokenEntry
+        {
+            public SecurityContextTokenEntryFeb2005(WSSecureConversationFeb2005 parent, SecurityStateEncoder securityStateEncoder, IList<Type> knownClaimTypes)
+                : base(parent, securityStateEncoder, knownClaimTypes)
+            {
+            }
+            
+            protected override bool CanReadGeneration(XmlDictionaryReader reader)
+            {
+                return reader.IsStartElement(DXD.SecureConversationDec2005Dictionary.Instance, XD.SecureConversationFeb2005Dictionary.Namespace);
+            }
+            
+            protected override bool CanReadGeneration(XmlElement element)
+            {
+                return (element.LocalName == DXD.SecureConversationDec2005Dictionary.Instance.Value &&
+                    element.NamespaceURI == XD.SecureConversationFeb2005Dictionary.Namespace.Value);
+            }
+            
+            protected override UniqueId ReadGeneration(XmlDictionaryReader reader)
+            {
+                return reader.ReadElementContentAsUniqueId();
+            }
+
+            protected override UniqueId ReadGeneration(XmlElement element)
+            {
+                return XmlHelper.ReadTextElementAsUniqueId(element);
+            }
+            
+            protected override void WriteGeneration(XmlDictionaryWriter writer, SecurityContextSecurityToken sct)
+            {
+                // serialize the generation
+                if (sct.KeyGeneration != null)
+                {
+                    writer.WriteStartElement(XD.SecureConversationFeb2005Dictionary.Prefix.Value, DXD.SecureConversationDec2005Dictionary.Instance,
+                        XD.SecureConversationFeb2005Dictionary.Namespace);
+                    XmlHelper.WriteStringAsUniqueId(writer, sct.KeyGeneration);
+                    writer.WriteEndElement();
+                }
+            }
+        }
+
+        public class DriverFeb2005 : Driver
+        {
+            public DriverFeb2005()
+            {
+            }
+
+            protected override SecureConversationDictionary DriverDictionary
+            {
+                get { return XD.SecureConversationFeb2005Dictionary; }
+            }
+
+            public override XmlDictionaryString CloseAction
+            {
+                get { return XD.SecureConversationFeb2005Dictionary.RequestSecurityContextClose; }
+            }
+
+            public override XmlDictionaryString CloseResponseAction
+            {
+                get { return XD.SecureConversationFeb2005Dictionary.RequestSecurityContextCloseResponse; }
+            }
+
+            public override bool IsSessionSupported
+            {
+                get { return true; }
+            }
+
+            public override XmlDictionaryString RenewAction
+            {
+                get { return XD.SecureConversationFeb2005Dictionary.RequestSecurityContextRenew; }
+            }
+
+            public override XmlDictionaryString RenewResponseAction
+            {
+                get { return XD.SecureConversationFeb2005Dictionary.RequestSecurityContextRenewResponse; }
+            }
+
+            public override XmlDictionaryString Namespace
+            {
+                get { return XD.SecureConversationFeb2005Dictionary.Namespace; }
+            }
+
+            public override string TokenTypeUri
+            {
+                get { return XD.SecureConversationFeb2005Dictionary.SecurityContextTokenType.Value; }
+            }
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/WSSecurityJan2004.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/WSSecurityJan2004.cs
new file mode 100644
index 0000000..db6a0f8
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/WSSecurityJan2004.cs
@@ -0,0 +1,455 @@
+﻿
+
+using System.Collections.Generic;
+using CoreWCF.IdentityModel.Selectors;
+using CoreWCF.IdentityModel.Tokens;
+using System.Security.Cryptography.X509Certificates;
+using CoreWCF.Security.Tokens;
+using System.Xml;
+//using HexBinary = System.Runtime.Remoting.Metadata.W3cXsd2001.SoapHexBinary;
+using TokenEntry = CoreWCF.Security.WSSecurityTokenSerializer.TokenEntry;
+using CoreWCF.IdentityModel;
+using System;
+
+namespace CoreWCF.Security
+{
+    internal class WSSecurityJan2004 : WSSecurityTokenSerializer.SerializerEntries
+    {
+        private SamlSerializer _samlSerializer;
+
+        public WSSecurityJan2004(WSSecurityTokenSerializer tokenSerializer, SamlSerializer samlSerializer)
+        {
+            WSSecurityTokenSerializer = tokenSerializer;
+            _samlSerializer = samlSerializer;
+        }
+
+        public WSSecurityTokenSerializer WSSecurityTokenSerializer { get; }
+
+        public SamlSerializer SamlSerializer
+        {
+            get { return _samlSerializer; }
+        }
+
+        protected void PopulateJan2004TokenEntries(IList<TokenEntry> tokenEntryList)
+        {
+            tokenEntryList.Add(new GenericXmlTokenEntry());
+            tokenEntryList.Add(new UserNamePasswordTokenEntry(WSSecurityTokenSerializer));
+            tokenEntryList.Add(new X509TokenEntry(WSSecurityTokenSerializer));
+        }
+
+        public override void PopulateTokenEntries(IList<TokenEntry> tokenEntryList)
+        {
+            PopulateJan2004TokenEntries(tokenEntryList);
+        }
+
+        internal abstract class BinaryTokenEntry : TokenEntry
+        {
+            internal static readonly XmlDictionaryString ElementName = XD.SecurityJan2004Dictionary.BinarySecurityToken;
+            internal static readonly XmlDictionaryString EncodingTypeAttribute = XD.SecurityJan2004Dictionary.EncodingType;
+            internal const string EncodingTypeAttributeString = SecurityJan2004Strings.EncodingType;
+            internal const string EncodingTypeValueBase64Binary = SecurityJan2004Strings.EncodingTypeValueBase64Binary;
+            internal const string EncodingTypeValueHexBinary = SecurityJan2004Strings.EncodingTypeValueHexBinary;
+            internal static readonly XmlDictionaryString ValueTypeAttribute = XD.SecurityJan2004Dictionary.ValueType;
+
+            private WSSecurityTokenSerializer _tokenSerializer;
+            private string[] _valueTypeUris = null;
+
+            protected BinaryTokenEntry(WSSecurityTokenSerializer tokenSerializer, string valueTypeUri)
+            {
+                _tokenSerializer = tokenSerializer;
+                _valueTypeUris = new string[1];
+                _valueTypeUris[0] = valueTypeUri;
+            }
+
+            protected BinaryTokenEntry(WSSecurityTokenSerializer tokenSerializer, string[] valueTypeUris)
+            {
+                if (valueTypeUris == null)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(valueTypeUris));
+                }
+
+                _tokenSerializer = tokenSerializer;
+                _valueTypeUris = new string[valueTypeUris.GetLength(0)];
+                for (int i = 0; i < _valueTypeUris.GetLength(0); ++i)
+                {
+                    _valueTypeUris[i] = valueTypeUris[i];
+                }
+            }
+
+            protected override XmlDictionaryString LocalName { get { return ElementName; } }
+            protected override XmlDictionaryString NamespaceUri { get { return XD.SecurityJan2004Dictionary.Namespace; } }
+            public override string TokenTypeUri { get { return _valueTypeUris[0]; } }
+            protected override string ValueTypeUri { get { return _valueTypeUris[0]; } }
+            public override bool SupportsTokenTypeUri(string tokenTypeUri)
+            {
+                for (int i = 0; i < _valueTypeUris.GetLength(0); ++i)
+                {
+                    if (_valueTypeUris[i] == tokenTypeUri)
+                    {
+                        return true;
+                    }
+                }
+
+                return false;
+            }
+
+            public abstract SecurityKeyIdentifierClause CreateKeyIdentifierClauseFromBinaryCore(byte[] rawData);
+
+            public override SecurityKeyIdentifierClause CreateKeyIdentifierClauseFromTokenXmlCore(XmlElement issuedTokenXml,
+                SecurityTokenReferenceStyle tokenReferenceStyle)
+            {
+                TokenReferenceStyleHelper.Validate(tokenReferenceStyle);
+
+                switch (tokenReferenceStyle)
+                {
+                    case SecurityTokenReferenceStyle.Internal:
+                        return CreateDirectReference(issuedTokenXml, UtilityStrings.IdAttribute, UtilityStrings.Namespace, TokenType);
+                    case SecurityTokenReferenceStyle.External:
+                        string encoding = issuedTokenXml.GetAttribute(EncodingTypeAttributeString, null);
+                        string encodedData = issuedTokenXml.InnerText;
+
+                        byte[] binaryData;
+                        if (encoding == null || encoding == EncodingTypeValueBase64Binary)
+                        {
+                            binaryData = Convert.FromBase64String(encodedData);
+                        }
+                        else if (encoding == EncodingTypeValueHexBinary)
+                        {
+                            throw new NotImplementedException();
+                           // binaryData = HexBinary.Parse(encodedData).Value;
+                        }
+                        else
+                        {
+                            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new MessageSecurityException(SR.UnknownEncodingInBinarySecurityToken));
+                        }
+
+                        return CreateKeyIdentifierClauseFromBinaryCore(binaryData);
+                    default:
+                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(tokenReferenceStyle)));
+                }
+            }
+
+            public abstract SecurityToken ReadBinaryCore(string id, string valueTypeUri, byte[] rawData);
+
+            public override SecurityToken ReadTokenCore(XmlDictionaryReader reader, SecurityTokenResolver tokenResolver)
+            {
+                string wsuId = reader.GetAttribute(XD.UtilityDictionary.IdAttribute, XD.UtilityDictionary.Namespace);
+                string valueTypeUri = reader.GetAttribute(ValueTypeAttribute, null);
+                string encoding = reader.GetAttribute(EncodingTypeAttribute, null);
+
+                byte[] binaryData;
+                if (encoding == null || encoding == EncodingTypeValueBase64Binary)
+                {
+                    binaryData = reader.ReadElementContentAsBase64();
+                }
+                else if (encoding == EncodingTypeValueHexBinary)
+                {
+                    throw new NotImplementedException();
+                   // binaryData = HexBinary.Parse(reader.ReadElementContentAsString()).Value;
+                }
+                else
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new MessageSecurityException(SR.UnknownEncodingInBinarySecurityToken));
+                }
+
+                return ReadBinaryCore(wsuId, valueTypeUri, binaryData);
+            }
+
+            public abstract void WriteBinaryCore(SecurityToken token, out string id, out byte[] rawData);
+
+            public override void WriteTokenCore(XmlDictionaryWriter writer, SecurityToken token)
+            {
+                string id;
+                byte[] rawData;
+
+                WriteBinaryCore(token, out id, out rawData);
+
+                if (rawData == null)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(rawData));
+                }
+
+                writer.WriteStartElement(XD.SecurityJan2004Dictionary.Prefix.Value, ElementName, XD.SecurityJan2004Dictionary.Namespace);
+                if (id != null)
+                {
+                    writer.WriteAttributeString(XD.UtilityDictionary.Prefix.Value, XD.UtilityDictionary.IdAttribute, XD.UtilityDictionary.Namespace, id);
+                }
+                if (_valueTypeUris != null)
+                {
+                    writer.WriteAttributeString(ValueTypeAttribute, null, _valueTypeUris[0]);
+                }
+                if (_tokenSerializer.EmitBspRequiredAttributes)
+                {
+                    writer.WriteAttributeString(EncodingTypeAttribute, null, EncodingTypeValueBase64Binary);
+                }
+                writer.WriteBase64(rawData, 0, rawData.Length);
+                writer.WriteEndElement(); // BinarySecurityToken
+            }
+        }
+
+        private class GenericXmlTokenEntry : TokenEntry
+        {
+            protected override XmlDictionaryString LocalName { get { return null; } }
+            protected override XmlDictionaryString NamespaceUri { get { return null; } }
+            protected override Type[] GetTokenTypesCore() { return new Type[] { typeof(GenericXmlSecurityToken) }; }
+            public override string TokenTypeUri { get { return null; } }
+            protected override string ValueTypeUri { get { return null; } }
+
+            public GenericXmlTokenEntry()
+            {
+            }
+
+
+            public override bool CanReadTokenCore(XmlElement element)
+            {
+                return false;
+            }
+
+            public override bool CanReadTokenCore(XmlDictionaryReader reader)
+            {
+                return false;
+            }
+
+            public override SecurityKeyIdentifierClause CreateKeyIdentifierClauseFromTokenXmlCore(XmlElement issuedTokenXml,
+                SecurityTokenReferenceStyle tokenReferenceStyle)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new NotSupportedException());
+            }
+
+            public override SecurityToken ReadTokenCore(XmlDictionaryReader reader, SecurityTokenResolver tokenResolver)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new NotSupportedException());
+            }
+
+            public override void WriteTokenCore(XmlDictionaryWriter writer, SecurityToken token)
+            {
+                BufferedGenericXmlSecurityToken bufferedXmlToken = token as BufferedGenericXmlSecurityToken;
+                if (bufferedXmlToken != null && bufferedXmlToken.TokenXmlBuffer != null)
+                {
+                    using (XmlDictionaryReader reader = bufferedXmlToken.TokenXmlBuffer.GetReader(0))
+                    {
+                        writer.WriteNode(reader, false);
+                    }
+                }
+                else
+                {
+                    GenericXmlSecurityToken xmlToken = (GenericXmlSecurityToken)token;
+                    xmlToken.TokenXml.WriteTo(writer);
+                }
+            }
+        }
+
+        private class UserNamePasswordTokenEntry : TokenEntry
+        {
+            private WSSecurityTokenSerializer _tokenSerializer;
+
+            public UserNamePasswordTokenEntry(WSSecurityTokenSerializer tokenSerializer)
+            {
+                _tokenSerializer = tokenSerializer;
+            }
+
+            protected override XmlDictionaryString LocalName { get { return XD.SecurityJan2004Dictionary.UserNameTokenElement; } }
+            protected override XmlDictionaryString NamespaceUri { get { return XD.SecurityJan2004Dictionary.Namespace; } }
+            protected override Type[] GetTokenTypesCore() { return new Type[] { typeof(UserNameSecurityToken) }; }
+            public override string TokenTypeUri { get { return SecurityJan2004Strings.UPTokenType; } }
+            protected override string ValueTypeUri { get { return null; } }
+
+            public override SecurityKeyIdentifierClause CreateKeyIdentifierClauseFromTokenXmlCore(XmlElement issuedTokenXml,
+                SecurityTokenReferenceStyle tokenReferenceStyle)
+            {
+                TokenReferenceStyleHelper.Validate(tokenReferenceStyle);
+
+                switch (tokenReferenceStyle)
+                {
+                    case SecurityTokenReferenceStyle.Internal:
+                        return CreateDirectReference(issuedTokenXml, UtilityStrings.IdAttribute, UtilityStrings.Namespace, typeof(UserNameSecurityToken));
+                    case SecurityTokenReferenceStyle.External:
+                        // UP tokens aren't referred to externally
+                        return null;
+                    default:
+                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(tokenReferenceStyle)));
+                }
+            }
+
+            public override SecurityToken ReadTokenCore(XmlDictionaryReader reader, SecurityTokenResolver tokenResolver)
+            {
+                string id;
+                string userName;
+                string password;
+
+                ParseToken(reader, out id, out userName, out password);
+
+                if (id == null)
+                {
+                    id = SecurityUniqueId.Create().Value;
+                }
+
+                return new UserNameSecurityToken(userName, password, id);
+            }
+
+            public override void WriteTokenCore(XmlDictionaryWriter writer, SecurityToken token)
+            {
+                UserNameSecurityToken upToken = (UserNameSecurityToken)token;
+                WriteUserNamePassword(writer, upToken.Id, upToken.UserName, upToken.Password);
+            }
+
+            private void WriteUserNamePassword(XmlDictionaryWriter writer, string id, string userName, string password)
+            {
+                writer.WriteStartElement(XD.SecurityJan2004Dictionary.Prefix.Value, XD.SecurityJan2004Dictionary.UserNameTokenElement,
+                    XD.SecurityJan2004Dictionary.Namespace); // <wsse:UsernameToken
+                writer.WriteAttributeString(XD.UtilityDictionary.Prefix.Value, XD.UtilityDictionary.IdAttribute,
+                    XD.UtilityDictionary.Namespace, id); // wsu:Id="..."
+                writer.WriteElementString(XD.SecurityJan2004Dictionary.Prefix.Value, XD.SecurityJan2004Dictionary.UserNameElement,
+                    XD.SecurityJan2004Dictionary.Namespace, userName); // ><wsse:Username>...</wsse:Username>
+                if (password != null)
+                {
+                    writer.WriteStartElement(XD.SecurityJan2004Dictionary.Prefix.Value, XD.SecurityJan2004Dictionary.PasswordElement,
+                        XD.SecurityJan2004Dictionary.Namespace);
+                    if (_tokenSerializer.EmitBspRequiredAttributes)
+                    {
+                        writer.WriteAttributeString(XD.SecurityJan2004Dictionary.TypeAttribute, null, SecurityJan2004Strings.UPTokenPasswordTextValue);
+                    }
+                    writer.WriteString(password); // <wsse:Password>...</wsse:Password>
+                    writer.WriteEndElement();
+                }
+                writer.WriteEndElement(); // </wsse:UsernameToken>
+            }
+
+            private static string ParsePassword(XmlDictionaryReader reader)
+            {
+                string type = reader.GetAttribute(XD.SecurityJan2004Dictionary.TypeAttribute, null);
+                if (type != null && type.Length > 0 && type != SecurityJan2004Strings.UPTokenPasswordTextValue)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new NotSupportedException(SR.Format(SR.UnsupportedPasswordType, type)));
+                }
+
+                return reader.ReadElementString();
+            }
+
+            private static void ParseToken(XmlDictionaryReader reader, out string id, out string userName, out string password)
+            {
+                id = null;
+                userName = null;
+                password = null;
+
+                reader.MoveToContent();
+                id = reader.GetAttribute(XD.UtilityDictionary.IdAttribute, XD.UtilityDictionary.Namespace);
+
+                reader.ReadStartElement(XD.SecurityJan2004Dictionary.UserNameTokenElement, XD.SecurityJan2004Dictionary.Namespace);
+                while (reader.IsStartElement())
+                {
+                    if (reader.IsStartElement(XD.SecurityJan2004Dictionary.UserNameElement, XD.SecurityJan2004Dictionary.Namespace))
+                    {
+                        userName = reader.ReadElementString();
+                    }
+                    else if (reader.IsStartElement(XD.SecurityJan2004Dictionary.PasswordElement, XD.SecurityJan2004Dictionary.Namespace))
+                    {
+                        password = ParsePassword(reader);
+                    }
+                    else if (reader.IsStartElement(XD.SecurityJan2004Dictionary.NonceElement, XD.SecurityJan2004Dictionary.Namespace))
+                    {
+                        // Nonce can be safely ignored
+                        reader.Skip();
+                    }
+                    else if (reader.IsStartElement(XD.UtilityDictionary.CreatedElement, XD.UtilityDictionary.Namespace))
+                    {
+                        // wsu:Created can be safely ignored
+                        reader.Skip();
+                    }
+                    else
+                    {
+                        throw new NotImplementedException();
+                      //  XmlHelper.OnUnexpectedChildNodeError(SecurityJan2004Strings.UserNameTokenElement, reader);
+                    }
+                }
+                reader.ReadEndElement();
+
+                if (userName == null)
+                {
+                    throw new NotImplementedException();
+                  //  XmlHelper.OnRequiredElementMissing(SecurityJan2004Strings.UserNameElement, SecurityJan2004Strings.Namespace);
+                }
+            }
+        }
+
+        protected class X509TokenEntry : BinaryTokenEntry
+        {
+            internal const string ValueTypeAbsoluteUri = SecurityJan2004Strings.X509TokenType;
+
+            public X509TokenEntry(WSSecurityTokenSerializer tokenSerializer)
+                : base(tokenSerializer, ValueTypeAbsoluteUri)
+            {
+            }
+
+            protected override Type[] GetTokenTypesCore() { return new Type[] { typeof(X509SecurityToken) }; }
+
+            public override SecurityKeyIdentifierClause CreateKeyIdentifierClauseFromBinaryCore(byte[] rawData)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new XmlException(SR.Format(SR.CantInferReferenceForToken, ValueTypeAbsoluteUri)));
+            }
+
+            public override SecurityToken ReadBinaryCore(string id, string valueTypeUri, byte[] rawData)
+            {
+                X509Certificate2 certificate;
+                if (!SecurityUtils.TryCreateX509CertificateFromRawData(rawData, out certificate))
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new MessageSecurityException(SR.InvalidX509RawData));
+                }
+                return new X509SecurityToken(certificate, id, false);
+            }
+
+            public override void WriteBinaryCore(SecurityToken token, out string id, out byte[] rawData)
+            {
+                id = token.Id;
+                X509SecurityToken x509Token = token as X509SecurityToken;
+                if (x509Token != null)
+                {
+                    rawData = x509Token.Certificate.GetRawCertData();
+                }
+                else
+                {
+                    throw new PlatformNotSupportedException();
+                }
+            }
+        }
+
+        public class IdManager : SignatureTargetIdManager
+        {
+            private IdManager()
+            {
+            }
+
+            public override string DefaultIdNamespacePrefix
+            {
+                get { return UtilityStrings.Prefix; }
+            }
+
+            public override string DefaultIdNamespaceUri
+            {
+                get { return UtilityStrings.Namespace; }
+            }
+
+            internal static IdManager Instance { get; } = new IdManager();
+
+            public override string ExtractId(XmlDictionaryReader reader)
+            {
+                if (reader == null)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(reader));
+                }
+
+                return reader.GetAttribute(XD.UtilityDictionary.IdAttribute, XD.UtilityDictionary.Namespace);
+            }
+
+            public override void WriteIdAttribute(XmlDictionaryWriter writer, string id)
+            {
+                if (writer == null)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(writer));
+                }
+
+                writer.WriteAttributeString(XD.UtilityDictionary.Prefix.Value, XD.UtilityDictionary.IdAttribute, XD.UtilityDictionary.Namespace, id);
+            }
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/WSSecurityOneDotOneReceiveSecurityHeader.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/WSSecurityOneDotOneReceiveSecurityHeader.cs
new file mode 100644
index 0000000..7f2f6ed
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/WSSecurityOneDotOneReceiveSecurityHeader.cs
@@ -0,0 +1,16 @@
+using CoreWCF.Channels;
+using CoreWCF.Description;
+
+namespace CoreWCF.Security
+{
+    internal class WSSecurityOneDotOneReceiveSecurityHeader : WSSecurityOneDotZeroReceiveSecurityHeader
+    {
+        public WSSecurityOneDotOneReceiveSecurityHeader(Message message, string actor, bool mustUnderstand, bool relay,
+            SecurityStandardsManager standardsManager,
+            SecurityAlgorithmSuite algorithmSuite,
+            int headerIndex, MessageDirection direction)
+            : base(message, actor, mustUnderstand, relay, standardsManager, algorithmSuite, headerIndex, direction)
+        {
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/WSSecurityOneDotOneSendSecurityHeader.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/WSSecurityOneDotOneSendSecurityHeader.cs
new file mode 100644
index 0000000..eeeafa4
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/WSSecurityOneDotOneSendSecurityHeader.cs
@@ -0,0 +1,18 @@
+
+using CoreWCF.Channels;
+using CoreWCF.Description;
+
+namespace CoreWCF.Security
+{
+    internal sealed class WSSecurityOneDotOneSendSecurityHeader : WSSecurityOneDotZeroSendSecurityHeader
+    {
+        public WSSecurityOneDotOneSendSecurityHeader(Message message, string actor, bool mustUnderstand, bool relay,
+            SecurityStandardsManager standardsManager,
+            SecurityAlgorithmSuite algorithmSuite,
+            MessageDirection direction)
+            : base(message, actor, mustUnderstand, relay, standardsManager, algorithmSuite, direction)
+        {
+        }
+    }
+}
+
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/WSSecurityOneDotZeroReceiveSecurityHeader.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/WSSecurityOneDotZeroReceiveSecurityHeader.cs
new file mode 100644
index 0000000..f24114d
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/WSSecurityOneDotZeroReceiveSecurityHeader.cs
@@ -0,0 +1,314 @@
+using CoreWCF.Channels;
+using CoreWCF.Description;
+using CoreWCF.IdentityModel;
+using CoreWCF.IdentityModel.Selectors;
+using CoreWCF.IdentityModel.Tokens;
+using CoreWCF.Security.Tokens;
+using System;
+using System.Collections.ObjectModel;
+using System.IO;
+using System.Linq;
+using System.Security.Cryptography;
+using System.Security.Cryptography.Xml;
+using System.Xml;
+using System.Xml.Linq;
+
+namespace CoreWCF.Security
+{
+    internal class WSSecurityOneDotZeroReceiveSecurityHeader : ReceiveSecurityHeader
+    {
+        private KeyedHashAlgorithm _signingKey;
+        public WSSecurityOneDotZeroReceiveSecurityHeader(Message message, string actor, bool mustUnderstand, bool relay,
+            SecurityStandardsManager standardsManager,
+            SecurityAlgorithmSuite algorithmSuite,
+            int headerIndex,
+            MessageDirection transferDirection)
+            : base(message, actor, mustUnderstand, relay, standardsManager, algorithmSuite, headerIndex, transferDirection)
+        {
+        }
+
+        protected override bool IsReaderAtReferenceList(XmlDictionaryReader reader)
+        {
+            return reader.IsStartElement(ReferenceList.ElementName, ReferenceList.NamespaceUri);
+        }
+
+        protected override bool IsReaderAtSignature(XmlDictionaryReader reader)
+        {
+            return reader.IsStartElement(XD.XmlSignatureDictionary.Signature, XD.XmlSignatureDictionary.Namespace);
+        }
+
+        protected override void EnsureDecryptionComplete()
+        {
+            // noop
+        }
+
+        protected override bool IsReaderAtEncryptedKey(XmlDictionaryReader reader)
+        {
+            return reader.IsStartElement(CoreWCF.XD.XmlEncryptionDictionary.EncryptedKey, CoreWCF.XD.XmlEncryptionDictionary.Namespace);
+        }
+
+        protected override bool IsReaderAtEncryptedData(XmlDictionaryReader reader)
+        {
+            bool encrypted = reader.IsStartElement(CoreWCF.XD.XmlEncryptionDictionary.EncryptedData, CoreWCF.XD.XmlEncryptionDictionary.Namespace);
+
+            if (encrypted == true)
+            {
+                throw new PlatformNotSupportedException();
+            }
+
+            return encrypted;
+        }
+
+        protected override bool IsReaderAtSecurityTokenReference(XmlDictionaryReader reader)
+        {
+            return reader.IsStartElement(XD.SecurityJan2004Dictionary.SecurityTokenReference, XD.SecurityJan2004Dictionary.Namespace);
+        }
+
+        protected override EncryptedData ReadSecurityHeaderEncryptedItem(XmlDictionaryReader reader, bool readXmlreferenceKeyInfoClause)
+        {
+            throw new NotImplementedException();
+        }
+
+        protected override byte[] DecryptSecurityHeaderElement(EncryptedData encryptedData, WrappedKeySecurityToken wrappedKeyToken, out SecurityToken encryptionToken)
+        {
+            throw new NotImplementedException();
+        }
+
+        protected override WrappedKeySecurityToken DecryptWrappedKey(XmlDictionaryReader reader)
+        {
+            throw new NotImplementedException();
+        }
+
+        protected override void OnDecryptionOfSecurityHeaderItemRequiringReferenceListEntry(string id)
+        {
+            throw new NotImplementedException();
+        }
+
+        protected override void ExecuteMessageProtectionPass(bool hasAtLeastOneSupportingTokenExpectedToBeSigned)
+        {
+            throw new NotImplementedException();
+        }
+
+        protected override ReferenceList ReadReferenceListCore(XmlDictionaryReader reader)
+        {
+            throw new NotImplementedException();
+        }
+
+        protected override void ProcessReferenceListCore(ReferenceList referenceList, WrappedKeySecurityToken wrappedKeyToken)
+        {
+            throw new NotImplementedException();
+        }
+
+        protected override void ReadSecurityTokenReference(XmlDictionaryReader reader)
+        {
+            throw new NotImplementedException();
+        }
+
+        protected override SignedXml ReadSignatureCore(XmlDictionaryReader signatureReader)
+        {
+            int headerIndex = this.Message.Headers.FindHeader(XD.SecurityJan2004Dictionary.Security.Value, XD.SecurityJan2004Dictionary.Namespace.Value);
+            XmlDictionaryReader headerReader  =   this.Message.Headers.GetReaderAtHeader(headerIndex);
+            var doc = new XmlDocument();
+            using(XmlReader reader = headerReader.ReadSubtree())
+            {
+                doc.Load(reader);
+            }
+            SignedXMLInternal signedXml = new SignedXMLInternal(doc);
+            XmlNodeList nodeList = doc.GetElementsByTagName("Signature");
+            signedXml.LoadXml((XmlElement)nodeList[0]);
+            using(XmlReader tempReader = signatureReader.ReadSubtree())
+            {
+                tempReader.Read();//move the reader
+            }
+            return signedXml;
+        }
+
+        protected override SecurityToken VerifySignature(SignedXml signedXml, bool isPrimarySignature, SecurityHeaderTokenResolver resolver, object signatureTarget, string id)
+        {
+            SecurityKeyIdentifier secutiryKeyIdentifier = null;
+            String keyInfoString = signedXml.Signature.KeyInfo.GetXml().OuterXml;
+            using (var strReader = new StringReader(keyInfoString))
+            {
+                XmlReader xmlReader = XmlReader.Create(strReader);
+                //xmlReader.Read();
+                secutiryKeyIdentifier =  this.StandardsManager.SecurityTokenSerializer.ReadKeyIdentifier(xmlReader);
+
+            }
+
+            if (secutiryKeyIdentifier == null)
+                throw new Exception("SecurityKeyIdentifier is missing");
+            SecurityToken token = ResolveSignatureToken(secutiryKeyIdentifier, resolver, isPrimarySignature);
+            if (isPrimarySignature)
+            {
+                RecordSignatureToken(token);
+            }
+            ReadOnlyCollection<SecurityKey> keys = token.SecurityKeys;
+            SecurityKey securityKey = (keys != null && keys.Count > 0) ? keys[0] : null;
+            if (securityKey == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new MessageSecurityException(
+                    SR.Format(SR.UnableToCreateICryptoFromTokenForSignatureVerification, token)));
+            }
+           // signedXml.SigningKey = securityKey;
+           // this.AlgorithmSuite.EnsureAcceptableSignatureKeySize(securityKey, token);
+           // this.AlgorithmSuite.EnsureAcceptableSignatureAlgorithm(securityKey, signedXml.Signature.SignedInfo.SignatureMethod);
+           // signedXml.StartSignatureVerification(securityKey);
+           // StandardSignedInfo signedInfo = (StandardSignedInfo)signedXml.Signature.SignedInfo;
+
+           // ValidateDigestsOfTargetsInSecurityHeader(signedInfo, this.Timestamp, isPrimarySignature, signatureTarget, id);
+
+            if (!isPrimarySignature)
+            {
+                //TODO securityKey is AsymmetricSecurityKey
+                //if ((!this.RequireMessageProtection) && (securityKey is AsymmetricSecurityKey) && (this.Version.Addressing != AddressingVersion.None))
+                //{
+                //    // For Transport Security using Asymmetric Keys verify that 
+                //    // the 'To' header is signed.
+                //    int headerIndex = this.Message.Headers.FindHeader(XD.AddressingDictionary.To.Value, this.Message.Version.Addressing.Namespace);
+                //    if (headerIndex == -1)
+                //        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new MessageSecurityException(SR.GetString(SR.TransportSecuredMessageMissingToHeader)));
+                //    XmlDictionaryReader toHeaderReader = this.Message.Headers.GetReaderAtHeader(headerIndex);
+                //    id = toHeaderReader.GetAttribute(XD.UtilityDictionary.IdAttribute, XD.UtilityDictionary.Namespace);
+
+                //    // DevDiv:938534 - We added a flag that allow unsigned headers. If this is set, we do not throw an Exception but move on to CompleteSignatureVerification()
+                //    if (LocalAppContextSwitches.AllowUnsignedToHeader)
+                //    {
+                //        // The lack of an id indicates that the sender did not wish to sign the header. We can safely assume that null indicates this header is not signed.
+                //        // If id is not null, then we need to validate the Digest and ensure signature is valid. The exception is thrown deeper in the System.IdentityModel stack.
+                //        if (id != null)
+                //        {
+                //            signedXml.EnsureDigestValidityIfIdMatches(id, toHeaderReader);
+                //        }
+                //    }
+                //    else
+                //    {
+                //        // default behavior for all platforms
+                //        if (id == null)
+                //        {
+                //            // 
+                //            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new MessageSecurityException(SR.GetString(SR.UnsignedToHeaderInTransportSecuredMessage)));
+                //        }
+                //        signedXml.EnsureDigestValidity(id, toHeaderReader);
+                //    }
+                //}
+                // signedXml.CompleteSignatureVerification();
+
+                SecurityAlgorithmSuite suite = AlgorithmSuite;
+                string canonicalizationAlgorithm = suite.DefaultCanonicalizationAlgorithm;
+                string signatureAlgorithm;
+                XmlDictionaryString signatureAlgorithmDictionaryString;
+                SecurityKey signatureKey;
+                suite.GetSignatureAlgorithmAndKey(token, out signatureAlgorithm, out signatureKey, out signatureAlgorithmDictionaryString);
+                AsymmetricAlgorithm asymmetricAlgorithm = null;
+                GetSigningAlgorithm(signatureKey, signatureAlgorithm, out _signingKey, out asymmetricAlgorithm);
+                if (!signedXml.CheckSignature(_signingKey))
+                {
+                    throw new Exception("Signature not valid.");
+                }
+                
+            }
+           // this.pendingSignature = signedXml;
+
+            //if (TD.SignatureVerificationSuccessIsEnabled())
+            //{
+            //    TD.SignatureVerificationSuccess(this.EventTraceActivity);
+            //}
+
+            return token;
+        }
+
+        private void GetSigningAlgorithm(SecurityKey signatureKey, string algorithmName, out KeyedHashAlgorithm symmetricAlgorithm, out AsymmetricAlgorithm asymmetricAlgorithm)
+        {
+            symmetricAlgorithm = null;
+            asymmetricAlgorithm = null;
+            SymmetricSecurityKey symmetricKey = signatureKey as SymmetricSecurityKey;
+            if (symmetricKey != null)
+            {
+                _signingKey = symmetricKey.GetKeyedHashAlgorithm(algorithmName);
+                if (_signingKey == null)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(
+                        SR.Format("UnableToCreateKeyedHashAlgorithm", symmetricKey, algorithmName)));
+                }
+            }
+            else
+            {
+                AsymmetricSecurityKey asymmetricKey = signatureKey as AsymmetricSecurityKey;
+                if (asymmetricKey == null)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(
+                        SR.Format(SR.UnknownICryptoType, _signingKey)));
+                }
+
+                asymmetricAlgorithm = asymmetricKey.GetAsymmetricAlgorithm(algorithmName, privateKey: true);
+                if (asymmetricAlgorithm == null)
+                {
+                    //TODO MUST before checkin search and replace SR.Format(" 
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(
+                        SR.Format("UnableToCreateHashAlgorithmFromAsymmetricCrypto", algorithmName,
+                            asymmetricKey)));
+                }
+            }
+        }
+
+        SecurityToken ResolveSignatureToken(SecurityKeyIdentifier keyIdentifier, SecurityTokenResolver resolver, bool isPrimarySignature)
+        {
+            SecurityToken token = null;
+            TryResolveKeyIdentifier(keyIdentifier, resolver, true, out token);
+            //TODO RSA
+            //if (token == null && !isPrimarySignature)
+            //{
+            //    // check if there is a rsa key token authenticator
+            //    if (keyIdentifier.Count == 1)
+            //    {
+            //        RsaKeyIdentifierClause rsaClause;
+            //        if (keyIdentifier.TryFind<RsaKeyIdentifierClause>(out rsaClause))
+            //        {
+            //            RsaSecurityTokenAuthenticator rsaAuthenticator = FindAllowedAuthenticator<RsaSecurityTokenAuthenticator>(false);
+            //            if (rsaAuthenticator != null)
+            //            {
+            //                token = new RsaSecurityToken(rsaClause.Rsa);
+            //                ReadOnlyCollection<IAuthorizationPolicy> authorizationPolicies = rsaAuthenticator.ValidateToken(token);
+            //                SupportingTokenAuthenticatorSpecification spec;
+            //                TokenTracker rsaTracker = GetSupportingTokenTracker(rsaAuthenticator, out spec);
+            //                if (rsaTracker == null)
+            //                {
+            //                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new MessageSecurityException(SR.GetString(SR.UnknownTokenAuthenticatorUsedInTokenProcessing, rsaAuthenticator)));
+            //                }
+            //                rsaTracker.RecordToken(token);
+            //                SecurityTokenAuthorizationPoliciesMapping.Add(token, authorizationPolicies);
+            //            }
+            //        }
+            //    }
+            //}
+            if (token == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new MessageSecurityException(
+                        SR.Format(SR.UnableToResolveKeyInfoForVerifyingSignature, keyIdentifier, resolver)));
+            }
+            return token;
+        }
+        protected static bool TryResolveKeyIdentifier(
+         SecurityKeyIdentifier keyIdentifier, SecurityTokenResolver resolver, bool isFromSignature, out SecurityToken token)
+        {
+            if (keyIdentifier == null)
+            {
+                if (isFromSignature)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new MessageSecurityException(SR.Format(SR.NoKeyInfoInSignatureToFindVerificationToken)));
+                }
+                else
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new MessageSecurityException(SR.Format(SR.NoKeyInfoInEncryptedItemToFindDecryptingToken)));
+                }
+            }
+
+            return resolver.TryResolveToken(keyIdentifier, out token);
+        }
+        protected override bool TryDeleteReferenceListEntry(string id)
+        {
+            throw new NotImplementedException();
+        }
+    }
+
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/WSSecurityOneDotZeroSendSecurityHeader.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/WSSecurityOneDotZeroSendSecurityHeader.cs
new file mode 100644
index 0000000..3a5c887
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/WSSecurityOneDotZeroSendSecurityHeader.cs
@@ -0,0 +1,872 @@
+using CoreWCF.IdentityModel;
+//TODO signedXML replace
+using System.Security.Cryptography.Xml;
+using System.Text;
+using System.IO;
+using System.Runtime;
+using System.Security.Cryptography;
+using CoreWCF.Channels;
+using CoreWCF.Description;
+using CoreWCF.Diagnostics;
+using System.Xml;
+using IPrefixGenerator = CoreWCF.IdentityModel.IPrefixGenerator;
+using ISecurityElement = CoreWCF.IdentityModel.ISecurityElement;
+using ISignatureValueSecurityElement = CoreWCF.IdentityModel.ISignatureValueSecurityElement;
+using CoreWCF.Security.Tokens;
+using System;
+using CoreWCF.IdentityModel.Tokens;
+using CoreWCF.Runtime;
+
+namespace CoreWCF.Security
+{
+    internal class WSSecurityOneDotZeroSendSecurityHeader : SendSecurityHeader
+    {
+        private HashStream _hashStream;
+        private SignedXml _signedXml;
+        ReferenceList referenceList;
+        private KeyedHashAlgorithm _signingKey;
+        private MessagePartSpecification _effectiveSignatureParts;
+
+        // For Transport Security we have to sign the 'To' header with the 
+        // supporting tokens.
+        private Stream _toHeaderStream = null;
+        private string _toHeaderId = null;
+
+        public WSSecurityOneDotZeroSendSecurityHeader(Message message, string actor, bool mustUnderstand, bool relay,
+            SecurityStandardsManager standardsManager,
+            SecurityAlgorithmSuite algorithmSuite,
+            MessageDirection direction)
+            : base(message, actor, mustUnderstand, relay, standardsManager, algorithmSuite, direction)
+        {
+        }
+
+        protected string EncryptionAlgorithm
+        {
+            get { return AlgorithmSuite.DefaultEncryptionAlgorithm; }
+        }
+
+        protected XmlDictionaryString EncryptionAlgorithmDictionaryString
+        {
+            get { return AlgorithmSuite.DefaultEncryptionAlgorithmDictionaryString; }
+        }
+
+        private void AddEncryptionReference(MessageHeader header, string headerId, IPrefixGenerator prefixGenerator, bool sign,
+            out MemoryStream plainTextStream, out string encryptedDataId)
+        {
+            throw new PlatformNotSupportedException();
+        }
+
+        private void AddSignatureReference(SecurityToken token, int position, SecurityTokenAttachmentMode mode)
+        {
+            SecurityKeyIdentifierClause keyIdentifierClause = null;
+            bool strTransformEnabled = ShouldUseStrTransformForToken(token, position, mode, out keyIdentifierClause);
+            AddTokenSignatureReference(token, keyIdentifierClause, strTransformEnabled);
+        }
+
+        private void AddPrimaryTokenSignatureReference(SecurityToken token, SecurityTokenParameters securityTokenParameters)
+        {
+            return;
+        }
+
+        // Given a token and useStarTransform value this method adds apporopriate reference accordingly.
+        // 1. If strTransform is disabled, it adds a reference to the token's id. 
+        // 2. Else if strtransform is enabled it adds a reference the security token's keyIdentifier's id.
+        private void AddTokenSignatureReference(SecurityToken token, SecurityKeyIdentifierClause keyIdentifierClause, bool strTransformEnabled)
+        {
+            throw new PlatformNotSupportedException();
+        }
+
+        private void AddSignatureReference(SendSecurityHeaderElement[] elements)
+        {
+            if (elements != null)
+            {
+                for (int i = 0; i < elements.Length; ++i)
+                {
+                    SecurityKeyIdentifierClause keyIdentifierClause = null;
+                    TokenElement signedEncryptedTokenElement = elements[i].Item as TokenElement;
+
+                    // signedEncryptedTokenElement can either be a TokenElement ( in SignThenEncrypt case) or EncryptedData ( in !SignThenEncryptCase)
+                    // STR-Transform does not make sense in !SignThenEncrypt case .
+                    // note: signedEncryptedTokenElement can also be SignatureConfirmation but we do not care about it here.
+                    bool useStrTransform = signedEncryptedTokenElement != null
+                                           && SignThenEncrypt
+                                           && ShouldUseStrTransformForToken(signedEncryptedTokenElement.Token,
+                                                                                 i,
+                                                                                 SecurityTokenAttachmentMode.SignedEncrypted,
+                                                                                 out keyIdentifierClause);
+
+                    if (!useStrTransform && elements[i].Id == null)
+                    {
+                        throw TraceUtility.ThrowHelperError(new MessageSecurityException(SR.ElementToSignMustHaveId), Message);
+                    }
+
+                    MemoryStream stream = new MemoryStream();
+                    XmlDictionaryWriter utf8Writer = TakeUtf8Writer();
+                    utf8Writer.StartCanonicalization(stream, false, null);
+                    elements[i].Item.WriteTo(utf8Writer, ServiceModelDictionaryManager.Instance);
+                    utf8Writer.EndCanonicalization();
+                    stream.Position = 0;
+                    if (useStrTransform)
+                    {
+                        throw new PlatformNotSupportedException("StrTransform not supported yet");
+                    }
+                    else
+                    {
+                        AddReference("#" + elements[i].Id, stream);
+                    }
+                }
+            }
+        }
+
+        private void AddSignatureReference(SecurityToken[] tokens, SecurityTokenAttachmentMode mode)
+        {
+            if (tokens != null)
+            {
+                for (int i = 0; i < tokens.Length; ++i)
+                {
+                    AddSignatureReference(tokens[i], i, mode);
+                }
+            }
+        }
+
+        private string GetSignatureHash(MessageHeader header, string headerId, IPrefixGenerator prefixGenerator, XmlDictionaryWriter writer, out byte[] hash)
+        {
+            HashStream hashStream = TakeHashStream();
+            XmlDictionaryWriter effectiveWriter;
+            XmlBuffer canonicalBuffer = null;
+
+            if (writer.CanCanonicalize)
+            {
+                effectiveWriter = writer;
+            }
+            else
+            {
+                canonicalBuffer = new XmlBuffer(int.MaxValue);
+                effectiveWriter = canonicalBuffer.OpenSection(XmlDictionaryReaderQuotas.Max);
+            }
+
+            effectiveWriter.StartCanonicalization(hashStream, false, null);
+
+            header.WriteStartHeader(effectiveWriter, Version);
+            if (headerId == null)
+            {
+                headerId = GenerateId();
+                StandardsManager.IdManager.WriteIdAttribute(effectiveWriter, headerId);
+            }
+            header.WriteHeaderContents(effectiveWriter, Version);
+            effectiveWriter.WriteEndElement();
+            effectiveWriter.EndCanonicalization();
+            effectiveWriter.Flush();
+
+            if (!ReferenceEquals(effectiveWriter, writer))
+            {
+                Fx.Assert(canonicalBuffer != null, "Canonical buffer cannot be null.");
+                canonicalBuffer.CloseSection();
+                canonicalBuffer.Close();
+                XmlDictionaryReader dicReader = canonicalBuffer.GetReader(0);
+                writer.WriteNode(dicReader, false);
+                dicReader.Close();
+            }
+
+            hash = hashStream.FlushHashAndGetValue();
+
+            return headerId;
+        }
+
+        private string GetSignatureStream(MessageHeader header, string headerId, IPrefixGenerator prefixGenerator, XmlDictionaryWriter writer, out Stream stream)
+        {
+            stream = new MemoryStream();
+            XmlDictionaryWriter effectiveWriter;
+            XmlBuffer canonicalBuffer = null;
+
+            if (writer.CanCanonicalize)
+            {
+                effectiveWriter = writer;
+            }
+            else
+            {
+                canonicalBuffer = new XmlBuffer(int.MaxValue);
+                effectiveWriter = canonicalBuffer.OpenSection(XmlDictionaryReaderQuotas.Max);
+            }
+
+            effectiveWriter.StartCanonicalization(stream, false, null);
+
+            header.WriteStartHeader(effectiveWriter, Version);
+            if (headerId == null)
+            {
+                headerId = GenerateId();
+                StandardsManager.IdManager.WriteIdAttribute(effectiveWriter, headerId);
+            }
+            header.WriteHeaderContents(effectiveWriter, Version);
+            effectiveWriter.WriteEndElement();
+            effectiveWriter.EndCanonicalization();
+            effectiveWriter.Flush();
+
+            if (!ReferenceEquals(effectiveWriter, writer))
+            {
+                Fx.Assert(canonicalBuffer != null, "Canonical buffer cannot be null.");
+                canonicalBuffer.CloseSection();
+                canonicalBuffer.Close();
+                XmlDictionaryReader dicReader = canonicalBuffer.GetReader(0);
+                writer.WriteNode(dicReader, false);
+                dicReader.Close();
+            }
+
+            stream.Position = 0;
+
+            return headerId;
+        }
+
+        private void AddReference(string id, Stream contents)
+        {
+            var reference = new System.Security.Cryptography.Xml.Reference(contents);
+            reference.Uri = id;
+            reference.DigestMethod = AlgorithmSuite.DefaultDigestAlgorithm;
+            reference.AddTransform(new XmlDsigExcC14NTransform());
+            _signedXml.AddReference(reference);
+        }
+
+        private void AddSignatureReference(MessageHeader header, string headerId, IPrefixGenerator prefixGenerator, XmlDictionaryWriter writer)
+        {
+            // No transforms added to Reference as the digest value has already been calculated
+            byte[] hashValue;
+            headerId = GetSignatureHash(header, headerId, prefixGenerator, writer, out hashValue);
+            var reference = new System.Security.Cryptography.Xml.Reference();
+            reference.DigestMethod = AlgorithmSuite.DefaultDigestAlgorithm;
+            reference.DigestValue = hashValue;
+            reference.Id = headerId;
+            _signedXml.AddReference(reference);
+        }
+
+        private void ApplySecurityAndWriteHeader(MessageHeader header, string headerId, XmlDictionaryWriter writer, IPrefixGenerator prefixGenerator)
+        {
+            if (!RequireMessageProtection && ShouldSignToHeader)
+            {
+                if ((header.Name == XD.AddressingDictionary.To.Value) &&
+                    (header.Namespace == Message.Version.Addressing.Namespace))
+                {
+                    if (_toHeaderStream == null)
+                    {
+                        Stream headerStream;
+                        headerId = GetSignatureStream(header, headerId, prefixGenerator, writer, out headerStream);
+                        _toHeaderStream = headerStream;
+                        _toHeaderId = headerId;
+                    }
+                    else
+                    {
+                        // More than one 'To' header is specified in the message.
+                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new MessageSecurityException(SR.TransportSecuredMessageHasMoreThanOneToHeader));
+                    }
+
+                    return;
+                }
+            }
+
+            MessagePartProtectionMode protectionMode = GetProtectionMode(header);
+            switch (protectionMode)
+            {
+                case MessagePartProtectionMode.None:
+                    header.WriteHeader(writer, Version);
+                    return;
+                case MessagePartProtectionMode.Sign:
+                    AddSignatureReference(header, headerId, prefixGenerator, writer);
+                    return;
+                case MessagePartProtectionMode.SignThenEncrypt:
+                case MessagePartProtectionMode.Encrypt:
+                case MessagePartProtectionMode.EncryptThenSign:
+                    throw new PlatformNotSupportedException(); 
+                default:
+                    Fx.Assert("Invalid MessagePartProtectionMode");
+                    return;
+            }
+        }
+
+        public override void ApplySecurityAndWriteHeaders(MessageHeaders headers, XmlDictionaryWriter writer, IPrefixGenerator prefixGenerator)
+        {
+            string[] headerIds;
+            if (RequireMessageProtection || ShouldSignToHeader)
+            {
+                headerIds = headers.GetHeaderAttributes(UtilityStrings.IdAttribute,
+                    StandardsManager.IdManager.DefaultIdNamespaceUri);
+            }
+            else
+            {
+                headerIds = null;
+            }
+            for (int i = 0; i < headers.Count; i++)
+            {
+                MessageHeader header = headers.GetMessageHeader(i);
+                if (Version.Addressing == AddressingVersion.None && header.Namespace == AddressingVersion.None.Namespace)
+                {
+                    continue;
+                }
+
+                if (header != this)
+                {
+                    ApplySecurityAndWriteHeader(header, headerIds == null ? null : headerIds[i], writer, prefixGenerator);
+                }
+            }
+        }
+
+        private static bool CanCanonicalizeAndFragment(XmlDictionaryWriter writer)
+        {
+            if (!writer.CanCanonicalize)
+            {
+                return false;
+            }
+            IFragmentCapableXmlDictionaryWriter fragmentingWriter = writer as IFragmentCapableXmlDictionaryWriter;
+            return fragmentingWriter != null && fragmentingWriter.CanFragment;
+        }
+
+        public override void ApplyBodySecurity(XmlDictionaryWriter writer, IPrefixGenerator prefixGenerator)
+        {
+            SecurityAppliedMessage message = SecurityAppliedMessage;
+            switch (message.BodyProtectionMode)
+            {
+                case MessagePartProtectionMode.None:
+                    return;
+                case MessagePartProtectionMode.Sign:
+                    var ms = new MemoryStream();
+                    if (CanCanonicalizeAndFragment(writer))
+                    {
+                        message.WriteBodyToSignWithFragments(ms, false, null, writer);
+                    }
+                    else
+                    {
+                        message.WriteBodyToSign(ms);
+                    }
+
+                    ms.Position = 0;
+                    AddReference("#" + message.BodyId, ms);
+                    return;
+                case MessagePartProtectionMode.SignThenEncrypt:
+                    throw new PlatformNotSupportedException();
+                case MessagePartProtectionMode.Encrypt:
+                    throw new PlatformNotSupportedException();
+                case MessagePartProtectionMode.EncryptThenSign:
+                    throw new PlatformNotSupportedException();
+                default:
+                    Fx.Assert("Invalid MessagePartProtectionMode");
+                    return;
+            }
+        }
+
+        protected override ISignatureValueSecurityElement CompletePrimarySignatureCore(
+            SendSecurityHeaderElement[] signatureConfirmations,
+            SecurityToken[] signedEndorsingTokens,
+            SecurityToken[] signedTokens,
+            SendSecurityHeaderElement[] basicTokens, bool isPrimarySignature)
+        {
+            if (_signedXml == null)
+            {
+                return null;
+            }
+
+            SecurityTimestamp timestamp = Timestamp;
+            if (timestamp != null)
+            {
+                if (timestamp.Id == null)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.TimestampToSignHasNoId));
+                }
+
+                var buffer = new byte[64];
+                var ms = new MemoryStream();
+                StandardsManager.WSUtilitySpecificationVersion.WriteTimestampCanonicalForm(
+                    ms, timestamp, buffer);
+                ms.Position = 0;
+                AddReference("#" + timestamp.Id, ms);
+                var reference = new System.Security.Cryptography.Xml.Reference(ms);
+            }
+
+            if ((ShouldSignToHeader) && (_signingKey != null || _signedXml.SigningKey != null) && (Version.Addressing != AddressingVersion.None))
+            {
+                if (_toHeaderStream != null)
+                {
+                    AddReference("#" + _toHeaderId, _toHeaderStream);
+                }
+                else
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.TransportSecurityRequireToHeader));
+                }
+            }
+
+            AddSignatureReference(signatureConfirmations);
+            if (isPrimarySignature && ShouldProtectTokens)
+            {
+                AddPrimaryTokenSignatureReference(ElementContainer.SourceSigningToken, SigningTokenParameters);
+            }
+
+            if (RequireMessageProtection)
+            {
+                throw new PlatformNotSupportedException(nameof(RequireMessageProtection));
+            }
+
+            if (_signedXml.SignedInfo.References.Count == 0)
+            {
+                throw TraceUtility.ThrowHelperError(new MessageSecurityException(SR.NoPartsOfMessageMatchedPartsToSign), Message);
+            }
+            try
+            {
+                if (_signingKey != null)
+                {
+                    _signedXml.ComputeSignature(_signingKey);
+                }
+                else
+                {
+                    _signedXml.ComputeSignature();
+                }
+
+                return new SignatureValue(_signedXml.Signature);
+            }
+            finally
+            {
+                _hashStream = null;
+                _signingKey = null;
+                _signedXml = null;
+                _effectiveSignatureParts = null;
+            }
+        }
+
+        internal class SignatureValue : ISignatureValueSecurityElement
+        {
+            private Signature _signature;
+
+            public SignatureValue(Signature signature)
+            {
+                _signature = signature;
+            }
+
+            public void WriteTo(XmlDictionaryWriter writer, DictionaryManager dictionaryManager)
+            {
+                _signature.GetXml().WriteTo(writer);
+            }
+
+            public bool HasId
+            {
+                get { return true; }
+            }
+
+            public string Id
+            {
+                get { return _signature.Id; }
+            }
+
+            public byte[] GetSignatureValue()
+            {
+                return _signature.SignatureValue;
+            }
+        }
+
+        private HashStream TakeHashStream()
+        {
+            HashStream hashStream = null;
+            if (_hashStream == null)
+            {
+                _hashStream = hashStream = new HashStream(CryptoHelper.CreateHashAlgorithm(AlgorithmSuite.DefaultDigestAlgorithm));
+            }
+            else
+            {
+                hashStream = _hashStream;
+                ;
+                hashStream.Reset();
+            }
+            return hashStream;
+        }
+
+        private XmlDictionaryWriter TakeUtf8Writer()
+        {
+            throw new PlatformNotSupportedException();
+        }
+
+        private MessagePartProtectionMode GetProtectionMode(MessageHeader header)
+        {
+            if (!RequireMessageProtection)
+            {
+                return MessagePartProtectionMode.None;
+            }
+            bool sign = _signedXml != null && _effectiveSignatureParts.IsHeaderIncluded(header);
+            bool encrypt = false;
+            return MessagePartProtectionModeHelper.GetProtectionMode(sign, encrypt, SignThenEncrypt);
+        }
+
+        protected override void StartPrimarySignatureCore(SecurityToken token,
+            SecurityKeyIdentifier keyIdentifier,
+            MessagePartSpecification signatureParts,
+            bool generateTargettableSignature)
+        {
+            SecurityAlgorithmSuite suite = AlgorithmSuite;
+            string canonicalizationAlgorithm = suite.DefaultCanonicalizationAlgorithm;
+            if (canonicalizationAlgorithm != SecurityAlgorithms.ExclusiveC14n)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(
+                    new MessageSecurityException(SR.Format(SR.UnsupportedCanonicalizationAlgorithm, suite.DefaultCanonicalizationAlgorithm)));
+            }
+            string signatureAlgorithm;
+            XmlDictionaryString signatureAlgorithmDictionaryString;
+            SecurityKey signatureKey;
+            suite.GetSignatureAlgorithmAndKey(token, out signatureAlgorithm, out signatureKey, out signatureAlgorithmDictionaryString);
+            AsymmetricAlgorithm asymmetricAlgorithm = null;
+            GetSigningAlgorithm(signatureKey, signatureAlgorithm, out _signingKey, out asymmetricAlgorithm);
+
+            _signedXml = new SignedXml();
+            _signedXml.SignedInfo.CanonicalizationMethod = canonicalizationAlgorithm;
+            _signedXml.SignedInfo.SignatureMethod = signatureAlgorithm;
+            _signedXml.SigningKey = asymmetricAlgorithm;
+            if (keyIdentifier != null)
+            {
+                var stream = new MemoryStream();
+                using (var xmlWriter = XmlDictionaryWriter.CreateTextWriter(stream, Encoding.UTF8, false))
+                {
+                    StandardsManager.SecurityTokenSerializer.WriteKeyIdentifier(xmlWriter, keyIdentifier);
+                }
+
+                stream.Position = 0;
+                XmlDocument doc = new XmlDocument();
+                doc.Load(stream);
+                var keyInfo = new KeyInfo();
+                keyInfo.LoadXml(doc.DocumentElement);
+                _signedXml.KeyInfo = keyInfo;
+            }
+
+            if (generateTargettableSignature)
+            {
+                _signedXml.Signature.Id = GenerateId();
+            }
+            _effectiveSignatureParts = signatureParts;
+        }
+
+        private void GetSigningAlgorithm(SecurityKey signatureKey, string algorithmName, out KeyedHashAlgorithm symmetricAlgorithm, out AsymmetricAlgorithm asymmetricAlgorithm)
+        {
+            symmetricAlgorithm = null;
+            asymmetricAlgorithm = null;
+            SymmetricSecurityKey symmetricKey = signatureKey as SymmetricSecurityKey;
+            if (symmetricKey != null)
+            {
+                _signingKey = symmetricKey.GetKeyedHashAlgorithm(algorithmName);
+                if (_signingKey == null)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(
+                        SR.Format("UnableToCreateKeyedHashAlgorithm", symmetricKey, algorithmName)));
+                }
+            }
+            else
+            {
+                AsymmetricSecurityKey asymmetricKey = signatureKey as AsymmetricSecurityKey;
+                if (asymmetricKey == null)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(
+                        SR.Format(SR.UnknownICryptoType, _signingKey)));
+                }
+
+                asymmetricAlgorithm = asymmetricKey.GetAsymmetricAlgorithm(algorithmName, privateKey: true);
+                if (asymmetricAlgorithm == null)
+                {
+                    //TODO MUST before checkin search and replace SR.Format(" 
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(
+                        SR.Format("UnableToCreateHashAlgorithmFromAsymmetricCrypto", algorithmName,
+                            asymmetricKey)));
+                }
+            }
+        }
+
+        protected override ISignatureValueSecurityElement CreateSupportingSignature(SecurityToken token, SecurityKeyIdentifier identifier)
+        {
+            StartPrimarySignatureCore(token, identifier, MessagePartSpecification.NoParts, false);
+            return CompletePrimarySignatureCore(null, null, null, null, false);
+        }
+
+        protected override ISignatureValueSecurityElement CreateSupportingSignature(SecurityToken token, SecurityKeyIdentifier identifier, ISecurityElement elementToSign)
+        {
+            string signatureAlgorithm;
+            XmlDictionaryString signatureAlgorithmDictionaryString;
+            SecurityKey signatureKey;
+            AlgorithmSuite.GetSignatureAlgorithmAndKey(token, out signatureAlgorithm, out signatureKey, out signatureAlgorithmDictionaryString);
+
+            SignedXml signedXml = new SignedXml();
+            SignedInfo signedInfo = signedXml.SignedInfo;
+            signedInfo.CanonicalizationMethod = AlgorithmSuite.DefaultCanonicalizationAlgorithm;
+            signedInfo.SignatureMethod = signatureAlgorithm;
+
+            if (elementToSign.Id == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.ElementToSignMustHaveId));
+            }
+
+            MemoryStream stream = new MemoryStream();
+            XmlDictionaryWriter utf8Writer = TakeUtf8Writer();
+            utf8Writer.StartCanonicalization(stream, false, null);
+            elementToSign.WriteTo(utf8Writer, ServiceModelDictionaryManager.Instance);
+            utf8Writer.EndCanonicalization();
+            stream.Position = 0;
+            AddReference("#" + elementToSign.Id, stream);
+
+            AsymmetricAlgorithm asymmetricAlgorithm = null;
+            KeyedHashAlgorithm keyedHashAlgorithm = null;
+            GetSigningAlgorithm(signatureKey, signatureAlgorithm, out keyedHashAlgorithm, out asymmetricAlgorithm);
+            if (keyedHashAlgorithm != null)
+            {
+                signedXml.ComputeSignature(keyedHashAlgorithm);
+            }
+            else
+            {
+                signedXml.SigningKey = asymmetricAlgorithm;
+                signedXml.ComputeSignature();
+            }
+
+            SetKeyInfo(signedXml, identifier);
+            return new SignatureValue(signedXml.Signature);
+        }
+
+        private void SetKeyInfo(SignedXml signedXml, SecurityKeyIdentifier identifier)
+        {
+            if (identifier != null)
+            {
+                var stream = new MemoryStream();
+                using (var xmlWriter = XmlDictionaryWriter.CreateTextWriter(stream, Encoding.UTF8, false))
+                {
+                    StandardsManager.SecurityTokenSerializer.WriteKeyIdentifier(xmlWriter, identifier);
+                }
+
+                stream.Position = 0;
+                XmlDocument doc = new XmlDocument();
+                doc.Load(stream);
+                var keyInfo = new KeyInfo();
+                keyInfo.LoadXml(doc.DocumentElement);
+                signedXml.KeyInfo = keyInfo;
+            }
+        }
+
+        protected override void WriteSecurityTokenReferencyEntry(XmlDictionaryWriter writer, SecurityToken securityToken, SecurityTokenParameters securityTokenParameters)
+        {
+            return;
+        }
+
+        protected override void StartEncryptionCore(SecurityToken token, SecurityKeyIdentifier keyIdentifier)
+        {
+            throw new NotImplementedException();
+        }
+
+        protected override ISecurityElement CompleteEncryptionCore(SendSecurityHeaderElement primarySignature, SendSecurityHeaderElement[] basicTokens, SendSecurityHeaderElement[] signatureConfirmations, SendSecurityHeaderElement[] endorsingSignatures)
+        {
+            if (this.referenceList == null)
+            {
+                return null;
+            }
+
+            throw new NotImplementedException();
+
+            //if (primarySignature != null && primarySignature.Item != null && primarySignature.MarkedForEncryption)
+            //{
+            //    EncryptElement(primarySignature);
+            //}
+
+            //if (basicTokens != null)
+            //{
+            //    for (int i = 0; i < basicTokens.Length; ++i)
+            //    {
+            //        if (basicTokens[i].MarkedForEncryption)
+            //            EncryptElement(basicTokens[i]);
+            //    }
+            //}
+
+            //if (signatureConfirmations != null)
+            //{
+            //    for (int i = 0; i < signatureConfirmations.Length; ++i)
+            //    {
+            //        if (signatureConfirmations[i].MarkedForEncryption)
+            //            EncryptElement(signatureConfirmations[i]);
+            //    }
+            //}
+
+            //if (endorsingSignatures != null)
+            //{
+            //    for (int i = 0; i < endorsingSignatures.Length; ++i)
+            //    {
+            //        if (endorsingSignatures[i].MarkedForEncryption)
+            //            EncryptElement(endorsingSignatures[i]);
+            //    }
+            //}
+
+            //try
+            //{
+            //    return this.referenceList.DataReferenceCount > 0 ? this.referenceList : null;
+            //}
+            //finally
+            //{
+            //    this.referenceList = null;
+            //    this.encryptingSymmetricAlgorithm = null;
+            //    this.encryptionKeyIdentifier = null;
+            //}
+        }
+    }
+
+    internal class WrappedXmlDictionaryWriter : XmlDictionaryWriter
+    {
+        private XmlDictionaryWriter _innerWriter;
+        private int _index;
+        private bool _insertId;
+        private bool _isStrReferenceElement;
+        private string _id;
+
+        public WrappedXmlDictionaryWriter(XmlDictionaryWriter writer, string id)
+        {
+            _innerWriter = writer;
+            _index = 0;
+            _insertId = false;
+            _isStrReferenceElement = false;
+            _id = id;
+        }
+
+        public override void WriteStartAttribute(string prefix, string localName, string namespaceUri)
+        {
+            if (_isStrReferenceElement && _insertId && localName == XD.UtilityDictionary.IdAttribute.Value)
+            {
+                // This means the serializer is already writing the Id out, so we don't write it again.
+                _insertId = false;
+            }
+            _innerWriter.WriteStartAttribute(prefix, localName, namespaceUri);
+        }
+
+        public override void WriteStartElement(string prefix, string localName, string namespaceUri)
+        {
+            if (_isStrReferenceElement && _insertId)
+            {
+                if (_id != null)
+                {
+                    _innerWriter.WriteAttributeString(XD.UtilityDictionary.Prefix.Value, XD.UtilityDictionary.IdAttribute, XD.UtilityDictionary.Namespace, _id);
+                }
+
+                _isStrReferenceElement = false;
+                _insertId = false;
+            }
+
+            _index++;
+
+            if (_index == 1 && localName == XD.SecurityJan2004Dictionary.SecurityTokenReference.Value)
+            {
+                _insertId = true;
+                _isStrReferenceElement = true;
+            }
+
+            _innerWriter.WriteStartElement(prefix, localName, namespaceUri);
+        }
+
+        // Below methods simply call into innerWritter
+        public override void Close()
+        {
+            _innerWriter.Close();
+        }
+
+        public override void Flush()
+        {
+            _innerWriter.Flush();
+        }
+
+        public override string LookupPrefix(string ns)
+        {
+            return _innerWriter.LookupPrefix(ns);
+        }
+
+        public override void WriteBase64(byte[] buffer, int index, int count)
+        {
+            _innerWriter.WriteBase64(buffer, index, count);
+        }
+
+        public override void WriteCData(string text)
+        {
+            _innerWriter.WriteCData(text);
+        }
+
+        public override void WriteCharEntity(char ch)
+        {
+            _innerWriter.WriteCharEntity(ch);
+        }
+
+        public override void WriteChars(char[] buffer, int index, int count)
+        {
+            _innerWriter.WriteChars(buffer, index, count);
+        }
+
+        public override void WriteComment(string text)
+        {
+            _innerWriter.WriteComment(text);
+        }
+
+        public override void WriteDocType(string name, string pubid, string sysid, string subset)
+        {
+            _innerWriter.WriteDocType(name, pubid, sysid, subset);
+        }
+
+        public override void WriteEndAttribute()
+        {
+            _innerWriter.WriteEndAttribute();
+        }
+
+        public override void WriteEndDocument()
+        {
+            _innerWriter.WriteEndDocument();
+        }
+
+        public override void WriteEndElement()
+        {
+            _innerWriter.WriteEndElement();
+        }
+
+        public override void WriteEntityRef(string name)
+        {
+            _innerWriter.WriteEntityRef(name);
+        }
+
+        public override void WriteFullEndElement()
+        {
+            _innerWriter.WriteFullEndElement();
+        }
+
+        public override void WriteProcessingInstruction(string name, string text)
+        {
+            _innerWriter.WriteProcessingInstruction(name, text);
+        }
+
+        public override void WriteRaw(string data)
+        {
+            _innerWriter.WriteRaw(data);
+        }
+
+        public override void WriteRaw(char[] buffer, int index, int count)
+        {
+            _innerWriter.WriteRaw(buffer, index, count);
+        }
+
+        public override void WriteStartDocument(bool standalone)
+        {
+            _innerWriter.WriteStartDocument(standalone);
+        }
+
+        public override void WriteStartDocument()
+        {
+            _innerWriter.WriteStartDocument();
+        }
+
+        public override WriteState WriteState
+        {
+            get { return _innerWriter.WriteState; }
+        }
+
+        public override void WriteString(string text)
+        {
+            _innerWriter.WriteString(text);
+        }
+
+        public override void WriteSurrogateCharEntity(char lowChar, char highChar)
+        {
+            _innerWriter.WriteSurrogateCharEntity(lowChar, highChar);
+        }
+
+        public override void WriteWhitespace(string ws)
+        {
+            _innerWriter.WriteWhitespace(ws);
+        }
+    }
+}
+
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/WSSecurityPolicy.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/WSSecurityPolicy.cs
new file mode 100644
index 0000000..38e767e
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/WSSecurityPolicy.cs
@@ -0,0 +1,3130 @@
+using System.Collections.Generic;
+using System.Collections.ObjectModel;
+using System.IO;
+using System.Runtime;
+using CoreWCF;
+using CoreWCF.Channels;
+using CoreWCF.Description;
+using CoreWCF.Security.Tokens;
+using System.Xml;
+namespace CoreWCF.Security
+{
+
+
+    abstract class WSSecurityPolicy
+    {
+        public static ContractDescription NullContract = new ContractDescription("null");
+        public static ServiceEndpoint NullServiceEndpoint = new ServiceEndpoint(NullContract);
+        public static XmlDocument doc = new XmlDocument();
+        public const string WsspPrefix = "sp";
+        public const string WspNamespace = MetadataStrings.WSPolicy.NamespaceUri; //@"http://schemas.xmlsoap.org/ws/2004/09/policy";
+        public const string Wsp15Namespace = MetadataStrings.WSPolicy.NamespaceUri15;
+        public const string WspPrefix = MetadataStrings.WSPolicy.Prefix; //"wsp";
+        public const string MsspNamespace = @"http://schemas.microsoft.com/ws/2005/07/securitypolicy";
+        public const string MsspPrefix = "mssp";
+        public const string PolicyName = MetadataStrings.WSPolicy.Elements.Policy; //"Policy";
+        public const string OptionalName = "Optional";
+        public const string TrueName = "true";
+        public const string FalseName = "false";
+        public const string SymmetricBindingName = "SymmetricBinding";
+        public const string AsymmetricBindingName = "AsymmetricBinding";
+        public const string TransportBindingName = "TransportBinding";
+        public const string OnlySignEntireHeadersAndBodyName = "OnlySignEntireHeadersAndBody";
+        public const string ProtectionTokenName = "ProtectionToken";
+        public const string InitiatorTokenName = "InitiatorToken";
+        public const string RecipientTokenName = "RecipientToken";
+        public const string TransportTokenName = "TransportToken";
+        public const string AlgorithmSuiteName = "AlgorithmSuite";
+        public const string LaxName = "Lax";
+        public const string LaxTsLastName = "LaxTsLast";
+        public const string LaxTsFirstName = "LaxTsFirst";
+        public const string StrictName = "Strict";
+        public const string IncludeTimestampName = "IncludeTimestamp";
+        public const string EncryptBeforeSigningName = "EncryptBeforeSigning";
+        public const string ProtectTokens = "ProtectTokens";
+        public const string EncryptSignatureName = "EncryptSignature";
+        public const string SignedSupportingTokensName = "SignedSupportingTokens";
+        public const string EndorsingSupportingTokensName = "EndorsingSupportingTokens";
+        public const string SignedEndorsingSupportingTokensName = "SignedEndorsingSupportingTokens";
+        public const string Wss10Name = "Wss10";
+        public const string MustSupportRefKeyIdentifierName = "MustSupportRefKeyIdentifier";
+        public const string MustSupportRefIssuerSerialName = "MustSupportRefIssuerSerial";
+        public const string MustSupportRefThumbprintName = "MustSupportRefThumbprint";
+        public const string MustSupportRefEncryptedKeyName = "MustSupportRefEncryptedKey";
+        public const string RequireSignatureConfirmationName = "RequireSignatureConfirmation";
+        public const string MustSupportIssuedTokensName = "MustSupportIssuedTokens";
+        public const string RequireClientEntropyName = "RequireClientEntropy";
+        public const string RequireServerEntropyName = "RequireServerEntropy";
+        public const string Wss11Name = "Wss11";
+        public const string Trust10Name = "Trust10";
+        public const string Trust13Name = "Trust13";
+        public const string RequireAppliesTo = "RequireAppliesTo";
+        public const string SignedPartsName = "SignedParts";
+        public const string EncryptedPartsName = "EncryptedParts";
+        public const string BodyName = "Body";
+        public const string HeaderName = "Header";
+        public const string NameName = "Name";
+        public const string NamespaceName = "Namespace";
+        public const string Basic128Name = "Basic128";
+        public const string Basic192Name = "Basic192";
+        public const string Basic256Name = "Basic256";
+        public const string TripleDesName = "TripleDes";
+        public const string Basic128Rsa15Name = "Basic128Rsa15";
+        public const string Basic192Rsa15Name = "Basic192Rsa15";
+        public const string Basic256Rsa15Name = "Basic256Rsa15";
+        public const string TripleDesRsa15Name = "TripleDesRsa15";
+        public const string Basic128Sha256Name = "Basic128Sha256";
+        public const string Basic192Sha256Name = "Basic192Sha256";
+        public const string Basic256Sha256Name = "Basic256Sha256";
+        public const string TripleDesSha256Name = "TripleDesSha256";
+        public const string Basic128Sha256Rsa15Name = "Basic128Sha256Rsa15";
+        public const string Basic192Sha256Rsa15Name = "Basic192Sha256Rsa15";
+        public const string Basic256Sha256Rsa15Name = "Basic256Sha256Rsa15";
+        public const string TripleDesSha256Rsa15Name = "TripleDesSha256Rsa15";
+        public const string IncludeTokenName = "IncludeToken";
+        public const string KerberosTokenName = "KerberosToken";
+        public const string X509TokenName = "X509Token";
+        public const string IssuedTokenName = "IssuedToken";
+        public const string UsernameTokenName = "UsernameToken";
+        public const string RsaTokenName = "RsaToken";
+        public const string KeyValueTokenName = "KeyValueToken";
+        public const string SpnegoContextTokenName = "SpnegoContextToken";
+        public const string SslContextTokenName = "SslContextToken";
+        public const string SecureConversationTokenName = "SecureConversationToken";
+        public const string WssGssKerberosV5ApReqToken11Name = "WssGssKerberosV5ApReqToken11";
+        public const string RequireDerivedKeysName = "RequireDerivedKeys";
+        public const string RequireIssuerSerialReferenceName = "RequireIssuerSerialReference";
+        public const string RequireKeyIdentifierReferenceName = "RequireKeyIdentifierReference";
+        public const string RequireThumbprintReferenceName = "RequireThumbprintReference";
+        public const string WssX509V3Token10Name = "WssX509V3Token10";
+        public const string WssUsernameToken10Name = "WssUsernameToken10";
+        public const string RequestSecurityTokenTemplateName = "RequestSecurityTokenTemplate";
+        public const string RequireExternalReferenceName = "RequireExternalReference";
+        public const string RequireInternalReferenceName = "RequireInternalReference";
+        public const string IssuerName = "Issuer";
+        public const string RequireClientCertificateName = "RequireClientCertificate";
+        public const string MustNotSendCancelName = "MustNotSendCancel";
+        public const string MustNotSendAmendName = "MustNotSendAmend";
+        public const string MustNotSendRenewName = "MustNotSendRenew";
+        public const string LayoutName = "Layout";
+        public const string BootstrapPolicyName = "BootstrapPolicy";
+        public const string HttpsTokenName = "HttpsToken";
+        public const string HttpBasicAuthenticationName = "HttpBasicAuthentication";
+        public const string HttpDigestAuthenticationName = "HttpDigestAuthentication";
+
+        bool _mustSupportRefKeyIdentifierName = false;
+        bool _mustSupportRefIssuerSerialName = false;
+        bool _mustSupportRefThumbprintName = false;
+        bool _protectionTokenHasAsymmetricKey = false;
+        /*
+        public virtual XmlElement CreateWsspAssertion(string name)
+        {
+            return doc.CreateElement(WsspPrefix, name, this.WsspNamespaceUri);
+        }
+
+        public virtual bool IsWsspAssertion(XmlElement assertion)
+        {
+            return assertion.NamespaceURI == this.WsspNamespaceUri;
+        }
+
+        public virtual bool IsWsspAssertion(XmlElement assertion, string name)
+        {
+            return assertion.NamespaceURI == this.WsspNamespaceUri && assertion.LocalName == name;
+        }
+
+        public virtual bool IsMsspAssertion(XmlElement assertion, string name)
+        {
+            return assertion.NamespaceURI == MsspNamespace && assertion.LocalName == name;
+        }
+
+        public virtual bool TryImportWsspAssertion(ICollection<XmlElement> assertions, string name, out XmlElement assertion)
+        {
+            assertion = null;
+
+            foreach (XmlElement e in assertions)
+            {
+                if (e.LocalName == name && e.NamespaceURI == this.WsspNamespaceUri)
+                {
+                    assertion = e;
+                    assertions.Remove(e);
+                    return true;
+                }
+            }
+
+            return false;
+        }
+
+        public virtual bool TryImportWsspAssertion(ICollection<XmlElement> assertions, string name)
+        {
+            return TryImportWsspAssertion(assertions, name, false);
+        }
+
+        public virtual bool TryImportWsspAssertion(ICollection<XmlElement> assertions, string name, bool isOptional)
+        {
+            foreach (XmlElement e in assertions)
+            {
+                if (e.LocalName == name && e.NamespaceURI == this.WsspNamespaceUri)
+                {
+                    assertions.Remove(e);
+                    return true;
+                }
+            }
+
+            return isOptional;
+        }
+
+        public virtual XmlElement CreateMsspAssertion(string name)
+        {
+            return doc.CreateElement(MsspPrefix, name, MsspNamespace);
+        }
+
+        public virtual bool CanImportAssertion(ICollection<XmlElement> assertions)
+        {
+            foreach (XmlElement e in assertions)
+            {
+                if (e.NamespaceURI == this.WsspNamespaceUri || e.NamespaceURI == WSSecurityPolicy.MsspNamespace)
+                {
+                    return true;
+                }
+            }
+
+            return false;
+        }
+
+        public abstract bool IsSecurityVersionSupported(MessageSecurityVersion version);
+
+        public abstract MessageSecurityVersion GetSupportedMessageSecurityVersion(SecurityVersion version);
+
+        public abstract string WsspNamespaceUri { get; }
+
+        public abstract TrustDriver TrustDriver { get; }
+
+        public virtual string AlwaysToRecipientUri
+        {
+            get { return this.WsspNamespaceUri + @"/IncludeToken/AlwaysToRecipient"; }
+        }
+
+        public virtual string NeverUri
+        {
+            get { return this.WsspNamespaceUri + @"/IncludeToken/Never"; }
+        }
+
+        public virtual string OnceUri
+        {
+            get { return this.WsspNamespaceUri + @"/IncludeToken/Once"; }
+        }
+
+        public virtual string AlwaysToInitiatorUri
+        {
+            get { return this.WsspNamespaceUri + @"/IncludeToken/AlwaysToInitiator"; }
+        }
+
+        public virtual bool TryImportMsspAssertion(ICollection<XmlElement> assertions, string name)
+        {
+            foreach (XmlElement e in assertions)
+            {
+                if (e.LocalName == name && e.NamespaceURI == MsspNamespace)
+                {
+                    assertions.Remove(e);
+                    return true;
+                }
+            }
+
+            return false;
+        }
+
+        public virtual XmlElement CreateWspPolicyWrapper(MetadataExporter exporter, params XmlElement[] nestedAssertions)
+        {
+            XmlElement result = doc.CreateElement(WspPrefix, PolicyName, exporter.PolicyVersion.Namespace);
+
+            if (nestedAssertions != null)
+            {
+                foreach (XmlElement e in nestedAssertions)
+                {
+                    if (e != null)
+                    {
+                        result.AppendChild(e);
+                    }
+                }
+            }
+
+            return result;
+        }
+
+        public virtual XmlElement CreateWsspSignedPartsAssertion(MessagePartSpecification parts)
+        {
+            if (parts == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("parts");
+            }
+
+            XmlElement result;
+
+            if (parts.IsEmpty())
+            {
+                result = null;
+            }
+            else
+            {
+                result = CreateWsspAssertion(SignedPartsName);
+                if (parts.IsBodyIncluded)
+                {
+                    result.AppendChild(CreateWsspAssertion(BodyName));
+                }
+                foreach (XmlQualifiedName header in parts.HeaderTypes)
+                {
+                    result.AppendChild(CreateWsspHeaderAssertion(header));
+                }
+            }
+            return result;
+        }
+
+        public virtual XmlElement CreateWsspEncryptedPartsAssertion(MessagePartSpecification parts)
+        {
+            if (parts == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("parts");
+            }
+
+            XmlElement result;
+
+            if (parts.IsEmpty())
+            {
+                result = null;
+            }
+            else
+            {
+                result = CreateWsspAssertion(EncryptedPartsName);
+                if (parts.IsBodyIncluded)
+                {
+                    result.AppendChild(CreateWsspAssertion(BodyName));
+                }
+                foreach (XmlQualifiedName header in parts.HeaderTypes)
+                {
+                    result.AppendChild(CreateWsspHeaderAssertion(header));
+                }
+            }
+            return result;
+        }
+
+        public virtual MessagePartSpecification TryGetProtectedParts(XmlElement assertion)
+        {
+            MessagePartSpecification parts = new MessagePartSpecification();
+
+            foreach (XmlNode node in assertion.ChildNodes)
+            {
+                if (node.NodeType == XmlNodeType.Whitespace || node.NodeType == XmlNodeType.Comment)
+                {
+                    continue;
+                }
+                else if (node is XmlElement)
+                {
+                    XmlElement element = (XmlElement)node;
+                    if (IsWsspAssertion(element, BodyName))
+                    {
+                        parts.IsBodyIncluded = true;
+                    }
+                    else if (IsWsspAssertion(element, HeaderName))
+                    {
+                        string name = element.GetAttribute(NameName);
+                        string ns = element.GetAttribute(NamespaceName);
+
+                        if (ns == null)
+                        {
+                            parts = null;
+                            break;
+                        }
+
+                        parts.HeaderTypes.Add(new XmlQualifiedName(name, ns));
+                    }
+                    else
+                    {
+                        parts = null;
+                        break;
+                    }
+                }
+                else
+                {
+                    parts = null;
+                    break;
+                }
+            }
+
+            return parts;
+        }
+
+        public virtual bool TryImportWsspEncryptedPartsAssertion(ICollection<XmlElement> assertions, out MessagePartSpecification parts, out XmlElement assertion)
+        {
+            if (TryImportWsspAssertion(assertions, EncryptedPartsName, out assertion))
+            {
+                parts = TryGetProtectedParts(assertion);
+            }
+            else
+            {
+                parts = null;
+            }
+
+            return parts != null;
+        }
+
+        public virtual bool TryImportWsspSignedPartsAssertion(ICollection<XmlElement> assertions, out MessagePartSpecification parts, out XmlElement assertion)
+        {
+            if (TryImportWsspAssertion(assertions, SignedPartsName, out assertion))
+            {
+                parts = TryGetProtectedParts(assertion);
+            }
+            else
+            {
+                parts = null;
+            }
+
+            return parts != null;
+        }
+
+        public virtual XmlElement CreateWsspHeaderAssertion(XmlQualifiedName header)
+        {
+            XmlElement result = CreateWsspAssertion(HeaderName);
+            result.SetAttribute(NameName, header.Name);
+            result.SetAttribute(NamespaceName, header.Namespace);
+
+            return result;
+        }
+
+        public virtual XmlElement CreateWsspSymmetricBindingAssertion(MetadataExporter exporter, PolicyConversionContext policyContext, SymmetricSecurityBindingElement binding)
+        {
+            if (binding == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("binding");
+            }
+
+            XmlElement result = CreateWsspAssertion(SymmetricBindingName);
+            result.AppendChild(
+                CreateWspPolicyWrapper(
+                    exporter,
+                    CreateWsspProtectionTokenAssertion(exporter, binding.ProtectionTokenParameters),
+                    CreateWsspAlgorithmSuiteAssertion(exporter, binding.DefaultAlgorithmSuite),
+                    CreateWsspLayoutAssertion(exporter, binding.SecurityHeaderLayout),
+                    CreateWsspIncludeTimestampAssertion(binding.IncludeTimestamp),
+                    CreateWsspEncryptBeforeSigningAssertion(binding.MessageProtectionOrder),
+                    CreateWsspEncryptSignatureAssertion(policyContext, binding),
+                    CreateWsspProtectTokensAssertion(binding),
+                    CreateWsspAssertion(OnlySignEntireHeadersAndBodyName)
+            ));
+
+            return result;
+        }
+
+        public virtual bool TryGetNestedPolicyAlternatives(MetadataImporter importer, XmlElement assertion, out Collection<Collection<XmlElement>> alternatives)
+        {
+            alternatives = null;
+
+            XmlElement policyElement = null;
+            foreach (XmlNode node in assertion.ChildNodes)
+            {
+                if (node is XmlElement && node.LocalName == PolicyName && (node.NamespaceURI == WspNamespace || node.NamespaceURI == Wsp15Namespace))
+                {
+                    policyElement = (XmlElement)node;
+                    break;
+                }
+            }
+
+            if (policyElement == null)
+            {
+                alternatives = null;
+            }
+            else
+            {
+                IEnumerable<IEnumerable<XmlElement>> enumerableAlternatives = importer.NormalizePolicy(new XmlElement[] { policyElement });
+
+                alternatives = new Collection<Collection<XmlElement>>();
+                foreach (IEnumerable<XmlElement> enumerableAlternative in enumerableAlternatives)
+                {
+                    Collection<XmlElement> alternative = new Collection<XmlElement>();
+                    alternatives.Add(alternative);
+                    foreach (XmlElement e in enumerableAlternative)
+                    {
+                        alternative.Add(e);
+                    }
+                }
+            }
+
+            return alternatives != null;
+        }
+
+        public virtual bool TryImportWsspSymmetricBindingAssertion(MetadataImporter importer, PolicyConversionContext policyContext, ICollection<XmlElement> assertions, out SymmetricSecurityBindingElement binding, out XmlElement assertion)
+        {
+            binding = null;
+
+            Collection<Collection<XmlElement>> alternatives;
+
+            if (TryImportWsspAssertion(assertions, SymmetricBindingName, out assertion)
+                && TryGetNestedPolicyAlternatives(importer, assertion, out alternatives))
+            {
+                foreach (Collection<XmlElement> alternative in alternatives)
+                {
+                    MessageProtectionOrder order;
+                    bool protectTokens;
+                    binding = new SymmetricSecurityBindingElement();
+                    if (TryImportWsspProtectionTokenAssertion(importer, policyContext, alternative, binding)
+                        && TryImportWsspAlgorithmSuiteAssertion(importer, alternative, binding)
+                        && TryImportWsspLayoutAssertion(importer, alternative, binding)
+                        && TryImportWsspIncludeTimestampAssertion(alternative, binding)
+                        && TryImportMessageProtectionOrderAssertions(alternative, out order)
+                        && TryImportWsspProtectTokensAssertion(alternative, out protectTokens)
+                        && TryImportWsspAssertion(alternative, OnlySignEntireHeadersAndBodyName, true)
+                        && alternative.Count == 0)
+                    {
+                        binding.MessageProtectionOrder = order;
+                        binding.ProtectTokens = protectTokens;
+                        break;
+                    }
+                    else
+                    {
+                        binding = null;
+                    }
+                }
+            }
+
+            return binding != null;
+        }
+
+        public virtual XmlElement CreateWsspAsymmetricBindingAssertion(MetadataExporter exporter, PolicyConversionContext policyContext, AsymmetricSecurityBindingElement binding)
+        {
+            if (binding == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("binding");
+            }
+
+            XmlElement result = CreateWsspAssertion(AsymmetricBindingName);
+            result.AppendChild(
+                CreateWspPolicyWrapper(
+                    exporter,
+                    CreateWsspInitiatorTokenAssertion(exporter, binding.InitiatorTokenParameters),
+                    CreateWsspRecipientTokenAssertion(exporter, binding.RecipientTokenParameters),
+                    CreateWsspAlgorithmSuiteAssertion(exporter, binding.DefaultAlgorithmSuite),
+                    CreateWsspLayoutAssertion(exporter, binding.SecurityHeaderLayout),
+                    CreateWsspIncludeTimestampAssertion(binding.IncludeTimestamp),
+                    CreateWsspEncryptBeforeSigningAssertion(binding.MessageProtectionOrder),
+                    CreateWsspEncryptSignatureAssertion(policyContext, binding),
+                    CreateWsspProtectTokensAssertion(binding),
+                    CreateWsspAssertion(OnlySignEntireHeadersAndBodyName)
+            ));
+
+            return result;
+        }
+
+        public virtual bool TryImportWsspAsymmetricBindingAssertion(MetadataImporter importer, PolicyConversionContext policyContext, ICollection<XmlElement> assertions, out AsymmetricSecurityBindingElement binding, out XmlElement assertion)
+        {
+            binding = null;
+
+            Collection<Collection<XmlElement>> alternatives;
+
+            if (TryImportWsspAssertion(assertions, AsymmetricBindingName, out assertion)
+                && TryGetNestedPolicyAlternatives(importer, assertion, out alternatives))
+            {
+                foreach (Collection<XmlElement> alternative in alternatives)
+                {
+                    MessageProtectionOrder order;
+                    bool protectTokens;
+                    binding = new AsymmetricSecurityBindingElement();
+                    if (TryImportWsspInitiatorTokenAssertion(importer, policyContext, alternative, binding)
+                        && TryImportWsspRecipientTokenAssertion(importer, policyContext, alternative, binding)
+                        && TryImportWsspAlgorithmSuiteAssertion(importer, alternative, binding)
+                        && TryImportWsspLayoutAssertion(importer, alternative, binding)
+                        && TryImportWsspIncludeTimestampAssertion(alternative, binding)
+                        && TryImportMessageProtectionOrderAssertions(alternative, out order)
+                        && TryImportWsspProtectTokensAssertion(alternative, out protectTokens)
+                        && TryImportWsspAssertion(alternative, OnlySignEntireHeadersAndBodyName, true)
+                        && alternative.Count == 0)
+                    {
+                        binding.MessageProtectionOrder = order;
+                        binding.ProtectTokens = protectTokens;
+                        break;
+                    }
+                    else
+                    {
+                        binding = null;
+                    }
+                }
+            }
+
+            return binding != null;
+        }
+
+        public virtual XmlElement CreateWsspTransportBindingAssertion(MetadataExporter exporter, TransportSecurityBindingElement binding, XmlElement transportTokenAssertion)
+        {
+            XmlElement result = CreateWsspAssertion(TransportBindingName);
+            result.AppendChild(
+                CreateWspPolicyWrapper(
+                    exporter,
+                    CreateWsspTransportTokenAssertion(exporter, transportTokenAssertion),
+                    CreateWsspAlgorithmSuiteAssertion(exporter, binding.DefaultAlgorithmSuite),
+                    CreateWsspLayoutAssertion(exporter, binding.SecurityHeaderLayout),
+                    CreateWsspIncludeTimestampAssertion(binding.IncludeTimestamp)
+            ));
+
+            return result;
+        }
+
+        public virtual bool TryImportWsspTransportBindingAssertion(MetadataImporter importer, ICollection<XmlElement> assertions, out TransportSecurityBindingElement binding, out XmlElement assertion)
+        {
+            binding = null;
+
+            Collection<Collection<XmlElement>> alternatives;
+
+            if (TryImportWsspAssertion(assertions, TransportBindingName, out assertion)
+                && TryGetNestedPolicyAlternatives(importer, assertion, out alternatives))
+            {
+                foreach (Collection<XmlElement> alternative in alternatives)
+                {
+                    XmlElement transportTokenAssertion;
+                    binding = new TransportSecurityBindingElement();
+                    if (TryImportWsspTransportTokenAssertion(importer, alternative, out transportTokenAssertion)
+                        && TryImportWsspAlgorithmSuiteAssertion(importer, alternative, binding)
+                        && TryImportWsspLayoutAssertion(importer, alternative, binding)
+                        && TryImportWsspIncludeTimestampAssertion(alternative, binding)
+                        && alternative.Count == 0)
+                    {
+                        if (false == importer.State.ContainsKey(SecurityBindingElementImporter.InSecureConversationBootstrapBindingImportMode))
+                        {
+                            // The transportTokenAssertion should be consumed by the transport binding importer
+                            // for all primary bindings. However, for secure conversation bootstrap bindings
+                            // the bootstrap policy does not contain any transport assertions, so adding the
+                            // transport token assertion to the collection of unimported assertions would
+                            // increase the likelihood of policy import failure due to unrecognized assertions. 
+                            assertions.Add(transportTokenAssertion);
+                        }
+                        break;
+                    }
+                    else
+                    {
+                        binding = null;
+                    }
+                }
+            }
+
+            return binding != null;
+        }
+
+        public virtual XmlElement CreateWsspWssAssertion(MetadataExporter exporter, SecurityBindingElement binding)
+        {
+            if (binding == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("binding");
+            }
+
+            if (binding.MessageSecurityVersion.SecurityVersion == SecurityVersion.WSSecurity10)
+            {
+                return CreateWsspWss10Assertion(exporter);
+            }
+            else if (binding.MessageSecurityVersion.SecurityVersion == SecurityVersion.WSSecurity11)
+            {
+                if (binding is SymmetricSecurityBindingElement)
+                {
+                    return CreateWsspWss11Assertion(exporter, ((SymmetricSecurityBindingElement)binding).RequireSignatureConfirmation);
+                }
+                else if (binding is AsymmetricSecurityBindingElement)
+                {
+                    return CreateWsspWss11Assertion(exporter, ((AsymmetricSecurityBindingElement)binding).RequireSignatureConfirmation);
+                }
+                else
+                {
+                    return CreateWsspWss11Assertion(exporter, false);
+                }
+            }
+            else
+            {
+                return null;
+            }
+        }
+
+        public virtual bool TryImportWsspWssAssertion(MetadataImporter importer, ICollection<XmlElement> assertions, SecurityBindingElement binding, out XmlElement assertion)
+        {
+            if (binding == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("binding");
+            }
+            if (assertions == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("assertions");
+            }
+
+            bool result = true;
+            Collection<Collection<XmlElement>> alternatives;
+
+            if (TryImportWsspAssertion(assertions, Wss10Name, out assertion))
+            {
+                if (TryGetNestedPolicyAlternatives(importer, assertion, out alternatives))
+                {
+                    foreach (Collection<XmlElement> alternative in alternatives)
+                    {
+                        TryImportWsspAssertion(alternative, MustSupportRefKeyIdentifierName);
+                        TryImportWsspAssertion(alternative, MustSupportRefIssuerSerialName);
+                        if (alternative.Count == 0)
+                        {
+                            binding.MessageSecurityVersion = this.GetSupportedMessageSecurityVersion(SecurityVersion.WSSecurity10);
+                            result = true;
+                            break;
+                        }
+                        else
+                        {
+                            result = false;
+                        }
+                    }
+                }
+            }
+            else if (TryImportWsspAssertion(assertions, Wss11Name, out assertion))
+            {
+                if (TryGetNestedPolicyAlternatives(importer, assertion, out alternatives))
+                {
+                    foreach (Collection<XmlElement> alternative in alternatives)
+                    {
+                        TryImportWsspAssertion(alternative, MustSupportRefKeyIdentifierName);
+                        TryImportWsspAssertion(alternative, MustSupportRefIssuerSerialName);
+                        TryImportWsspAssertion(alternative, MustSupportRefThumbprintName);
+                        TryImportWsspAssertion(alternative, MustSupportRefEncryptedKeyName);
+                        bool requireSignatureConfirmation = TryImportWsspAssertion(alternative, RequireSignatureConfirmationName);
+                        if (alternative.Count == 0)
+                        {
+                            binding.MessageSecurityVersion = this.GetSupportedMessageSecurityVersion(SecurityVersion.WSSecurity11);
+                            if (binding is SymmetricSecurityBindingElement)
+                            {
+                                ((SymmetricSecurityBindingElement)binding).RequireSignatureConfirmation = requireSignatureConfirmation;
+                            }
+                            else if (binding is AsymmetricSecurityBindingElement)
+                            {
+                                ((AsymmetricSecurityBindingElement)binding).RequireSignatureConfirmation = requireSignatureConfirmation;
+                            }
+                            result = true;
+                            break;
+                        }
+                        else
+                        {
+                            result = false;
+                        }
+                    }
+                }
+            }
+
+            return result;
+        }
+
+        public virtual XmlElement CreateWsspWss10Assertion(MetadataExporter exporter)
+        {
+            XmlElement result = CreateWsspAssertion(Wss10Name);
+            result.AppendChild(
+                CreateWspPolicyWrapper(
+                    exporter,
+                    CreateWsspAssertionMustSupportRefKeyIdentifierName(),
+                    CreateWsspAssertionMustSupportRefIssuerSerialName()
+            ));
+
+            return result;
+        }
+
+        public virtual XmlElement CreateWsspWss11Assertion(MetadataExporter exporter, bool requireSignatureConfirmation)
+        {
+            XmlElement result = CreateWsspAssertion(Wss11Name);
+            result.AppendChild(
+                CreateWspPolicyWrapper(
+                    exporter,
+                    CreateWsspAssertionMustSupportRefKeyIdentifierName(),
+                    CreateWsspAssertionMustSupportRefIssuerSerialName(),
+                    CreateWsspAssertionMustSupportRefThumbprintName(),
+                    CreateWsspAssertionMustSupportRefEncryptedKeyName(),
+                    CreateWsspRequireSignatureConformationAssertion(requireSignatureConfirmation)
+            ));
+
+            return result;
+        }
+        public virtual XmlElement CreateWsspAssertionMustSupportRefKeyIdentifierName()
+        {
+            if (_mustSupportRefKeyIdentifierName)
+            {
+                return CreateWsspAssertion(MustSupportRefKeyIdentifierName);
+            }
+            else
+            {
+                return null;
+            }
+        }
+
+        public virtual XmlElement CreateWsspAssertionMustSupportRefIssuerSerialName()
+        {
+            if (_mustSupportRefIssuerSerialName)
+            {
+                return CreateWsspAssertion(MustSupportRefIssuerSerialName);
+            }
+            else
+            {
+                return null;
+            }
+        }
+
+        public virtual XmlElement CreateWsspAssertionMustSupportRefThumbprintName()
+        {
+            if (_mustSupportRefThumbprintName)
+            {
+                return CreateWsspAssertion(MustSupportRefThumbprintName);
+            }
+            else
+            {
+                return null;
+            }
+        }
+
+        public virtual XmlElement CreateWsspAssertionMustSupportRefEncryptedKeyName()
+        {
+            // protectionTokenHasAsymmetricKey is only set to true for a SymmetricBindingElement having an asymmetric key
+            if (_protectionTokenHasAsymmetricKey)
+            {
+                return CreateWsspAssertion(MustSupportRefEncryptedKeyName);
+            }
+            else
+            {
+                return null;
+            }
+        }
+
+        public virtual XmlElement CreateWsspRequireSignatureConformationAssertion(bool requireSignatureConfirmation)
+        {
+            if (requireSignatureConfirmation)
+            {
+                return CreateWsspAssertion(RequireSignatureConfirmationName);
+            }
+            else
+            {
+                return null;
+            }
+        }
+
+        public abstract XmlElement CreateWsspTrustAssertion(MetadataExporter exporter, SecurityKeyEntropyMode keyEntropyMode);
+
+        public abstract bool TryImportWsspTrustAssertion(MetadataImporter importer, ICollection<XmlElement> assertions, SecurityBindingElement binding, out XmlElement assertion);
+
+        protected XmlElement CreateWsspTrustAssertion(string trustName, MetadataExporter exporter, SecurityKeyEntropyMode keyEntropyMode)
+        {
+            XmlElement result = CreateWsspAssertion(trustName);
+            result.AppendChild(
+                CreateWspPolicyWrapper(
+                    exporter,
+                    CreateWsspAssertion(MustSupportIssuedTokensName),
+                    CreateWsspRequireClientEntropyAssertion(keyEntropyMode),
+                    CreateWsspRequireServerEntropyAssertion(keyEntropyMode)
+            ));
+
+            return result;
+        }
+
+        protected bool TryImportWsspTrustAssertion(string trustName, MetadataImporter importer, ICollection<XmlElement> assertions, SecurityBindingElement binding, out XmlElement assertion)
+        {
+            if (binding == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("binding");
+            }
+            if (assertions == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("assertions");
+            }
+
+            bool result = true;
+            Collection<Collection<XmlElement>> alternatives;
+
+            if (TryImportWsspAssertion(assertions, trustName, out assertion)
+                && TryGetNestedPolicyAlternatives(importer, assertion, out alternatives))
+            {
+                foreach (Collection<XmlElement> alternative in alternatives)
+                {
+                    TryImportWsspAssertion(alternative, MustSupportIssuedTokensName);
+                    bool requireClientEntropy = TryImportWsspAssertion(alternative, RequireClientEntropyName);
+                    bool requireServerEntropy = TryImportWsspAssertion(alternative, RequireServerEntropyName);
+                    if (trustName == Trust13Name)
+                    {
+                        // We are just reading this optional element.
+                        TryImportWsspAssertion(alternative, RequireAppliesTo);
+                    }
+                    if (alternative.Count == 0)
+                    {
+                        if (requireClientEntropy)
+                        {
+                            if (requireServerEntropy)
+                            {
+                                binding.KeyEntropyMode = SecurityKeyEntropyMode.CombinedEntropy;
+                            }
+                            else
+                            {
+                                binding.KeyEntropyMode = SecurityKeyEntropyMode.ClientEntropy;
+                            }
+                        }
+                        else if (requireServerEntropy)
+                        {
+                            binding.KeyEntropyMode = SecurityKeyEntropyMode.ServerEntropy;
+                        }
+
+                        result = true;
+                        break;
+                    }
+                    else
+                    {
+                        result = false;
+                    }
+                }
+            }
+
+            return result;
+        }
+
+        public virtual XmlElement CreateWsspRequireClientEntropyAssertion(SecurityKeyEntropyMode keyEntropyMode)
+        {
+            if (keyEntropyMode == SecurityKeyEntropyMode.ClientEntropy || keyEntropyMode == SecurityKeyEntropyMode.CombinedEntropy)
+            {
+                return CreateWsspAssertion(RequireClientEntropyName);
+            }
+            else
+            {
+                return null;
+            }
+        }
+
+        public virtual XmlElement CreateWsspRequireServerEntropyAssertion(SecurityKeyEntropyMode keyEntropyMode)
+        {
+            if (keyEntropyMode == SecurityKeyEntropyMode.ServerEntropy || keyEntropyMode == SecurityKeyEntropyMode.CombinedEntropy)
+            {
+                return CreateWsspAssertion(RequireServerEntropyName);
+            }
+            else
+            {
+                return null;
+            }
+        }
+
+        public virtual Collection<XmlElement> CreateWsspSupportingTokensAssertion(MetadataExporter exporter, Collection<SecurityTokenParameters> signed, Collection<SecurityTokenParameters> signedEncrypted, Collection<SecurityTokenParameters> endorsing, Collection<SecurityTokenParameters> signedEndorsing, Collection<SecurityTokenParameters> optionalSigned, Collection<SecurityTokenParameters> optionalSignedEncrypted, Collection<SecurityTokenParameters> optionalEndorsing, Collection<SecurityTokenParameters> optionalSignedEndorsing)
+        {
+            return CreateWsspSupportingTokensAssertion(exporter, signed, signedEncrypted, endorsing, signedEndorsing, optionalSigned, optionalSignedEncrypted, optionalEndorsing, optionalSignedEndorsing, null);
+        }
+
+        public virtual Collection<XmlElement> CreateWsspSupportingTokensAssertion(MetadataExporter exporter, Collection<SecurityTokenParameters> signed, Collection<SecurityTokenParameters> signedEncrypted, Collection<SecurityTokenParameters> endorsing, Collection<SecurityTokenParameters> signedEndorsing, Collection<SecurityTokenParameters> optionalSigned, Collection<SecurityTokenParameters> optionalSignedEncrypted, Collection<SecurityTokenParameters> optionalEndorsing, Collection<SecurityTokenParameters> optionalSignedEndorsing, AddressingVersion addressingVersion)
+        {
+            Collection<XmlElement> supportingTokenAssertions = new Collection<XmlElement>();
+
+            // Signed Supporting Tokens
+            XmlElement supportingTokenAssertion = CreateWsspSignedSupportingTokensAssertion(exporter, signed, signedEncrypted, optionalSigned, optionalSignedEncrypted);
+            if (supportingTokenAssertion != null)
+                supportingTokenAssertions.Add(supportingTokenAssertion);
+
+            // Endorsing Supporting Tokens.
+            supportingTokenAssertion = CreateWsspEndorsingSupportingTokensAssertion(exporter, endorsing, optionalEndorsing, addressingVersion);
+            if (supportingTokenAssertion != null)
+                supportingTokenAssertions.Add(supportingTokenAssertion);
+
+            // Signed Endorsing Supporting Tokens.
+            supportingTokenAssertion = CreateWsspSignedEndorsingSupportingTokensAssertion(exporter, signedEndorsing, optionalSignedEndorsing, addressingVersion);
+            if (supportingTokenAssertion != null)
+                supportingTokenAssertions.Add(supportingTokenAssertion);
+
+            return supportingTokenAssertions;
+        }
+
+        protected XmlElement CreateWsspSignedSupportingTokensAssertion(MetadataExporter exporter, Collection<SecurityTokenParameters> signed, Collection<SecurityTokenParameters> signedEncrypted, Collection<SecurityTokenParameters> optionalSigned, Collection<SecurityTokenParameters> optionalSignedEncrypted)
+        {
+            XmlElement result;
+
+            if ((signed == null || signed.Count == 0)
+                && (signedEncrypted == null || signedEncrypted.Count == 0)
+                && (optionalSigned == null || optionalSigned.Count == 0)
+                && (optionalSignedEncrypted == null || optionalSignedEncrypted.Count == 0))
+            {
+                result = null;
+            }
+            else
+            {
+                XmlElement policy = CreateWspPolicyWrapper(exporter);
+
+                if (signed != null)
+                {
+                    foreach (SecurityTokenParameters p in signed)
+                    {
+                        policy.AppendChild(CreateTokenAssertion(exporter, p));
+                    }
+                }
+                if (signedEncrypted != null)
+                {
+                    foreach (SecurityTokenParameters p in signedEncrypted)
+                    {
+                        policy.AppendChild(CreateTokenAssertion(exporter, p));
+                    }
+                }
+                if (optionalSigned != null)
+                {
+                    foreach (SecurityTokenParameters p in optionalSigned)
+                    {
+                        policy.AppendChild(CreateTokenAssertion(exporter, p, true));
+                    }
+                }
+                if (optionalSignedEncrypted != null)
+                {
+                    foreach (SecurityTokenParameters p in optionalSignedEncrypted)
+                    {
+                        policy.AppendChild(CreateTokenAssertion(exporter, p, true));
+                    }
+                }
+
+                result = CreateWsspAssertion(SignedSupportingTokensName);
+                result.AppendChild(policy);
+            }
+
+            return result;
+        }
+
+        protected XmlElement CreateWsspEndorsingSupportingTokensAssertion(MetadataExporter exporter, Collection<SecurityTokenParameters> endorsing, Collection<SecurityTokenParameters> optionalEndorsing, AddressingVersion addressingVersion)
+        {
+            return CreateWsspiSupportingTokensAssertion(exporter, endorsing, optionalEndorsing, addressingVersion, EndorsingSupportingTokensName);
+        }
+
+        protected XmlElement CreateWsspSignedEndorsingSupportingTokensAssertion(MetadataExporter exporter, Collection<SecurityTokenParameters> signedEndorsing, Collection<SecurityTokenParameters> optionalSignedEndorsing, AddressingVersion addressingVersion)
+        {
+            return CreateWsspiSupportingTokensAssertion(exporter, signedEndorsing, optionalSignedEndorsing, addressingVersion, SignedEndorsingSupportingTokensName);
+        }
+
+        protected XmlElement CreateWsspiSupportingTokensAssertion(MetadataExporter exporter, Collection<SecurityTokenParameters> endorsing, Collection<SecurityTokenParameters> optionalEndorsing, AddressingVersion addressingVersion, string assertionName)
+        {
+            XmlElement result;
+            bool hasAssymetricKey = false;
+
+            if ((endorsing == null || endorsing.Count == 0)
+                && (optionalEndorsing == null || optionalEndorsing.Count == 0))
+            {
+                result = null;
+            }
+            else
+            {
+                XmlElement policy = CreateWspPolicyWrapper(exporter);
+
+                if (endorsing != null)
+                {
+                    foreach (SecurityTokenParameters p in endorsing)
+                    {
+                        if (p.HasAsymmetricKey)
+                            hasAssymetricKey = true;
+
+                        policy.AppendChild(CreateTokenAssertion(exporter, p));
+                    }
+                }
+                if (optionalEndorsing != null)
+                {
+                    foreach (SecurityTokenParameters p in optionalEndorsing)
+                    {
+                        if (p.HasAsymmetricKey)
+                            hasAssymetricKey = true;
+
+                        policy.AppendChild(CreateTokenAssertion(exporter, p, true));
+                    }
+                }
+                if (addressingVersion != null && AddressingVersion.None != addressingVersion)
+                {
+                    // only add assertion to sign the 'To' only if an assymetric key is found
+                    if (hasAssymetricKey)
+                    {
+                        policy.AppendChild(
+                            CreateWsspSignedPartsAssertion(
+                                new MessagePartSpecification(new XmlQualifiedName(AddressingStrings.To, addressingVersion.Namespace))));
+                    }
+                }
+
+                result = CreateWsspAssertion(assertionName);
+                result.AppendChild(policy);
+            }
+
+            return result;
+        }
+
+        public virtual bool TryImportWsspSupportingTokensAssertion(MetadataImporter importer, PolicyConversionContext policyContext, ICollection<XmlElement> assertions, Collection<SecurityTokenParameters> signed, Collection<SecurityTokenParameters> signedEncrypted, Collection<SecurityTokenParameters> endorsing, Collection<SecurityTokenParameters> signedEndorsing, Collection<SecurityTokenParameters> optionalSigned, Collection<SecurityTokenParameters> optionalSignedEncrypted, Collection<SecurityTokenParameters> optionalEndorsing, Collection<SecurityTokenParameters> optionalSignedEndorsing)
+        {
+            XmlElement assertion;
+
+            if (!TryImportWsspSignedSupportingTokensAssertion(
+                importer,
+                policyContext,
+                assertions,
+                signed,
+                signedEncrypted,
+                optionalSigned,
+                optionalSignedEncrypted,
+                out assertion)
+                && assertion != null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.GetString(SR.UnsupportedSecurityPolicyAssertion, assertion.OuterXml)));
+            }
+
+            if (!TryImportWsspEndorsingSupportingTokensAssertion(
+                importer,
+                policyContext,
+                assertions,
+                endorsing,
+                optionalEndorsing,
+                out assertion)
+                && assertion != null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.GetString(SR.UnsupportedSecurityPolicyAssertion, assertion.OuterXml)));
+            }
+
+            if (!TryImportWsspSignedEndorsingSupportingTokensAssertion(
+                importer,
+                policyContext,
+                assertions,
+                signedEndorsing,
+                optionalSignedEndorsing,
+                out assertion)
+                && assertion != null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.GetString(SR.UnsupportedSecurityPolicyAssertion, assertion.OuterXml)));
+            }
+
+            return true;
+        }
+
+        protected bool TryImportWsspSignedSupportingTokensAssertion(MetadataImporter importer, PolicyConversionContext policyContext, ICollection<XmlElement> assertions, Collection<SecurityTokenParameters> signed, Collection<SecurityTokenParameters> signedEncrypted, Collection<SecurityTokenParameters> optionalSigned, Collection<SecurityTokenParameters> optionalSignedEncrypted, out XmlElement assertion)
+        {
+            if (signed == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("signed");
+            }
+            if (signedEncrypted == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("signedEncrypted");
+            }
+            if (optionalSigned == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("optionalSigned");
+            }
+            if (optionalSignedEncrypted == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("optionalSignedEncrypted");
+            }
+
+            bool result = true;
+
+            Collection<Collection<XmlElement>> alternatives;
+
+            if (TryImportWsspAssertion(assertions, SignedSupportingTokensName, out assertion)
+                && TryGetNestedPolicyAlternatives(importer, assertion, out alternatives))
+            {
+                foreach (Collection<XmlElement> alternative in alternatives)
+                {
+                    Collection<SecurityTokenParameters> signedSupportingTokens = new Collection<SecurityTokenParameters>();
+                    Collection<SecurityTokenParameters> optionalSignedSupportingTokens = new Collection<SecurityTokenParameters>();
+                    SecurityTokenParameters parameters;
+                    bool isOptional;
+                    while (alternative.Count > 0 && TryImportTokenAssertion(importer, policyContext, alternative, out parameters, out isOptional))
+                    {
+                        if (isOptional)
+                        {
+                            optionalSignedSupportingTokens.Add(parameters);
+                        }
+                        else
+                        {
+                            signedSupportingTokens.Add(parameters);
+                        }
+                    }
+                    if (alternative.Count == 0)
+                    {
+                        foreach (SecurityTokenParameters p in signedSupportingTokens)
+                        {
+                            if (p is UserNameSecurityTokenParameters)
+                            {
+                                signedEncrypted.Add(p);
+                            }
+                            else
+                            {
+                                signed.Add(p);
+                            }
+                        }
+                        foreach (SecurityTokenParameters p in optionalSignedSupportingTokens)
+                        {
+                            if (p is UserNameSecurityTokenParameters)
+                            {
+                                optionalSignedEncrypted.Add(p);
+                            }
+                            else
+                            {
+                                optionalSigned.Add(p);
+                            }
+                        }
+                        result = true;
+                        break;
+                    }
+                    else
+                    {
+                        result = false;
+                    }
+                }
+            }
+
+            return result;
+        }
+
+        protected bool TryImportWsspEndorsingSupportingTokensAssertion(MetadataImporter importer, PolicyConversionContext policyContext, ICollection<XmlElement> assertions, Collection<SecurityTokenParameters> endorsing, Collection<SecurityTokenParameters> optionalEndorsing, out XmlElement assertion)
+        {
+            if (endorsing == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("endorsing");
+            }
+            if (optionalEndorsing == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("optionalEndorsing");
+            }
+
+            bool result = true;
+
+            Collection<Collection<XmlElement>> alternatives;
+
+            if (TryImportWsspAssertion(assertions, EndorsingSupportingTokensName, out assertion)
+                && TryGetNestedPolicyAlternatives(importer, assertion, out alternatives))
+            {
+                foreach (Collection<XmlElement> alternative in alternatives)
+                {
+                    MessagePartSpecification signedParts;
+                    if (!TryImportWsspSignedPartsAssertion(alternative, out signedParts, out assertion) && assertion != null)
+                    {
+                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.GetString(SR.UnsupportedSecurityPolicyAssertion, assertion.OuterXml)));
+                    }
+
+                    Collection<SecurityTokenParameters> supportingTokens = new Collection<SecurityTokenParameters>();
+                    Collection<SecurityTokenParameters> optionalSupportingTokens = new Collection<SecurityTokenParameters>();
+                    SecurityTokenParameters parameters;
+                    bool isOptional;
+                    while (alternative.Count > 0 && TryImportTokenAssertion(importer, policyContext, alternative, out parameters, out isOptional))
+                    {
+                        if (isOptional)
+                        {
+                            optionalSupportingTokens.Add(parameters);
+                        }
+                        else
+                        {
+                            supportingTokens.Add(parameters);
+                        }
+                    }
+                    if (alternative.Count == 0)
+                    {
+                        foreach (SecurityTokenParameters p in supportingTokens)
+                        {
+                            endorsing.Add(p);
+                        }
+                        foreach (SecurityTokenParameters p in optionalSupportingTokens)
+                        {
+                            optionalEndorsing.Add(p);
+                        }
+                        result = true;
+                        break;
+                    }
+                    else
+                    {
+                        result = false;
+                    }
+                }
+            }
+
+            return result;
+        }
+
+        protected bool TryImportWsspSignedEndorsingSupportingTokensAssertion(MetadataImporter importer, PolicyConversionContext policyContext, ICollection<XmlElement> assertions, Collection<SecurityTokenParameters> signedEndorsing, Collection<SecurityTokenParameters> optionalSignedEndorsing, out XmlElement assertion)
+        {
+            if (signedEndorsing == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("signedEndorsing");
+            }
+            if (optionalSignedEndorsing == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("optionalSignedEndorsing");
+            }
+
+            bool result = true;
+
+            Collection<Collection<XmlElement>> alternatives;
+
+            if (TryImportWsspAssertion(assertions, SignedEndorsingSupportingTokensName, out assertion)
+                && TryGetNestedPolicyAlternatives(importer, assertion, out alternatives))
+            {
+                foreach (Collection<XmlElement> alternative in alternatives)
+                {
+                    MessagePartSpecification signedParts;
+                    if (!TryImportWsspSignedPartsAssertion(alternative, out signedParts, out assertion) && assertion != null)
+                    {
+                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.GetString(SR.UnsupportedSecurityPolicyAssertion, assertion.OuterXml)));
+                    }
+
+                    Collection<SecurityTokenParameters> supportingTokens = new Collection<SecurityTokenParameters>();
+                    Collection<SecurityTokenParameters> optionalSupportingTokens = new Collection<SecurityTokenParameters>();
+                    SecurityTokenParameters parameters;
+                    bool isOptional;
+                    while (alternative.Count > 0 && TryImportTokenAssertion(importer, policyContext, alternative, out parameters, out isOptional))
+                    {
+                        if (isOptional)
+                        {
+                            optionalSupportingTokens.Add(parameters);
+                        }
+                        else
+                        {
+                            supportingTokens.Add(parameters);
+                        }
+                    }
+                    if (alternative.Count == 0)
+                    {
+                        foreach (SecurityTokenParameters p in supportingTokens)
+                        {
+                            signedEndorsing.Add(p);
+                        }
+                        foreach (SecurityTokenParameters p in optionalSupportingTokens)
+                        {
+                            optionalSignedEndorsing.Add(p);
+                        }
+                        result = true;
+                        break;
+                    }
+                    else
+                    {
+                        result = false;
+                    }
+                }
+            }
+
+            return result;
+        }
+
+        public virtual XmlElement CreateWsspEncryptSignatureAssertion(PolicyConversionContext policyContext, SecurityBindingElement binding)
+        {
+            MessageProtectionOrder protectionOrder;
+            if (binding is SymmetricSecurityBindingElement)
+            {
+                protectionOrder = ((SymmetricSecurityBindingElement)binding).MessageProtectionOrder;
+            }
+            else
+            {
+                protectionOrder = ((AsymmetricSecurityBindingElement)binding).MessageProtectionOrder;
+            }
+
+            if (protectionOrder == MessageProtectionOrder.SignBeforeEncryptAndEncryptSignature 
+                && ContainsEncryptionParts(policyContext, binding))
+            {
+                return CreateWsspAssertion(EncryptSignatureName);
+            }
+            else
+            {
+                return null;
+            }
+        }
+
+        // This api checks whether or not the message will or may contain Encrypted parts
+        // to decide whether or not to emit sp:EncryptSignature on Binding assertion.
+        // 1) (Optional)EndpointSupporting.
+        // 2) (Optional)OperationSupporting.
+        // 3) In/Out/Fault Message ProtectionLevel for each Operation.
+        bool ContainsEncryptionParts(PolicyConversionContext policyContext, SecurityBindingElement security)
+        {
+            // special case for RST/RSTR since we hard coded the security for them
+            if (policyContext.Contract == NullContract)
+                return true;
+
+            if (security.EndpointSupportingTokenParameters.SignedEncrypted.Count > 0 ||
+                security.OptionalEndpointSupportingTokenParameters.SignedEncrypted.Count > 0)
+            {
+                return true;
+            }
+            foreach (SupportingTokenParameters r in security.OperationSupportingTokenParameters.Values)
+            {
+                if (r.SignedEncrypted.Count > 0)
+                {
+                    return true;
+                }
+            }
+            foreach (SupportingTokenParameters r in security.OptionalOperationSupportingTokenParameters.Values)
+            {
+                if (r.SignedEncrypted.Count > 0)
+                {
+                    return true;
+                }
+            }
+
+            BindingParameterCollection bindingParameters = new BindingParameterCollection();
+            bindingParameters.Add(ChannelProtectionRequirements.CreateFromContract(policyContext.Contract, policyContext.BindingElements.Find<SecurityBindingElement>().GetIndividualProperty<ISecurityCapabilities>(), false));
+            ChannelProtectionRequirements protectionRequirements = SecurityBindingElement.ComputeProtectionRequirements(security, bindingParameters, policyContext.BindingElements, true);
+            protectionRequirements.MakeReadOnly();
+
+            WSSecurityPolicy sp = WSSecurityPolicy.GetSecurityPolicyDriver(security.MessageSecurityVersion);
+
+            foreach (OperationDescription operation in policyContext.Contract.Operations)
+            {
+                // export policy for application messages
+                foreach (MessageDescription message in operation.Messages)
+                {
+                    MessagePartSpecification parts;
+                    ScopedMessagePartSpecification scopedParts;
+
+                    // confidentiality
+                    if (message.Direction == MessageDirection.Input)
+                    {
+                        scopedParts = protectionRequirements.IncomingEncryptionParts;
+                    }
+                    else
+                    {
+                        scopedParts = protectionRequirements.OutgoingEncryptionParts;
+                    }
+
+                    if (scopedParts.TryGetParts(message.Action, out parts))
+                    {
+                        if (!parts.IsEmpty())
+                        {
+                            return true;
+                        }
+                    }
+                }
+
+                // export policy for faults
+                foreach (FaultDescription fault in operation.Faults)
+                {
+                    MessagePartSpecification parts;
+
+                    // confidentiality
+                    if (protectionRequirements.OutgoingEncryptionParts.TryGetParts(fault.Action, out parts))
+                    {
+                        if (!parts.IsEmpty())
+                        {
+                            return true;
+                        }
+                    }
+                }
+            }
+            return false;
+        }
+
+        public virtual XmlElement CreateWsspEncryptBeforeSigningAssertion(MessageProtectionOrder protectionOrder)
+        {
+            if (protectionOrder == MessageProtectionOrder.EncryptBeforeSign)
+            {
+                return CreateWsspAssertion(EncryptBeforeSigningName);
+            }
+            else
+            {
+                return null;
+            }
+        }
+
+        public virtual XmlElement CreateWsspProtectTokensAssertion(SecurityBindingElement sbe)
+        {
+            if (sbe.ProtectTokens)
+            {
+                return CreateWsspAssertion(ProtectTokens);
+            }
+            else
+            {
+                return null;
+            }
+        }
+
+
+        public virtual bool TryImportMessageProtectionOrderAssertions(ICollection<XmlElement> assertions, out MessageProtectionOrder order)
+        {
+            if (TryImportWsspAssertion(assertions, EncryptBeforeSigningName))
+            {
+                order = MessageProtectionOrder.EncryptBeforeSign;
+            }
+            else if (TryImportWsspAssertion(assertions, EncryptSignatureName))
+            {
+                order = MessageProtectionOrder.SignBeforeEncryptAndEncryptSignature;
+            }
+            else
+            {
+                order = MessageProtectionOrder.SignBeforeEncrypt;
+            }
+
+            return true;
+        }
+
+        public virtual XmlElement CreateWsspIncludeTimestampAssertion(bool includeTimestamp)
+        {
+            if (includeTimestamp)
+            {
+                return CreateWsspAssertion(IncludeTimestampName);
+            }
+            else
+            {
+                return null;
+            }
+        }
+
+        public virtual bool TryImportWsspIncludeTimestampAssertion(ICollection<XmlElement> assertions, SecurityBindingElement binding)
+        {
+            binding.IncludeTimestamp = TryImportWsspAssertion(assertions, IncludeTimestampName);
+            return true;
+        }
+
+        public virtual bool TryImportWsspProtectTokensAssertion(ICollection<XmlElement> assertions, out bool protectTokens)
+        {
+            if (TryImportWsspAssertion(assertions, ProtectTokens))
+            {
+                protectTokens = true;
+            }
+            else
+            {
+                protectTokens = false;
+            }
+
+            return true;
+        }
+
+        public virtual XmlElement CreateWsspLayoutAssertion(MetadataExporter exporter, SecurityHeaderLayout layout)
+        {
+            XmlElement result = CreateWsspAssertion(LayoutName);
+            result.AppendChild(
+                CreateWspPolicyWrapper(
+                    exporter,
+                    CreateLayoutAssertion(layout)
+            ));
+
+            return result;
+        }
+
+        public virtual bool TryImportWsspLayoutAssertion(MetadataImporter importer, ICollection<XmlElement> assertions, SecurityBindingElement binding)
+        {
+            bool result = false;
+            XmlElement assertion;
+
+            if (TryImportWsspAssertion(assertions, LayoutName, out assertion))
+            {
+                SecurityHeaderLayout layout;
+                Collection<Collection<XmlElement>> alternatives;
+
+                if (TryGetNestedPolicyAlternatives(importer, assertion, out alternatives))
+                {
+                    foreach (Collection<XmlElement> alternative in alternatives)
+                    {
+                        if (TryImportLayoutAssertion(alternative, out layout)
+                            && alternative.Count == 0)
+                        {
+                            binding.SecurityHeaderLayout = layout;
+                            result = true;
+                            break;
+                        }
+                    }
+                }
+            }
+            else
+            {
+                binding.SecurityHeaderLayout = SecurityHeaderLayout.Lax;
+                result = true;
+            }
+
+            return result;
+        }
+
+        public virtual XmlElement CreateLayoutAssertion(SecurityHeaderLayout layout)
+        {
+            switch (layout)
+            {
+                default:
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("layout"));
+                case SecurityHeaderLayout.Lax:
+                    return CreateWsspAssertion(LaxName);
+                case SecurityHeaderLayout.LaxTimestampFirst:
+                    return CreateWsspAssertion(LaxTsFirstName);
+                case SecurityHeaderLayout.LaxTimestampLast:
+                    return CreateWsspAssertion(LaxTsLastName);
+                case SecurityHeaderLayout.Strict:
+                    return CreateWsspAssertion(StrictName);
+            }
+        }
+
+        public virtual bool TryImportLayoutAssertion(ICollection<XmlElement> assertions, out SecurityHeaderLayout layout)
+        {
+            bool result = true;
+            layout = SecurityHeaderLayout.Lax;
+
+            if (TryImportWsspAssertion(assertions, LaxName))
+            {
+                layout = SecurityHeaderLayout.Lax;
+            }
+            else if (TryImportWsspAssertion(assertions, LaxTsFirstName))
+            {
+                layout = SecurityHeaderLayout.LaxTimestampFirst;
+            }
+            else if (TryImportWsspAssertion(assertions, LaxTsLastName))
+            {
+                layout = SecurityHeaderLayout.LaxTimestampLast;
+            }
+            else if (TryImportWsspAssertion(assertions, StrictName))
+            {
+                layout = SecurityHeaderLayout.Strict;
+            }
+            else
+            {
+                result = false;
+            }
+
+            return result;
+        }
+
+        public virtual XmlElement CreateWsspAlgorithmSuiteAssertion(MetadataExporter exporter, SecurityAlgorithmSuite suite)
+        {
+            XmlElement result = CreateWsspAssertion(AlgorithmSuiteName);
+            result.AppendChild(
+                CreateWspPolicyWrapper(
+                    exporter,
+                    CreateAlgorithmSuiteAssertion(suite)
+            ));
+
+            return result;
+        }
+
+        public virtual bool TryImportWsspAlgorithmSuiteAssertion(MetadataImporter importer, ICollection<XmlElement> assertions, SecurityBindingElement binding)
+        {
+            SecurityAlgorithmSuite suite = null;
+            XmlElement assertion;
+            Collection<Collection<XmlElement>> alternatives;
+
+            if (TryImportWsspAssertion(assertions, AlgorithmSuiteName, out assertion)
+                && TryGetNestedPolicyAlternatives(importer, assertion, out alternatives))
+            {
+                foreach (Collection<XmlElement> alternative in alternatives)
+                {
+                    if (TryImportAlgorithmSuiteAssertion(alternative, out suite)
+                        && alternative.Count == 0)
+                    {
+                        binding.DefaultAlgorithmSuite = suite;
+                        break;
+                    }
+                    else
+                    {
+                        suite = null;
+                    }
+                }
+            }
+
+            return suite != null;
+        }
+
+        public virtual XmlElement CreateAlgorithmSuiteAssertion(SecurityAlgorithmSuite suite)
+        {
+            if (suite == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("suite");
+            }
+
+            XmlElement result;
+
+            if (suite == SecurityAlgorithmSuite.Basic256)
+                result = CreateWsspAssertion(Basic256Name);
+            else if (suite == SecurityAlgorithmSuite.Basic192)
+                result = CreateWsspAssertion(Basic192Name);
+            else if (suite == SecurityAlgorithmSuite.Basic128)
+                result = CreateWsspAssertion(Basic128Name);
+            else if (suite == SecurityAlgorithmSuite.TripleDes)
+                result = CreateWsspAssertion(TripleDesName);
+            else if (suite == SecurityAlgorithmSuite.Basic256Rsa15)
+                result = CreateWsspAssertion(Basic256Rsa15Name);
+            else if (suite == SecurityAlgorithmSuite.Basic192Rsa15)
+                result = CreateWsspAssertion(Basic192Rsa15Name);
+            else if (suite == SecurityAlgorithmSuite.Basic128Rsa15)
+                result = CreateWsspAssertion(Basic128Rsa15Name);
+            else if (suite == SecurityAlgorithmSuite.TripleDesRsa15)
+                result = CreateWsspAssertion(TripleDesRsa15Name);
+            else if (suite == SecurityAlgorithmSuite.Basic256Sha256)
+                result = CreateWsspAssertion(Basic256Sha256Name);
+            else if (suite == SecurityAlgorithmSuite.Basic192Sha256)
+                result = CreateWsspAssertion(Basic192Sha256Name);
+            else if (suite == SecurityAlgorithmSuite.Basic128Sha256)
+                result = CreateWsspAssertion(Basic128Sha256Name);
+            else if (suite == SecurityAlgorithmSuite.TripleDesSha256)
+                result = CreateWsspAssertion(TripleDesSha256Name);
+            else if (suite == SecurityAlgorithmSuite.Basic256Sha256Rsa15)
+                result = CreateWsspAssertion(Basic256Sha256Rsa15Name);
+            else if (suite == SecurityAlgorithmSuite.Basic192Sha256Rsa15)
+                result = CreateWsspAssertion(Basic192Sha256Rsa15Name);
+            else if (suite == SecurityAlgorithmSuite.Basic128Sha256Rsa15)
+                result = CreateWsspAssertion(Basic128Sha256Rsa15Name);
+            else if (suite == SecurityAlgorithmSuite.TripleDesSha256Rsa15)
+                result = CreateWsspAssertion(TripleDesSha256Rsa15Name);
+            else
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("suite"));
+            }
+
+            return result;
+        }
+
+        public virtual bool TryImportAlgorithmSuiteAssertion(ICollection<XmlElement> assertions, out SecurityAlgorithmSuite suite)
+        {
+            if (TryImportWsspAssertion(assertions, Basic256Name))
+                suite = SecurityAlgorithmSuite.Basic256;
+            else if (TryImportWsspAssertion(assertions, Basic192Name))
+                suite = SecurityAlgorithmSuite.Basic192;
+            else if (TryImportWsspAssertion(assertions, Basic128Name))
+                suite = SecurityAlgorithmSuite.Basic128;
+            else if (TryImportWsspAssertion(assertions, TripleDesName))
+                suite = SecurityAlgorithmSuite.TripleDes;
+            else if (TryImportWsspAssertion(assertions, Basic256Rsa15Name))
+                suite = SecurityAlgorithmSuite.Basic256Rsa15;
+            else if (TryImportWsspAssertion(assertions, Basic192Rsa15Name))
+                suite = SecurityAlgorithmSuite.Basic192Rsa15;
+            else if (TryImportWsspAssertion(assertions, Basic128Rsa15Name))
+                suite = SecurityAlgorithmSuite.Basic128Rsa15;
+            else if (TryImportWsspAssertion(assertions, TripleDesRsa15Name))
+                suite = SecurityAlgorithmSuite.TripleDesRsa15;
+            else if (TryImportWsspAssertion(assertions, Basic256Sha256Name))
+                suite = SecurityAlgorithmSuite.Basic256Sha256;
+            else if (TryImportWsspAssertion(assertions, Basic192Sha256Name))
+                suite = SecurityAlgorithmSuite.Basic192Sha256;
+            else if (TryImportWsspAssertion(assertions, Basic128Sha256Name))
+                suite = SecurityAlgorithmSuite.Basic128Sha256;
+            else if (TryImportWsspAssertion(assertions, TripleDesSha256Name))
+                suite = SecurityAlgorithmSuite.TripleDesSha256;
+            else if (TryImportWsspAssertion(assertions, Basic256Sha256Rsa15Name))
+                suite = SecurityAlgorithmSuite.Basic256Sha256Rsa15;
+            else if (TryImportWsspAssertion(assertions, Basic192Sha256Rsa15Name))
+                suite = SecurityAlgorithmSuite.Basic192Sha256Rsa15;
+            else if (TryImportWsspAssertion(assertions, Basic128Sha256Rsa15Name))
+                suite = SecurityAlgorithmSuite.Basic128Sha256Rsa15;
+            else if (TryImportWsspAssertion(assertions, TripleDesSha256Rsa15Name))
+                suite = SecurityAlgorithmSuite.TripleDesSha256Rsa15;
+            else
+                suite = null;
+
+            return suite != null;
+        }
+
+        public virtual XmlElement CreateWsspProtectionTokenAssertion(MetadataExporter exporter, SecurityTokenParameters parameters)
+        {
+            XmlElement result = CreateWsspAssertion(ProtectionTokenName);
+
+            result.AppendChild(
+                CreateWspPolicyWrapper(
+                    exporter,
+                    CreateTokenAssertion(exporter, parameters)
+            ));
+            _protectionTokenHasAsymmetricKey = parameters.HasAsymmetricKey;
+
+            return result;
+        }
+
+        public virtual bool TryImportWsspProtectionTokenAssertion(MetadataImporter importer, PolicyConversionContext policyContext, ICollection<XmlElement> assertions, SymmetricSecurityBindingElement binding)
+        {
+            bool result = false;
+
+            XmlElement assertion;
+            Collection<Collection<XmlElement>> alternatives;
+            if (TryImportWsspAssertion(assertions, ProtectionTokenName, out assertion)
+                && TryGetNestedPolicyAlternatives(importer, assertion, out alternatives))
+            {
+                foreach (Collection<XmlElement> alternative in alternatives)
+                {
+                    SecurityTokenParameters tokenParameters;
+                    bool isOptional;
+                    if (TryImportTokenAssertion(importer, policyContext, alternative, out tokenParameters, out isOptional)
+                        && alternative.Count == 0)
+                    {
+                        result = true;
+                        binding.ProtectionTokenParameters = tokenParameters;
+                        break;
+                    }
+                }
+            }
+
+            return result;
+        }
+
+        public virtual bool TryImportWsspInitiatorTokenAssertion(MetadataImporter importer, PolicyConversionContext policyContext, ICollection<XmlElement> assertions, AsymmetricSecurityBindingElement binding)
+        {
+            bool result = false;
+
+            XmlElement assertion;
+            Collection<Collection<XmlElement>> alternatives;
+            if (TryImportWsspAssertion(assertions, InitiatorTokenName, out assertion)
+                && TryGetNestedPolicyAlternatives(importer, assertion, out alternatives))
+            {
+                foreach (Collection<XmlElement> alternative in alternatives)
+                {
+                    SecurityTokenParameters tokenParameters;
+                    bool isOptional;
+                    if (TryImportTokenAssertion(importer, policyContext, alternative, out tokenParameters, out isOptional)
+                        && alternative.Count == 0)
+                    {
+                        result = true;
+                        binding.InitiatorTokenParameters = tokenParameters;
+                        break;
+                    }
+                }
+            }
+
+            return result;
+        }
+
+        public virtual bool TryImportWsspRecipientTokenAssertion(MetadataImporter importer, PolicyConversionContext policyContext, ICollection<XmlElement> assertions, AsymmetricSecurityBindingElement binding)
+        {
+            bool result = false;
+
+            XmlElement assertion;
+            Collection<Collection<XmlElement>> alternatives;
+            if (TryImportWsspAssertion(assertions, RecipientTokenName, out assertion)
+                && TryGetNestedPolicyAlternatives(importer, assertion, out alternatives))
+            {
+                foreach (Collection<XmlElement> alternative in alternatives)
+                {
+                    SecurityTokenParameters tokenParameters;
+                    bool isOptional;
+                    if (TryImportTokenAssertion(importer, policyContext, alternative, out tokenParameters, out isOptional)
+                        && alternative.Count == 0)
+                    {
+                        result = true;
+                        binding.RecipientTokenParameters = tokenParameters;
+                        break;
+                    }
+                }
+            }
+
+            return result;
+        }
+
+        public virtual XmlElement CreateWsspInitiatorTokenAssertion(MetadataExporter exporter, SecurityTokenParameters parameters)
+        {
+            XmlElement result = CreateWsspAssertion(InitiatorTokenName);
+
+            result.AppendChild(
+                CreateWspPolicyWrapper(
+                    exporter,
+                    CreateTokenAssertion(exporter, parameters)
+            ));
+
+            return result;
+        }
+
+        public virtual XmlElement CreateWsspRecipientTokenAssertion(MetadataExporter exporter, SecurityTokenParameters parameters)
+        {
+            XmlElement result = CreateWsspAssertion(RecipientTokenName);
+
+            result.AppendChild(
+                CreateWspPolicyWrapper(
+                    exporter,
+                    CreateTokenAssertion(exporter, parameters)
+            ));
+
+            return result;
+        }
+
+        public virtual XmlElement CreateWsspTransportTokenAssertion(MetadataExporter exporter, XmlElement transportTokenAssertion)
+        {
+            if (transportTokenAssertion == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("transportTokenAssertion");
+            }
+
+            XmlElement result = CreateWsspAssertion(TransportTokenName);
+
+            result.AppendChild(
+                CreateWspPolicyWrapper(
+                    exporter,
+                    (XmlElement)(doc.ImportNode(transportTokenAssertion, true))
+            ));
+
+            return result;
+        }
+
+        public virtual bool TryImportWsspTransportTokenAssertion(MetadataImporter importer, ICollection<XmlElement> assertions, out XmlElement transportBindingAssertion)
+        {
+            transportBindingAssertion = null;
+
+            XmlElement assertion;
+            Collection<Collection<XmlElement>> alternatives;
+            if (TryImportWsspAssertion(assertions, TransportTokenName, out assertion)
+                && TryGetNestedPolicyAlternatives(importer, assertion, out alternatives)
+                && alternatives.Count == 1
+                && alternatives[0].Count == 1)
+            {
+                // we cannot process choices of transport tokens due to the current contract between 
+                // security and transport binding element converters
+                transportBindingAssertion = alternatives[0][0];
+            }
+
+            return transportBindingAssertion != null;
+        }
+
+        public virtual XmlElement CreateTokenAssertion(MetadataExporter exporter, SecurityTokenParameters parameters)
+        {
+            return CreateTokenAssertion(exporter, parameters, false);
+        }
+
+        public virtual XmlElement CreateTokenAssertion(MetadataExporter exporter, SecurityTokenParameters parameters, bool isOptional)
+        {
+            if (parameters == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("parameters");
+            }
+
+            XmlElement result;
+
+            if (parameters is KerberosSecurityTokenParameters)
+            {
+                result = CreateWsspKerberosTokenAssertion(exporter, (KerberosSecurityTokenParameters)parameters);
+            }
+            else if (parameters is X509SecurityTokenParameters)
+            {
+                result = CreateWsspX509TokenAssertion(exporter, (X509SecurityTokenParameters)parameters);
+            }
+            else if (parameters is UserNameSecurityTokenParameters)
+            {
+                result = CreateWsspUsernameTokenAssertion(exporter, (UserNameSecurityTokenParameters)parameters);
+            }
+            else if (parameters is IssuedSecurityTokenParameters)
+            {
+                result = CreateWsspIssuedTokenAssertion(exporter, (IssuedSecurityTokenParameters)parameters);
+            }
+            else if (parameters is SspiSecurityTokenParameters)
+            {
+                result = CreateWsspSpnegoContextTokenAssertion(exporter, (SspiSecurityTokenParameters)parameters);
+            }
+            else if (parameters is SslSecurityTokenParameters)
+            {
+                result = CreateMsspSslContextTokenAssertion(exporter, (SslSecurityTokenParameters)parameters);
+            }
+            else if (parameters is SecureConversationSecurityTokenParameters)
+            {
+                result = CreateWsspSecureConversationTokenAssertion(exporter, (SecureConversationSecurityTokenParameters)parameters);
+            }
+            else if (parameters is RsaSecurityTokenParameters)
+            {
+                result = CreateWsspRsaTokenAssertion((RsaSecurityTokenParameters)parameters);
+            }
+            else
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("parameters"));
+            }
+
+            if (result != null && isOptional)
+            {
+                result.SetAttribute(OptionalName, exporter.PolicyVersion.Namespace, TrueName);
+            }
+
+            return result;
+        }
+
+        public virtual bool TryImportTokenAssertion(MetadataImporter importer, PolicyConversionContext policyContext, Collection<XmlElement> assertions, out SecurityTokenParameters parameters, out bool isOptional)
+        {
+            parameters = null;
+            isOptional = false;
+
+            if (assertions.Count >= 1)
+            {
+                XmlElement tokenAssertion = assertions[0];
+                if (TryImportWsspKerberosTokenAssertion(importer, tokenAssertion, out parameters)
+                    || TryImportWsspX509TokenAssertion(importer, tokenAssertion, out parameters)
+                    || TryImportWsspUsernameTokenAssertion(importer, tokenAssertion, out parameters)
+                    || TryImportWsspIssuedTokenAssertion(importer, policyContext, tokenAssertion, out parameters)
+                    || TryImportWsspSpnegoContextTokenAssertion(importer, tokenAssertion, out parameters)
+                    || TryImportMsspSslContextTokenAssertion(importer, tokenAssertion, out parameters)
+                    || TryImportWsspSecureConversationTokenAssertion(importer, tokenAssertion, out parameters)
+                    || TryImportWsspRsaTokenAssertion(importer, tokenAssertion, out parameters))
+                {
+                    string optionalAttribute = tokenAssertion.GetAttribute(OptionalName, WspNamespace);
+
+                    if (String.IsNullOrEmpty(optionalAttribute))
+                    {
+                        optionalAttribute = tokenAssertion.GetAttribute(OptionalName, Wsp15Namespace);
+                    }
+
+                    try
+                    {
+                        isOptional = XmlUtil.IsTrue(optionalAttribute);
+                    }
+                    catch ( Exception e )
+                    {
+                        if (Fx.IsFatal(e))
+                            throw;
+                        if (e is NullReferenceException)
+                            throw;
+
+                        importer.Errors.Add(new MetadataConversionError(SR.GetString(SR.UnsupportedBooleanAttribute, OptionalName, e.Message), false));
+                        return false;
+                    }
+
+                    assertions.RemoveAt(0);
+                }
+            }
+
+            return (parameters != null);
+        }
+        
+        public virtual void SetIncludeTokenValue(XmlElement tokenAssertion, SecurityTokenInclusionMode inclusionMode)
+        {
+            switch (inclusionMode)
+            {
+                default:
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("inclusionMode"));
+                case SecurityTokenInclusionMode.AlwaysToInitiator:
+                    tokenAssertion.SetAttribute(IncludeTokenName, this.WsspNamespaceUri, AlwaysToInitiatorUri);
+                    break;
+                case SecurityTokenInclusionMode.AlwaysToRecipient:
+                    tokenAssertion.SetAttribute(IncludeTokenName, this.WsspNamespaceUri, AlwaysToRecipientUri);
+                    break;
+                case SecurityTokenInclusionMode.Never:
+                    tokenAssertion.SetAttribute(IncludeTokenName, this.WsspNamespaceUri, NeverUri);
+                    break;
+                case SecurityTokenInclusionMode.Once:
+                    tokenAssertion.SetAttribute(IncludeTokenName, this.WsspNamespaceUri, OnceUri);
+                    break;
+            }
+        }
+
+        public virtual bool TryGetIncludeTokenValue(XmlElement assertion, out SecurityTokenInclusionMode mode)
+        {
+            string includeTokenUri = assertion.GetAttribute(IncludeTokenName, this.WsspNamespaceUri);
+
+            if (includeTokenUri == AlwaysToInitiatorUri)
+            {
+                mode = SecurityTokenInclusionMode.AlwaysToInitiator;
+                return true;
+            }
+            else if (includeTokenUri == AlwaysToRecipientUri)
+            {
+                mode = SecurityTokenInclusionMode.AlwaysToRecipient;
+                return true;
+            }
+            else if (includeTokenUri == NeverUri)
+            {
+                mode = SecurityTokenInclusionMode.Never;
+                return true;
+            }
+            else if (includeTokenUri == OnceUri)
+            {
+                mode = SecurityTokenInclusionMode.Once;
+                return true;
+            }
+            else
+            {
+                mode = SecurityTokenInclusionMode.Never;
+                return false;
+            }
+        }
+
+        public virtual XmlElement CreateWsspRequireDerivedKeysAssertion(bool requireDerivedKeys)
+        {
+            if (requireDerivedKeys)
+            {
+                return CreateWsspAssertion(RequireDerivedKeysName);
+            }
+            else
+            {
+                return null;
+            }
+        }
+
+        public virtual bool TryImportWsspRequireDerivedKeysAssertion(ICollection<XmlElement> assertions, SecurityTokenParameters parameters)
+        {
+            parameters.RequireDerivedKeys = TryImportWsspAssertion(assertions, RequireDerivedKeysName);
+            return true;
+        }
+
+        public virtual XmlElement CreateWsspKerberosTokenAssertion(MetadataExporter exporter, KerberosSecurityTokenParameters parameters)
+        {
+            XmlElement result = CreateWsspAssertion(KerberosTokenName);
+            SetIncludeTokenValue(result, parameters.InclusionMode);
+            result.AppendChild(
+                CreateWspPolicyWrapper(
+                    exporter,
+                    CreateWsspRequireDerivedKeysAssertion(parameters.RequireDerivedKeys),
+                    CreateWsspAssertion(WssGssKerberosV5ApReqToken11Name)
+            ));
+            return result;
+        }
+
+        public virtual bool TryImportWsspKerberosTokenAssertion(MetadataImporter importer, XmlElement assertion, out SecurityTokenParameters parameters)
+        {
+            parameters = null;
+
+            SecurityTokenInclusionMode inclusionMode;
+            Collection<Collection<XmlElement>> alternatives;
+
+            if (IsWsspAssertion(assertion, KerberosTokenName)
+                && TryGetIncludeTokenValue(assertion, out inclusionMode))
+            {
+                if (TryGetNestedPolicyAlternatives(importer, assertion, out alternatives))
+                {
+                    foreach (Collection<XmlElement> alternative in alternatives)
+                    {
+                        parameters = new KerberosSecurityTokenParameters();
+                        if (TryImportWsspRequireDerivedKeysAssertion(alternative, parameters)
+                            && TryImportWsspAssertion(alternative, WssGssKerberosV5ApReqToken11Name, true)
+                            && alternative.Count == 0)
+                        {
+                            parameters.InclusionMode = inclusionMode;
+                            break;
+                        }
+                        else
+                        {
+                            parameters = null;
+                        }
+                    }
+                }
+                else
+                {
+                    parameters = new KerberosSecurityTokenParameters();
+                    parameters.RequireDerivedKeys = false;
+                    parameters.InclusionMode = inclusionMode;
+                }
+            }
+
+            return parameters != null;
+        }
+
+        public virtual XmlElement CreateX509ReferenceStyleAssertion(X509KeyIdentifierClauseType referenceStyle)
+        {
+            switch (referenceStyle)
+            {
+                default:
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("referenceStyle"));
+                case X509KeyIdentifierClauseType.IssuerSerial:
+                    _mustSupportRefIssuerSerialName = true;
+                    return CreateWsspAssertion(RequireIssuerSerialReferenceName);
+                case X509KeyIdentifierClauseType.SubjectKeyIdentifier:
+                    _mustSupportRefKeyIdentifierName = true;
+                    return CreateWsspAssertion(RequireKeyIdentifierReferenceName);
+                case X509KeyIdentifierClauseType.Thumbprint:
+                    _mustSupportRefThumbprintName = true;
+                    return CreateWsspAssertion(RequireThumbprintReferenceName);
+                case X509KeyIdentifierClauseType.Any:
+                    _mustSupportRefIssuerSerialName = true;
+                    _mustSupportRefKeyIdentifierName = true;
+                    _mustSupportRefThumbprintName = true;
+                    return null;
+            }
+        }
+
+        public virtual bool TryImportX509ReferenceStyleAssertion(ICollection<XmlElement> assertions, X509SecurityTokenParameters parameters)
+        {
+            if (TryImportWsspAssertion(assertions, RequireIssuerSerialReferenceName))
+            {
+                parameters.X509ReferenceStyle = X509KeyIdentifierClauseType.IssuerSerial;
+            }
+            else if (TryImportWsspAssertion(assertions, RequireKeyIdentifierReferenceName))
+            {
+                parameters.X509ReferenceStyle = X509KeyIdentifierClauseType.SubjectKeyIdentifier;
+            }
+            else if (TryImportWsspAssertion(assertions, RequireThumbprintReferenceName))
+            {
+                parameters.X509ReferenceStyle = X509KeyIdentifierClauseType.Thumbprint;
+            }
+
+            return true;
+        }
+
+        public virtual XmlElement CreateWsspX509TokenAssertion(MetadataExporter exporter, X509SecurityTokenParameters parameters)
+        {
+            XmlElement result = CreateWsspAssertion(X509TokenName);
+            SetIncludeTokenValue(result, parameters.InclusionMode);
+            result.AppendChild(
+                CreateWspPolicyWrapper(
+                    exporter,
+                    CreateWsspRequireDerivedKeysAssertion(parameters.RequireDerivedKeys),
+                    CreateX509ReferenceStyleAssertion(parameters.X509ReferenceStyle),
+                    CreateWsspAssertion(WssX509V3Token10Name)
+            ));
+            return result;
+        }
+
+        public virtual bool TryImportWsspX509TokenAssertion(MetadataImporter importer, XmlElement assertion, out SecurityTokenParameters parameters)
+        {
+            parameters = null;
+
+            SecurityTokenInclusionMode inclusionMode;
+            Collection<Collection<XmlElement>> alternatives;
+
+            if (IsWsspAssertion(assertion, X509TokenName)
+                && TryGetIncludeTokenValue(assertion, out inclusionMode))
+            {
+                if (TryGetNestedPolicyAlternatives(importer, assertion, out alternatives))
+                {
+                    foreach (Collection<XmlElement> alternative in alternatives)
+                    {
+                        X509SecurityTokenParameters x509 = new X509SecurityTokenParameters();
+                        parameters = x509;
+                        if (TryImportWsspRequireDerivedKeysAssertion(alternative, x509)
+                            && TryImportX509ReferenceStyleAssertion(alternative, x509)
+                            && TryImportWsspAssertion(alternative, WssX509V3Token10Name, true)
+                            && alternative.Count == 0)
+                        {
+                            parameters.InclusionMode = inclusionMode;
+                            break;
+                        }
+                        else
+                        {
+                            parameters = null;
+                        }
+                    }
+                }
+                else
+                {
+                    parameters = new X509SecurityTokenParameters();
+                    parameters.RequireDerivedKeys = false;
+                    parameters.InclusionMode = inclusionMode;
+                }
+            }
+
+            return parameters != null;
+        }
+
+        public virtual XmlElement CreateWsspUsernameTokenAssertion(MetadataExporter exporter, UserNameSecurityTokenParameters parameters)
+        {
+            XmlElement result = CreateWsspAssertion(UsernameTokenName);
+            SetIncludeTokenValue(result, parameters.InclusionMode);
+            result.AppendChild(
+                CreateWspPolicyWrapper(
+                    exporter,
+                    CreateWsspAssertion(WssUsernameToken10Name)
+            ));
+            return result;
+        }
+
+        public virtual bool TryImportWsspUsernameTokenAssertion(MetadataImporter importer, XmlElement assertion, out SecurityTokenParameters parameters)
+        {
+            parameters = null;
+
+            SecurityTokenInclusionMode inclusionMode;
+            Collection<Collection<XmlElement>> alternatives;
+
+            if (IsWsspAssertion(assertion, UsernameTokenName)
+                && TryGetIncludeTokenValue(assertion, out inclusionMode))
+            {
+                if (TryGetNestedPolicyAlternatives(importer, assertion, out alternatives))
+                {
+                    foreach (Collection<XmlElement> alternative in alternatives)
+                    {
+                        if (TryImportWsspAssertion(alternative, WssUsernameToken10Name)
+                            && alternative.Count == 0)
+                        {
+                            parameters = new UserNameSecurityTokenParameters();
+                            parameters.InclusionMode = inclusionMode;
+                            break;
+                        }
+                    }
+                }
+                else
+                {
+                    parameters = new UserNameSecurityTokenParameters();
+                    parameters.InclusionMode = inclusionMode;
+                }
+            }
+
+            return parameters != null;
+        }
+
+        public virtual XmlElement CreateWsspRsaTokenAssertion(RsaSecurityTokenParameters parameters)
+        {
+            XmlElement result = CreateMsspAssertion(RsaTokenName);
+            SetIncludeTokenValue(result, parameters.InclusionMode);
+            return result;
+        }
+
+        public virtual bool TryImportWsspRsaTokenAssertion(MetadataImporter importer, XmlElement assertion, out SecurityTokenParameters parameters)
+        {
+            parameters = null;
+
+            SecurityTokenInclusionMode inclusionMode;
+            Collection<Collection<XmlElement>> alternatives;
+
+            if (IsMsspAssertion(assertion, RsaTokenName)
+                && TryGetIncludeTokenValue(assertion, out inclusionMode)
+                && TryGetNestedPolicyAlternatives(importer, assertion, out alternatives) == false)
+            {
+                parameters = new RsaSecurityTokenParameters();
+                parameters.InclusionMode = inclusionMode;
+            }
+
+            return parameters != null;
+        }
+
+        public virtual XmlElement CreateReferenceStyleAssertion(SecurityTokenReferenceStyle referenceStyle)
+        {
+            switch (referenceStyle)
+            {
+                default:
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("referenceStyle"));
+                case SecurityTokenReferenceStyle.External:
+                    return CreateWsspAssertion(RequireExternalReferenceName);
+                case SecurityTokenReferenceStyle.Internal:
+                    return CreateWsspAssertion(RequireInternalReferenceName);
+            }
+        }
+
+        public virtual bool TryImportReferenceStyleAssertion(ICollection<XmlElement> assertions, IssuedSecurityTokenParameters parameters)
+        {
+            if (TryImportWsspAssertion(assertions, RequireExternalReferenceName))
+            {
+                parameters.ReferenceStyle = SecurityTokenReferenceStyle.External;
+            }
+            else if (TryImportWsspAssertion(assertions, RequireInternalReferenceName))
+            {
+                parameters.ReferenceStyle = SecurityTokenReferenceStyle.Internal;
+            }
+
+            return true;
+        }
+
+        public virtual XmlElement CreateWsspIssuerElement(EndpointAddress issuerAddress, EndpointAddress issuerMetadataAddress)
+        {
+            XmlElement result;
+            if (issuerAddress == null && issuerMetadataAddress == null)
+            {
+                result = null;
+            }
+            else
+            {
+                EndpointAddress addressToSerialize;
+                addressToSerialize = issuerAddress == null ? EndpointAddress.AnonymousAddress : issuerAddress;
+
+                MemoryStream stream;
+                XmlWriter writer;
+
+                if (issuerMetadataAddress != null)
+                {
+                    MetadataSet metadataSet = new MetadataSet();
+                    metadataSet.MetadataSections.Add(new MetadataSection(null, null, new MetadataReference(issuerMetadataAddress, AddressingVersion.WSAddressing10)));
+
+                    stream = new MemoryStream();
+                    writer = new XmlTextWriter(stream, System.Text.Encoding.UTF8);
+                    metadataSet.WriteTo(XmlDictionaryWriter.CreateDictionaryWriter(writer));
+                    writer.Flush();
+                    stream.Seek(0, SeekOrigin.Begin);
+
+                    addressToSerialize = new EndpointAddress(
+                        addressToSerialize.Uri,
+                        addressToSerialize.Identity,
+                        addressToSerialize.Headers,
+                        XmlDictionaryReader.CreateDictionaryReader(XmlReader.Create(stream)),
+                        addressToSerialize.GetReaderAtExtensions());
+                }
+
+                stream = new MemoryStream();
+                writer = new XmlTextWriter(stream, System.Text.Encoding.UTF8);
+                writer.WriteStartElement(IssuerName, this.WsspNamespaceUri);
+                addressToSerialize.WriteContentsTo(AddressingVersion.WSAddressing10, writer);
+                writer.WriteEndElement();
+                writer.Flush();
+                stream.Seek(0, SeekOrigin.Begin);
+                result = (XmlElement)doc.ReadNode(new XmlTextReader(stream) { DtdProcessing = DtdProcessing.Prohibit });
+            }
+            return result;
+        }
+
+        public virtual bool TryGetIssuer(XmlElement assertion, out EndpointAddress issuer, out EndpointAddress issuerMetadata)
+        {
+            bool result = true;
+            issuer = null;
+            issuerMetadata = null;
+
+            foreach (XmlNode node in assertion.ChildNodes)
+            {
+                if (node is XmlElement && IsWsspAssertion((XmlElement)node, IssuerName))
+                {
+                    try
+                    {
+                        issuer = EndpointAddress.ReadFrom(XmlDictionaryReader.CreateDictionaryReader(new XmlNodeReader(node)));
+                        XmlDictionaryReader metadataReader = issuer.GetReaderAtMetadata();
+                        if (metadataReader != null)
+                        {
+                            while (metadataReader.MoveToContent() == XmlNodeType.Element)
+                            {
+                                if (metadataReader.LocalName == MetadataStrings.MetadataExchangeStrings.Metadata
+                                    && metadataReader.NamespaceURI == MetadataStrings.MetadataExchangeStrings.Namespace)
+                                {
+                                    MetadataSet metadataSet = MetadataSet.ReadFrom(metadataReader);
+                                    foreach (MetadataSection section in metadataSet.MetadataSections)
+                                    {
+                                        if (section.Metadata is MetadataReference)
+                                        {
+                                            issuerMetadata = ((MetadataReference)section.Metadata).Address;
+                                        }
+                                    }
+
+                                    break;
+                                }
+                                else
+                                {
+                                    metadataReader.Skip();
+                                }
+                            }
+                        }
+                    }
+                    catch (Exception e)
+                    {
+                        if (Fx.IsFatal(e))
+                            throw;
+                        if (e is NullReferenceException)
+                            throw;
+                        result = false;
+                    }
+                    break;
+                }
+            }
+
+            return result;
+        }
+
+        public virtual XmlElement CreateWsspIssuedTokenAssertion(MetadataExporter exporter, IssuedSecurityTokenParameters parameters)
+        {
+            XmlElement result = CreateWsspAssertion(IssuedTokenName);
+            SetIncludeTokenValue(result, parameters.InclusionMode);
+            XmlElement issuerAssertion = CreateWsspIssuerElement(parameters.IssuerAddress, parameters.IssuerMetadataAddress);
+            if (issuerAssertion != null)
+            {
+                result.AppendChild(issuerAssertion);
+            }
+            XmlElement tokenTemplate = CreateWsspAssertion(RequestSecurityTokenTemplateName);
+            TrustDriver driver = this.TrustDriver;
+            foreach (XmlElement p in parameters.CreateRequestParameters(driver))
+            {
+                tokenTemplate.AppendChild(doc.ImportNode(p, true));
+            }
+            result.AppendChild(tokenTemplate);
+            result.AppendChild(
+                CreateWspPolicyWrapper(
+                    exporter,
+                    CreateWsspRequireDerivedKeysAssertion(parameters.RequireDerivedKeys),
+                    CreateReferenceStyleAssertion(parameters.ReferenceStyle)
+            ));
+            return result;
+        }
+
+        public virtual bool TryGetRequestSecurityTokenTemplate(XmlElement assertion, out Collection<XmlElement> requestParameters)
+        {
+            requestParameters = null;
+
+            foreach (XmlNode node in assertion.ChildNodes)
+            {
+                if (node is XmlElement && IsWsspAssertion((XmlElement)node, RequestSecurityTokenTemplateName))
+                {
+                    requestParameters = new Collection<XmlElement>();
+                    foreach (XmlNode p in node.ChildNodes)
+                    {
+                        if (p is XmlElement)
+                        {
+                            requestParameters.Add((XmlElement)p);
+                        }
+                    }
+                }
+            }
+
+            return requestParameters != null;
+        }
+
+        public virtual bool TryImportWsspIssuedTokenAssertion(MetadataImporter importer, PolicyConversionContext policyContext, XmlElement assertion, out SecurityTokenParameters parameters)
+        {
+            parameters = null;
+
+            SecurityTokenInclusionMode inclusionMode;
+            Collection<Collection<XmlElement>> alternatives;
+            EndpointAddress issuer;
+            EndpointAddress issuerMetadata;
+            Collection<XmlElement> requestSecurityTokenTemplate;
+
+            if (IsWsspAssertion(assertion, IssuedTokenName)
+                && TryGetIncludeTokenValue(assertion, out inclusionMode)
+                && TryGetIssuer(assertion, out issuer, out issuerMetadata)
+                && TryGetRequestSecurityTokenTemplate(assertion, out requestSecurityTokenTemplate))
+            {
+                if (TryGetNestedPolicyAlternatives(importer, assertion, out alternatives))
+                {
+                    foreach (Collection<XmlElement> alternative in alternatives)
+                    {
+                        IssuedSecurityTokenParameters issued = new IssuedSecurityTokenParameters();
+                        parameters = issued;
+                        if (TryImportWsspRequireDerivedKeysAssertion(alternative, issued)
+                            && TryImportReferenceStyleAssertion(alternative, issued)
+                            && alternative.Count == 0)
+                        {
+                            issued.InclusionMode = inclusionMode;
+                            issued.IssuerAddress = issuer;
+                            issued.IssuerMetadataAddress = issuerMetadata;
+                            issued.SetRequestParameters(requestSecurityTokenTemplate, this.TrustDriver);
+
+                            TokenIssuerPolicyResolver policyResolver = new TokenIssuerPolicyResolver(this.TrustDriver);
+                            policyResolver.ResolveTokenIssuerPolicy(importer, policyContext, issued);
+
+                            break;
+                        }
+                        else
+                        {
+                            parameters = null;
+                        }
+                    }
+                }
+                else
+                {
+                    IssuedSecurityTokenParameters issued = new IssuedSecurityTokenParameters();
+                    parameters = issued;
+                    issued.InclusionMode = inclusionMode;
+                    issued.IssuerAddress = issuer;
+                    issued.IssuerMetadataAddress = issuerMetadata;
+                    issued.SetRequestParameters(requestSecurityTokenTemplate, this.TrustDriver);
+                    issued.RequireDerivedKeys = false;
+                }
+            }
+
+            return parameters != null;
+        }
+
+        public virtual XmlElement CreateWsspMustNotSendCancelAssertion(bool requireCancel)
+        {
+            if (!requireCancel)
+            {
+                XmlElement result = CreateWsspAssertion(MustNotSendCancelName);
+                return result;
+            }
+            else
+            {
+                return null;
+            }
+        }
+
+        public virtual bool TryImportWsspMustNotSendCancelAssertion(ICollection<XmlElement> assertions, out bool requireCancellation)
+        {
+            requireCancellation = !TryImportWsspAssertion(assertions, MustNotSendCancelName);
+            return true;
+        }
+
+        public virtual XmlElement CreateWsspSpnegoContextTokenAssertion(MetadataExporter exporter, SspiSecurityTokenParameters parameters)
+        {
+            XmlElement result = CreateWsspAssertion(SpnegoContextTokenName);
+            SetIncludeTokenValue(result, parameters.InclusionMode);
+            result.AppendChild(
+                CreateWspPolicyWrapper(
+                    exporter,
+                    CreateWsspRequireDerivedKeysAssertion(parameters.RequireDerivedKeys),
+                    CreateWsspMustNotSendCancelAssertion(parameters.RequireCancellation)
+            ));
+            return result;
+        }
+
+        public virtual bool TryImportWsspSpnegoContextTokenAssertion(MetadataImporter importer, XmlElement assertion, out SecurityTokenParameters parameters)
+        {
+            parameters = null;
+
+            SecurityTokenInclusionMode inclusionMode;
+            Collection<Collection<XmlElement>> alternatives;
+
+            if (IsWsspAssertion(assertion, SpnegoContextTokenName)
+                && TryGetIncludeTokenValue(assertion, out inclusionMode))
+            {
+                if (TryGetNestedPolicyAlternatives(importer, assertion, out alternatives))
+                {
+                    foreach (Collection<XmlElement> alternative in alternatives)
+                    {
+                        SspiSecurityTokenParameters sspi = new SspiSecurityTokenParameters();
+                        parameters = sspi;
+                        bool requireCancellation;
+                        if (TryImportWsspRequireDerivedKeysAssertion(alternative, sspi)
+                            && TryImportWsspMustNotSendCancelAssertion(alternative, out requireCancellation)
+                            && alternative.Count == 0)
+                        {
+                            sspi.RequireCancellation = requireCancellation;
+                            sspi.InclusionMode = inclusionMode;
+                            break;
+                        }
+                        else
+                        {
+                            parameters = null;
+                        }
+                    }
+                }
+                else
+                {
+                    parameters = new SspiSecurityTokenParameters();
+                    parameters.RequireDerivedKeys = false;
+                    parameters.InclusionMode = inclusionMode;
+                }
+            }
+
+            return parameters != null;
+        }
+
+        public abstract XmlElement CreateWsspHttpsTokenAssertion(MetadataExporter exporter, HttpsTransportBindingElement httpsBinding);
+
+        public abstract bool TryImportWsspHttpsTokenAssertion(MetadataImporter importer, ICollection<XmlElement> assertions, HttpsTransportBindingElement httpsBinding);
+
+        public virtual bool ContainsWsspHttpsTokenAssertion(ICollection<XmlElement> assertions)
+        {
+            return (PolicyConversionContext.FindAssertion(assertions, HttpsTokenName, this.WsspNamespaceUri, false) != null);
+        }
+
+        public virtual XmlElement CreateMsspRequireClientCertificateAssertion(bool requireClientCertificate)
+        {
+            if (requireClientCertificate)
+            {
+                return CreateMsspAssertion(RequireClientCertificateName);
+            }
+            else
+            {
+                return null;
+            }
+        }
+
+        public virtual bool TryImportMsspRequireClientCertificateAssertion(ICollection<XmlElement> assertions, SslSecurityTokenParameters parameters)
+        {
+            parameters.RequireClientCertificate = TryImportMsspAssertion(assertions, RequireClientCertificateName);
+            return true;
+        }
+
+        public virtual XmlElement CreateMsspSslContextTokenAssertion(MetadataExporter exporter, SslSecurityTokenParameters parameters)
+        {
+            XmlElement result = CreateMsspAssertion(SslContextTokenName);
+            SetIncludeTokenValue(result, parameters.InclusionMode);
+            result.AppendChild(
+                CreateWspPolicyWrapper(
+                    exporter,
+                    CreateWsspRequireDerivedKeysAssertion(parameters.RequireDerivedKeys),
+                    CreateWsspMustNotSendCancelAssertion(parameters.RequireCancellation),
+                    CreateMsspRequireClientCertificateAssertion(parameters.RequireClientCertificate)
+            ));
+            return result;
+        }
+
+        public virtual bool TryImportMsspSslContextTokenAssertion(MetadataImporter importer, XmlElement assertion, out SecurityTokenParameters parameters)
+        {
+            parameters = null;
+
+            SecurityTokenInclusionMode inclusionMode;
+            Collection<Collection<XmlElement>> alternatives;
+
+            if (IsMsspAssertion(assertion, SslContextTokenName)
+                && TryGetIncludeTokenValue(assertion, out inclusionMode))
+            {
+                if (TryGetNestedPolicyAlternatives(importer, assertion, out alternatives))
+                {
+                    foreach (Collection<XmlElement> alternative in alternatives)
+                    {
+                        SslSecurityTokenParameters ssl = new SslSecurityTokenParameters();
+                        parameters = ssl;
+                        bool requireCancellation;
+                        if (TryImportWsspRequireDerivedKeysAssertion(alternative, ssl)
+                            && TryImportWsspMustNotSendCancelAssertion(alternative, out requireCancellation)
+                            && TryImportMsspRequireClientCertificateAssertion(alternative, ssl)
+                            && alternative.Count == 0)
+                        {
+                            ssl.RequireCancellation = requireCancellation;
+                            ssl.InclusionMode = inclusionMode;
+                            break;
+                        }
+                        else
+                        {
+                            parameters = null;
+                        }
+                    }
+                }
+                else
+                {
+                    parameters = new SslSecurityTokenParameters();
+                    parameters.RequireDerivedKeys = false;
+                    parameters.InclusionMode = inclusionMode;
+                }
+            }
+
+            return parameters != null;
+        }
+
+        public virtual XmlElement CreateWsspBootstrapPolicyAssertion(MetadataExporter exporter, SecurityBindingElement bootstrapSecurity)
+        {
+            if (bootstrapSecurity == null)
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("bootstrapBinding");
+
+            WSSecurityPolicy sp = WSSecurityPolicy.GetSecurityPolicyDriver(bootstrapSecurity.MessageSecurityVersion);
+
+            // create complete bootstrap binding
+
+            CustomBinding bootstrapBinding = new CustomBinding(bootstrapSecurity);
+            if (exporter.State.ContainsKey(SecurityPolicyStrings.SecureConversationBootstrapBindingElementsBelowSecurityKey))
+            {
+                BindingElementCollection bindingElementsBelowSecurity = exporter.State[SecurityPolicyStrings.SecureConversationBootstrapBindingElementsBelowSecurityKey] as BindingElementCollection;
+                if (bindingElementsBelowSecurity != null)
+                {
+                    foreach (BindingElement be in bindingElementsBelowSecurity)
+                    {
+                        bootstrapBinding.Elements.Add(be);
+                    }
+                }
+            }
+
+            // generate policy for the "how" of security 
+
+            ServiceEndpoint bootstrapEndpoint = new ServiceEndpoint(NullContract);
+            bootstrapEndpoint.Binding = bootstrapBinding;
+            PolicyConversionContext policyContext = exporter.ExportPolicy(bootstrapEndpoint);
+
+            // generate policy for the "what" of security (protection assertions)
+
+            // hard-coded requirements in V1: sign and encrypt RST and RSTR body
+            ChannelProtectionRequirements bootstrapProtection = new ChannelProtectionRequirements();
+            bootstrapProtection.IncomingEncryptionParts.AddParts(new MessagePartSpecification(true));
+            bootstrapProtection.OutgoingEncryptionParts.AddParts(new MessagePartSpecification(true));
+            bootstrapProtection.IncomingSignatureParts.AddParts(new MessagePartSpecification(true));
+            bootstrapProtection.OutgoingSignatureParts.AddParts(new MessagePartSpecification(true));
+
+            // add boostrap binding protection requirements (e.g. addressing headers)
+            ChannelProtectionRequirements cpr = bootstrapBinding.GetProperty<ChannelProtectionRequirements>(new BindingParameterCollection());
+            if (cpr != null)
+            {
+                bootstrapProtection.Add(cpr);
+            }
+
+            // extract channel-scope protection requirements and union them across request and response
+            MessagePartSpecification encryption = new MessagePartSpecification();
+            encryption.Union(bootstrapProtection.IncomingEncryptionParts.ChannelParts);
+            encryption.Union(bootstrapProtection.OutgoingEncryptionParts.ChannelParts);
+            encryption.MakeReadOnly();
+            MessagePartSpecification signature = new MessagePartSpecification();
+            signature.Union(bootstrapProtection.IncomingSignatureParts.ChannelParts);
+            signature.Union(bootstrapProtection.OutgoingSignatureParts.ChannelParts);
+            signature.MakeReadOnly();
+
+            // create final boostrap policy assertion
+
+            XmlElement nestedPolicy = CreateWspPolicyWrapper(
+                    exporter,
+                    sp.CreateWsspSignedPartsAssertion(signature),
+                    sp.CreateWsspEncryptedPartsAssertion(encryption));
+            foreach (XmlElement e in sp.FilterWsspPolicyAssertions(policyContext.GetBindingAssertions()))
+            {
+                nestedPolicy.AppendChild(e);
+            }
+            XmlElement result = CreateWsspAssertion(BootstrapPolicyName);
+            result.AppendChild(nestedPolicy);
+
+            return result;
+        }
+
+        public virtual ICollection<XmlElement> FilterWsspPolicyAssertions(ICollection<XmlElement> policyAssertions)
+        {
+            Collection<XmlElement> result = new Collection<XmlElement>();
+
+            foreach (XmlElement assertion in policyAssertions)
+                if (IsWsspAssertion(assertion))
+                    result.Add(assertion);
+
+            return result;
+        }
+
+        public virtual bool TryImportWsspBootstrapPolicyAssertion(MetadataImporter importer, ICollection<XmlElement> assertions, SecureConversationSecurityTokenParameters parameters)
+        {
+            bool result = false;
+
+            XmlElement assertion;
+            Collection<Collection<XmlElement>> alternatives;
+
+            if (TryImportWsspAssertion(assertions, BootstrapPolicyName, out assertion)
+                && TryGetNestedPolicyAlternatives(importer, assertion, out alternatives))
+            {
+                BindingElementCollection bindingElements;
+                importer.State[SecurityBindingElementImporter.InSecureConversationBootstrapBindingImportMode] = SecurityBindingElementImporter.InSecureConversationBootstrapBindingImportMode;
+                try
+                {
+                    bindingElements = importer.ImportPolicy(NullServiceEndpoint, alternatives);
+                    if (importer.State.ContainsKey(SecurityBindingElementImporter.SecureConversationBootstrapEncryptionRequirements))
+                    {
+                        MessagePartSpecification encryption = (MessagePartSpecification)importer.State[SecurityBindingElementImporter.SecureConversationBootstrapEncryptionRequirements];
+                        if (encryption.IsBodyIncluded != true)
+                        {
+                            importer.Errors.Add(new MetadataConversionError(SR.GetString(SR.UnsupportedSecureConversationBootstrapProtectionRequirements), false));
+                            bindingElements = null;
+                        }
+                    }
+                    if (importer.State.ContainsKey(SecurityBindingElementImporter.SecureConversationBootstrapSignatureRequirements))
+                    {
+                        MessagePartSpecification signature = (MessagePartSpecification)importer.State[SecurityBindingElementImporter.SecureConversationBootstrapSignatureRequirements];
+                        if (signature.IsBodyIncluded != true)
+                        {
+                            importer.Errors.Add(new MetadataConversionError(SR.GetString(SR.UnsupportedSecureConversationBootstrapProtectionRequirements), false));
+                            bindingElements = null;
+                        }
+                    }
+                }
+                finally
+                {
+                    importer.State.Remove(SecurityBindingElementImporter.InSecureConversationBootstrapBindingImportMode);
+                    if (importer.State.ContainsKey(SecurityBindingElementImporter.SecureConversationBootstrapEncryptionRequirements))
+                        importer.State.Remove(SecurityBindingElementImporter.SecureConversationBootstrapEncryptionRequirements);
+                    if (importer.State.ContainsKey(SecurityBindingElementImporter.SecureConversationBootstrapSignatureRequirements))
+                        importer.State.Remove(SecurityBindingElementImporter.SecureConversationBootstrapSignatureRequirements);
+                }
+                if (bindingElements != null)
+                {
+                    parameters.BootstrapSecurityBindingElement = bindingElements.Find<SecurityBindingElement>();
+                    return true;
+                }
+                else
+                {
+                    parameters.BootstrapSecurityBindingElement = null;
+                    return true; // Consider returning false here.
+                }
+            }
+
+            return result;
+        }
+
+        public virtual XmlElement CreateWsspSecureConversationTokenAssertion(MetadataExporter exporter, SecureConversationSecurityTokenParameters parameters)
+        {
+            XmlElement result = CreateWsspAssertion(SecureConversationTokenName);
+            SetIncludeTokenValue(result, parameters.InclusionMode);
+            result.AppendChild(
+                CreateWspPolicyWrapper(
+                    exporter,
+                    CreateWsspRequireDerivedKeysAssertion(parameters.RequireDerivedKeys),
+                    CreateWsspMustNotSendCancelAssertion(parameters.RequireCancellation),
+                    CreateWsspBootstrapPolicyAssertion(exporter, parameters.BootstrapSecurityBindingElement)
+            ));
+            return result;
+        }
+
+        public virtual bool TryImportWsspSecureConversationTokenAssertion(MetadataImporter importer, XmlElement assertion, out SecurityTokenParameters parameters)
+        {
+            parameters = null;
+
+            SecurityTokenInclusionMode inclusionMode;
+            Collection<Collection<XmlElement>> alternatives;
+
+            if (IsWsspAssertion(assertion, SecureConversationTokenName)
+                && TryGetIncludeTokenValue(assertion, out inclusionMode))
+            {
+                if (TryGetNestedPolicyAlternatives(importer, assertion, out alternatives))
+                {
+                    foreach (Collection<XmlElement> alternative in alternatives)
+                    {
+                        SecureConversationSecurityTokenParameters sc = new SecureConversationSecurityTokenParameters();
+                        parameters = sc;
+                        bool requireCancellation;
+                        if (TryImportWsspRequireDerivedKeysAssertion(alternative, sc)
+                            && TryImportWsspMustNotSendCancelAssertion(alternative, out requireCancellation)
+                            && TryImportWsspBootstrapPolicyAssertion(importer, alternative, sc)
+                            && alternative.Count == 0)
+                        {
+                            sc.RequireCancellation = requireCancellation;
+                            sc.InclusionMode = inclusionMode;
+                            break;
+                        }
+                        else
+                        {
+                            parameters = null;
+                        }
+                    }
+                }
+                else
+                {
+                    parameters = new SecureConversationSecurityTokenParameters();
+                    parameters.InclusionMode = inclusionMode;
+                    parameters.RequireDerivedKeys = false;
+                }
+            }
+
+            return parameters != null;
+        }
+
+        class TokenIssuerPolicyResolver
+        {
+            const string WSIdentityNamespace = @"http://schemas.xmlsoap.org/ws/2005/05/identity";
+            static readonly Uri SelfIssuerUri = new Uri(WSIdentityNamespace + "/issuer/self");
+
+            TrustDriver trustDriver;
+
+            public TokenIssuerPolicyResolver(TrustDriver driver)
+            {
+                this.trustDriver = driver;
+            }
+
+            public void ResolveTokenIssuerPolicy(MetadataImporter importer, PolicyConversionContext policyContext, IssuedSecurityTokenParameters parameters)
+            {
+                if (policyContext == null)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("policyContext");
+                }
+                if (parameters == null)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("parameters");
+                }
+
+                EndpointAddress mexAddress = (parameters.IssuerMetadataAddress != null) ? parameters.IssuerMetadataAddress : parameters.IssuerAddress;
+                if (mexAddress == null || mexAddress.IsAnonymous || mexAddress.Uri.Equals(SelfIssuerUri))
+                {
+                    return;
+                }
+                int maximumRedirections = (int)importer.State[SecurityBindingElementImporter.MaxPolicyRedirectionsKey];
+
+                if (maximumRedirections <= 0)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.GetString(SR.MaximumPolicyRedirectionsExceeded)));
+                }
+                --maximumRedirections;
+
+                //
+                // Try to retrieve the proxy from the importer.State bag so that we can have secure mex
+                // and it fails, then we can create a default one
+                //
+                MetadataExchangeClient policyFetcher = null;
+                if ((importer.State != null) && (importer.State.ContainsKey(MetadataExchangeClient.MetadataExchangeClientKey)))
+                {
+                    policyFetcher = importer.State[MetadataExchangeClient.MetadataExchangeClientKey] as MetadataExchangeClient;
+                }
+
+                if (policyFetcher == null)
+                    policyFetcher = new MetadataExchangeClient(mexAddress);
+
+                ServiceEndpointCollection federationEndpoints = null;
+                MetadataSet metadataSet = null;
+                Exception mexException = null;
+                try
+                {
+                    metadataSet = policyFetcher.GetMetadata(mexAddress);
+                }
+                catch (Exception e)
+                {
+                    if (Fx.IsFatal(e))
+                        throw;
+                    if (e is NullReferenceException)
+                        throw;
+
+                    mexException = e;
+                }
+
+                //
+                // DCR 6729: Try the http get option here if mex failed.
+                //
+                if (metadataSet == null )
+                {
+                    try
+                    {
+                        metadataSet = policyFetcher.GetMetadata(mexAddress.Uri, MetadataExchangeClientMode.HttpGet);
+                    }
+                    catch (Exception e)
+                    {
+                        if (Fx.IsFatal(e))
+                            throw;
+                        if (e is NullReferenceException)
+                            throw;
+
+                        if (mexException == null)
+                            mexException = e;
+                    }
+                }
+
+                if (metadataSet == null)
+                {
+                    //
+                    // we could not retrieve the metadata from the issuer for some reason
+                    //
+                    if (mexException != null)
+                        importer.Errors.Add(new MetadataConversionError(SR.GetString(SR.UnableToObtainIssuerMetadata, mexAddress, mexException), false));
+   
+                    return;
+                }
+                WsdlImporter wsdlImporter;
+                // NOTE: Microsoft, Policy import/export is seperate from WSDL however, this policy importer
+                //      invokes the WsdlImporter. In the event that the current MetadataImporter is a WsdlImporter,
+                //      we should use it's collection of extensions for the import process. Other wise
+                WsdlImporter currentWsdlImporter = importer as WsdlImporter;
+                if (currentWsdlImporter != null)
+                {
+                    wsdlImporter = new WsdlImporter(metadataSet, importer.PolicyImportExtensions, currentWsdlImporter.WsdlImportExtensions);
+                }
+                else
+                {
+                    wsdlImporter = new WsdlImporter(metadataSet, importer.PolicyImportExtensions, null);
+                }
+
+                //
+                // Copy the State from the first importer to the second one so that the state can be passed to the second round wsdl retrieval
+                //
+                if ((importer.State != null) && (importer.State.ContainsKey(MetadataExchangeClient.MetadataExchangeClientKey)))
+                {
+                    wsdlImporter.State.Add(MetadataExchangeClient.MetadataExchangeClientKey, importer.State[MetadataExchangeClient.MetadataExchangeClientKey]);
+                }
+
+                wsdlImporter.State.Add(SecurityBindingElementImporter.MaxPolicyRedirectionsKey, maximumRedirections);
+
+                federationEndpoints = wsdlImporter.ImportAllEndpoints();
+
+                // copy all the import errors into the current metadata importer
+                for (int i = 0; i < wsdlImporter.Errors.Count; ++i)
+                {
+                    MetadataConversionError error = wsdlImporter.Errors[i];
+                    importer.Errors.Add(new MetadataConversionError(SR.GetString(SR.ErrorImportingIssuerMetadata, mexAddress, InsertEllipsisIfTooLong(error.Message)), error.IsWarning));
+                }
+
+                if (federationEndpoints != null)
+                {
+                    AddCompatibleFederationEndpoints(federationEndpoints, parameters);
+                    if (parameters.AlternativeIssuerEndpoints != null && parameters.AlternativeIssuerEndpoints.Count > 0)
+                    {
+                        importer.Errors.Add(new MetadataConversionError(SR.GetString(SR.MultipleIssuerEndpointsFound, mexAddress)));
+                    }
+                }
+            }
+
+            static string InsertEllipsisIfTooLong(string message)
+            {
+                const int MaxLength = 1024;
+                const string Ellipsis = "....";
+
+                if (message != null && message.Length > MaxLength)
+                {
+                    return String.Format(System.Globalization.CultureInfo.InvariantCulture, "{0}{1}{2}",
+                        message.Substring(0, (MaxLength - Ellipsis.Length) / 2),
+                        Ellipsis,
+                        message.Substring(message.Length - (MaxLength - Ellipsis.Length) / 2));
+                }
+                return message;
+            }
+
+            void AddCompatibleFederationEndpoints(ServiceEndpointCollection serviceEndpoints, IssuedSecurityTokenParameters parameters)
+            {
+                // check if an explicit issuer address has been specified. If so,add the endpoint corresponding to that address only. If not add all acceptable endpoints.
+
+                bool isIssuerSpecified = (parameters.IssuerAddress != null && !parameters.IssuerAddress.IsAnonymous);
+                foreach (ServiceEndpoint endpoint in serviceEndpoints)
+                {
+                    TrustDriver trustDriver;
+                    if (!TryGetTrustDriver(endpoint, out trustDriver))
+                    {
+                        // if endpoint does not have trustDriver, assume
+                        // parent trustDriver.
+                        trustDriver = this.trustDriver;
+                    }
+                    bool isFederationContract = false;
+                    ContractDescription contract = endpoint.Contract;
+                    for (int j = 0; j < contract.Operations.Count; ++j)
+                    {
+                        OperationDescription operation = contract.Operations[j];
+                        bool hasIncomingRst = false;
+                        bool hasOutgoingRstr = false;
+                        for (int k = 0; k < operation.Messages.Count; ++k)
+                        {
+                            MessageDescription message = operation.Messages[k];
+                            if (message.Action == trustDriver.RequestSecurityTokenAction.Value && message.Direction == MessageDirection.Input)
+                            {
+                                hasIncomingRst = true;
+                            }
+                            else if ((((trustDriver.StandardsManager.TrustVersion == TrustVersion.WSTrustFeb2005) && (message.Action == trustDriver.RequestSecurityTokenResponseAction.Value)) || 
+                                ((trustDriver.StandardsManager.TrustVersion == TrustVersion.WSTrust13) && (message.Action == trustDriver.RequestSecurityTokenResponseFinalAction.Value))) && 
+                                message.Direction == MessageDirection.Output)
+                            {
+                                hasOutgoingRstr = true;
+                            }
+                        }
+                        if (hasIncomingRst && hasOutgoingRstr)
+                        {
+                            isFederationContract = true;
+                            break;
+                        }
+                    }
+                    if (isFederationContract)
+                    {
+                        // skip if it is not an acceptable endpoint
+                        if (isIssuerSpecified && !parameters.IssuerAddress.Uri.Equals(endpoint.Address.Uri))
+                        {
+                            continue;
+                        }
+
+                        if (parameters.IssuerBinding == null)
+                        {
+                            parameters.IssuerAddress = endpoint.Address;
+                            parameters.IssuerBinding = endpoint.Binding;
+                        }
+                        else
+                        {
+                            IssuedSecurityTokenParameters.AlternativeIssuerEndpoint endpointInfo = new IssuedSecurityTokenParameters.AlternativeIssuerEndpoint();
+                            endpointInfo.IssuerAddress = endpoint.Address;
+                            endpointInfo.IssuerBinding = endpoint.Binding;
+                            parameters.AlternativeIssuerEndpoints.Add(endpointInfo);
+                        }
+                    }
+                }
+            }
+
+            bool TryGetTrustDriver(ServiceEndpoint endpoint, out TrustDriver trustDriver)
+            {
+                SecurityBindingElement sbe = endpoint.Binding.CreateBindingElements().Find<SecurityBindingElement>();
+                trustDriver = null;
+                if (sbe != null)
+                {
+                    MessageSecurityVersion messageSecurityVersion = sbe.MessageSecurityVersion;
+                    if (messageSecurityVersion.TrustVersion == TrustVersion.WSTrustFeb2005)
+                    {
+                        trustDriver = new WSTrustFeb2005.DriverFeb2005(new SecurityStandardsManager(messageSecurityVersion, WSSecurityTokenSerializer.DefaultInstance));
+                    }
+                    else if (messageSecurityVersion.TrustVersion == TrustVersion.WSTrust13)
+                    {
+                        trustDriver = new WSTrustDec2005.DriverDec2005(new SecurityStandardsManager(messageSecurityVersion, WSSecurityTokenSerializer.DefaultInstance));
+                    }
+                }
+                return trustDriver != null;
+            }
+        }
+
+        public static bool TryGetSecurityPolicyDriver(ICollection<XmlElement> assertions, out WSSecurityPolicy securityPolicy)
+        {
+            SecurityPolicyManager policyManager = new SecurityPolicyManager();
+            return policyManager.TryGetSecurityPolicyDriver(assertions, out securityPolicy); 
+        }
+
+        public static WSSecurityPolicy GetSecurityPolicyDriver(MessageSecurityVersion version)
+        {
+            SecurityPolicyManager policyManager = new SecurityPolicyManager();
+            return policyManager.GetSecurityPolicyDriver(version);
+        }
+
+        class SecurityPolicyManager
+        {
+            List<WSSecurityPolicy> drivers;
+
+            public SecurityPolicyManager()
+            {
+                this.drivers = new List<WSSecurityPolicy>();
+                Initialize();
+            }
+
+            public void Initialize()
+            {
+                this.drivers.Add(new WSSecurityPolicy11());
+                this.drivers.Add(new WSSecurityPolicy12());
+            }
+
+            public bool TryGetSecurityPolicyDriver(ICollection<XmlElement> assertions, out WSSecurityPolicy securityPolicy)
+            {
+                securityPolicy = null;
+
+                for (int i = 0; i < this.drivers.Count; ++i)
+                {
+                    if (this.drivers[i].CanImportAssertion(assertions))
+                    {
+                        securityPolicy = this.drivers[i];
+                        return true;
+                    }
+                }
+
+                return false;
+            }
+
+            public WSSecurityPolicy GetSecurityPolicyDriver(MessageSecurityVersion version)
+            {
+                for (int i = 0; i < this.drivers.Count; ++i)
+                {
+                    if (this.drivers[i].IsSecurityVersionSupported(version))
+                    {
+                        return this.drivers[i];
+                    }
+                }
+
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new NotSupportedException());
+            }
+
+        }*/
+    }
+
+    static class SecurityPolicyStrings
+    {
+        public const string SecureConversationBootstrapBindingElementsBelowSecurityKey = "SecureConversationBootstrapBindingElementsBelowSecurityKey";
+    }
+
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/WSSecurityPolicy11.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/WSSecurityPolicy11.cs
new file mode 100644
index 0000000..ff0929c
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/WSSecurityPolicy11.cs
@@ -0,0 +1,117 @@
+using System;
+using System.Collections.Generic;
+using System.Runtime;
+using CoreWCF.Channels;
+using CoreWCF.Description;
+using System.Xml;
+
+namespace CoreWCF.Security
+{
+
+    class WSSecurityPolicy11 : WSSecurityPolicy
+    {
+        public const string WsspNamespace = @"http://schemas.xmlsoap.org/ws/2005/07/securitypolicy";
+         
+        /*
+        public override string WsspNamespaceUri
+        {
+            get { return WSSecurityPolicy11.WsspNamespace; }
+        }
+
+        public override bool IsSecurityVersionSupported(MessageSecurityVersion version)
+        {
+            return version == MessageSecurityVersion.WSSecurity10WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11BasicSecurityProfile10 ||
+                version == MessageSecurityVersion.WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11 ||
+                version == MessageSecurityVersion.WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11BasicSecurityProfile10;
+        }
+
+        public override MessageSecurityVersion GetSupportedMessageSecurityVersion(SecurityVersion version)
+        {
+                return (version == SecurityVersion.WSSecurity10) ? MessageSecurityVersion.WSSecurity10WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11BasicSecurityProfile10 : MessageSecurityVersion.WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11BasicSecurityProfile10;
+        }
+
+       
+        public override TrustDriver TrustDriver
+        {
+            get
+            {
+                return new WSTrustFeb2005.DriverFeb2005(new SecurityStandardsManager(MessageSecurityVersion.WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11, WSSecurityTokenSerializer.DefaultInstance));
+            }
+        }
+
+        // WS-SecurityPolicy 11 should still use the mssp namespace for MustNotSendCancel
+        public override XmlElement CreateWsspMustNotSendCancelAssertion(bool requireCancel)
+        {
+            if (!requireCancel)
+            {
+                XmlElement result = CreateMsspAssertion(MustNotSendCancelName);
+                return result;
+            }
+            else
+            {
+                return null;
+            }
+        }
+
+        // WS-SecurityPolicy 11 should still use the mssp namespace for MustNotSendCancel
+        public override bool TryImportWsspMustNotSendCancelAssertion(ICollection<XmlElement> assertions, out bool requireCancellation)
+        {
+            requireCancellation = !TryImportMsspAssertion(assertions, MustNotSendCancelName);
+            return true;
+        }
+
+        public override XmlElement CreateWsspHttpsTokenAssertion(MetadataExporter exporter, HttpsTransportBindingElement httpsBinding)
+        {
+            XmlElement result = CreateWsspAssertion(HttpsTokenName);
+            result.SetAttribute(RequireClientCertificateName, httpsBinding.RequireClientCertificate ? TrueName : FalseName);
+            return result;
+        }
+
+        public override bool TryImportWsspHttpsTokenAssertion(MetadataImporter importer, ICollection<XmlElement> assertions, HttpsTransportBindingElement httpsBinding)
+        {
+            if (assertions == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("assertions");
+            }
+
+            bool result;
+            XmlElement assertion;
+
+            if (TryImportWsspAssertion(assertions, HttpsTokenName, out assertion))
+            {
+                result = true;
+                string v = assertion.GetAttribute(RequireClientCertificateName);
+                try 
+                {
+                    httpsBinding.RequireClientCertificate = XmlUtil.IsTrue(v);
+                }
+                catch (Exception e)
+                {
+                    if (Fx.IsFatal(e))
+                        throw;
+                    if (e is NullReferenceException)
+                        throw;
+
+                    importer.Errors.Add(new MetadataConversionError(SR.GetString(SR.UnsupportedBooleanAttribute, RequireClientCertificateName, e.Message), false));
+                    result = false;
+                }
+            }
+            else
+            {
+                result = false;
+            }
+
+            return result;
+        }
+
+        public override XmlElement CreateWsspTrustAssertion(MetadataExporter exporter, SecurityKeyEntropyMode keyEntropyMode)
+        {
+            return CreateWsspTrustAssertion(Trust10Name, exporter, keyEntropyMode);
+        }
+
+        public override bool TryImportWsspTrustAssertion(MetadataImporter importer, ICollection<XmlElement> assertions, SecurityBindingElement binding, out XmlElement assertion)
+        {
+            return TryImportWsspTrustAssertion(Trust10Name, importer, assertions, binding, out assertion);
+        }*/
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/WSSecurityPolicy12.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/WSSecurityPolicy12.cs
new file mode 100644
index 0000000..694f2d1
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/WSSecurityPolicy12.cs
@@ -0,0 +1,649 @@
+using System;
+using System.Collections.Generic;
+using System.Collections.ObjectModel;
+using System.Net;
+using System.Runtime;
+using CoreWCF.Description;
+using CoreWCF.Channels;
+using CoreWCF.Security.Tokens;
+using System.Text;
+using System.Xml;
+
+namespace CoreWCF.Security
+{
+    class WSSecurityPolicy12 : WSSecurityPolicy
+    {
+        public const string WsspNamespace = @"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702";
+
+        public const string SignedEncryptedSupportingTokensName = "SignedEncryptedSupportingTokens";
+        public const string RequireImpliedDerivedKeysName = "RequireImpliedDerivedKeys";
+        public const string RequireExplicitDerivedKeysName = "RequireExplicitDerivedKeys";
+
+        /*public override string WsspNamespaceUri
+        {
+            get { return WSSecurityPolicy12.WsspNamespace; }
+        }
+
+        
+        public override bool IsSecurityVersionSupported(MessageSecurityVersion version)
+        {
+            return version == MessageSecurityVersion.WSSecurity10WSTrust13WSSecureConversation13WSSecurityPolicy12BasicSecurityProfile10 ||
+                version == MessageSecurityVersion.WSSecurity11WSTrust13WSSecureConversation13WSSecurityPolicy12 ||
+                version == MessageSecurityVersion.WSSecurity11WSTrust13WSSecureConversation13WSSecurityPolicy12BasicSecurityProfile10;
+        }
+
+        public override MessageSecurityVersion GetSupportedMessageSecurityVersion(SecurityVersion version)
+        {
+            return (version == SecurityVersion.WSSecurity10) ? MessageSecurityVersion.WSSecurity10WSTrust13WSSecureConversation13WSSecurityPolicy12BasicSecurityProfile10 : MessageSecurityVersion.WSSecurity11WSTrust13WSSecureConversation13WSSecurityPolicy12BasicSecurityProfile10;
+        }
+
+        public override TrustDriver TrustDriver
+        {
+            get
+            {
+                return new WSTrustDec2005.DriverDec2005(new SecurityStandardsManager(MessageSecurityVersion.WSSecurity11WSTrust13WSSecureConversation13WSSecurityPolicy12, WSSecurityTokenSerializer.DefaultInstance));
+            }
+        }
+
+        public override XmlElement CreateWsspHttpsTokenAssertion(MetadataExporter exporter, HttpsTransportBindingElement httpsBinding)
+        {
+            Fx.Assert(httpsBinding != null, "httpsBinding must not be null.");
+            Fx.Assert(httpsBinding.AuthenticationScheme.IsSingleton(), "authenticationScheme must be a singleton value for security-mode TransportWithMessageCredential.");
+
+            XmlElement result = CreateWsspAssertion(WSSecurityPolicy.HttpsTokenName);
+            if (httpsBinding.RequireClientCertificate ||
+                httpsBinding.AuthenticationScheme == AuthenticationSchemes.Basic ||
+                httpsBinding.AuthenticationScheme == AuthenticationSchemes.Digest)
+            {
+                XmlElement policy = CreateWspPolicyWrapper(exporter);
+                if (httpsBinding.RequireClientCertificate)
+                {
+                    policy.AppendChild(CreateWsspAssertion(WSSecurityPolicy.RequireClientCertificateName));
+                }
+                if (httpsBinding.AuthenticationScheme == AuthenticationSchemes.Basic)
+                {
+                    policy.AppendChild(CreateWsspAssertion(WSSecurityPolicy.HttpBasicAuthenticationName));
+                }
+                else if (httpsBinding.AuthenticationScheme == AuthenticationSchemes.Digest)
+                {
+                    policy.AppendChild(CreateWsspAssertion(WSSecurityPolicy.HttpDigestAuthenticationName));
+                }
+                result.AppendChild(policy);
+            }
+            return result;
+        }
+
+        public override bool TryImportWsspHttpsTokenAssertion(MetadataImporter importer, ICollection<XmlElement> assertions, HttpsTransportBindingElement httpsBinding)
+        {
+            if (assertions == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("assertions");
+            }
+
+            bool result = true;
+            XmlElement assertion;
+
+            if (TryImportWsspAssertion(assertions, HttpsTokenName, out assertion))
+            {
+                XmlElement policyElement = null;
+                foreach (XmlNode node in assertion.ChildNodes)
+                {
+                    if (node is XmlElement && node.LocalName == WSSecurityPolicy.PolicyName && (node.NamespaceURI == WSSecurityPolicy.WspNamespace || node.NamespaceURI == WSSecurityPolicy.Wsp15Namespace))
+                    {
+                        policyElement = (XmlElement)node;
+                        break;
+                    }
+                }
+
+                if (policyElement != null)
+                {
+                    foreach (XmlNode node in policyElement.ChildNodes)
+                    {
+                        if (node is XmlElement && node.NamespaceURI == this.WsspNamespaceUri)
+                        {
+                            if (node.LocalName == WSSecurityPolicy.RequireClientCertificateName)
+                            {
+                                httpsBinding.RequireClientCertificate = true;
+                            }
+                            else if (node.LocalName == WSSecurityPolicy.HttpBasicAuthenticationName)
+                            {
+                                httpsBinding.AuthenticationScheme = AuthenticationSchemes.Basic;
+                            }
+                            else if (node.LocalName == WSSecurityPolicy.HttpDigestAuthenticationName)
+                            {
+                                httpsBinding.AuthenticationScheme = AuthenticationSchemes.Digest;
+                            }
+                        }
+                    }
+                }
+            }
+            else
+            {
+                result = false;
+            }
+
+            return result;
+        }
+
+        public override Collection<XmlElement> CreateWsspSupportingTokensAssertion(MetadataExporter exporter, Collection<SecurityTokenParameters> signed, Collection<SecurityTokenParameters> signedEncrypted, Collection<SecurityTokenParameters> endorsing, Collection<SecurityTokenParameters> signedEndorsing, Collection<SecurityTokenParameters> optionalSigned, Collection<SecurityTokenParameters> optionalSignedEncrypted, Collection<SecurityTokenParameters> optionalEndorsing, Collection<SecurityTokenParameters> optionalSignedEndorsing, AddressingVersion addressingVersion)
+        {
+            Collection<XmlElement> supportingTokenAssertions = new Collection<XmlElement>();
+
+            // Signed Supporting Tokens
+            XmlElement supportingTokenAssertion = CreateWsspSignedSupportingTokensAssertion(exporter, signed, optionalSigned);
+            if (supportingTokenAssertion != null)
+                supportingTokenAssertions.Add(supportingTokenAssertion);
+
+            // Signed Encrypted Supporting Tokens
+            supportingTokenAssertion = CreateWsspSignedEncryptedSupportingTokensAssertion(exporter, signedEncrypted, optionalSignedEncrypted);
+            if (supportingTokenAssertion != null)
+                supportingTokenAssertions.Add(supportingTokenAssertion);
+
+            // Endorsing Supporting Tokens.
+            supportingTokenAssertion = CreateWsspEndorsingSupportingTokensAssertion(exporter, endorsing, optionalEndorsing, addressingVersion);
+            if (supportingTokenAssertion != null)
+                supportingTokenAssertions.Add(supportingTokenAssertion);
+
+            // Signed Endorsing Supporting Tokens.
+            supportingTokenAssertion = CreateWsspSignedEndorsingSupportingTokensAssertion(exporter, signedEndorsing, optionalSignedEndorsing, addressingVersion);
+            if (supportingTokenAssertion != null)
+                supportingTokenAssertions.Add(supportingTokenAssertion);
+
+            return supportingTokenAssertions;
+        }
+
+        public override XmlElement CreateWsspSpnegoContextTokenAssertion(MetadataExporter exporter, SspiSecurityTokenParameters parameters)
+        {
+            XmlElement result = CreateWsspAssertion(SpnegoContextTokenName);
+            SetIncludeTokenValue(result, parameters.InclusionMode);
+            result.AppendChild(
+                CreateWspPolicyWrapper(
+                    exporter,
+                    CreateWsspRequireDerivedKeysAssertion(parameters.RequireDerivedKeys),
+                    // Always emit <sp:MustNotSendCancel/> for spnego and sslnego
+                    CreateWsspMustNotSendCancelAssertion(false),
+                    CreateWsspMustNotSendAmendAssertion(),
+                    CreateWsspMustNotSendRenewAssertion()
+            ));
+            return result;
+        }
+
+        public override XmlElement CreateMsspSslContextTokenAssertion(MetadataExporter exporter, SslSecurityTokenParameters parameters)
+        {
+            XmlElement result = CreateMsspAssertion(SslContextTokenName);
+            SetIncludeTokenValue(result, parameters.InclusionMode);
+            result.AppendChild(
+                CreateWspPolicyWrapper(
+                    exporter,
+                    CreateWsspRequireDerivedKeysAssertion(parameters.RequireDerivedKeys),
+                    // Always emit <sp:MustNotSendCancel/> for spnego and sslnego
+                    CreateWsspMustNotSendCancelAssertion(false),
+                    CreateMsspRequireClientCertificateAssertion(parameters.RequireClientCertificate),
+                    CreateWsspMustNotSendAmendAssertion(),
+                    CreateWsspMustNotSendRenewAssertion()
+            ));
+            return result;
+        }
+
+        public override XmlElement CreateWsspSecureConversationTokenAssertion(MetadataExporter exporter, SecureConversationSecurityTokenParameters parameters)
+        {
+            XmlElement result = CreateWsspAssertion(SecureConversationTokenName);
+            SetIncludeTokenValue(result, parameters.InclusionMode);
+            result.AppendChild(
+                CreateWspPolicyWrapper(
+                    exporter,
+                    CreateWsspRequireDerivedKeysAssertion(parameters.RequireDerivedKeys),
+                    CreateWsspMustNotSendCancelAssertion(parameters.RequireCancellation),
+                    CreateWsspBootstrapPolicyAssertion(exporter, parameters.BootstrapSecurityBindingElement),
+                    CreateWsspMustNotSendAmendAssertion(),
+                    (!parameters.RequireCancellation || !parameters.CanRenewSession) ? CreateWsspMustNotSendRenewAssertion() : null
+            ));
+            return result;
+        }
+
+        XmlElement CreateWsspMustNotSendAmendAssertion()
+        {
+            XmlElement result = CreateWsspAssertion(MustNotSendAmendName);
+            return result;
+        }
+
+        XmlElement CreateWsspMustNotSendRenewAssertion()
+        {
+            XmlElement result = CreateWsspAssertion(MustNotSendRenewName);
+            return result;
+        }
+
+        public override bool TryImportWsspSpnegoContextTokenAssertion(MetadataImporter importer, XmlElement assertion, out SecurityTokenParameters parameters)
+        {
+            parameters = null;
+
+            SecurityTokenInclusionMode inclusionMode;
+            Collection<Collection<XmlElement>> alternatives;
+
+            if (IsWsspAssertion(assertion, SpnegoContextTokenName)
+                && TryGetIncludeTokenValue(assertion, out inclusionMode))
+            {
+                if (TryGetNestedPolicyAlternatives(importer, assertion, out alternatives))
+                {
+                    foreach (Collection<XmlElement> alternative in alternatives)
+                    {
+                        SspiSecurityTokenParameters sspi = new SspiSecurityTokenParameters();
+                        parameters = sspi;
+                        bool requireCancellation;
+                        bool canRenewSession;
+                        if (TryImportWsspRequireDerivedKeysAssertion(alternative, sspi)
+                            && TryImportWsspMustNotSendCancelAssertion(alternative, out requireCancellation)
+                            && TryImportWsspMustNotSendAmendAssertion(alternative)
+                            // We do not support Renew for spnego and sslnego. Read the 
+                            // assertion if present and ignore it.
+                            && TryImportWsspMustNotSendRenewAssertion(alternative, out canRenewSession)
+                            && alternative.Count == 0)
+                        {
+                            // Client always set this to true to match the standardbinding.
+                            // This setting on client has no effect for spnego and sslnego.
+                            sspi.RequireCancellation = true;
+                            sspi.InclusionMode = inclusionMode;
+                            break;
+                        }
+                        else
+                        {
+                            parameters = null;
+                        }
+                    }
+                }
+                else
+                {
+                    parameters = new SspiSecurityTokenParameters();
+                    parameters.RequireDerivedKeys = false;
+                    parameters.InclusionMode = inclusionMode;
+                }
+            }
+
+            return parameters != null;
+        }
+
+        public override bool TryImportMsspSslContextTokenAssertion(MetadataImporter importer, XmlElement assertion, out SecurityTokenParameters parameters)
+        {
+            parameters = null;
+
+            SecurityTokenInclusionMode inclusionMode;
+            Collection<Collection<XmlElement>> alternatives;
+
+            if (IsMsspAssertion(assertion, SslContextTokenName)
+                && TryGetIncludeTokenValue(assertion, out inclusionMode))
+            {
+                if (TryGetNestedPolicyAlternatives(importer, assertion, out alternatives))
+                {
+                    foreach (Collection<XmlElement> alternative in alternatives)
+                    {
+                        SslSecurityTokenParameters ssl = new SslSecurityTokenParameters();
+                        parameters = ssl;
+                        bool requireCancellation;
+                        bool canRenewSession;
+                        if (TryImportWsspRequireDerivedKeysAssertion(alternative, ssl)
+                            && TryImportWsspMustNotSendCancelAssertion(alternative, out requireCancellation)
+                            && TryImportWsspMustNotSendAmendAssertion(alternative)
+                            // We do not support Renew for spnego and sslnego. Read the 
+                            // assertion if present and ignore it.
+                            && TryImportWsspMustNotSendRenewAssertion(alternative, out canRenewSession)
+                            && TryImportMsspRequireClientCertificateAssertion(alternative, ssl)
+                            && alternative.Count == 0)
+                        {
+                            // Client always set this to true to match the standardbinding.
+                            // This setting on client has no effect for spnego and sslnego.
+                            ssl.RequireCancellation = true;
+                            ssl.InclusionMode = inclusionMode;
+                            break;
+                        }
+                        else
+                        {
+                            parameters = null;
+                        }
+                    }
+                }
+                else
+                {
+                    parameters = new SslSecurityTokenParameters();
+                    parameters.RequireDerivedKeys = false;
+                    parameters.InclusionMode = inclusionMode;
+                }
+            }
+
+            return parameters != null;
+        }
+
+        public override bool TryImportWsspSecureConversationTokenAssertion(MetadataImporter importer, XmlElement assertion, out SecurityTokenParameters parameters)
+        {
+            parameters = null;
+
+            SecurityTokenInclusionMode inclusionMode;
+            Collection<Collection<XmlElement>> alternatives;
+
+            if (IsWsspAssertion(assertion, SecureConversationTokenName)
+                && TryGetIncludeTokenValue(assertion, out inclusionMode))
+            {
+                if (TryGetNestedPolicyAlternatives(importer, assertion, out alternatives))
+                {
+                    foreach (Collection<XmlElement> alternative in alternatives)
+                    {
+                        SecureConversationSecurityTokenParameters sc = new SecureConversationSecurityTokenParameters();
+                        parameters = sc;
+                        bool requireCancellation;
+                        bool canRenewSession;
+                        if (TryImportWsspRequireDerivedKeysAssertion(alternative, sc)
+                            && TryImportWsspMustNotSendCancelAssertion(alternative, out requireCancellation)
+                            && TryImportWsspMustNotSendAmendAssertion(alternative)
+                            && TryImportWsspMustNotSendRenewAssertion(alternative, out canRenewSession)
+                            && TryImportWsspBootstrapPolicyAssertion(importer, alternative, sc)
+                            && alternative.Count == 0)
+                        {
+                            sc.RequireCancellation = requireCancellation;
+                            sc.CanRenewSession = canRenewSession;
+                            sc.InclusionMode = inclusionMode;
+                            break;
+                        }
+                        else
+                        {
+                            parameters = null;
+                        }
+                    }
+                }
+                else
+                {
+                    parameters = new SecureConversationSecurityTokenParameters();
+                    parameters.InclusionMode = inclusionMode;
+                    parameters.RequireDerivedKeys = false;
+                }
+            }
+
+            return parameters != null;
+        }
+
+        public virtual bool TryImportWsspMustNotSendAmendAssertion(ICollection<XmlElement> assertions)
+        {
+            TryImportWsspAssertion(assertions, MustNotSendAmendName);
+            return true;
+        }
+
+        public virtual bool TryImportWsspMustNotSendRenewAssertion(ICollection<XmlElement> assertions, out bool canRenewSession)
+        {
+            canRenewSession = !TryImportWsspAssertion(assertions, MustNotSendRenewName);
+            return true;
+        }
+
+        XmlElement CreateWsspSignedSupportingTokensAssertion(MetadataExporter exporter, Collection<SecurityTokenParameters> signed, Collection<SecurityTokenParameters> optionalSigned)
+        {
+            XmlElement result;
+
+            if ((signed == null || signed.Count == 0)
+                && (optionalSigned == null || optionalSigned.Count == 0))
+            {
+                result = null;
+            }
+            else
+            {
+                XmlElement policy = CreateWspPolicyWrapper(exporter);
+
+                if (signed != null)
+                {
+                    foreach (SecurityTokenParameters p in signed)
+                    {
+                        policy.AppendChild(CreateTokenAssertion(exporter, p));
+                    }
+                }
+                if (optionalSigned != null)
+                {
+                    foreach (SecurityTokenParameters p in optionalSigned)
+                    {
+                        policy.AppendChild(CreateTokenAssertion(exporter, p, true));
+                    }
+                }
+
+                result = CreateWsspAssertion(SignedSupportingTokensName);
+                result.AppendChild(policy);
+            }
+
+            return result;
+        }
+
+        XmlElement CreateWsspSignedEncryptedSupportingTokensAssertion(MetadataExporter exporter, Collection<SecurityTokenParameters> signedEncrypted, Collection<SecurityTokenParameters> optionalSignedEncrypted)
+        {
+            XmlElement result;
+
+            if ((signedEncrypted == null || signedEncrypted.Count == 0)
+                && (optionalSignedEncrypted == null || optionalSignedEncrypted.Count == 0))
+            {
+                result = null;
+            }
+            else
+            {
+                XmlElement policy = CreateWspPolicyWrapper(exporter);
+
+                if (signedEncrypted != null)
+                {
+                    foreach (SecurityTokenParameters p in signedEncrypted)
+                    {
+                        policy.AppendChild(CreateTokenAssertion(exporter, p));
+                    }
+                }
+                if (optionalSignedEncrypted != null)
+                {
+                    foreach (SecurityTokenParameters p in optionalSignedEncrypted)
+                    {
+                        policy.AppendChild(CreateTokenAssertion(exporter, p, true));
+                    }
+                }
+
+                result = CreateWsspAssertion(SignedEncryptedSupportingTokensName);
+                result.AppendChild(policy);
+            }
+
+            return result;
+        }
+
+        public override bool TryImportWsspSupportingTokensAssertion(MetadataImporter importer, PolicyConversionContext policyContext, ICollection<XmlElement> assertions, Collection<SecurityTokenParameters> signed, Collection<SecurityTokenParameters> signedEncrypted, Collection<SecurityTokenParameters> endorsing, Collection<SecurityTokenParameters> signedEndorsing, Collection<SecurityTokenParameters> optionalSigned, Collection<SecurityTokenParameters> optionalSignedEncrypted, Collection<SecurityTokenParameters> optionalEndorsing, Collection<SecurityTokenParameters> optionalSignedEndorsing)
+        {
+            XmlElement assertion;
+
+            if (!TryImportWsspSignedSupportingTokensAssertion(
+                importer,
+                policyContext,
+                assertions,
+                signed,
+                optionalSigned,
+                out assertion)
+                && assertion != null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.GetString(SR.UnsupportedSecurityPolicyAssertion, assertion.OuterXml)));
+            }
+
+            if (!TryImportWsspSignedEncryptedSupportingTokensAssertion(
+                importer,
+                policyContext,
+                assertions,
+                signedEncrypted,
+                optionalSignedEncrypted,
+                out assertion)
+                && assertion != null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.GetString(SR.UnsupportedSecurityPolicyAssertion, assertion.OuterXml)));
+            }
+
+            if (!TryImportWsspEndorsingSupportingTokensAssertion(
+                importer,
+                policyContext,
+                assertions,
+                endorsing,
+                optionalEndorsing,
+                out assertion)
+                && assertion != null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.GetString(SR.UnsupportedSecurityPolicyAssertion, assertion.OuterXml)));
+            }
+
+            if (!TryImportWsspSignedEndorsingSupportingTokensAssertion(
+                importer,
+                policyContext,
+                assertions,
+                signedEndorsing,
+                optionalSignedEndorsing,
+                out assertion)
+                && assertion != null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.GetString(SR.UnsupportedSecurityPolicyAssertion, assertion.OuterXml)));
+            }
+
+            return true;
+        }
+
+        bool TryImportWsspSignedSupportingTokensAssertion(MetadataImporter importer, PolicyConversionContext policyContext, ICollection<XmlElement> assertions, Collection<SecurityTokenParameters> signed, Collection<SecurityTokenParameters> optionalSigned, out XmlElement assertion)
+        {
+            if (signed == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("signed");
+            }
+            if (optionalSigned == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("optionalSigned");
+            }
+
+            bool result = true;
+
+            Collection<Collection<XmlElement>> alternatives;
+
+            if (TryImportWsspAssertion(assertions, SignedSupportingTokensName, out assertion)
+                && TryGetNestedPolicyAlternatives(importer, assertion, out alternatives))
+            {
+                foreach (Collection<XmlElement> alternative in alternatives)
+                {
+                    SecurityTokenParameters parameters;
+                    bool isOptional;
+                    while (alternative.Count > 0 && TryImportTokenAssertion(importer, policyContext, alternative, out parameters, out isOptional))
+                    {
+                        if (isOptional)
+                        {
+                            optionalSigned.Add(parameters);
+                        }
+                        else
+                        {
+                            signed.Add(parameters);
+                        }
+                    }
+                    if (alternative.Count == 0)
+                    {
+                        result = true;
+                        break;
+                    }
+                    else
+                    {
+                        result = false;
+                    }
+                }
+            }
+
+            return result;
+        }
+
+        bool TryImportWsspSignedEncryptedSupportingTokensAssertion(MetadataImporter importer, PolicyConversionContext policyContext, ICollection<XmlElement> assertions, Collection<SecurityTokenParameters> signedEncrypted, Collection<SecurityTokenParameters> optionalSignedEncrypted, out XmlElement assertion)
+        {
+            if (signedEncrypted == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("signedEncrypted");
+            }
+            if (optionalSignedEncrypted == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("optionalSignedEncrypted");
+            }
+
+            bool result = true;
+
+            Collection<Collection<XmlElement>> alternatives;
+
+            if (TryImportWsspAssertion(assertions, SignedEncryptedSupportingTokensName, out assertion)
+                && TryGetNestedPolicyAlternatives(importer, assertion, out alternatives))
+            {
+                foreach (Collection<XmlElement> alternative in alternatives)
+                {
+                    SecurityTokenParameters parameters;
+                    bool isOptional;
+                    while (alternative.Count > 0 && TryImportTokenAssertion(importer, policyContext, alternative, out parameters, out isOptional))
+                    {
+                        if (isOptional)
+                        {
+                            optionalSignedEncrypted.Add(parameters);
+                        }
+                        else
+                        {
+                            signedEncrypted.Add(parameters);
+                        }
+                    }
+                    if (alternative.Count == 0)
+                    {
+                        result = true;
+                        break;
+                    }
+                    else
+                    {
+                        result = false;
+                    }
+                }
+            }
+
+            return result;
+        }
+
+        public override bool TryImportWsspRequireDerivedKeysAssertion(ICollection<XmlElement> assertions, SecurityTokenParameters parameters)
+        {
+            parameters.RequireDerivedKeys = TryImportWsspAssertion(assertions, WSSecurityPolicy.RequireDerivedKeysName);
+
+            if (!parameters.RequireDerivedKeys)
+            {
+                parameters.RequireDerivedKeys = TryImportWsspAssertion(assertions, WSSecurityPolicy12.RequireExplicitDerivedKeysName);
+            }
+
+            if (!parameters.RequireDerivedKeys)
+            {
+                XmlElement assertion = null;
+                if (TryImportWsspAssertion(assertions, WSSecurityPolicy12.RequireImpliedDerivedKeysName, out assertion))
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.GetString(SR.UnsupportedSecurityPolicyAssertion, assertion.OuterXml)));
+            }
+
+            return true;
+        }
+
+        public override XmlElement CreateWsspTrustAssertion(MetadataExporter exporter, SecurityKeyEntropyMode keyEntropyMode)
+        {
+            return CreateWsspTrustAssertion(Trust13Name, exporter, keyEntropyMode);
+        }
+
+        public override bool TryImportWsspTrustAssertion(MetadataImporter importer, ICollection<XmlElement> assertions, SecurityBindingElement binding, out XmlElement assertion)
+        {
+            return TryImportWsspTrustAssertion(Trust13Name, importer, assertions, binding, out assertion);
+        }
+
+        public override XmlElement CreateWsspRsaTokenAssertion(RsaSecurityTokenParameters parameters)
+        {
+            XmlElement result = CreateWsspAssertion(KeyValueTokenName);
+            SetIncludeTokenValue(result, parameters.InclusionMode);
+            return result;
+        }
+
+        public override bool TryImportWsspRsaTokenAssertion(MetadataImporter importer, XmlElement assertion, out SecurityTokenParameters parameters)
+        {
+            parameters = null;
+
+            SecurityTokenInclusionMode inclusionMode;
+            Collection<Collection<XmlElement>> alternatives;
+
+            if (IsWsspAssertion(assertion, KeyValueTokenName)
+                && TryGetIncludeTokenValue(assertion, out inclusionMode)
+                && TryGetNestedPolicyAlternatives(importer, assertion, out alternatives) == false)
+            {
+                parameters = new RsaSecurityTokenParameters();
+                parameters.InclusionMode = inclusionMode;
+            }
+
+            return parameters != null;
+        }*/
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/WSSecurityTokenSerializer.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/WSSecurityTokenSerializer.cs
new file mode 100644
index 0000000..a353910
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/WSSecurityTokenSerializer.cs
@@ -0,0 +1,572 @@
+using System.Collections.Generic;
+using CoreWCF.IdentityModel.Selectors;
+using CoreWCF.IdentityModel.Tokens;
+using CoreWCF.Runtime;
+using CoreWCF.Security.Tokens;
+using System.Xml;
+using System.Threading.Tasks;
+using System;
+using CoreWCF.IdentityModel;
+using static CoreWCF.Security.WSKeyInfoSerializer;
+
+namespace CoreWCF.Security
+{
+    public class WSSecurityTokenSerializer : SecurityTokenSerializer
+    {
+        private const int DefaultMaximumKeyDerivationOffset = 64; // bytes 
+        private const int DefaultMaximumKeyDerivationLabelLength = 128; // bytes
+        private const int DefaultMaximumKeyDerivationNonceLength = 128; // bytes
+
+        private static WSSecurityTokenSerializer s_instance;
+        private readonly List<SerializerEntries> _serializerEntries;
+        private WSSecureConversation _secureConversation;
+        private readonly List<TokenEntry> _tokenEntries = new List<TokenEntry>();
+        private int _maximumKeyDerivationNonceLength;
+
+        private KeyInfoSerializer _keyInfoSerializer;
+
+        public WSSecurityTokenSerializer()
+            : this(SecurityVersion.WSSecurity11)
+        {
+        }
+
+        public WSSecurityTokenSerializer(bool emitBspRequiredAttributes)
+            : this(SecurityVersion.WSSecurity11, emitBspRequiredAttributes)
+        {
+        }
+
+        public WSSecurityTokenSerializer(SecurityVersion securityVersion)
+            : this(securityVersion, false)
+        {
+        }
+
+        public WSSecurityTokenSerializer(SecurityVersion securityVersion, bool emitBspRequiredAttributes)
+            : this(securityVersion, emitBspRequiredAttributes, null)
+        {
+        }
+
+        public WSSecurityTokenSerializer(SecurityVersion securityVersion, bool emitBspRequiredAttributes, SamlSerializer samlSerializer)
+            : this(securityVersion, emitBspRequiredAttributes, samlSerializer, null, null)
+        {
+        }
+
+        public WSSecurityTokenSerializer(SecurityVersion securityVersion, bool emitBspRequiredAttributes, SamlSerializer samlSerializer, SecurityStateEncoder securityStateEncoder, IEnumerable<Type> knownTypes)
+            : this(securityVersion, emitBspRequiredAttributes, samlSerializer, securityStateEncoder, knownTypes, DefaultMaximumKeyDerivationOffset, DefaultMaximumKeyDerivationLabelLength, DefaultMaximumKeyDerivationNonceLength)
+        {
+        }
+
+        public WSSecurityTokenSerializer(SecurityVersion securityVersion, TrustVersion trustVersion, SecureConversationVersion secureConversationVersion, bool emitBspRequiredAttributes, SamlSerializer samlSerializer, SecurityStateEncoder securityStateEncoder, IEnumerable<Type> knownTypes)
+            : this(securityVersion, trustVersion, secureConversationVersion, emitBspRequiredAttributes, samlSerializer, securityStateEncoder, knownTypes, DefaultMaximumKeyDerivationOffset, DefaultMaximumKeyDerivationLabelLength, DefaultMaximumKeyDerivationNonceLength)
+        {
+        }
+
+        public WSSecurityTokenSerializer(SecurityVersion securityVersion, bool emitBspRequiredAttributes, SamlSerializer samlSerializer, SecurityStateEncoder securityStateEncoder, IEnumerable<Type> knownTypes,
+            int maximumKeyDerivationOffset, int maximumKeyDerivationLabelLength, int maximumKeyDerivationNonceLength)
+            : this(securityVersion, TrustVersion.Default, SecureConversationVersion.Default, emitBspRequiredAttributes, samlSerializer, securityStateEncoder, knownTypes, maximumKeyDerivationOffset, maximumKeyDerivationLabelLength, maximumKeyDerivationNonceLength)
+        {
+        }
+
+        public WSSecurityTokenSerializer(SecurityVersion securityVersion, TrustVersion trustVersion, SecureConversationVersion secureConversationVersion, bool emitBspRequiredAttributes, SamlSerializer samlSerializer, SecurityStateEncoder securityStateEncoder, IEnumerable<Type> knownTypes,
+            int maximumKeyDerivationOffset, int maximumKeyDerivationLabelLength, int maximumKeyDerivationNonceLength)
+        {
+            if (maximumKeyDerivationOffset < 0)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(maximumKeyDerivationOffset), SR.ValueMustBeNonNegative));
+            }
+            if (maximumKeyDerivationLabelLength < 0)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(maximumKeyDerivationLabelLength), SR.ValueMustBeNonNegative));
+            }
+            if (maximumKeyDerivationNonceLength <= 0)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(maximumKeyDerivationNonceLength), SR.ValueMustBeGreaterThanZero));
+            }
+
+            SecurityVersion = securityVersion ?? throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException(nameof(securityVersion)));
+            EmitBspRequiredAttributes = emitBspRequiredAttributes;
+            MaximumKeyDerivationOffset = maximumKeyDerivationOffset;
+            _maximumKeyDerivationNonceLength = maximumKeyDerivationNonceLength;
+            MaximumKeyDerivationLabelLength = maximumKeyDerivationLabelLength;
+
+            _serializerEntries = new List<SerializerEntries>();
+
+            if (secureConversationVersion == SecureConversationVersion.WSSecureConversationFeb2005)
+            {
+                _secureConversation = new WSSecureConversationFeb2005(this, securityStateEncoder, knownTypes, maximumKeyDerivationOffset, maximumKeyDerivationLabelLength, maximumKeyDerivationNonceLength);
+            }
+            else if (secureConversationVersion == SecureConversationVersion.WSSecureConversation13)
+            {
+                _secureConversation = new WSSecureConversationDec2005(this, securityStateEncoder, knownTypes, maximumKeyDerivationOffset, maximumKeyDerivationLabelLength, maximumKeyDerivationNonceLength);
+            }
+            else
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new NotSupportedException());
+            }
+
+            if (securityVersion == SecurityVersion.WSSecurity10)
+            {
+                _serializerEntries.Add(new WSSecurityJan2004(this, samlSerializer));
+            }
+            else if (securityVersion == SecurityVersion.WSSecurity11)
+            {
+                _serializerEntries.Add(new WSSecurityXXX2005(this, samlSerializer));
+            }
+            else
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(securityVersion), SR.MessageSecurityVersionOutOfRange));
+            }
+            _serializerEntries.Add(_secureConversation);
+            //TODO later
+            TrustDictionary trustDictionary;
+            if (trustVersion == TrustVersion.WSTrustFeb2005)
+            {
+                _serializerEntries.Add(new WSTrustFeb2005(this));
+                trustDictionary = DXD.TrustDec2005Dictionary;
+            }
+            else if (trustVersion == TrustVersion.WSTrust13)
+            {
+                _serializerEntries.Add(new WSTrustDec2005(this));
+                trustDictionary = DXD.TrustDec2005Dictionary;
+            }
+            else
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new NotSupportedException());
+            }
+
+            _tokenEntries = new List<TokenEntry>();
+
+            for (int i = 0; i < _serializerEntries.Count; ++i)
+            {
+                SerializerEntries serializerEntry = _serializerEntries[i];
+                serializerEntry.PopulateTokenEntries(_tokenEntries);
+            }
+
+          DictionaryManager dictionaryManager = new DictionaryManager(ServiceModelDictionary.CurrentVersion);
+            dictionaryManager.SecureConversationDec2005Dictionary = DXD.SecureConversationDec2005Dictionary;
+            dictionaryManager.SecurityAlgorithmDec2005Dictionary = DXD.SecurityAlgorithmDec2005Dictionary;
+
+            _keyInfoSerializer = new WSKeyInfoSerializer(EmitBspRequiredAttributes, dictionaryManager, trustDictionary, this, securityVersion, secureConversationVersion);
+        }
+
+        public static WSSecurityTokenSerializer DefaultInstance
+        {
+            get
+            {
+                if (s_instance == null)
+                {
+                    s_instance = new WSSecurityTokenSerializer();
+                }
+
+                return s_instance;
+            }
+        }
+
+        public bool EmitBspRequiredAttributes { get; }
+
+        public SecurityVersion SecurityVersion { get; }
+
+        public int MaximumKeyDerivationOffset { get; }
+
+        public int MaximumKeyDerivationLabelLength { get; }
+
+        public int MaximumKeyDerivationNonceLength
+        {
+            get { return _maximumKeyDerivationNonceLength; }
+        }
+
+        private bool ShouldWrapException(Exception e)
+        {
+            if (Fx.IsFatal(e))
+            {
+                return false;
+            }
+            return ((e is ArgumentException) || (e is FormatException) || (e is InvalidOperationException));
+        }
+
+        protected override bool CanReadTokenCore(XmlReader reader)
+        {
+            XmlDictionaryReader localReader = XmlDictionaryReader.CreateDictionaryReader(reader);
+            for (int i = 0; i < _tokenEntries.Count; i++)
+            {
+                TokenEntry tokenEntry = _tokenEntries[i];
+                if (tokenEntry.CanReadTokenCore(localReader))
+                {
+                    return true;
+                }
+            }
+            return false;
+        }
+
+        protected override SecurityToken ReadTokenCore(XmlReader reader, SecurityTokenResolver tokenResolver)
+        {
+            XmlDictionaryReader localReader = XmlDictionaryReader.CreateDictionaryReader(reader);
+            for (int i = 0; i < _tokenEntries.Count; i++)
+            {
+                TokenEntry tokenEntry = _tokenEntries[i];
+                if (tokenEntry.CanReadTokenCore(localReader))
+                {
+                    try
+                    {
+                        return tokenEntry.ReadTokenCore(localReader, tokenResolver);
+                    }
+                    catch (Exception e)
+                    {
+                        if (!ShouldWrapException(e))
+                        {
+                            throw;
+                        }
+                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new XmlException(SR.ErrorDeserializingTokenXml, e));
+                    }
+                }
+            }
+            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new XmlException(SR.Format(SR.CannotReadToken, reader.LocalName, reader.NamespaceURI, localReader.GetAttribute(XD.SecurityJan2004Dictionary.ValueType, null))));
+        }
+
+        protected override bool CanWriteTokenCore(SecurityToken token)
+        {
+            for (int i = 0; i < _tokenEntries.Count; i++)
+            {
+                TokenEntry tokenEntry = _tokenEntries[i];
+                if (tokenEntry.SupportsCore(token.GetType()))
+                {
+                    return true;
+                }
+            }
+            return false;
+        }
+
+        protected override void WriteTokenCore(XmlWriter writer, SecurityToken token)
+        {
+            bool wroteToken = false;
+            XmlDictionaryWriter localWriter = XmlDictionaryWriter.CreateDictionaryWriter(writer);
+            for (int i = 0; i < _tokenEntries.Count; i++)
+            {
+                TokenEntry tokenEntry = _tokenEntries[i];
+                if (tokenEntry.SupportsCore(token.GetType()))
+                {
+                    try
+                    {
+                        tokenEntry.WriteTokenCore(localWriter, token);
+                    }
+                    catch (Exception e)
+                    {
+                        if (!ShouldWrapException(e))
+                        {
+                            throw;
+                        }
+                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new XmlException(SR.Format(SR.ErrorSerializingSecurityToken), e));
+                    }
+                    wroteToken = true;
+                    break;
+                }
+            }
+
+            if (!wroteToken)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.StandardsManagerCannotWriteObject, token.GetType())));
+            }
+
+            localWriter.Flush();
+        }
+
+        protected override bool CanReadKeyIdentifierCore(XmlReader reader)
+        {
+            throw new PlatformNotSupportedException();
+        }
+
+        protected override SecurityKeyIdentifier ReadKeyIdentifierCore(XmlReader reader)
+        {
+            try
+            {
+                return _keyInfoSerializer.ReadKeyIdentifier(reader);
+            }
+            catch (Exception ex)
+            {
+                throw Fx.Exception.AsError(new MessageSecurityException(ex.Message));
+            }
+        }
+
+        protected override bool CanWriteKeyIdentifierCore(SecurityKeyIdentifier keyIdentifier)
+        {
+            throw new PlatformNotSupportedException();
+        }
+
+        protected override void WriteKeyIdentifierCore(XmlWriter writer, SecurityKeyIdentifier keyIdentifier)
+        {
+            try
+            {
+                _keyInfoSerializer.WriteKeyIdentifier(writer, keyIdentifier);
+            }
+            catch (Exception ex)
+            {
+                throw Fx.Exception.AsError(new MessageSecurityException(ex.Message));
+            }
+        }
+
+        protected override bool CanReadKeyIdentifierClauseCore(XmlReader reader)
+        {
+            throw new PlatformNotSupportedException();
+        }
+
+        protected override SecurityKeyIdentifierClause ReadKeyIdentifierClauseCore(XmlReader reader)
+        {
+            try
+            {
+                return _keyInfoSerializer.ReadKeyIdentifierClause(reader);
+            }
+            catch (Exception ex)
+            {
+                throw Fx.Exception.AsError(new MessageSecurityException(ex.Message));
+            }
+        }
+
+        protected override bool CanWriteKeyIdentifierClauseCore(SecurityKeyIdentifierClause keyIdentifierClause)
+        {
+            throw new PlatformNotSupportedException();
+        }
+
+        protected override void WriteKeyIdentifierClauseCore(XmlWriter writer, SecurityKeyIdentifierClause keyIdentifierClause)
+        {
+            try
+            {
+                _keyInfoSerializer.WriteKeyIdentifierClause(writer, keyIdentifierClause);
+            }
+            catch (Exception ex)
+            {
+                throw Fx.Exception.AsError(new MessageSecurityException(ex.Message));
+            }
+        }
+
+        internal Type[] GetTokenTypes(string tokenTypeUri)
+        {
+            if (tokenTypeUri != null)
+            {
+                for (int i = 0; i < _tokenEntries.Count; i++)
+                {
+                    TokenEntry tokenEntry = _tokenEntries[i];
+
+                    if (tokenEntry.SupportsTokenTypeUri(tokenTypeUri))
+                    {
+                        return tokenEntry.GetTokenTypes();
+                    }
+                }
+            }
+            return null;
+        }
+
+        protected internal virtual string GetTokenTypeUri(Type tokenType)
+        {
+            if (tokenType != null)
+            {
+                for (int i = 0; i < _tokenEntries.Count; i++)
+                {
+                    TokenEntry tokenEntry = _tokenEntries[i];
+
+                    if (tokenEntry.SupportsCore(tokenType))
+                    {
+                        return tokenEntry.TokenTypeUri;
+                    }
+                }
+            }
+            return null;
+        }
+
+        public virtual bool TryCreateKeyIdentifierClauseFromTokenXml(XmlElement element, SecurityTokenReferenceStyle tokenReferenceStyle, out SecurityKeyIdentifierClause securityKeyIdentifierClause)
+        {
+            if (element == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(element));
+            }
+
+            securityKeyIdentifierClause = null;
+
+            try
+            {
+                securityKeyIdentifierClause = CreateKeyIdentifierClauseFromTokenXml(element, tokenReferenceStyle);
+            }
+            catch (XmlException)
+            {
+                return false;
+            }
+
+            return true;
+        }
+
+        public virtual SecurityKeyIdentifierClause CreateKeyIdentifierClauseFromTokenXml(XmlElement element, SecurityTokenReferenceStyle tokenReferenceStyle)
+        {
+            if (element == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(element));
+            }
+
+            for (int i = 0; i < _tokenEntries.Count; i++)
+            {
+                TokenEntry tokenEntry = _tokenEntries[i];
+                if (tokenEntry.CanReadTokenCore(element))
+                {
+                    try
+                    {
+                        return tokenEntry.CreateKeyIdentifierClauseFromTokenXmlCore(element, tokenReferenceStyle);
+                    }
+                    catch (Exception e)
+                    {
+                        if (!ShouldWrapException(e))
+                        {
+                            throw;
+                        }
+                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new XmlException(SR.ErrorDeserializingKeyIdentifierClauseFromTokenXml, e));
+                    }
+                }
+            }
+
+            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new XmlException(SR.Format(SR.CannotReadToken, element.LocalName, element.NamespaceURI, element.GetAttribute(SecurityJan2004Strings.ValueType, null))));
+        }
+
+        internal abstract new class TokenEntry
+        {
+            private Type[] _tokenTypes = null;
+            protected abstract XmlDictionaryString LocalName { get; }
+            protected abstract XmlDictionaryString NamespaceUri { get; }
+            public Type TokenType { get { return GetTokenTypes()[0]; } }
+            public abstract string TokenTypeUri { get; }
+            protected abstract string ValueTypeUri { get; }
+
+            protected abstract Type[] GetTokenTypesCore();
+
+            public Type[] GetTokenTypes()
+            {
+                if (_tokenTypes == null)
+                {
+                    _tokenTypes = GetTokenTypesCore();
+                }
+
+                return _tokenTypes;
+            }
+
+            public bool SupportsCore(Type tokenType)
+            {
+                Type[] tokenTypes = GetTokenTypes();
+                for (int i = 0; i < tokenTypes.Length; ++i)
+                {
+                    if (tokenTypes[i].IsAssignableFrom(tokenType))
+                    {
+                        return true;
+                    }
+                }
+                return false;
+            }
+
+            public virtual bool SupportsTokenTypeUri(string tokenTypeUri)
+            {
+                return (TokenTypeUri == tokenTypeUri);
+            }
+
+            protected static SecurityKeyIdentifierClause CreateDirectReference(XmlElement issuedTokenXml, string idAttributeLocalName, string idAttributeNamespace, Type tokenType)
+            {
+                string id = issuedTokenXml.GetAttribute(idAttributeLocalName, idAttributeNamespace);
+                if (id == null)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new XmlException(SR.Format(SR.RequiredAttributeMissing, idAttributeLocalName, issuedTokenXml.LocalName)));
+                }
+                return new LocalIdKeyIdentifierClause(id, tokenType);
+            }
+
+            public virtual bool CanReadTokenCore(XmlElement element)
+            {
+                string valueTypeUri = null;
+
+                if (element.HasAttribute(SecurityJan2004Strings.ValueType, null))
+                {
+                    valueTypeUri = element.GetAttribute(SecurityJan2004Strings.ValueType, null);
+                }
+
+                return element.LocalName == LocalName.Value && element.NamespaceURI == NamespaceUri.Value && valueTypeUri == ValueTypeUri;
+            }
+
+            public virtual bool CanReadTokenCore(XmlDictionaryReader reader)
+            {
+                return reader.IsStartElement(LocalName, NamespaceUri) &&
+                       reader.GetAttribute(XD.SecurityJan2004Dictionary.ValueType, null) == ValueTypeUri;
+            }
+
+            public virtual Task<SecurityToken> ReadTokenCoreAsync(XmlDictionaryReader reader, SecurityTokenResolver tokenResolver)
+            {
+                return Task.FromResult(ReadTokenCore(reader, tokenResolver));
+            }
+
+            public abstract SecurityKeyIdentifierClause CreateKeyIdentifierClauseFromTokenXmlCore(XmlElement issuedTokenXml, SecurityTokenReferenceStyle tokenReferenceStyle);
+
+            public abstract SecurityToken ReadTokenCore(XmlDictionaryReader reader, SecurityTokenResolver tokenResolver);
+
+            public abstract void WriteTokenCore(XmlDictionaryWriter writer, SecurityToken token);
+        }
+
+        internal abstract new class SerializerEntries
+        {
+            public virtual void PopulateTokenEntries(IList<TokenEntry> tokenEntries) { }
+        }
+
+        internal class CollectionDictionary : IXmlDictionary
+        {
+            private List<XmlDictionaryString> _dictionaryStrings;
+
+            public CollectionDictionary(List<XmlDictionaryString> dictionaryStrings)
+            {
+                _dictionaryStrings = dictionaryStrings ?? throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException(nameof(dictionaryStrings)));
+            }
+
+            public bool TryLookup(string value, out XmlDictionaryString result)
+            {
+                if (value == null)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException(nameof(value)));
+                }
+
+                for (int i = 0; i < _dictionaryStrings.Count; ++i)
+                {
+                    if (_dictionaryStrings[i].Value.Equals(value))
+                    {
+                        result = _dictionaryStrings[i];
+                        return true;
+                    }
+                }
+                result = null;
+                return false;
+            }
+
+            public bool TryLookup(int key, out XmlDictionaryString result)
+            {
+                for (int i = 0; i < _dictionaryStrings.Count; ++i)
+                {
+                    if (_dictionaryStrings[i].Key == key)
+                    {
+                        result = _dictionaryStrings[i];
+                        return true;
+                    }
+                }
+                result = null;
+                return false;
+            }
+
+            public bool TryLookup(XmlDictionaryString value, out XmlDictionaryString result)
+            {
+                if (value == null)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException(nameof(value)));
+                }
+
+                for (int i = 0; i < _dictionaryStrings.Count; ++i)
+                {
+                    if ((_dictionaryStrings[i].Key == value.Key) &&
+                        (_dictionaryStrings[i].Value.Equals(value.Value)))
+                    {
+                        result = _dictionaryStrings[i];
+                        return true;
+                    }
+                }
+                result = null;
+                return false;
+            }
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/WSSecurityXXX2005.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/WSSecurityXXX2005.cs
new file mode 100644
index 0000000..4ad18db
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/WSSecurityXXX2005.cs
@@ -0,0 +1,20 @@
+﻿
+using System.Collections.Generic;
+using CoreWCF.IdentityModel.Tokens;
+using TokenEntry = CoreWCF.Security.WSSecurityTokenSerializer.TokenEntry;
+
+namespace CoreWCF.Security
+{
+    internal class WSSecurityXXX2005 : WSSecurityJan2004
+    {
+        public WSSecurityXXX2005(WSSecurityTokenSerializer tokenSerializer, SamlSerializer samlSerializer)
+            : base(tokenSerializer, samlSerializer)
+        {
+        }
+
+        public override void PopulateTokenEntries(IList<TokenEntry> tokenEntryList)
+        {
+            PopulateJan2004TokenEntries(tokenEntryList);
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/WSTrust.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/WSTrust.cs
new file mode 100644
index 0000000..bd3e385
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/WSTrust.cs
@@ -0,0 +1,1664 @@
+namespace CoreWCF.Security
+{
+    using System;
+    using CoreWCF;
+    using CoreWCF.Description;
+    using CoreWCF.Dispatcher;
+    using System.Collections;
+    using System.Collections.Generic;
+    using System.Collections.ObjectModel;
+    using System.Diagnostics;
+    using System.Globalization;
+    using System.IO;
+    using System.Text;
+    using System.Threading;
+    using System.Xml;
+    using CoreWCF.Runtime;
+
+    using System.Security.Cryptography;
+    using CoreWCF.IdentityModel.Claims;
+    using CoreWCF.IdentityModel.Policy;
+    using CoreWCF.IdentityModel.Selectors;
+    using CoreWCF.IdentityModel.Tokens;
+    using System.Security.Cryptography.X509Certificates;
+    using CoreWCF.Security.Tokens;
+// using HexBinary = System.Runtime.Remoting.Metadata.W3cXsd2001.SoapHexBinary;
+    using CoreWCF.Channels;
+    using CoreWCF.Security;
+    using System.Runtime.Serialization;
+
+    using KeyIdentifierEntry = WSSecurityTokenSerializer.KeyIdentifierEntry;
+    using KeyIdentifierClauseEntry = WSSecurityTokenSerializer.KeyIdentifierClauseEntry;
+    using TokenEntry = WSSecurityTokenSerializer.TokenEntry;
+    using StrEntry = WSSecurityTokenSerializer.StrEntry;
+    using Psha1DerivedKeyGenerator = CoreWCF.IdentityModel.Psha1DerivedKeyGenerator;
+    using CoreWCF.IdentityModel;
+
+    abstract class WSTrust : WSSecurityTokenSerializer.SerializerEntries
+    {
+        WSSecurityTokenSerializer tokenSerializer;
+
+        public WSTrust(WSSecurityTokenSerializer tokenSerializer)
+        {
+            this.tokenSerializer = tokenSerializer;
+        }
+
+        public WSSecurityTokenSerializer WSSecurityTokenSerializer
+        {
+            get { return this.tokenSerializer; }
+        }
+
+        public abstract TrustDictionary SerializerDictionary
+        {
+            get;
+        }
+
+        public override void PopulateTokenEntries(IList<TokenEntry> tokenEntryList)
+        {
+            tokenEntryList.Add(new BinarySecretTokenEntry(this));
+        }
+
+        class BinarySecretTokenEntry : TokenEntry
+        {
+            WSTrust parent;
+            TrustDictionary otherDictionary;
+
+            public BinarySecretTokenEntry(WSTrust parent)
+            {
+                this.parent = parent;
+                this.otherDictionary = null;
+
+                if (parent.SerializerDictionary is TrustDec2005Dictionary)
+                {
+                    this.otherDictionary = CoreWCF.XD.TrustFeb2005Dictionary;
+                }
+
+                if (parent.SerializerDictionary is TrustFeb2005Dictionary)
+                {
+                   
+                  this.otherDictionary = DXD.TrustDec2005Dictionary;
+                }
+
+                // always set it, so we don't have to worry about null
+                if (this.otherDictionary == null)
+                    this.otherDictionary = this.parent.SerializerDictionary;
+            }
+
+            protected override XmlDictionaryString LocalName { get { return parent.SerializerDictionary.BinarySecret; } }
+            protected override XmlDictionaryString NamespaceUri { get { return parent.SerializerDictionary.Namespace; } }
+            protected override Type[] GetTokenTypesCore() { return new Type[] { typeof(BinarySecretSecurityToken) }; }
+            public override string TokenTypeUri { get { return null; } }
+            protected override string ValueTypeUri { get { return null; } }
+
+            public override bool CanReadTokenCore(XmlElement element)
+            {
+                string valueTypeUri = null;
+
+                if (element.HasAttribute(SecurityJan2004Strings.ValueType, null))
+                {
+                    valueTypeUri = element.GetAttribute(SecurityJan2004Strings.ValueType, null);
+                }
+
+                return element.LocalName == LocalName.Value && (element.NamespaceURI == NamespaceUri.Value || element.NamespaceURI == this.otherDictionary.Namespace.Value) && valueTypeUri == this.ValueTypeUri;
+            }
+
+            public override bool CanReadTokenCore(XmlDictionaryReader reader)
+            {
+                return (reader.IsStartElement(this.LocalName, this.NamespaceUri) || reader.IsStartElement(this.LocalName, this.otherDictionary.Namespace)) &&
+                       reader.GetAttribute(CoreWCF.XD.SecurityJan2004Dictionary.ValueType, null) == this.ValueTypeUri;
+            }
+
+
+            public override SecurityKeyIdentifierClause CreateKeyIdentifierClauseFromTokenXmlCore(XmlElement issuedTokenXml,
+                SecurityTokenReferenceStyle tokenReferenceStyle)
+            {
+                TokenReferenceStyleHelper.Validate(tokenReferenceStyle);
+
+                switch (tokenReferenceStyle)
+                {
+                    case SecurityTokenReferenceStyle.Internal:
+                        return CreateDirectReference(issuedTokenXml, UtilityStrings.IdAttribute, UtilityStrings.Namespace, typeof(GenericXmlSecurityToken));
+                    case SecurityTokenReferenceStyle.External:
+                        // Binary Secret tokens aren't referred to externally
+                        return null;
+                    default:
+                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("tokenReferenceStyle"));
+                }
+            }
+
+            public override SecurityToken ReadTokenCore(XmlDictionaryReader reader, SecurityTokenResolver tokenResolver)
+            {
+                string secretType = reader.GetAttribute(CoreWCF.XD.SecurityJan2004Dictionary.TypeAttribute, null);
+                string id = reader.GetAttribute(CoreWCF.XD.UtilityDictionary.IdAttribute, CoreWCF.XD.UtilityDictionary.Namespace);
+                bool isNonce = false;
+
+                if (secretType != null && secretType.Length > 0)
+                {
+                    if (secretType == parent.SerializerDictionary.NonceBinarySecret.Value || secretType == otherDictionary.NonceBinarySecret.Value)
+                    {
+                        isNonce = true;
+                    }
+                    else if (secretType != parent.SerializerDictionary.SymmetricKeyBinarySecret.Value && secretType != otherDictionary.SymmetricKeyBinarySecret.Value)
+                    {
+                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new MessageSecurityException(SR.Format(SR.UnexpectedBinarySecretType, parent.SerializerDictionary.SymmetricKeyBinarySecret.Value, secretType)));
+                    }
+                }
+
+                byte[] secret = reader.ReadElementContentAsBase64();
+                if (isNonce)
+                {
+                    return new NonceToken(id, secret);
+                }
+                else
+                {
+                    return new BinarySecretSecurityToken(id, secret);
+                }
+            }
+
+            public override void WriteTokenCore(XmlDictionaryWriter writer, SecurityToken token)
+            {
+                BinarySecretSecurityToken simpleToken = token as BinarySecretSecurityToken;
+                byte[] secret = simpleToken.GetKeyBytes();
+                writer.WriteStartElement(parent.SerializerDictionary.Prefix.Value, parent.SerializerDictionary.BinarySecret, parent.SerializerDictionary.Namespace);
+                if (simpleToken.Id != null)
+                {
+                    writer.WriteAttributeString(CoreWCF.XD.UtilityDictionary.Prefix.Value, CoreWCF.XD.UtilityDictionary.IdAttribute, CoreWCF.XD.UtilityDictionary.Namespace, simpleToken.Id);
+                }
+                if (token is NonceToken)
+                {
+                    writer.WriteAttributeString(CoreWCF.XD.SecurityJan2004Dictionary.TypeAttribute, null, parent.SerializerDictionary.NonceBinarySecret.Value);
+                }
+                writer.WriteBase64(secret, 0, secret.Length);
+                writer.WriteEndElement();
+            }
+
+        }
+
+        public abstract class Driver : TrustDriver
+        {
+            static readonly string base64Uri = SecurityJan2004Strings.EncodingTypeValueBase64Binary;
+            static readonly string hexBinaryUri = SecurityJan2004Strings.EncodingTypeValueHexBinary;
+
+
+            SecurityStandardsManager standardsManager;
+            List<SecurityTokenAuthenticator> entropyAuthenticators;
+
+            public Driver(SecurityStandardsManager standardsManager)
+            {
+                this.standardsManager = standardsManager;
+                this.entropyAuthenticators = new List<SecurityTokenAuthenticator>(2);
+            }
+
+            public abstract TrustDictionary DriverDictionary
+            {
+                get;
+            }
+
+            public override XmlDictionaryString RequestSecurityTokenAction
+            {
+                get
+                {
+                    return DriverDictionary.RequestSecurityTokenIssuance;
+                }
+            }
+
+            public override XmlDictionaryString RequestSecurityTokenResponseAction
+            {
+                get
+                {
+                    return DriverDictionary.RequestSecurityTokenIssuanceResponse;
+                }
+            }
+
+            public override string RequestTypeIssue
+            {
+                get
+                {
+                    return DriverDictionary.RequestTypeIssue.Value;
+                }
+            }
+
+            public override string ComputedKeyAlgorithm
+            {
+                get { return DriverDictionary.Psha1ComputedKeyUri.Value; }
+            }
+
+            public override SecurityStandardsManager StandardsManager
+            {
+                get
+                {
+                    return this.standardsManager;
+                }
+            }
+
+            public override XmlDictionaryString Namespace
+            {
+                get { return DriverDictionary.Namespace; }
+            }
+
+            public override RequestSecurityToken CreateRequestSecurityToken(XmlReader xmlReader)
+            {
+                XmlDictionaryReader reader = XmlDictionaryReader.CreateDictionaryReader(xmlReader);
+                reader.MoveToStartElement(DriverDictionary.RequestSecurityToken, DriverDictionary.Namespace);
+                string context = null;
+                string tokenTypeUri = null;
+                string requestType = null;
+                int keySize = 0;
+                XmlDocument doc = new XmlDocument();
+                XmlElement rstXml = (doc.ReadNode(reader) as XmlElement);
+                SecurityKeyIdentifierClause renewTarget = null;
+                SecurityKeyIdentifierClause closeTarget = null;
+                for (int i = 0; i < rstXml.Attributes.Count; ++i)
+                {
+                    XmlAttribute attr = rstXml.Attributes[i];
+                    if (attr.LocalName == DriverDictionary.Context.Value)
+                    {
+                        context = attr.Value;
+                    }
+                }
+                for (int i = 0; i < rstXml.ChildNodes.Count; ++i)
+                {
+                    XmlElement child = (rstXml.ChildNodes[i] as XmlElement);
+                    if (child != null)
+                    {
+                        if (child.LocalName == DriverDictionary.TokenType.Value && child.NamespaceURI == DriverDictionary.Namespace.Value)
+                            tokenTypeUri = XmlHelper.ReadTextElementAsTrimmedString(child);
+                        else if (child.LocalName == DriverDictionary.RequestType.Value && child.NamespaceURI == DriverDictionary.Namespace.Value)
+                            requestType = XmlHelper.ReadTextElementAsTrimmedString(child);
+                        else if (child.LocalName == DriverDictionary.KeySize.Value && child.NamespaceURI == DriverDictionary.Namespace.Value)
+                            keySize = Int32.Parse(XmlHelper.ReadTextElementAsTrimmedString(child), NumberFormatInfo.InvariantInfo);
+                    }
+                }
+
+                ReadTargets(rstXml, out renewTarget, out closeTarget);
+
+                RequestSecurityToken rst = new RequestSecurityToken(standardsManager, rstXml, context, tokenTypeUri, requestType, keySize, renewTarget, closeTarget);
+                return rst;
+            }
+
+            CoreWCF.IdentityModel.XmlBuffer GetIssuedTokenBuffer(CoreWCF.IdentityModel.XmlBuffer rstrBuffer)
+            {
+                CoreWCF.IdentityModel.XmlBuffer issuedTokenBuffer = null;
+                using (XmlDictionaryReader reader = rstrBuffer.GetReader(0))
+                {
+                    reader.ReadFullStartElement();
+                    while (reader.IsStartElement())
+                    {
+                        if (reader.IsStartElement(this.DriverDictionary.RequestedSecurityToken, this.DriverDictionary.Namespace))
+                        {
+                            reader.ReadStartElement();
+                            reader.MoveToContent();
+                            issuedTokenBuffer = new CoreWCF.IdentityModel.XmlBuffer(Int32.MaxValue);
+                            using (XmlDictionaryWriter writer = issuedTokenBuffer.OpenSection(reader.Quotas))
+                            {
+                                writer.WriteNode(reader, false);
+                                issuedTokenBuffer.CloseSection();
+                                issuedTokenBuffer.Close();
+                            }
+                            reader.ReadEndElement();
+                            break;
+                        }
+                        else
+                        {
+                            reader.Skip();
+                        }
+                    }
+                }
+                return issuedTokenBuffer;
+            }
+
+            public override RequestSecurityTokenResponse CreateRequestSecurityTokenResponse(XmlReader xmlReader)
+            {
+                if (xmlReader == null)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("xmlReader");
+                }
+                XmlDictionaryReader reader = XmlDictionaryReader.CreateDictionaryReader(xmlReader);
+                if (reader.IsStartElement(DriverDictionary.RequestSecurityTokenResponse, DriverDictionary.Namespace) == false)
+                {
+                    XmlHelper.OnRequiredElementMissing(DriverDictionary.RequestSecurityTokenResponse.Value, DriverDictionary.Namespace.Value);
+                }
+
+                CoreWCF.IdentityModel.XmlBuffer rstrBuffer = new CoreWCF.IdentityModel.XmlBuffer(Int32.MaxValue);
+                using (XmlDictionaryWriter writer = rstrBuffer.OpenSection(reader.Quotas))
+                {
+                    writer.WriteNode(reader, false);
+                    rstrBuffer.CloseSection();
+                    rstrBuffer.Close();
+                }
+                XmlDocument doc = new XmlDocument();
+                XmlElement rstrXml;
+                using (XmlReader reader2 = rstrBuffer.GetReader(0))
+                {
+                    rstrXml = (doc.ReadNode(reader2) as XmlElement);
+                }
+
+                CoreWCF.IdentityModel.XmlBuffer issuedTokenBuffer = GetIssuedTokenBuffer(rstrBuffer);
+                string context = null;
+                string tokenTypeUri = null;
+                int keySize = 0;
+                SecurityKeyIdentifierClause requestedAttachedReference = null;
+                SecurityKeyIdentifierClause requestedUnattachedReference = null;
+                bool computeKey = false;
+                DateTime created = DateTime.UtcNow;
+                DateTime expires = SecurityUtils.MaxUtcDateTime;
+                bool isRequestedTokenClosed = false;
+                for (int i = 0; i < rstrXml.Attributes.Count; ++i)
+                {
+                    XmlAttribute attr = rstrXml.Attributes[i];
+                    if (attr.LocalName == DriverDictionary.Context.Value)
+                    {
+                        context = attr.Value;
+                    }
+                }
+
+                for (int i = 0; i < rstrXml.ChildNodes.Count; ++i)
+                {
+                    XmlElement child = (rstrXml.ChildNodes[i] as XmlElement);
+                    if (child != null)
+                    {
+                        if (child.LocalName == DriverDictionary.TokenType.Value && child.NamespaceURI == DriverDictionary.Namespace.Value)
+                            tokenTypeUri = XmlHelper.ReadTextElementAsTrimmedString(child);
+                        else if (child.LocalName == DriverDictionary.KeySize.Value && child.NamespaceURI == DriverDictionary.Namespace.Value)
+                            keySize = Int32.Parse(XmlHelper.ReadTextElementAsTrimmedString(child), NumberFormatInfo.InvariantInfo);
+                        else if (child.LocalName == DriverDictionary.RequestedProofToken.Value && child.NamespaceURI == DriverDictionary.Namespace.Value)
+                        {
+                            XmlElement proofXml = XmlHelper.GetChildElement(child);
+                            if (proofXml.LocalName == DriverDictionary.ComputedKey.Value && proofXml.NamespaceURI == DriverDictionary.Namespace.Value)
+                            {
+                                string computedKeyAlgorithm = XmlHelper.ReadTextElementAsTrimmedString(proofXml);
+                                if (computedKeyAlgorithm != this.DriverDictionary.Psha1ComputedKeyUri.Value)
+                                {
+                                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new SecurityNegotiationException(SR.Format(SR.UnknownComputedKeyAlgorithm, computedKeyAlgorithm)));
+                                }
+                                computeKey = true;
+                            }
+                        }
+                        else if (child.LocalName == DriverDictionary.Lifetime.Value && child.NamespaceURI == DriverDictionary.Namespace.Value)
+                        {
+                            XmlElement createdXml = XmlHelper.GetChildElement(child, UtilityStrings.CreatedElement, UtilityStrings.Namespace);
+                            if (createdXml != null)
+                            {
+                                created = DateTime.ParseExact(XmlHelper.ReadTextElementAsTrimmedString(createdXml),
+                                    WSUtilitySpecificationVersion.AcceptedDateTimeFormats, DateTimeFormatInfo.InvariantInfo, DateTimeStyles.None).ToUniversalTime();
+                            }
+                            XmlElement expiresXml = XmlHelper.GetChildElement(child, UtilityStrings.ExpiresElement, UtilityStrings.Namespace);
+                            if (expiresXml != null)
+                            {
+                                expires = DateTime.ParseExact(XmlHelper.ReadTextElementAsTrimmedString(expiresXml),
+                                    WSUtilitySpecificationVersion.AcceptedDateTimeFormats, DateTimeFormatInfo.InvariantInfo, DateTimeStyles.None).ToUniversalTime();
+                            }
+                        }
+                    }
+                }
+
+                isRequestedTokenClosed = ReadRequestedTokenClosed(rstrXml);
+                ReadReferences(rstrXml, out requestedAttachedReference, out requestedUnattachedReference);
+
+                return new RequestSecurityTokenResponse(standardsManager, rstrXml, context, tokenTypeUri, keySize, requestedAttachedReference, requestedUnattachedReference,
+                                                        computeKey, created, expires, isRequestedTokenClosed, issuedTokenBuffer);
+            }
+
+            public override RequestSecurityTokenResponseCollection CreateRequestSecurityTokenResponseCollection(XmlReader xmlReader)
+            {
+                XmlDictionaryReader reader = XmlDictionaryReader.CreateDictionaryReader(xmlReader);
+                List<RequestSecurityTokenResponse> rstrCollection = new List<RequestSecurityTokenResponse>(2);
+                string rootName = reader.Name;
+                reader.ReadStartElement(DriverDictionary.RequestSecurityTokenResponseCollection, DriverDictionary.Namespace);
+                while (reader.IsStartElement(DriverDictionary.RequestSecurityTokenResponse.Value, DriverDictionary.Namespace.Value))
+                {
+                    RequestSecurityTokenResponse rstr = this.CreateRequestSecurityTokenResponse(reader);
+                    rstrCollection.Add(rstr);
+                }
+                reader.ReadEndElement();
+                if (rstrCollection.Count == 0)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new XmlException(SR.Format(SR.NoRequestSecurityTokenResponseElements)));
+                return new RequestSecurityTokenResponseCollection(rstrCollection.AsReadOnly(), this.StandardsManager);
+            }
+
+            XmlElement GetAppliesToElement(XmlElement rootElement)
+            {
+                if (rootElement == null)
+                {
+                    return null;
+                }
+                for (int i = 0; i < rootElement.ChildNodes.Count; ++i)
+                {
+                    XmlElement elem = (rootElement.ChildNodes[i] as XmlElement);
+                    if (elem != null)
+                    {
+                        if (elem.LocalName == DriverDictionary.AppliesTo.Value && elem.NamespaceURI == Namespaces.WSPolicy)
+                        {
+                            return elem;
+                        }
+                    }
+                }
+                return null;
+            }
+
+            T GetAppliesTo<T>(XmlElement rootXml, XmlObjectSerializer serializer)
+            {
+                XmlElement appliesToElement = GetAppliesToElement(rootXml);
+                if (appliesToElement != null)
+                {
+                    using (XmlReader reader = new XmlNodeReader(appliesToElement))
+                    {
+                        reader.ReadStartElement();
+                        lock (serializer)
+                        {
+                            return (T)serializer.ReadObject(reader);
+                        }
+                    }
+                }
+                else
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.NoAppliesToPresent)));
+                }
+            }
+
+            public override T GetAppliesTo<T>(RequestSecurityToken rst, XmlObjectSerializer serializer)
+            {
+                if (rst == null)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("rst");
+
+                return GetAppliesTo<T>(rst.RequestSecurityTokenXml, serializer);
+            }
+
+            public override T GetAppliesTo<T>(RequestSecurityTokenResponse rstr, XmlObjectSerializer serializer)
+            {
+                if (rstr == null)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("rstr");
+
+                return GetAppliesTo<T>(rstr.RequestSecurityTokenResponseXml, serializer);
+            }
+
+            public override bool IsAppliesTo(string localName, string namespaceUri)
+            {
+                return (localName == DriverDictionary.AppliesTo.Value && namespaceUri == Namespaces.WSPolicy);
+            }
+
+            void GetAppliesToQName(XmlElement rootElement, out string localName, out string namespaceUri)
+            {
+                localName = namespaceUri = null;
+                XmlElement appliesToElement = GetAppliesToElement(rootElement);
+                if (appliesToElement != null)
+                {
+                    using (XmlReader reader = new XmlNodeReader(appliesToElement))
+                    {
+                        reader.ReadStartElement();
+                        reader.MoveToContent();
+                        localName = reader.LocalName;
+                        namespaceUri = reader.NamespaceURI;
+                    }
+                }
+            }
+
+            public override void GetAppliesToQName(RequestSecurityToken rst, out string localName, out string namespaceUri)
+            {
+                if (rst == null)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("rst");
+
+                GetAppliesToQName(rst.RequestSecurityTokenXml, out localName, out namespaceUri);
+            }
+
+            public override void GetAppliesToQName(RequestSecurityTokenResponse rstr, out string localName, out string namespaceUri)
+            {
+                if (rstr == null)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("rstr");
+
+                GetAppliesToQName(rstr.RequestSecurityTokenResponseXml, out localName, out namespaceUri);
+            }
+
+            public override byte[] GetAuthenticator(RequestSecurityTokenResponse rstr)
+            {
+                if (rstr != null && rstr.RequestSecurityTokenResponseXml != null && rstr.RequestSecurityTokenResponseXml.ChildNodes != null)
+                {
+                    for (int i = 0; i < rstr.RequestSecurityTokenResponseXml.ChildNodes.Count; ++i)
+                    {
+                        XmlElement element = rstr.RequestSecurityTokenResponseXml.ChildNodes[i] as XmlElement;
+                        if (element != null)
+                        {
+                            if (element.LocalName == DriverDictionary.Authenticator.Value && element.NamespaceURI == DriverDictionary.Namespace.Value)
+                            {
+                                XmlElement combinedHashElement = XmlHelper.GetChildElement(element);
+                                if (combinedHashElement.LocalName == DriverDictionary.CombinedHash.Value && combinedHashElement.NamespaceURI == DriverDictionary.Namespace.Value)
+                                {
+                                    string authenticatorString = XmlHelper.ReadTextElementAsTrimmedString(combinedHashElement);
+                                    return Convert.FromBase64String(authenticatorString);
+                                }
+                            }
+                        }
+                    }
+                }
+                return null;
+            }
+
+            public override BinaryNegotiation GetBinaryNegotiation(RequestSecurityTokenResponse rstr)
+            {
+                if (rstr == null)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("rstr");
+
+                return GetBinaryNegotiation(rstr.RequestSecurityTokenResponseXml);
+            }
+
+            public override BinaryNegotiation GetBinaryNegotiation(RequestSecurityToken rst)
+            {
+                if (rst == null)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("rst");
+
+                return GetBinaryNegotiation(rst.RequestSecurityTokenXml);
+            }
+
+            BinaryNegotiation GetBinaryNegotiation(XmlElement rootElement)
+            {
+                if (rootElement == null)
+                {
+                    return null;
+                }
+                for (int i = 0; i < rootElement.ChildNodes.Count; ++i)
+                {
+                    XmlElement elem = rootElement.ChildNodes[i] as XmlElement;
+                    if (elem != null)
+                    {
+                        if (elem.LocalName == DriverDictionary.BinaryExchange.Value && elem.NamespaceURI == DriverDictionary.Namespace.Value)
+                        {
+                            return ReadBinaryNegotiation(elem);
+                        }
+                    }
+                }
+                return null;
+            }
+
+            public override SecurityToken GetEntropy(RequestSecurityToken rst, SecurityTokenResolver resolver)
+            {
+                if (rst == null)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("rst");
+
+                return GetEntropy(rst.RequestSecurityTokenXml, resolver);
+            }
+
+            public override SecurityToken GetEntropy(RequestSecurityTokenResponse rstr, SecurityTokenResolver resolver)
+            {
+                if (rstr == null)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("rstr");
+
+                return GetEntropy(rstr.RequestSecurityTokenResponseXml, resolver);
+            }
+
+            SecurityToken GetEntropy(XmlElement rootElement, SecurityTokenResolver resolver)
+            {
+                if (rootElement == null || rootElement.ChildNodes == null)
+                {
+                    return null;
+                }
+                for (int i = 0; i < rootElement.ChildNodes.Count; ++i)
+                {
+                    XmlElement element = rootElement.ChildNodes[i] as XmlElement;
+                    if (element != null)
+                    {
+                        if (element.LocalName == DriverDictionary.Entropy.Value && element.NamespaceURI == DriverDictionary.Namespace.Value)
+                        {
+                            XmlElement tokenXml = XmlHelper.GetChildElement(element);
+                            string valueTypeUri = element.GetAttribute(SecurityJan2004Strings.ValueType);
+                            if (valueTypeUri.Length == 0)
+                                valueTypeUri = null;
+                            return standardsManager.SecurityTokenSerializer.ReadToken(new XmlNodeReader(tokenXml), resolver);
+                        }
+                    }
+                }
+                return null;
+            }
+
+            void GetIssuedAndProofXml(RequestSecurityTokenResponse rstr, out XmlElement issuedTokenXml, out XmlElement proofTokenXml)
+            {
+                issuedTokenXml = null;
+                proofTokenXml = null;
+                if ((rstr.RequestSecurityTokenResponseXml != null) && (rstr.RequestSecurityTokenResponseXml.ChildNodes != null))
+                {
+                    for (int i = 0; i < rstr.RequestSecurityTokenResponseXml.ChildNodes.Count; ++i)
+                    {
+                        XmlElement elem = rstr.RequestSecurityTokenResponseXml.ChildNodes[i] as XmlElement;
+                        if (elem != null)
+                        {
+                            if (elem.LocalName == DriverDictionary.RequestedSecurityToken.Value && elem.NamespaceURI == DriverDictionary.Namespace.Value)
+                            {
+                                if (issuedTokenXml != null)
+                                {
+                                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.RstrHasMultipleIssuedTokens)));
+                                }
+                                issuedTokenXml = XmlHelper.GetChildElement(elem);
+                            }
+                            else if (elem.LocalName == DriverDictionary.RequestedProofToken.Value && elem.NamespaceURI == DriverDictionary.Namespace.Value)
+                            {
+                                if (proofTokenXml != null)
+                                {
+                                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.RstrHasMultipleProofTokens)));
+                                }
+                                proofTokenXml = XmlHelper.GetChildElement(elem);
+                            }
+                        }
+                    }
+                }
+            }
+
+            /// <summary>
+            /// The algorithm for computing the key is:
+            /// 1. If there is requestorEntropy:
+            ///    a. If there is no <RequestedProofToken> use the requestorEntropy as the key
+            ///    b. If there is a <RequestedProofToken> with a ComputedKeyUri, combine the client and server entropies
+            ///    c. Anything else, throw
+            /// 2. If there is no requestorEntropy:
+            ///    a. THere has to be a <RequestedProofToken> that contains the proof key
+            /// </summary>
+            public override GenericXmlSecurityToken GetIssuedToken(RequestSecurityTokenResponse rstr, SecurityTokenResolver resolver, IList<SecurityTokenAuthenticator> allowedAuthenticators, SecurityKeyEntropyMode keyEntropyMode, byte[] requestorEntropy, string expectedTokenType,
+                ReadOnlyCollection<IAuthorizationPolicy> authorizationPolicies, int defaultKeySize, bool isBearerKeyType)
+            {
+
+                SecurityKeyEntropyModeHelper.Validate(keyEntropyMode);
+
+                if (defaultKeySize < 0)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("defaultKeySize", SR.Format(SR.ValueMustBeNonNegative)));
+                }
+
+                if (rstr == null)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("rstr");
+
+                string tokenType;
+                if (rstr.TokenType != null)
+                {
+                    if (expectedTokenType != null && expectedTokenType != rstr.TokenType)
+                    {
+                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.BadIssuedTokenType, rstr.TokenType, expectedTokenType)));
+                    }
+                    tokenType = rstr.TokenType;
+                }
+                else
+                {
+                    tokenType = expectedTokenType;
+                }
+
+                // search the response elements for licenseXml, proofXml, and lifetime
+                DateTime created = rstr.ValidFrom;
+                DateTime expires = rstr.ValidTo;
+                XmlElement proofXml;
+                XmlElement issuedTokenXml;
+                GetIssuedAndProofXml(rstr, out issuedTokenXml, out proofXml);
+
+                if (issuedTokenXml == null)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.NoLicenseXml)));
+
+                if (isBearerKeyType)
+                {
+                    if (proofXml != null)
+                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.BearerKeyTypeCannotHaveProofKey)));
+
+                    return new GenericXmlSecurityToken(issuedTokenXml, null, created, expires, rstr.RequestedAttachedReference, rstr.RequestedUnattachedReference, authorizationPolicies);
+                }
+
+                SecurityToken proofToken;
+                SecurityToken entropyToken = GetEntropy(rstr, resolver);
+                if (keyEntropyMode == SecurityKeyEntropyMode.ClientEntropy)
+                {
+                    if (requestorEntropy == null)
+                    {
+                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.EntropyModeRequiresRequestorEntropy, keyEntropyMode)));
+                    }
+                    // enforce that there is no entropy or proof token in the RSTR
+                    if (proofXml != null || entropyToken != null)
+                    {
+                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.EntropyModeCannotHaveProofTokenOrIssuerEntropy, keyEntropyMode)));
+                    }
+                    proofToken = new BinarySecretSecurityToken(requestorEntropy);
+                }
+                else if (keyEntropyMode == SecurityKeyEntropyMode.ServerEntropy)
+                {
+                    if (requestorEntropy != null)
+                    {
+                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.EntropyModeCannotHaveRequestorEntropy, keyEntropyMode)));
+                    }
+                    if (rstr.ComputeKey || entropyToken != null)
+                    {
+                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.EntropyModeCannotHaveComputedKey, keyEntropyMode)));
+                    }
+                    if (proofXml == null)
+                    {
+                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.EntropyModeRequiresProofToken, keyEntropyMode)));
+                    }
+                    string valueTypeUri = proofXml.GetAttribute(SecurityJan2004Strings.ValueType);
+                    if (valueTypeUri.Length == 0)
+                        valueTypeUri = null;
+                    proofToken = standardsManager.SecurityTokenSerializer.ReadToken(new XmlNodeReader(proofXml), resolver);
+                }
+                else
+                {
+                    if (!rstr.ComputeKey)
+                    {
+                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.EntropyModeRequiresComputedKey, keyEntropyMode)));
+                    }
+                    if (entropyToken == null)
+                    {
+                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.EntropyModeRequiresIssuerEntropy, keyEntropyMode)));
+                    }
+                    if (requestorEntropy == null)
+                    {
+                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.EntropyModeRequiresRequestorEntropy, keyEntropyMode)));
+                    }
+                    if (rstr.KeySize == 0 && defaultKeySize == 0)
+                    {
+                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.RstrKeySizeNotProvided)));
+                    }
+                    int issuedKeySize = (rstr.KeySize != 0) ? rstr.KeySize : defaultKeySize;
+                    byte[] issuerEntropy;
+                    if (entropyToken is BinarySecretSecurityToken)
+                        issuerEntropy = ((BinarySecretSecurityToken)entropyToken).GetKeyBytes();
+                    else if (entropyToken is WrappedKeySecurityToken)
+                        issuerEntropy = ((WrappedKeySecurityToken)entropyToken).GetWrappedKey();
+                    else
+                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new NotSupportedException(SR.Format(SR.UnsupportedIssuerEntropyType)));
+                    // compute the PSHA1 derived key
+                    byte[] issuedKey = RequestSecurityTokenResponse.ComputeCombinedKey(requestorEntropy, issuerEntropy, issuedKeySize);
+                    proofToken = new BinarySecretSecurityToken(issuedKey);
+                }
+
+                SecurityKeyIdentifierClause internalReference = rstr.RequestedAttachedReference;
+                SecurityKeyIdentifierClause externalReference = rstr.RequestedUnattachedReference;
+
+                return new BufferedGenericXmlSecurityToken(issuedTokenXml, proofToken, created, expires, internalReference, externalReference, authorizationPolicies, rstr.IssuedTokenBuffer);
+            }
+
+            public override GenericXmlSecurityToken GetIssuedToken(RequestSecurityTokenResponse rstr, string expectedTokenType,
+                ReadOnlyCollection<IAuthorizationPolicy> authorizationPolicies, RSA clientKey)
+            {
+                if (rstr == null)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException("rstr"));
+
+                string tokenType;
+                if (rstr.TokenType != null)
+                {
+                    if (expectedTokenType != null && expectedTokenType != rstr.TokenType)
+                    {
+                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.BadIssuedTokenType, rstr.TokenType, expectedTokenType)));
+                    }
+                    tokenType = rstr.TokenType;
+                }
+                else
+                {
+                    tokenType = expectedTokenType;
+                }
+
+                // search the response elements for licenseXml, proofXml, and lifetime
+                DateTime created = rstr.ValidFrom;
+                DateTime expires = rstr.ValidTo;
+                XmlElement proofXml;
+                XmlElement issuedTokenXml;
+                GetIssuedAndProofXml(rstr, out issuedTokenXml, out proofXml);
+
+                if (issuedTokenXml == null)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.NoLicenseXml)));
+
+                // enforce that there is no proof token in the RSTR
+                if (proofXml != null)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.ProofTokenXmlUnexpectedInRstr)));
+                }
+                SecurityKeyIdentifierClause internalReference = rstr.RequestedAttachedReference;
+                SecurityKeyIdentifierClause externalReference = rstr.RequestedUnattachedReference;
+
+                SecurityToken proofToken = new RsaSecurityToken(clientKey);
+                return new BufferedGenericXmlSecurityToken(issuedTokenXml, proofToken, created, expires, internalReference, externalReference, authorizationPolicies, rstr.IssuedTokenBuffer);
+            }
+
+            public override bool IsAtRequestSecurityTokenResponse(XmlReader reader)
+            {
+                if (reader == null)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("reader");
+
+                return reader.IsStartElement(DriverDictionary.RequestSecurityTokenResponse.Value, DriverDictionary.Namespace.Value);
+            }
+
+            public override bool IsAtRequestSecurityTokenResponseCollection(XmlReader reader)
+            {
+                if (reader == null)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("reader");
+
+                return reader.IsStartElement(DriverDictionary.RequestSecurityTokenResponseCollection.Value, DriverDictionary.Namespace.Value);
+            }
+
+            public override bool IsRequestedSecurityTokenElement(string name, string nameSpace)
+            {
+                return (name == DriverDictionary.RequestedSecurityToken.Value && nameSpace == DriverDictionary.Namespace.Value);
+            }
+
+            public override bool IsRequestedProofTokenElement(string name, string nameSpace)
+            {
+                return (name == DriverDictionary.RequestedProofToken.Value && nameSpace == DriverDictionary.Namespace.Value);
+            }
+
+            public static BinaryNegotiation ReadBinaryNegotiation(XmlElement elem)
+            {
+                if (elem == null)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("elem");
+
+                // get the encoding and valueType attributes
+                string encodingUri = null;
+                string valueTypeUri = null;
+                byte[] negotiationData = null;
+                if (elem.Attributes != null)
+                {
+                    for (int i = 0; i < elem.Attributes.Count; ++i)
+                    {
+                        XmlAttribute attr = elem.Attributes[i];
+                        if (attr.LocalName == SecurityJan2004Strings.EncodingType && attr.NamespaceURI.Length == 0)
+                        {
+                            encodingUri = attr.Value;
+                            if (encodingUri != base64Uri && encodingUri != hexBinaryUri)
+                            {
+                                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new XmlException(SR.Format(SR.UnsupportedBinaryEncoding, encodingUri)));
+                            }
+                        }
+                        else if (attr.LocalName == SecurityJan2004Strings.ValueType && attr.NamespaceURI.Length == 0)
+                        {
+                            valueTypeUri = attr.Value;
+                        }
+                        // ignore all other attributes
+                    }
+                }
+                if (encodingUri == null)
+                {
+                    XmlHelper.OnRequiredAttributeMissing("EncodingType", elem.Name);
+                }
+                if (valueTypeUri == null)
+                {
+                    XmlHelper.OnRequiredAttributeMissing("ValueType", elem.Name);
+                }
+                string encodedBlob = XmlHelper.ReadTextElementAsTrimmedString(elem);
+                if (encodingUri == base64Uri)
+                {
+                    negotiationData = Convert.FromBase64String(encodedBlob);
+                }
+                else
+                {
+                    throw new NotImplementedException();
+                   // negotiationData = HexBinary.Parse(encodedBlob).Value;
+                }
+                return new BinaryNegotiation(valueTypeUri, negotiationData);
+            }
+
+            // Note in Apr2004, internal & external references aren't supported - 
+            // our strategy is to see if there's a token reference (and use it for external ref) and backup is to scan the token xml to compute reference
+            protected virtual void ReadReferences(XmlElement rstrXml, out SecurityKeyIdentifierClause requestedAttachedReference,
+                    out SecurityKeyIdentifierClause requestedUnattachedReference)
+            {
+                XmlElement issuedTokenXml = null;
+                requestedAttachedReference = null;
+                requestedUnattachedReference = null;
+                for (int i = 0; i < rstrXml.ChildNodes.Count; ++i)
+                {
+                    XmlElement child = rstrXml.ChildNodes[i] as XmlElement;
+                    if (child != null)
+                    {
+                        if (child.LocalName == DriverDictionary.RequestedSecurityToken.Value && child.NamespaceURI == DriverDictionary.Namespace.Value)
+                        {
+                            issuedTokenXml = XmlHelper.GetChildElement(child);
+                        }
+                        else if (child.LocalName == DriverDictionary.RequestedTokenReference.Value && child.NamespaceURI == DriverDictionary.Namespace.Value)
+                        {
+                            requestedUnattachedReference = GetKeyIdentifierXmlReferenceClause(XmlHelper.GetChildElement(child));
+                        }
+                    }
+                }
+
+                if (issuedTokenXml != null)
+                {
+                    requestedAttachedReference = standardsManager.CreateKeyIdentifierClauseFromTokenXml(issuedTokenXml, SecurityTokenReferenceStyle.Internal);
+                    if (requestedUnattachedReference == null)
+                    {
+                        try
+                        {
+                            requestedUnattachedReference = standardsManager.CreateKeyIdentifierClauseFromTokenXml(issuedTokenXml, SecurityTokenReferenceStyle.External);
+                        }
+                        catch (XmlException)
+                        {
+                            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new XmlException(SR.Format(SR.TrustDriverIsUnableToCreatedNecessaryAttachedOrUnattachedReferences, issuedTokenXml.ToString())));
+                        }
+                    }
+                }
+            }
+
+            internal bool TryReadKeyIdentifierClause(XmlNodeReader reader, out SecurityKeyIdentifierClause keyIdentifierClause)
+            {
+                keyIdentifierClause = null;
+
+                try
+                {
+                    keyIdentifierClause = standardsManager.SecurityTokenSerializer.ReadKeyIdentifierClause(reader);
+                }
+                catch (XmlException e)
+                {
+                    if (Fx.IsFatal(e))
+                    {
+                        throw;
+                    }
+
+                    keyIdentifierClause = null;
+                    return false;
+                }
+                catch (Exception e)
+                {
+                    if (Fx.IsFatal(e))
+                    {
+                        throw;
+                    }
+
+                    keyIdentifierClause = null;
+                    return false;
+                }
+
+                return true;
+            }
+
+            internal SecurityKeyIdentifierClause CreateGenericXmlSecurityKeyIdentifierClause(XmlNodeReader reader, XmlElement keyIdentifierReferenceXmlElement)
+            {
+                SecurityKeyIdentifierClause keyIdentifierClause = null;
+                XmlDictionaryReader localReader = XmlDictionaryReader.CreateDictionaryReader(reader);
+                string strId = localReader.GetAttribute(CoreWCF.XD.UtilityDictionary.IdAttribute, CoreWCF.XD.UtilityDictionary.Namespace);
+                keyIdentifierClause = new GenericXmlSecurityKeyIdentifierClause(keyIdentifierReferenceXmlElement);
+                if (!String.IsNullOrEmpty(strId))
+                {
+                    keyIdentifierClause.Id = strId;
+                }
+                return keyIdentifierClause;
+            }
+
+            internal SecurityKeyIdentifierClause GetKeyIdentifierXmlReferenceClause(XmlElement keyIdentifierReferenceXmlElement)
+            {
+                SecurityKeyIdentifierClause keyIdentifierClause = null;
+                XmlNodeReader reader = new XmlNodeReader(keyIdentifierReferenceXmlElement);
+                if (!this.TryReadKeyIdentifierClause(reader, out keyIdentifierClause))
+                {
+                    keyIdentifierClause = CreateGenericXmlSecurityKeyIdentifierClause(new XmlNodeReader(keyIdentifierReferenceXmlElement), keyIdentifierReferenceXmlElement);
+                }
+
+                return keyIdentifierClause;
+            }
+
+            protected virtual bool ReadRequestedTokenClosed(XmlElement rstrXml)
+            {
+                return false;
+            }
+
+            protected virtual void ReadTargets(XmlElement rstXml, out SecurityKeyIdentifierClause renewTarget, out SecurityKeyIdentifierClause closeTarget)
+            {
+                renewTarget = null;
+                closeTarget = null;
+            }
+
+            public override void OnRSTRorRSTRCMissingException()
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new XmlException(SR.Format(SR.ExpectedOneOfTwoElementsFromNamespace,
+                    DriverDictionary.RequestSecurityTokenResponse, DriverDictionary.RequestSecurityTokenResponseCollection,
+                    DriverDictionary.Namespace)));
+            }
+
+            void WriteAppliesTo(object appliesTo, Type appliesToType, XmlObjectSerializer serializer, XmlWriter xmlWriter)
+            {
+                XmlDictionaryWriter writer = XmlDictionaryWriter.CreateDictionaryWriter(xmlWriter);
+                writer.WriteStartElement(Namespaces.WSPolicyPrefix, DriverDictionary.AppliesTo.Value, Namespaces.WSPolicy);
+                lock (serializer)
+                {
+                    serializer.WriteObject(writer, appliesTo);
+                }
+                writer.WriteEndElement();
+            }
+
+            public void WriteBinaryNegotiation(BinaryNegotiation negotiation, XmlWriter xmlWriter)
+            {
+                if (negotiation == null)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("negotiation");
+
+                XmlDictionaryWriter writer = XmlDictionaryWriter.CreateDictionaryWriter(xmlWriter);
+                negotiation.WriteTo(writer, this.DriverDictionary.Prefix.Value,
+                                            this.DriverDictionary.BinaryExchange, this.DriverDictionary.Namespace,
+                                            CoreWCF.XD.SecurityJan2004Dictionary.ValueType, null);
+            }
+
+            public override void WriteRequestSecurityToken(RequestSecurityToken rst, XmlWriter xmlWriter)
+            {
+                if (rst == null)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("rst");
+                }
+                if (xmlWriter == null)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("xmlWriter");
+                }
+                XmlDictionaryWriter writer = XmlDictionaryWriter.CreateDictionaryWriter(xmlWriter);
+                if (rst.IsReceiver)
+                {
+                    rst.WriteTo(writer);
+                    return;
+                }
+                writer.WriteStartElement(DriverDictionary.Prefix.Value, DriverDictionary.RequestSecurityToken, DriverDictionary.Namespace);
+                XmlHelper.AddNamespaceDeclaration(writer, DriverDictionary.Prefix.Value, DriverDictionary.Namespace);
+                if (rst.Context != null)
+                    writer.WriteAttributeString(DriverDictionary.Context, null, rst.Context);
+
+                rst.OnWriteCustomAttributes(writer);
+                if (rst.TokenType != null)
+                {
+                    writer.WriteStartElement(DriverDictionary.Prefix.Value, DriverDictionary.TokenType, DriverDictionary.Namespace);
+                    writer.WriteString(rst.TokenType);
+                    writer.WriteEndElement();
+                }
+                if (rst.RequestType != null)
+                {
+                    writer.WriteStartElement(DriverDictionary.Prefix.Value, DriverDictionary.RequestType, DriverDictionary.Namespace);
+                    writer.WriteString(rst.RequestType);
+                    writer.WriteEndElement();
+                }
+
+                if (rst.AppliesTo != null)
+                {
+                    WriteAppliesTo(rst.AppliesTo, rst.AppliesToType, rst.AppliesToSerializer, writer);
+                }
+
+                SecurityToken entropyToken = rst.GetRequestorEntropy();
+                if (entropyToken != null)
+                {
+                    writer.WriteStartElement(DriverDictionary.Prefix.Value, DriverDictionary.Entropy, DriverDictionary.Namespace);
+                    standardsManager.SecurityTokenSerializer.WriteToken(writer, entropyToken);
+                    writer.WriteEndElement();
+                }
+
+                if (rst.KeySize != 0)
+                {
+                    writer.WriteStartElement(DriverDictionary.Prefix.Value, DriverDictionary.KeySize, DriverDictionary.Namespace);
+                    writer.WriteValue(rst.KeySize);
+                    writer.WriteEndElement();
+                }
+
+                BinaryNegotiation negotiationData = rst.GetBinaryNegotiation();
+                if (negotiationData != null)
+                    WriteBinaryNegotiation(negotiationData, writer);
+
+                WriteTargets(rst, writer);
+
+                if (rst.RequestProperties != null)
+                {
+                    foreach (XmlElement property in rst.RequestProperties)
+                    {
+                        property.WriteTo(writer);
+                    }
+                }
+
+                rst.OnWriteCustomElements(writer);
+                writer.WriteEndElement();
+            }
+
+            protected virtual void WriteTargets(RequestSecurityToken rst, XmlDictionaryWriter writer)
+            {
+            }
+
+            // Note in Apr2004, internal & external references aren't supported - our strategy is to generate the external ref as the TokenReference.
+            protected virtual void WriteReferences(RequestSecurityTokenResponse rstr, XmlDictionaryWriter writer)
+            {
+                if (rstr.RequestedUnattachedReference != null)
+                {
+                    writer.WriteStartElement(DriverDictionary.Prefix.Value, DriverDictionary.RequestedTokenReference, DriverDictionary.Namespace);
+                    standardsManager.SecurityTokenSerializer.WriteKeyIdentifierClause(writer, rstr.RequestedUnattachedReference);
+                    writer.WriteEndElement();
+                }
+            }
+
+            protected virtual void WriteRequestedTokenClosed(RequestSecurityTokenResponse rstr, XmlDictionaryWriter writer)
+            {
+            }
+
+            public override void WriteRequestSecurityTokenResponse(RequestSecurityTokenResponse rstr, XmlWriter xmlWriter)
+            {
+                if (rstr == null)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("rstr");
+                if (xmlWriter == null)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("xmlWriter");
+                XmlDictionaryWriter writer = XmlDictionaryWriter.CreateDictionaryWriter(xmlWriter);
+                if (rstr.IsReceiver)
+                {
+                    rstr.WriteTo(writer);
+                    return;
+                }
+                writer.WriteStartElement(DriverDictionary.Prefix.Value, DriverDictionary.RequestSecurityTokenResponse, DriverDictionary.Namespace);
+                if (rstr.Context != null)
+                {
+                    writer.WriteAttributeString(DriverDictionary.Context, null, rstr.Context);
+                }
+                // define WSUtility at the top level to avoid multiple definitions below
+                XmlHelper.AddNamespaceDeclaration(writer, UtilityStrings.Prefix, CoreWCF.XD.UtilityDictionary.Namespace);
+                rstr.OnWriteCustomAttributes(writer);
+
+                if (rstr.TokenType != null)
+                    writer.WriteElementString(DriverDictionary.Prefix.Value, DriverDictionary.TokenType, DriverDictionary.Namespace, rstr.TokenType);
+
+                if (rstr.RequestedSecurityToken != null)
+                {
+                    writer.WriteStartElement(DriverDictionary.Prefix.Value, DriverDictionary.RequestedSecurityToken, DriverDictionary.Namespace);
+                    standardsManager.SecurityTokenSerializer.WriteToken(writer, rstr.RequestedSecurityToken);
+                    writer.WriteEndElement();
+                }
+
+                if (rstr.AppliesTo != null)
+                {
+                    WriteAppliesTo(rstr.AppliesTo, rstr.AppliesToType, rstr.AppliesToSerializer, writer);
+                }
+
+                WriteReferences(rstr, writer);
+
+                if (rstr.ComputeKey || rstr.RequestedProofToken != null)
+                {
+                    writer.WriteStartElement(DriverDictionary.Prefix.Value, DriverDictionary.RequestedProofToken, DriverDictionary.Namespace);
+                    if (rstr.ComputeKey)
+                    {
+                        writer.WriteElementString(DriverDictionary.Prefix.Value, DriverDictionary.ComputedKey, DriverDictionary.Namespace, DriverDictionary.Psha1ComputedKeyUri.Value);
+                    }
+                    else
+                    {
+                        standardsManager.SecurityTokenSerializer.WriteToken(writer, rstr.RequestedProofToken);
+                    }
+                    writer.WriteEndElement();
+                }
+
+                SecurityToken entropyToken = rstr.GetIssuerEntropy();
+                if (entropyToken != null)
+                {
+                    writer.WriteStartElement(DriverDictionary.Prefix.Value, DriverDictionary.Entropy, DriverDictionary.Namespace);
+                    standardsManager.SecurityTokenSerializer.WriteToken(writer, entropyToken);
+                    writer.WriteEndElement();
+                }
+
+                // To write out the lifetime, the following algorithm is used
+                //   1. If the lifetime is explicitly set, write it out.
+                //   2. Else, if a token/tokenbuilder has been set, use the lifetime in that.
+                //   3. Else do not serialize lifetime
+                if (rstr.IsLifetimeSet || rstr.RequestedSecurityToken != null)
+                {
+                    DateTime effectiveTime = SecurityUtils.MinUtcDateTime;
+                    DateTime expirationTime = SecurityUtils.MaxUtcDateTime;
+
+                    if (rstr.IsLifetimeSet)
+                    {
+                        effectiveTime = rstr.ValidFrom.ToUniversalTime();
+                        expirationTime = rstr.ValidTo.ToUniversalTime();
+                    }
+                    else if (rstr.RequestedSecurityToken != null)
+                    {
+                        effectiveTime = rstr.RequestedSecurityToken.ValidFrom.ToUniversalTime();
+                        expirationTime = rstr.RequestedSecurityToken.ValidTo.ToUniversalTime();
+                    }
+
+                    // write out the lifetime
+                    writer.WriteStartElement(DriverDictionary.Prefix.Value, DriverDictionary.Lifetime, DriverDictionary.Namespace);
+                    // write out Created
+                    writer.WriteStartElement(CoreWCF.XD.UtilityDictionary.Prefix.Value, CoreWCF.XD.UtilityDictionary.CreatedElement, CoreWCF.XD.UtilityDictionary.Namespace);
+                    writer.WriteString(effectiveTime.ToString("yyyy-MM-ddTHH:mm:ss.fffZ", CultureInfo.InvariantCulture.DateTimeFormat));
+                    writer.WriteEndElement(); // wsu:Created
+                    // write out Expires
+                    writer.WriteStartElement(CoreWCF.XD.UtilityDictionary.Prefix.Value, CoreWCF.XD.UtilityDictionary.ExpiresElement, CoreWCF.XD.UtilityDictionary.Namespace);
+                    writer.WriteString(expirationTime.ToString("yyyy-MM-ddTHH:mm:ss.fffZ", CultureInfo.InvariantCulture.DateTimeFormat));
+                    writer.WriteEndElement(); // wsu:Expires
+                    writer.WriteEndElement(); // wsse:Lifetime
+                }
+
+                byte[] authenticator = rstr.GetAuthenticator();
+                if (authenticator != null)
+                {
+                    writer.WriteStartElement(DriverDictionary.Prefix.Value, DriverDictionary.Authenticator, DriverDictionary.Namespace);
+                    writer.WriteStartElement(DriverDictionary.Prefix.Value, DriverDictionary.CombinedHash, DriverDictionary.Namespace);
+                    writer.WriteBase64(authenticator, 0, authenticator.Length);
+                    writer.WriteEndElement();
+                    writer.WriteEndElement();
+                }
+
+                if (rstr.KeySize > 0)
+                {
+                    writer.WriteStartElement(DriverDictionary.Prefix.Value, DriverDictionary.KeySize, DriverDictionary.Namespace);
+                    writer.WriteValue(rstr.KeySize);
+                    writer.WriteEndElement();
+                }
+
+                WriteRequestedTokenClosed(rstr, writer);
+
+                BinaryNegotiation negotiationData = rstr.GetBinaryNegotiation();
+                if (negotiationData != null)
+                    WriteBinaryNegotiation(negotiationData, writer);
+
+                rstr.OnWriteCustomElements(writer);
+                writer.WriteEndElement();
+            }
+
+            public override void WriteRequestSecurityTokenResponseCollection(RequestSecurityTokenResponseCollection rstrCollection, XmlWriter xmlWriter)
+            {
+                if (rstrCollection == null)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("rstrCollection");
+
+                XmlDictionaryWriter writer = XmlDictionaryWriter.CreateDictionaryWriter(xmlWriter);
+                writer.WriteStartElement(DriverDictionary.Prefix.Value, DriverDictionary.RequestSecurityTokenResponseCollection, DriverDictionary.Namespace);
+                foreach (RequestSecurityTokenResponse rstr in rstrCollection.RstrCollection)
+                {
+                    rstr.WriteTo(writer);
+                }
+                writer.WriteEndElement();
+            }
+
+            protected void SetProtectionLevelForFederation(OperationDescriptionCollection operations)
+            {
+                foreach (OperationDescription operation in operations)
+                {
+                    foreach (MessageDescription message in operation.Messages)
+                    {
+                        if (message.Body.Parts.Count > 0)
+                        {
+                            foreach (MessagePartDescription part in message.Body.Parts)
+                            {
+                                part.ProtectionLevel = System.Net.Security.ProtectionLevel.EncryptAndSign;
+                            }
+                        }
+                        if (OperationFormatter.IsValidReturnValue(message.Body.ReturnValue))
+                        {
+                            message.Body.ReturnValue.ProtectionLevel = System.Net.Security.ProtectionLevel.EncryptAndSign;
+                        }
+                    }
+                }
+            }
+
+            public override bool TryParseKeySizeElement(XmlElement element, out int keySize)
+            {
+                if (element == null)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("element");
+
+                if (element.LocalName == this.DriverDictionary.KeySize.Value
+                    && element.NamespaceURI == this.DriverDictionary.Namespace.Value)
+                {
+                    keySize = Int32.Parse(XmlHelper.ReadTextElementAsTrimmedString(element), NumberFormatInfo.InvariantInfo);
+                    return true;
+                }
+
+                keySize = 0;
+                return false;
+            }
+
+            public override XmlElement CreateKeySizeElement(int keySize)
+            {
+                if (keySize < 0)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("keySize", SR.Format(SR.ValueMustBeNonNegative)));
+                }
+                XmlDocument doc = new XmlDocument();
+                XmlElement result = doc.CreateElement(this.DriverDictionary.Prefix.Value, this.DriverDictionary.KeySize.Value,
+                    this.DriverDictionary.Namespace.Value);
+                result.AppendChild(doc.CreateTextNode(keySize.ToString(System.Globalization.CultureInfo.InvariantCulture.NumberFormat)));
+                return result;
+            }
+
+            public override XmlElement CreateKeyTypeElement(SecurityKeyType keyType)
+            {
+                if (keyType == SecurityKeyType.SymmetricKey)
+                    return CreateSymmetricKeyTypeElement();
+                else if (keyType == SecurityKeyType.AsymmetricKey)
+                    return CreatePublicKeyTypeElement();
+                else
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.UnableToCreateKeyTypeElementForUnknownKeyType, keyType.ToString())));
+            }
+
+            public override bool TryParseKeyTypeElement(XmlElement element, out SecurityKeyType keyType)
+            {
+                if (element == null)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("element");
+
+                if (TryParseSymmetricKeyElement(element))
+                {
+                    keyType = SecurityKeyType.SymmetricKey;
+                    return true;
+                }
+                else if (TryParsePublicKeyElement(element))
+                {
+                    keyType = SecurityKeyType.AsymmetricKey;
+                    return true;
+                }
+
+                keyType = SecurityKeyType.SymmetricKey;
+                return false;
+
+            }
+
+            public bool TryParseSymmetricKeyElement(XmlElement element)
+            {
+                if (element == null)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("element");
+
+                return element.LocalName == this.DriverDictionary.KeyType.Value
+                    && element.NamespaceURI == this.DriverDictionary.Namespace.Value
+                    && element.InnerText == this.DriverDictionary.SymmetricKeyType.Value;
+            }
+
+            XmlElement CreateSymmetricKeyTypeElement()
+            {
+                XmlDocument doc = new XmlDocument();
+                XmlElement result = doc.CreateElement(this.DriverDictionary.Prefix.Value, this.DriverDictionary.KeyType.Value,
+                    this.DriverDictionary.Namespace.Value);
+                result.AppendChild(doc.CreateTextNode(this.DriverDictionary.SymmetricKeyType.Value));
+                return result;
+            }
+
+            bool TryParsePublicKeyElement(XmlElement element)
+            {
+                if (element == null)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("element");
+
+                return element.LocalName == this.DriverDictionary.KeyType.Value
+                    && element.NamespaceURI == this.DriverDictionary.Namespace.Value
+                    && element.InnerText == this.DriverDictionary.PublicKeyType.Value;
+            }
+
+            XmlElement CreatePublicKeyTypeElement()
+            {
+                XmlDocument doc = new XmlDocument();
+                XmlElement result = doc.CreateElement(this.DriverDictionary.Prefix.Value, this.DriverDictionary.KeyType.Value,
+                    this.DriverDictionary.Namespace.Value);
+                result.AppendChild(doc.CreateTextNode(this.DriverDictionary.PublicKeyType.Value));
+                return result;
+            }
+
+            public override bool TryParseTokenTypeElement(XmlElement element, out string tokenType)
+            {
+                if (element == null)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("element");
+
+                if (element.LocalName == this.DriverDictionary.TokenType.Value
+                    && element.NamespaceURI == this.DriverDictionary.Namespace.Value)
+                {
+                    tokenType = element.InnerText;
+                    return true;
+                }
+
+                tokenType = null;
+                return false;
+            }
+
+            public override XmlElement CreateTokenTypeElement(string tokenTypeUri)
+            {
+                if (tokenTypeUri == null)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("tokenTypeUri");
+                }
+                XmlDocument doc = new XmlDocument();
+                XmlElement result = doc.CreateElement(this.DriverDictionary.Prefix.Value, this.DriverDictionary.TokenType.Value,
+                    this.DriverDictionary.Namespace.Value);
+                result.AppendChild(doc.CreateTextNode(tokenTypeUri));
+                return result;
+            }
+
+            public override XmlElement CreateUseKeyElement(SecurityKeyIdentifier keyIdentifier, SecurityStandardsManager standardsManager)
+            {
+                if (keyIdentifier == null)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("keyIdentifier");
+                }
+                if (standardsManager == null)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("standardsManager");
+                }
+                XmlDocument doc = new XmlDocument();
+                XmlElement result = doc.CreateElement(this.DriverDictionary.UseKey.Value, this.DriverDictionary.Namespace.Value);
+                MemoryStream stream = new MemoryStream();
+                using (XmlDictionaryWriter writer = XmlDictionaryWriter.CreateDictionaryWriter(new XmlTextWriter(stream, Encoding.UTF8)))
+                {
+#pragma warning suppress 56506 // standardsManager.SecurityTokenSerializer can never be null.
+                    standardsManager.SecurityTokenSerializer.WriteKeyIdentifier(writer, keyIdentifier);
+                    writer.Flush();
+                    stream.Seek(0, SeekOrigin.Begin);
+                    XmlNode skiNode;
+                    using (XmlDictionaryReader reader = XmlDictionaryReader.CreateDictionaryReader(new XmlTextReader(stream) { DtdProcessing = DtdProcessing.Prohibit }))
+                    {
+                        reader.MoveToContent();
+                        skiNode = doc.ReadNode(reader);
+                    }
+                    result.AppendChild(skiNode);
+                }
+                return result;
+            }
+
+            public override XmlElement CreateSignWithElement(string signatureAlgorithm)
+            {
+                if (signatureAlgorithm == null)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("signatureAlgorithm");
+                }
+                XmlDocument doc = new XmlDocument();
+                XmlElement result = doc.CreateElement(this.DriverDictionary.Prefix.Value, this.DriverDictionary.SignWith.Value,
+                    this.DriverDictionary.Namespace.Value);
+                result.AppendChild(doc.CreateTextNode(signatureAlgorithm));
+                return result;
+            }
+
+            internal override bool IsSignWithElement(XmlElement element, out string signatureAlgorithm)
+            {
+                return CheckElement(element, this.DriverDictionary.SignWith.Value, this.DriverDictionary.Namespace.Value, out signatureAlgorithm);
+            }
+
+            public override XmlElement CreateEncryptWithElement(string encryptionAlgorithm)
+            {
+                if (encryptionAlgorithm == null)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("encryptionAlgorithm");
+                }
+                XmlDocument doc = new XmlDocument();
+                XmlElement result = doc.CreateElement(this.DriverDictionary.Prefix.Value, this.DriverDictionary.EncryptWith.Value,
+                    this.DriverDictionary.Namespace.Value);
+                result.AppendChild(doc.CreateTextNode(encryptionAlgorithm));
+                return result;
+            }
+
+            public override XmlElement CreateEncryptionAlgorithmElement(string encryptionAlgorithm)
+            {
+                if (encryptionAlgorithm == null)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("encryptionAlgorithm");
+                }
+                XmlDocument doc = new XmlDocument();
+                XmlElement result = doc.CreateElement(this.DriverDictionary.Prefix.Value, this.DriverDictionary.EncryptionAlgorithm.Value,
+                    this.DriverDictionary.Namespace.Value);
+                result.AppendChild(doc.CreateTextNode(encryptionAlgorithm));
+                return result;
+            }
+
+            internal override bool IsEncryptWithElement(XmlElement element, out string encryptWithAlgorithm)
+            {
+                return CheckElement(element, this.DriverDictionary.EncryptWith.Value, this.DriverDictionary.Namespace.Value, out encryptWithAlgorithm);
+            }
+
+            internal override bool IsEncryptionAlgorithmElement(XmlElement element, out string encryptionAlgorithm)
+            {
+                return CheckElement(element, this.DriverDictionary.EncryptionAlgorithm.Value, this.DriverDictionary.Namespace.Value, out encryptionAlgorithm);
+            }
+
+            public override XmlElement CreateComputedKeyAlgorithmElement(string algorithm)
+            {
+                if (algorithm == null)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("algorithm");
+                }
+                XmlDocument doc = new XmlDocument();
+                XmlElement result = doc.CreateElement(this.DriverDictionary.Prefix.Value, this.DriverDictionary.ComputedKeyAlgorithm.Value,
+                    this.DriverDictionary.Namespace.Value);
+                result.AppendChild(doc.CreateTextNode(algorithm));
+                return result;
+            }
+
+            public override XmlElement CreateCanonicalizationAlgorithmElement(string algorithm)
+            {
+                if (algorithm == null)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("algorithm");
+                }
+                XmlDocument doc = new XmlDocument();
+                XmlElement result = doc.CreateElement(this.DriverDictionary.Prefix.Value, this.DriverDictionary.CanonicalizationAlgorithm.Value,
+                    this.DriverDictionary.Namespace.Value);
+                result.AppendChild(doc.CreateTextNode(algorithm));
+                return result;
+            }
+
+            internal override bool IsCanonicalizationAlgorithmElement(XmlElement element, out string canonicalizationAlgorithm)
+            {
+                return CheckElement(element, this.DriverDictionary.CanonicalizationAlgorithm.Value, this.DriverDictionary.Namespace.Value, out canonicalizationAlgorithm);
+            }
+
+            public override bool TryParseRequiredClaimsElement(XmlElement element, out System.Collections.ObjectModel.Collection<XmlElement> requiredClaims)
+            {
+                if (element == null)
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("element");
+
+                if (element.LocalName == this.DriverDictionary.Claims.Value
+                    && element.NamespaceURI == this.DriverDictionary.Namespace.Value)
+                {
+                    requiredClaims = new System.Collections.ObjectModel.Collection<XmlElement>();
+                    foreach (XmlNode node in element.ChildNodes)
+                        if (node is XmlElement)
+                        {
+                            // PreSharp Bug: Parameter 'requiredClaims' to this public method must be validated: A null-dereference can occur here.
+#pragma warning suppress 56506
+                            requiredClaims.Add((XmlElement)node);
+                        }
+                    return true;
+                }
+
+                requiredClaims = null;
+                return false;
+            }
+
+            public override XmlElement CreateRequiredClaimsElement(IEnumerable<XmlElement> claimsList)
+            {
+                if (claimsList == null)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("claimsList");
+                }
+                XmlDocument doc = new XmlDocument();
+                XmlElement result = doc.CreateElement(this.DriverDictionary.Prefix.Value, this.DriverDictionary.Claims.Value,
+                    this.DriverDictionary.Namespace.Value);
+                foreach (XmlElement claimElement in claimsList)
+                {
+                    XmlElement element = (XmlElement)doc.ImportNode(claimElement, true);
+                    result.AppendChild(element);
+                }
+                return result;
+            }
+
+            internal static void ValidateRequestedKeySize(int keySize, SecurityAlgorithmSuite algorithmSuite)
+            {
+                if ((keySize % 8 == 0) && algorithmSuite.IsSymmetricKeyLengthSupported(keySize))
+                {
+                    return;
+                }
+                else
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new SecurityNegotiationException(SR.Format(SR.InvalidKeyLengthRequested, keySize)));
+                }
+            }
+
+            static void ValidateRequestorEntropy(SecurityToken entropy, SecurityKeyEntropyMode mode)
+            {
+                if ((mode == SecurityKeyEntropyMode.ClientEntropy || mode == SecurityKeyEntropyMode.CombinedEntropy)
+                    && (entropy == null))
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new InvalidOperationException(SR.Format(SR.EntropyModeRequiresRequestorEntropy, mode)));
+                }
+                if (mode == SecurityKeyEntropyMode.ServerEntropy && entropy != null)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new InvalidOperationException(SR.Format(SR.EntropyModeCannotHaveRequestorEntropy, mode)));
+                }
+            }
+
+            internal static void ProcessRstAndIssueKey(RequestSecurityToken requestSecurityToken, SecurityTokenResolver resolver, SecurityKeyEntropyMode keyEntropyMode, SecurityAlgorithmSuite algorithmSuite, out int issuedKeySize, out byte[] issuerEntropy, out byte[] proofKey,
+                out SecurityToken proofToken)
+            {
+                SecurityToken requestorEntropyToken = requestSecurityToken.GetRequestorEntropy(resolver);
+                ValidateRequestorEntropy(requestorEntropyToken, keyEntropyMode);
+                byte[] requestorEntropy;
+                if (requestorEntropyToken != null)
+                {
+                    if (requestorEntropyToken is BinarySecretSecurityToken)
+                    {
+                        BinarySecretSecurityToken skToken = (BinarySecretSecurityToken)requestorEntropyToken;
+                        requestorEntropy = skToken.GetKeyBytes();
+                    }
+                    else if (requestorEntropyToken is WrappedKeySecurityToken)
+                    {
+                        requestorEntropy = ((WrappedKeySecurityToken)requestorEntropyToken).GetWrappedKey();
+                    }
+                    else
+                    {
+                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new InvalidOperationException(SR.Format(SR.TokenCannotCreateSymmetricCrypto, requestorEntropyToken)));
+                    }
+                }
+                else
+                {
+                    requestorEntropy = null;
+                }
+
+                if (keyEntropyMode == SecurityKeyEntropyMode.ClientEntropy)
+                {
+                    if (requestorEntropy != null)
+                    {
+                        // validate that the entropy length matches the algorithm suite
+                        ValidateRequestedKeySize(requestorEntropy.Length * 8, algorithmSuite);
+                    }
+                    proofKey = requestorEntropy;
+                    issuerEntropy = null;
+                    issuedKeySize = 0;
+                    proofToken = null;
+                }
+                else
+                {
+                    if (requestSecurityToken.KeySize != 0)
+                    {
+                        ValidateRequestedKeySize(requestSecurityToken.KeySize, algorithmSuite);
+                        issuedKeySize = requestSecurityToken.KeySize;
+                    }
+                    else
+                    {
+                        issuedKeySize = algorithmSuite.DefaultSymmetricKeyLength;
+                    }
+                    RNGCryptoServiceProvider random = new RNGCryptoServiceProvider();
+                    if (keyEntropyMode == SecurityKeyEntropyMode.ServerEntropy)
+                    {
+                        proofKey = new byte[issuedKeySize / 8];
+                        // proof key is completely issued by the server
+                        random.GetNonZeroBytes(proofKey);
+                        issuerEntropy = null;
+                        proofToken = new BinarySecretSecurityToken(proofKey);
+                    }
+                    else
+                    {
+                        issuerEntropy = new byte[issuedKeySize / 8];
+                        random.GetNonZeroBytes(issuerEntropy);
+                        proofKey = RequestSecurityTokenResponse.ComputeCombinedKey(requestorEntropy, issuerEntropy, issuedKeySize);
+                        proofToken = null;
+                    }
+                }
+            }
+
+        }
+
+        protected static bool CheckElement(XmlElement element, string name, string ns, out string value)
+        {
+            value = null;
+            if (element.LocalName != name || element.NamespaceURI != ns)
+                return false;
+            if (element.FirstChild is XmlText)
+            {
+                value = ((XmlText)element.FirstChild).Value;
+                return true;
+            }
+            return false;
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/WSTrustDec2005.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/WSTrustDec2005.cs
new file mode 100644
index 0000000..a241d5d
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/WSTrustDec2005.cs
@@ -0,0 +1,63 @@
+﻿
+
+using System.Xml;
+
+namespace CoreWCF.Security
+{
+    class WSTrustDec2005 : WSTrustFeb2005
+    {
+        public WSTrustDec2005(WSSecurityTokenSerializer tokenSerializer)
+            : base(tokenSerializer)
+        {
+        }
+
+        public override TrustDictionary SerializerDictionary
+        {
+            get { return DXD.TrustDec2005Dictionary; }
+        }
+
+        public class DriverDec2005 : DriverFeb2005
+        {
+            public DriverDec2005(SecurityStandardsManager standardsManager)
+                : base(standardsManager)
+            {
+            }
+
+            //public override TrustDictionary DriverDictionary
+            //{
+            //    get
+            //    {
+            //        return DXD.TrustDec2005Dictionary;
+            //    }
+            //}
+
+            //public override XmlDictionaryString RequestSecurityTokenResponseFinalAction
+            //{
+            //    get
+            //    {
+            //        return DXD.TrustDec2005Dictionary.RequestSecurityTokenCollectionIssuanceFinalResponse;
+            //    }
+            //}
+
+            internal virtual bool IsSecondaryParametersElement(XmlElement element)
+            {
+                return ((element.LocalName == DXD.TrustDec2005Dictionary.SecondaryParameters.Value) &&
+                        (element.NamespaceURI == DXD.TrustDec2005Dictionary.Namespace.Value));
+            }
+
+            public virtual XmlElement CreateKeyWrapAlgorithmElement(string keyWrapAlgorithm)
+            {
+                if (keyWrapAlgorithm == null)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(keyWrapAlgorithm));
+                }
+
+                XmlDocument doc = new XmlDocument();
+                XmlElement result = doc.CreateElement(DXD.TrustDec2005Dictionary.Prefix.Value, DXD.TrustDec2005Dictionary.KeyWrapAlgorithm.Value,
+                    DXD.TrustDec2005Dictionary.Namespace.Value);
+                result.AppendChild(doc.CreateTextNode(keyWrapAlgorithm));
+                return result;
+            }
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/WSTrustFeb2005.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/WSTrustFeb2005.cs
new file mode 100644
index 0000000..e6c0503
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/WSTrustFeb2005.cs
@@ -0,0 +1,227 @@
+﻿
+
+using CoreWCF.IdentityModel;
+using CoreWCF.IdentityModel.Tokens;
+using CoreWCF.Security.Tokens;
+using System;
+using System.Collections.ObjectModel;
+using System.Xml;
+
+namespace CoreWCF.Security
+{
+    internal class WSTrustFeb2005 : WSTrust
+    {
+        public WSTrustFeb2005(WSSecurityTokenSerializer tokenSerializer)
+            : base(tokenSerializer)
+        {
+        }
+
+        public override TrustDictionary SerializerDictionary
+        {
+            get { return XD.TrustFeb2005Dictionary; }
+        }
+
+        public class DriverFeb2005 : Driver
+        {
+            public DriverFeb2005(SecurityStandardsManager standardsManager)
+                : base(standardsManager)
+            {
+            }
+
+            public override TrustDictionary DriverDictionary
+            {
+                get
+                {
+                    return XD.TrustFeb2005Dictionary;
+                }
+            }
+
+            public override XmlDictionaryString RequestSecurityTokenResponseFinalAction
+            {
+                get
+                {
+                    return XD.TrustFeb2005Dictionary.RequestSecurityTokenIssuanceResponse;
+                }
+            }
+
+            public override bool IsSessionSupported
+            {
+                get
+                {
+                    return true;
+                }
+            }
+
+            public override bool IsIssuedTokensSupported
+            {
+                get
+                {
+                    return true;
+                }
+            }
+
+            public override string IssuedTokensHeaderName
+            {
+                get
+                {
+                    return DriverDictionary.IssuedTokensHeader.Value;
+                }
+            }
+
+            public override string IssuedTokensHeaderNamespace
+            {
+                get
+                {
+                    return DriverDictionary.Namespace.Value;
+                }
+            }
+
+            public override string RequestTypeRenew
+            {
+                get
+                {
+                    return DriverDictionary.RequestTypeRenew.Value;
+                }
+            }
+
+            public override string RequestTypeClose
+            {
+                get
+                {
+                    return DriverDictionary.RequestTypeClose.Value;
+                }
+            }
+
+            public override Collection<XmlElement> ProcessUnknownRequestParameters(Collection<XmlElement> unknownRequestParameters, Collection<XmlElement> originalRequestParameters)
+            {
+                throw new NotImplementedException();
+            }
+
+            protected override void ReadReferences(XmlElement rstrXml, out SecurityKeyIdentifierClause requestedAttachedReference,
+                    out SecurityKeyIdentifierClause requestedUnattachedReference)
+            {
+                XmlElement issuedTokenXml = null;
+                requestedAttachedReference = null;
+                requestedUnattachedReference = null;
+                for (int i = 0; i < rstrXml.ChildNodes.Count; ++i)
+                {
+                    XmlElement child = rstrXml.ChildNodes[i] as XmlElement;
+                    if (child != null)
+                    {
+                        if (child.LocalName == DriverDictionary.RequestedSecurityToken.Value && child.NamespaceURI == DriverDictionary.Namespace.Value)
+                        {
+                            issuedTokenXml = XmlHelper.GetChildElement(child);
+                        }
+                        else if (child.LocalName == DriverDictionary.RequestedAttachedReference.Value && child.NamespaceURI == DriverDictionary.Namespace.Value)
+                        {
+                            requestedAttachedReference = GetKeyIdentifierXmlReferenceClause(XmlHelper.GetChildElement(child));
+                        }
+                        else if (child.LocalName == DriverDictionary.RequestedUnattachedReference.Value && child.NamespaceURI == DriverDictionary.Namespace.Value)
+                        {
+                            requestedUnattachedReference = GetKeyIdentifierXmlReferenceClause(XmlHelper.GetChildElement(child));
+                        }
+                    }
+                }
+
+                try
+                {
+                    if (issuedTokenXml != null)
+                    {
+                        if (requestedAttachedReference == null)
+                        {
+                            StandardsManager.TryCreateKeyIdentifierClauseFromTokenXml(issuedTokenXml, SecurityTokenReferenceStyle.Internal, out requestedAttachedReference);
+                        }
+                        if (requestedUnattachedReference == null)
+                        {
+                            StandardsManager.TryCreateKeyIdentifierClauseFromTokenXml(issuedTokenXml, SecurityTokenReferenceStyle.External, out requestedUnattachedReference);
+                        }
+                    }
+                }
+                catch (XmlException)
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new XmlException(SR.Format(SR.TrustDriverIsUnableToCreatedNecessaryAttachedOrUnattachedReferences, issuedTokenXml.ToString())));
+                }
+            }
+
+            protected override bool ReadRequestedTokenClosed(XmlElement rstrXml)
+            {
+                for (int i = 0; i < rstrXml.ChildNodes.Count; ++i)
+                {
+                    XmlElement child = (rstrXml.ChildNodes[i] as XmlElement);
+                    if (child != null)
+                    {
+                        if (child.LocalName == DriverDictionary.RequestedTokenClosed.Value && child.NamespaceURI == DriverDictionary.Namespace.Value)
+                        {
+                            return true;
+                        }
+                    }
+                }
+                return false;
+            }
+
+            protected override void ReadTargets(XmlElement rstXml, out SecurityKeyIdentifierClause renewTarget, out SecurityKeyIdentifierClause closeTarget)
+            {
+                renewTarget = null;
+                closeTarget = null;
+
+                for (int i = 0; i < rstXml.ChildNodes.Count; ++i)
+                {
+                    XmlElement child = (rstXml.ChildNodes[i] as XmlElement);
+                    if (child != null)
+                    {
+                        if (child.LocalName == DriverDictionary.RenewTarget.Value && child.NamespaceURI == DriverDictionary.Namespace.Value)
+                        {
+                            renewTarget = StandardsManager.SecurityTokenSerializer.ReadKeyIdentifierClause(new XmlNodeReader(child.FirstChild));
+                        }
+                        else if (child.LocalName == DriverDictionary.CloseTarget.Value && child.NamespaceURI == DriverDictionary.Namespace.Value)
+                        {
+                            closeTarget = StandardsManager.SecurityTokenSerializer.ReadKeyIdentifierClause(new XmlNodeReader(child.FirstChild));
+                        }
+                    }
+                }
+            }
+
+            protected override void WriteReferences(RequestSecurityTokenResponse rstr, XmlDictionaryWriter writer)
+            {
+                if (rstr.RequestedAttachedReference != null)
+                {
+                    writer.WriteStartElement(DriverDictionary.Prefix.Value, DriverDictionary.RequestedAttachedReference, DriverDictionary.Namespace);
+                    StandardsManager.SecurityTokenSerializer.WriteKeyIdentifierClause(writer, rstr.RequestedAttachedReference);
+                    writer.WriteEndElement();
+                }
+
+                if (rstr.RequestedUnattachedReference != null)
+                {
+                    writer.WriteStartElement(DriverDictionary.Prefix.Value, DriverDictionary.RequestedUnattachedReference, DriverDictionary.Namespace);
+                    StandardsManager.SecurityTokenSerializer.WriteKeyIdentifierClause(writer, rstr.RequestedUnattachedReference);
+                    writer.WriteEndElement();
+                }
+            }
+
+            protected override void WriteRequestedTokenClosed(RequestSecurityTokenResponse rstr, XmlDictionaryWriter writer)
+            {
+                if (rstr.IsRequestedTokenClosed)
+                {
+                    writer.WriteElementString(DriverDictionary.RequestedTokenClosed, DriverDictionary.Namespace, String.Empty);
+                }
+            }
+
+            protected override void WriteTargets(RequestSecurityToken rst, XmlDictionaryWriter writer)
+            {
+                if (rst.RenewTarget != null)
+                {
+                    writer.WriteStartElement(DriverDictionary.Prefix.Value, DriverDictionary.RenewTarget, DriverDictionary.Namespace);
+                    StandardsManager.SecurityTokenSerializer.WriteKeyIdentifierClause(writer, rst.RenewTarget);
+                    writer.WriteEndElement();
+                }
+
+                if (rst.CloseTarget != null)
+                {
+                    writer.WriteStartElement(DriverDictionary.Prefix.Value, DriverDictionary.CloseTarget, DriverDictionary.Namespace);
+                    StandardsManager.SecurityTokenSerializer.WriteKeyIdentifierClause(writer, rst.CloseTarget);
+                    writer.WriteEndElement();
+                }
+            }
+        }
+        }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/WSUtilitySpecificationVersion.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/WSUtilitySpecificationVersion.cs
new file mode 100644
index 0000000..9a77588
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/WSUtilitySpecificationVersion.cs
@@ -0,0 +1,182 @@
+
+
+namespace CoreWCF.Security
+{
+    using CoreWCF;
+    using System.IO;
+    using System.Text;
+    using System.Xml;
+    using System;
+
+    using CanonicalFormWriter = CoreWCF.IdentityModel.CanonicalFormWriter;
+    using SignatureResourcePool = CoreWCF.IdentityModel.SignatureResourcePool;
+    using HashStream = IdentityModel.HashStream;
+
+    internal abstract class WSUtilitySpecificationVersion
+    {
+        internal static readonly string[] AcceptedDateTimeFormats = new string[]
+        {
+            "yyyy-MM-ddTHH:mm:ss.fffffffZ",
+            "yyyy-MM-ddTHH:mm:ss.ffffffZ",
+            "yyyy-MM-ddTHH:mm:ss.fffffZ",
+            "yyyy-MM-ddTHH:mm:ss.ffffZ",
+            "yyyy-MM-ddTHH:mm:ss.fffZ",
+            "yyyy-MM-ddTHH:mm:ss.ffZ",
+            "yyyy-MM-ddTHH:mm:ss.fZ",
+            "yyyy-MM-ddTHH:mm:ssZ"
+        };
+
+        internal WSUtilitySpecificationVersion(XmlDictionaryString namespaceUri)
+        {
+            NamespaceUri = namespaceUri;
+        }
+
+        public static WSUtilitySpecificationVersion Default
+        {
+            get { return OneDotZero; }
+        }
+
+        internal XmlDictionaryString NamespaceUri { get; }
+
+        public static WSUtilitySpecificationVersion OneDotZero
+        {
+            get { return WSUtilitySpecificationVersionOneDotZero.Instance; }
+        }
+
+        internal abstract bool IsReaderAtTimestamp(XmlDictionaryReader reader);
+
+        internal abstract SecurityTimestamp ReadTimestamp(XmlDictionaryReader reader, string digestAlgorithm, SignatureResourcePool resourcePool);
+
+        internal abstract void WriteTimestamp(XmlDictionaryWriter writer, SecurityTimestamp timestamp);
+
+        internal abstract void WriteTimestampCanonicalForm(Stream stream, SecurityTimestamp timestamp, byte[] buffer);
+
+        private sealed class WSUtilitySpecificationVersionOneDotZero : WSUtilitySpecificationVersion
+        {
+            private WSUtilitySpecificationVersionOneDotZero()
+                : base(XD.UtilityDictionary.Namespace)
+            {
+            }
+
+            public static WSUtilitySpecificationVersionOneDotZero Instance { get; } = new WSUtilitySpecificationVersionOneDotZero();
+
+            internal override bool IsReaderAtTimestamp(XmlDictionaryReader reader)
+            {
+                return reader.IsStartElement(XD.UtilityDictionary.Timestamp, XD.UtilityDictionary.Namespace);
+            }
+
+            internal override SecurityTimestamp ReadTimestamp(XmlDictionaryReader reader, string digestAlgorithm, SignatureResourcePool resourcePool)
+            {
+                bool canonicalize = digestAlgorithm != null && reader.CanCanonicalize;
+                HashStream hashStream = null;
+
+                reader.MoveToStartElement(XD.UtilityDictionary.Timestamp, XD.UtilityDictionary.Namespace);
+                if (canonicalize)
+                {
+                    hashStream = resourcePool.TakeHashStream(digestAlgorithm);
+                    reader.StartCanonicalization(hashStream, false, null);
+                }
+                string id = reader.GetAttribute(XD.UtilityDictionary.IdAttribute, XD.UtilityDictionary.Namespace);
+                reader.ReadStartElement();
+
+                reader.ReadStartElement(XD.UtilityDictionary.CreatedElement, XD.UtilityDictionary.Namespace);
+                DateTime creationTimeUtc = reader.ReadContentAsDateTime().ToUniversalTime();
+                reader.ReadEndElement();
+
+                DateTime expiryTimeUtc;
+                if (reader.IsStartElement(XD.UtilityDictionary.ExpiresElement, XD.UtilityDictionary.Namespace))
+                {
+                    reader.ReadStartElement();
+                    expiryTimeUtc = reader.ReadContentAsDateTime().ToUniversalTime();
+                    reader.ReadEndElement();
+                }
+                else
+                {
+                    expiryTimeUtc = SecurityUtils.MaxUtcDateTime;
+                }
+
+                reader.ReadEndElement();
+
+                byte[] digest;
+                if (canonicalize)
+                {
+                    reader.EndCanonicalization();
+                    digest = hashStream.FlushHashAndGetValue();
+                }
+                else
+                {
+                    digest = null;
+                }
+                return new SecurityTimestamp(creationTimeUtc, expiryTimeUtc, id, digestAlgorithm, digest);
+            }
+
+            internal override void WriteTimestamp(XmlDictionaryWriter writer, SecurityTimestamp timestamp)
+            {
+                writer.WriteStartElement(XD.UtilityDictionary.Prefix.Value, XD.UtilityDictionary.Timestamp, XD.UtilityDictionary.Namespace);
+                writer.WriteAttributeString(XD.UtilityDictionary.IdAttribute, XD.UtilityDictionary.Namespace, timestamp.Id);
+
+                writer.WriteStartElement(XD.UtilityDictionary.CreatedElement, XD.UtilityDictionary.Namespace);
+                char[] creationTime = timestamp.GetCreationTimeChars();
+                writer.WriteChars(creationTime, 0, creationTime.Length);
+                writer.WriteEndElement(); // wsu:Created
+
+                writer.WriteStartElement(XD.UtilityDictionary.ExpiresElement, XD.UtilityDictionary.Namespace);
+                char[] expiryTime = timestamp.GetExpiryTimeChars();
+                writer.WriteChars(expiryTime, 0, expiryTime.Length);
+                writer.WriteEndElement(); // wsu:Expires
+
+                writer.WriteEndElement();
+            }
+
+            internal override void WriteTimestampCanonicalForm(Stream stream, SecurityTimestamp timestamp, byte[] workBuffer)
+            {
+                TimestampCanonicalFormWriter.Instance.WriteCanonicalForm(
+                    stream,
+                    timestamp.Id, timestamp.GetCreationTimeChars(), timestamp.GetExpiryTimeChars(),
+                    workBuffer);
+            }
+        }
+
+        private sealed class TimestampCanonicalFormWriter : CanonicalFormWriter
+        {
+            private const string timestamp = UtilityStrings.Prefix + ":" + UtilityStrings.Timestamp;
+            private const string created = UtilityStrings.Prefix + ":" + UtilityStrings.CreatedElement;
+            private const string expires = UtilityStrings.Prefix + ":" + UtilityStrings.ExpiresElement;
+            private const string idAttribute = UtilityStrings.Prefix + ":" + UtilityStrings.IdAttribute;
+            private const string ns = "xmlns:" + UtilityStrings.Prefix + "=\"" + UtilityStrings.Namespace + "\"";
+
+            private const string xml1 = "<" + timestamp + " " + ns + " " + idAttribute + "=\"";
+            private const string xml2 = "\"><" + created + ">";
+            private const string xml3 = "</" + created + "><" + expires + ">";
+            private const string xml4 = "</" + expires + "></" + timestamp + ">";
+
+            private readonly byte[] _fragment1;
+            private readonly byte[] _fragment2;
+            private readonly byte[] _fragment3;
+            private readonly byte[] _fragment4;
+
+            private TimestampCanonicalFormWriter()
+            {
+                Encoding encoding = CanonicalFormWriter.Utf8WithoutPreamble;
+                _fragment1 = encoding.GetBytes(xml1);
+                _fragment2 = encoding.GetBytes(xml2);
+                _fragment3 = encoding.GetBytes(xml3);
+                _fragment4 = encoding.GetBytes(xml4);
+            }
+
+            public static TimestampCanonicalFormWriter Instance { get; } = new TimestampCanonicalFormWriter();
+
+            public void WriteCanonicalForm(Stream stream, string id, char[] created, char[] expires, byte[] workBuffer)
+            {
+                stream.Write(_fragment1, 0, _fragment1.Length);
+                EncodeAndWrite(stream, workBuffer, id);
+                stream.Write(_fragment2, 0, _fragment2.Length);
+                EncodeAndWrite(stream, workBuffer, created);
+                stream.Write(_fragment3, 0, _fragment3.Length);
+                EncodeAndWrite(stream, workBuffer, expires);
+                stream.Write(_fragment4, 0, _fragment4.Length);
+            }
+        }
+    }
+}
+
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/WrapperSecurityCommunicationObject.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/WrapperSecurityCommunicationObject.cs
new file mode 100644
index 0000000..011ee1b
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/WrapperSecurityCommunicationObject.cs
@@ -0,0 +1,351 @@
+
+using CoreWCF.Channels;
+using CoreWCF.IdentityModel.Selectors;
+using CoreWCF.Diagnostics;
+using System.Threading.Tasks;
+using CoreWCF.Runtime;
+using System;
+using System.Threading;
+
+namespace CoreWCF.Security
+{
+    internal class WrapperSecurityCommunicationObject : CommunicationObject
+    {
+        private ISecurityCommunicationObject _innerCommunicationObject;
+
+        public WrapperSecurityCommunicationObject(ISecurityCommunicationObject innerCommunicationObject)
+            : base()
+        {
+            _innerCommunicationObject = innerCommunicationObject ?? throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(innerCommunicationObject));
+        }
+
+        protected override Type GetCommunicationObjectType()
+        {
+            return _innerCommunicationObject.GetType();
+        }
+
+        protected override TimeSpan DefaultCloseTimeout
+        {
+            get { return _innerCommunicationObject.DefaultCloseTimeout; }
+        }
+
+        protected override TimeSpan DefaultOpenTimeout
+        {
+            get { return _innerCommunicationObject.DefaultOpenTimeout; }
+        }
+
+        protected override void OnAbort()
+        {
+            _innerCommunicationObject.OnAbort();
+        }
+
+
+
+        protected override void OnFaulted()
+        {
+            _innerCommunicationObject.OnFaulted();
+            base.OnFaulted();
+        }
+
+        new internal void ThrowIfDisposedOrImmutable()
+        {
+            base.ThrowIfDisposedOrImmutable();
+        }
+
+        protected override Task OnCloseAsync(CancellationToken token)
+        {
+            return _innerCommunicationObject.OnCloseAsync(DefaultCloseTimeout);
+        }
+
+        protected override Task OnOpenAsync(CancellationToken token)
+        {
+            return _innerCommunicationObject.OnOpenAsync(DefaultOpenTimeout);
+        }
+    }
+
+    //internal abstract class CommunicationObjectSecurityTokenProvider : SecurityTokenProvider, IAsyncCommunicationObject, ISecurityCommunicationObject
+    //{
+    //   // private EventTraceActivity _eventTraceActivity;
+
+    //    protected CommunicationObjectSecurityTokenProvider()
+    //    {
+    //        CommunicationObject = new WrapperSecurityCommunicationObject(this);
+    //    }
+
+    //    //internal EventTraceActivity EventTraceActivity
+    //    //{
+    //    //    get
+    //    //    {
+    //    //        if (_eventTraceActivity == null)
+    //    //        {
+    //    //            _eventTraceActivity = EventTraceActivity.GetFromThreadOrCreate();
+    //    //        }
+    //    //        return _eventTraceActivity;
+    //    //    }
+    //    //}
+
+    //    protected WrapperSecurityCommunicationObject CommunicationObject { get; }
+
+    //    public event EventHandler Closed
+    //    {
+    //        add { CommunicationObject.Closed += value; }
+    //        remove { CommunicationObject.Closed -= value; }
+    //    }
+
+    //    public event EventHandler Closing
+    //    {
+    //        add { CommunicationObject.Closing += value; }
+    //        remove { CommunicationObject.Closing -= value; }
+    //    }
+
+    //    public event EventHandler Faulted
+    //    {
+    //        add { CommunicationObject.Faulted += value; }
+    //        remove { CommunicationObject.Faulted -= value; }
+    //    }
+
+    //    public event EventHandler Opened
+    //    {
+    //        add { CommunicationObject.Opened += value; }
+    //        remove { CommunicationObject.Opened -= value; }
+    //    }
+
+    //    public event EventHandler Opening
+    //    {
+    //        add { CommunicationObject.Opening += value; }
+    //        remove { CommunicationObject.Opening -= value; }
+    //    }
+
+    //    public CommunicationState State
+    //    {
+    //        get { return CommunicationObject.State; }
+    //    }
+
+    //    public virtual TimeSpan DefaultOpenTimeout
+    //    {
+    //        get { return ServiceDefaults.OpenTimeout; }
+    //    }
+
+    //    public virtual TimeSpan DefaultCloseTimeout
+    //    {
+    //        get { return ServiceDefaults.CloseTimeout; }
+    //    }
+
+    //    // communication object
+    //    public void Abort()
+    //    {
+    //        CommunicationObject.Abort();
+    //    }
+
+    //    public void Close()
+    //    {
+    //        CommunicationObject.Close();
+    //    }
+
+    //    public Task CloseAsync(TimeSpan timeout)
+    //    {
+    //        return ((IAsyncCommunicationObject)CommunicationObject).CloseAsync(timeout);
+    //    }
+
+    //    public void Close(TimeSpan timeout)
+    //    {
+    //        CommunicationObject.Close(timeout);
+    //    }
+
+    //    public IAsyncResult BeginClose(AsyncCallback callback, object state)
+    //    {
+    //        return CommunicationObject.BeginClose(callback, state);
+    //    }
+
+    //    public IAsyncResult BeginClose(TimeSpan timeout, AsyncCallback callback, object state)
+    //    {
+    //        return CommunicationObject.BeginClose(timeout, callback, state);
+    //    }
+
+    //    public void EndClose(IAsyncResult result)
+    //    {
+    //        CommunicationObject.EndClose(result);
+    //    }
+
+    //    public void Open()
+    //    {
+    //        CommunicationObject.Open();
+    //    }
+
+    //    public Task OpenAsync(TimeSpan timeout)
+    //    {
+    //        return ((IAsyncCommunicationObject)CommunicationObject).OpenAsync(timeout);
+    //    }
+
+    //    public void Open(TimeSpan timeout)
+    //    {
+    //        CommunicationObject.Open(timeout);
+    //    }
+
+    //    public IAsyncResult BeginOpen(AsyncCallback callback, object state)
+    //    {
+    //        return CommunicationObject.BeginOpen(callback, state);
+    //    }
+
+    //    public IAsyncResult BeginOpen(TimeSpan timeout, AsyncCallback callback, object state)
+    //    {
+    //        return CommunicationObject.BeginOpen(timeout, callback, state);
+    //    }
+
+    //    public void EndOpen(IAsyncResult result)
+    //    {
+    //        CommunicationObject.EndOpen(result);
+    //    }
+
+    //    public void Dispose()
+    //    {
+    //        Close();
+    //    }
+
+    //    // ISecurityCommunicationObject methods
+    //    public virtual void OnAbort()
+    //    {
+    //    }
+
+    //    public virtual Task OnCloseAsync(TimeSpan timeout)
+    //    {
+    //        return Task.CompletedTask;
+    //    }
+
+    //    public virtual void OnClosed()
+    //    {
+    //    }
+
+    //    public virtual void OnClosing()
+    //    {
+    //    }
+
+    //    public virtual void OnFaulted()
+    //    {
+    //        OnAbort();
+    //    }
+
+    //    public virtual Task OnOpenAsync(TimeSpan timeout)
+    //    {
+    //        return Task.CompletedTask;
+    //    }
+
+    //    public virtual void OnOpened()
+    //    {
+    //    }
+
+    //    public virtual void OnOpening()
+    //    {
+    //    }
+    //}
+
+    internal abstract class CommunicationObjectSecurityTokenAuthenticator : SecurityTokenAuthenticator, ICommunicationObject, ISecurityCommunicationObject
+    {
+        protected CommunicationObjectSecurityTokenAuthenticator()
+        {
+            CommunicationObject = new WrapperSecurityCommunicationObject(this);
+        }
+
+        protected WrapperSecurityCommunicationObject CommunicationObject { get; }
+
+        public event EventHandler Closed
+        {
+            add { CommunicationObject.Closed += value; }
+            remove { CommunicationObject.Closed -= value; }
+        }
+
+        public event EventHandler Closing
+        {
+            add { CommunicationObject.Closing += value; }
+            remove { CommunicationObject.Closing -= value; }
+        }
+
+        public event EventHandler Faulted
+        {
+            add { CommunicationObject.Faulted += value; }
+            remove { CommunicationObject.Faulted -= value; }
+        }
+
+        public event EventHandler Opened
+        {
+            add { CommunicationObject.Opened += value; }
+            remove { CommunicationObject.Opened -= value; }
+        }
+
+        public event EventHandler Opening
+        {
+            add { CommunicationObject.Opening += value; }
+            remove { CommunicationObject.Opening -= value; }
+        }
+
+        public CommunicationState State
+        {
+            get { return CommunicationObject.State; }
+        }
+
+        public virtual TimeSpan DefaultOpenTimeout
+        {
+            get { return ServiceDefaults.OpenTimeout; }
+        }
+
+        public virtual TimeSpan DefaultCloseTimeout
+        {
+            get { return ServiceDefaults.CloseTimeout; }
+        }
+
+        // communication object
+        public void Abort()
+        {
+            CommunicationObject.Abort();
+        }
+
+       
+        public virtual void OnClose(TimeSpan timeout)
+        {
+        }
+
+        public Task OnCloseAsync(TimeSpan timeout)
+        {
+            return Task.CompletedTask;
+        }
+
+        public virtual void OnFaulted()
+        {
+            Abort();
+        }
+
+        public virtual void OnOpen(TimeSpan timeout)
+        {
+        }
+
+        public Task OnOpenAsync(TimeSpan timeout)
+        {
+            return Task.CompletedTask;
+        }
+
+        public virtual Task CloseAsync()
+        {
+            return Task.CompletedTask;
+        }
+
+        public virtual  Task CloseAsync(CancellationToken token)
+        {
+            return Task.CompletedTask;
+        }
+
+        public virtual Task OpenAsync()
+        {
+            return Task.CompletedTask;
+        }
+
+        public virtual Task OpenAsync(CancellationToken token)
+        {
+            return Task.CompletedTask;
+        }
+
+        public void OnAbort()
+        {
+            
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/XmlHelper.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/XmlHelper.cs
new file mode 100644
index 0000000..55891f9
--- /dev/null
+++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/XmlHelper.cs
@@ -0,0 +1,417 @@
+
+
+
+using System;
+using System.Text;
+using System.Xml;
+
+namespace CoreWCF.Security
+{
+    internal static class XmlHelper
+    {
+        internal static void AddNamespaceDeclaration(XmlDictionaryWriter writer, string prefix, XmlDictionaryString ns)
+        {
+            string p = writer.LookupPrefix(ns.Value);
+            if (p == null || p != prefix)
+            {
+                writer.WriteXmlnsAttribute(prefix, ns);
+            }
+        }
+
+        internal static string EnsureNamespaceDefined(XmlDictionaryWriter writer, XmlDictionaryString ns, string defaultPrefix)
+        {
+            string p = writer.LookupPrefix(ns.Value);
+            if (p == null)
+            {
+                writer.WriteXmlnsAttribute(defaultPrefix, ns);
+                p = defaultPrefix;
+            }
+
+            return p;
+        }
+
+        internal static XmlQualifiedName GetAttributeValueAsQName(XmlReader reader, string attributeName)
+        {
+            string qname = reader.GetAttribute(attributeName);
+            if (qname == null)
+            {
+                return null;
+            }
+            return GetValueAsQName(reader, qname);
+        }
+
+        /// <summary>
+        /// Enforces that parent has exactly 1 child of type XML element and nothing else (barring comments and whitespaces)
+        /// and returns the child
+        /// </summary>
+        internal static XmlElement GetChildElement(XmlElement parent)
+        {
+            if (parent == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(parent));
+            }
+
+            XmlElement result = null;
+            for (int i = 0; i < parent.ChildNodes.Count; ++i)
+            {
+                XmlNode child = parent.ChildNodes[i];
+                if (child.NodeType == XmlNodeType.Whitespace || child.NodeType == XmlNodeType.Comment)
+                {
+                    continue;
+                }
+                else if (child.NodeType == XmlNodeType.Element && result == null)
+                {
+                    result = ((XmlElement)child);
+                }
+                else
+                {
+                    OnUnexpectedChildNodeError(parent, child);
+                }
+            }
+
+            if (result == null)
+            {
+                OnChildNodeTypeMissing(parent, XmlNodeType.Element);
+            }
+
+            return result;
+        }
+
+        internal static XmlElement GetChildElement(XmlElement parent, string childLocalName, string childNamespace)
+        {
+            if (parent == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(parent));
+            }
+
+            for (int i = 0; i < parent.ChildNodes.Count; ++i)
+            {
+                XmlNode child = parent.ChildNodes[i];
+
+                if (child.NodeType == XmlNodeType.Whitespace || child.NodeType == XmlNodeType.Comment)
+                {
+                    continue;
+                }
+                else if (child.NodeType == XmlNodeType.Element)
+                {
+                    if (child.LocalName == childLocalName && child.NamespaceURI == childNamespace)
+                    {
+                        return ((XmlElement)child);
+                    }
+                }
+                else
+                {
+                    OnUnexpectedChildNodeError(parent, child);
+                }
+            }
+
+            return null;
+        }
+
+        internal static XmlQualifiedName GetValueAsQName(XmlReader reader, string value)
+        {
+            string prefix;
+            string name;
+            SplitIntoPrefixAndName(value, out prefix, out name);
+            string ns = reader.LookupNamespace(prefix);
+            if (ns == null && prefix.Length > 0)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new XmlException(SR.Format(SR.CouldNotFindNamespaceForPrefix, prefix)));
+            }
+            return new XmlQualifiedName(name, ns);
+        }
+
+        internal static string GetWhiteSpace(XmlReader reader)
+        {
+            string s = null;
+            StringBuilder sb = null;
+            while (reader.NodeType == XmlNodeType.Whitespace || reader.NodeType == XmlNodeType.SignificantWhitespace)
+            {
+                if (sb != null)
+                {
+                    sb.Append(reader.Value);
+                }
+                else if (s != null)
+                {
+                    sb = new StringBuilder(s);
+                    sb.Append(reader.Value);
+                    s = null;
+                }
+                else
+                {
+                    s = reader.Value;
+                }
+                if (!reader.Read())
+                {
+                    break;
+                }
+            }
+            return sb != null ? sb.ToString() : s;
+        }
+
+        internal static bool IsWhitespaceOrComment(XmlReader reader)
+        {
+            if (reader.NodeType == XmlNodeType.Comment)
+            {
+                return true;
+            }
+            else if (reader.NodeType == XmlNodeType.Whitespace)
+            {
+                return true;
+            }
+            else
+            {
+                return false;
+            }
+        }
+
+        internal static void OnChildNodeTypeMissing(string parentName, XmlNodeType expectedNodeType)
+        {
+            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new XmlException(SR.Format(SR.ChildNodeTypeMissing, parentName, expectedNodeType)));
+        }
+
+        internal static void OnChildNodeTypeMissing(XmlElement parent, XmlNodeType expectedNodeType)
+        {
+            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new XmlException(SR.Format(SR.ChildNodeTypeMissing, parent.Name, expectedNodeType)));
+        }
+
+        internal static void OnEmptyElementError(XmlReader r)
+        {
+            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new XmlException(SR.Format(SR.EmptyXmlElementError, r.Name)));
+        }
+
+        internal static void OnEmptyElementError(XmlElement e)
+        {
+            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new XmlException(SR.Format(SR.EmptyXmlElementError, e.Name)));
+        }
+
+        internal static void OnEOF()
+        {
+            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new XmlException(SR.Format(SR.UnexpectedEndOfFile)));
+        }
+
+        internal static void OnNamespaceMissing(string prefix)
+        {
+            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new XmlException(SR.Format(SR.CouldNotFindNamespaceForPrefix, prefix)));
+        }
+
+        internal static void OnRequiredAttributeMissing(string attrName, string elementName)
+        {
+            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new XmlException(SR.Format(SR.RequiredAttributeMissing, attrName, elementName)));
+        }
+
+        internal static void OnRequiredElementMissing(string elementName, string elementNamespace)
+        {
+            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new XmlException(SR.Format(SR.ExpectedElementMissing, elementName, elementNamespace)));
+        }
+
+        internal static void OnUnexpectedChildNodeError(string parentName, XmlReader r)
+        {
+            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new XmlException(SR.Format(SR.UnexpectedXmlChildNode, r.Name, r.NodeType, parentName)));
+        }
+
+        internal static void OnUnexpectedChildNodeError(XmlElement parent, XmlNode n)
+        {
+            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new XmlException(SR.Format(SR.UnexpectedXmlChildNode, n.Name, n.NodeType, parent.Name)));
+        }
+
+        internal static string ReadEmptyElementAndRequiredAttribute(XmlDictionaryReader reader,
+            XmlDictionaryString name, XmlDictionaryString namespaceUri, XmlDictionaryString attributeName,
+            out string prefix)
+        {
+            reader.MoveToStartElement(name, namespaceUri);
+            prefix = reader.Prefix;
+            bool isEmptyElement = reader.IsEmptyElement;
+            string value = reader.GetAttribute(attributeName, null);
+            if (value == null)
+            {
+                OnRequiredAttributeMissing(attributeName.Value, null);
+            }
+            reader.Read();
+
+            if (!isEmptyElement)
+            {
+                reader.ReadEndElement();
+            }
+            return value;
+        }
+
+        internal static string GetRequiredNonEmptyAttribute(XmlDictionaryReader reader, XmlDictionaryString name, XmlDictionaryString ns)
+        {
+            string value = reader.GetAttribute(name, ns);
+            if (value == null || value.Length == 0)
+            {
+                OnRequiredAttributeMissing(name.Value, reader == null ? null : reader.Name);
+            }
+            return value;
+        }
+
+        internal static byte[] GetRequiredBase64Attribute(XmlDictionaryReader reader, XmlDictionaryString name, XmlDictionaryString ns)
+        {
+            if (!reader.MoveToAttribute(name.Value, ns == null ? null : ns.Value))
+            {
+                OnRequiredAttributeMissing(name.Value, ns == null ? null : ns.Value);
+            }
+            byte[] value = reader.ReadContentAsBase64();
+            if (value == null || value.Length == 0)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(
+                    new XmlException(SR.Format(SR.EmptyBase64Attribute, name, ns)));
+            }
+
+            return value;
+        }
+
+        internal static string ReadTextElementAsTrimmedString(XmlElement element)
+        {
+            if (element == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(element));
+            }
+
+            using (XmlReader reader = new XmlNodeReader(element))
+            {
+                reader.MoveToContent();
+                return XmlUtil.Trim(reader.ReadElementContentAsString());
+            }
+        }
+
+        internal static void SplitIntoPrefixAndName(string qName, out string prefix, out string name)
+        {
+            string[] parts = qName.Split(':');
+            if (parts.Length > 2)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgument(SR.Format(SR.InvalidQName));
+            }
+
+            if (parts.Length == 2)
+            {
+                prefix = parts[0].Trim();
+                name = parts[1].Trim();
+            }
+            else
+            {
+                prefix = string.Empty;
+                name = qName.Trim();
+            }
+        }
+
+        internal static void ValidateIdPrefix(string idPrefix)
+        {
+            if (idPrefix == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException(nameof(idPrefix)));
+            }
+
+            if (idPrefix.Length == 0)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(idPrefix), SR.Format(SR.ValueMustBeGreaterThanZero)));
+            }
+
+            if ((!Char.IsLetter(idPrefix[0]) && idPrefix[0] != '_'))
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(idPrefix), SR.Format(SR.InValidateIdPrefix, idPrefix[0])));
+            }
+
+            for (int i = 1; i < idPrefix.Length; i++)
+            {
+                char c = idPrefix[i];
+                if (!Char.IsLetter(c) && !Char.IsNumber(c) && c != '.' && c != '_' && c != '-')
+                {
+                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(idPrefix), SR.Format(SR.InValidateId, idPrefix[i])));
+                }
+            }
+        }
+
+        internal static UniqueId GetAttributeAsUniqueId(XmlDictionaryReader reader, XmlDictionaryString localName, XmlDictionaryString ns)
+        {
+            return GetAttributeAsUniqueId(reader, localName.Value, (ns != null ? ns.Value : null));
+        }
+
+        private static UniqueId GetAttributeAsUniqueId(XmlDictionaryReader reader, string name, string ns)
+        {
+            if (!reader.MoveToAttribute(name, ns))
+            {
+                return null;
+            }
+
+            UniqueId id = reader.ReadContentAsUniqueId();
+            reader.MoveToElement();
+
+            return id;
+        }
+
+        static public void WriteAttributeStringAsUniqueId(XmlDictionaryWriter writer, string prefix, XmlDictionaryString localName, XmlDictionaryString ns, UniqueId id)
+        {
+            writer.WriteStartAttribute(prefix, localName, ns);
+            writer.WriteValue(id);
+            writer.WriteEndAttribute();
+        }
+
+        static public void WriteElementStringAsUniqueId(XmlWriter writer, string localName, UniqueId id)
+        {
+            writer.WriteStartElement(localName);
+            writer.WriteValue(id);
+            writer.WriteEndElement();
+        }
+        static public void WriteElementStringAsUniqueId(XmlDictionaryWriter writer, XmlDictionaryString localName, XmlDictionaryString ns, UniqueId id)
+        {
+            writer.WriteStartElement(localName, ns);
+            writer.WriteValue(id);
+            writer.WriteEndElement();
+        }
+
+        static public void WriteElementContentAsInt64(XmlDictionaryWriter writer, XmlDictionaryString localName, XmlDictionaryString ns, Int64 value)
+        {
+            writer.WriteStartElement(localName, ns);
+            writer.WriteValue(value);
+            writer.WriteEndElement();
+        }
+
+        static public Int64 ReadElementContentAsInt64(XmlDictionaryReader reader)
+        {
+            reader.ReadFullStartElement();
+            Int64 i = reader.ReadContentAsLong();
+            reader.ReadEndElement();
+            return i;
+        }
+
+        static public void WriteStringAsUniqueId(XmlDictionaryWriter writer, UniqueId id)
+        {
+            writer.WriteValue(id);
+        }
+
+        static public UniqueId ReadElementStringAsUniqueId(XmlDictionaryReader reader, XmlDictionaryString localName, XmlDictionaryString ns)
+        {
+            if (reader.IsStartElement(localName, ns) && reader.IsEmptyElement)
+            {
+                reader.Read();
+                return new UniqueId(string.Empty);
+            }
+
+            reader.ReadStartElement(localName, ns);
+            UniqueId id = reader.ReadContentAsUniqueId();
+            reader.ReadEndElement();
+            return id;
+        }
+
+        static public UniqueId ReadElementStringAsUniqueId(XmlDictionaryReader reader)
+        {
+            if (reader.IsStartElement() && reader.IsEmptyElement)
+            {
+                reader.Read();
+                return new UniqueId(string.Empty);
+            }
+
+            reader.ReadStartElement();
+            UniqueId id = reader.ReadContentAsUniqueId();
+            reader.ReadEndElement();
+            return id;
+        }
+
+        static public UniqueId ReadTextElementAsUniqueId(XmlElement element)
+        {
+            return new UniqueId(ReadTextElementAsTrimmedString(element));
+        }
+    }
+}
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/SecurityMode.cs b/src/CoreWCF.Primitives/src/CoreWCF/SecurityMode.cs
index d93c600..509417e 100644
--- a/src/CoreWCF.Primitives/src/CoreWCF/SecurityMode.cs
+++ b/src/CoreWCF.Primitives/src/CoreWCF/SecurityMode.cs
@@ -1,5 +1,6 @@
 namespace CoreWCF
 {
+    using System;
     public enum SecurityMode
     {
         None = 0,
@@ -7,4 +8,41 @@ namespace CoreWCF
         Message = 2,
         TransportWithMessageCredential = 3,
     }
+    [Flags]
+    internal enum UnifiedSecurityMode
+    {
+        None = 0x001,
+        Transport = 0x004,
+        Message = 0x008,
+        Both = 0x010,
+        TransportWithMessageCredential = 0x020,
+        TransportCredentialOnly = 0x040,
+    }
+   public static class SecurityModeHelper
+    {
+        public static bool IsDefined(SecurityMode value)
+        {
+            return (value == SecurityMode.None ||
+                value == SecurityMode.Transport ||
+                value == SecurityMode.Message ||
+                value == SecurityMode.TransportWithMessageCredential);
+        }
+
+        internal static SecurityMode ToSecurityMode(UnifiedSecurityMode value)
+        {
+            switch (value)
+            {
+                case UnifiedSecurityMode.None:
+                    return SecurityMode.None;
+                case UnifiedSecurityMode.Transport:
+                    return SecurityMode.Transport;
+                case UnifiedSecurityMode.Message:
+                    return SecurityMode.Message;
+                case UnifiedSecurityMode.TransportWithMessageCredential:
+                    return SecurityMode.TransportWithMessageCredential;
+                default:
+                    return (SecurityMode)value;
+            }
+        }
+    }
 }
\ No newline at end of file
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/ServiceAuthenticationManager.cs b/src/CoreWCF.Primitives/src/CoreWCF/ServiceAuthenticationManager.cs
index b94e689..28c2481 100644
--- a/src/CoreWCF.Primitives/src/CoreWCF/ServiceAuthenticationManager.cs
+++ b/src/CoreWCF.Primitives/src/CoreWCF/ServiceAuthenticationManager.cs
@@ -14,4 +14,121 @@ namespace CoreWCF
             return authPolicy;
         }
     }
+    internal class SCTServiceAuthenticationManagerWrapper : ServiceAuthenticationManager
+    {
+        ServiceAuthenticationManager wrappedAuthenticationManager;
+
+        internal SCTServiceAuthenticationManagerWrapper(ServiceAuthenticationManager wrappedServiceAuthManager)
+        {
+            if (wrappedServiceAuthManager == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("wrappedServiceAuthManager");
+            }
+
+            this.wrappedAuthenticationManager = wrappedServiceAuthManager;
+        }
+
+        public override ReadOnlyCollection<IAuthorizationPolicy> Authenticate(ReadOnlyCollection<IAuthorizationPolicy> authPolicy, Uri listenUri, ref Message message)
+        {
+            if ((message != null) &&
+                (message.Properties != null) &&
+                (message.Properties.Security != null) &&
+                (message.Properties.Security.TransportToken != null) &&
+                (message.Properties.Security.ServiceSecurityContext != null) &&
+                (message.Properties.Security.ServiceSecurityContext.AuthorizationPolicies != null))
+            {
+                List<IAuthorizationPolicy> authPolicies = new List<IAuthorizationPolicy>(message.Properties.Security.ServiceSecurityContext.AuthorizationPolicies);
+                foreach (IAuthorizationPolicy policy in message.Properties.Security.TransportToken.SecurityTokenPolicies)
+                {
+                    authPolicies.Remove(policy);
+                }
+                authPolicy = authPolicies.AsReadOnly();
+            }
+
+            return this.wrappedAuthenticationManager.Authenticate(authPolicy, listenUri, ref message);
+        }
+    }
+
+    /*
+    internal class ServiceAuthenticationManagerWrapper : ServiceAuthenticationManager
+    {
+        ServiceAuthenticationManager wrappedAuthenticationManager;
+        string[] filteredActionUriCollection;
+
+        internal ServiceAuthenticationManagerWrapper(ServiceAuthenticationManager wrappedServiceAuthManager, string[] actionUriFilter)
+        {
+            if (wrappedServiceAuthManager == null)
+            {
+                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("wrappedServiceAuthManager");
+            }
+
+            if ((actionUriFilter != null) && (actionUriFilter.Length > 0))
+            {
+                this.filteredActionUriCollection = new string[actionUriFilter.Length];
+                for (int i = 0; i < actionUriFilter.Length; ++i)
+                {
+                    this.filteredActionUriCollection[i] = actionUriFilter[i];
+                }
+            }
+
+            this.wrappedAuthenticationManager = wrappedServiceAuthManager;
+        }
+
+        public override ReadOnlyCollection<IAuthorizationPolicy> Authenticate(ReadOnlyCollection<IAuthorizationPolicy> authPolicy, Uri listenUri, ref Message message)
+        {
+            if (CanSkipAuthentication(message))
+            {
+                return authPolicy;
+            }
+
+            if (this.filteredActionUriCollection != null)
+            {
+                for (int i = 0; i < this.filteredActionUriCollection.Length; ++i)
+                {
+                    if ((message != null) &&
+                        (message.Headers != null) &&
+                        !String.IsNullOrEmpty(message.Headers.Action) &&
+                        (message.Headers.Action == this.filteredActionUriCollection[i]))
+                    {
+                        return authPolicy;
+                    }
+                }
+            }
+
+            return this.wrappedAuthenticationManager.Authenticate(authPolicy, listenUri, ref message);
+        }
+
+        //
+        // We skip the authentication step if the client already has an SCT and there are no Transport level tokens.
+        // ServiceAuthenticationManager would have been called when the SCT was issued and there is no need to do
+        // Authentication again. If TransportToken was present then we would call ServiceAutenticationManager as 
+        // TransportTokens are not authenticated during SCT issuance.
+        //
+        bool CanSkipAuthentication(Message message)
+        {
+            if ((message != null) && (message.Properties != null) && (message.Properties.Security != null) && (message.Properties.Security.TransportToken == null))
+            {
+                if ((message.Properties.Security.ProtectionToken != null) &&
+                    (message.Properties.Security.ProtectionToken.SecurityToken != null) &&
+                    (message.Properties.Security.ProtectionToken.SecurityToken.GetType() == typeof(SecurityContextSecurityToken)))
+                {
+                    return true;
+                }
+
+                if (message.Properties.Security.HasIncomingSupportingTokens)
+                {
+                    foreach (SupportingTokenSpecification tokenSpecification in message.Properties.Security.IncomingSupportingTokens)
+                    {
+                        if ((tokenSpecification.SecurityTokenAttachmentMode == SecurityTokenAttachmentMode.Endorsing) &&
+                            (tokenSpecification.SecurityToken.GetType() == typeof(SecurityContextSecurityToken)))
+                        {
+                            return true;
+                        }
+                    }
+                }
+            }
+
+            return false;
+        }
+    }*/
 }
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/ServiceHostBase.cs b/src/CoreWCF.Primitives/src/CoreWCF/ServiceHostBase.cs
index cec4444..a45c6d2 100644
--- a/src/CoreWCF.Primitives/src/CoreWCF/ServiceHostBase.cs
+++ b/src/CoreWCF.Primitives/src/CoreWCF/ServiceHostBase.cs
@@ -126,20 +126,18 @@ namespace CoreWCF
         {
             get
             {
-                // TODO: Decide if Credentials should be populated?
-                return null;
-                //if (this.Description == null)
-                //{
-                //    return null;
-                //}
-                //else if (this.State == CommunicationState.Created || this.State == CommunicationState.Opening)
-                //{
-                //    return EnsureCredentials(this.Description);
-                //}
-                //else
-                //{
-                //    return this.readOnlyCredentials;
-                //}
+                if (this.Description == null)
+                {
+                    return null;
+                }
+                else if (this.State == CommunicationState.Created || this.State == CommunicationState.Opening)
+                {
+                    return EnsureCredentials(this.Description);
+                }
+                else
+                {
+                    return this.readOnlyCredentials;
+                }
             }
         }
 
@@ -337,11 +335,6 @@ namespace CoreWCF
         //    throw new PlatformNotSupportedException();
         //}
 
-        protected override void OnAbort()
-        {
-            throw new PlatformNotSupportedException();
-        }
-
         internal void OnAddChannelDispatcher(ChannelDispatcherBase channelDispatcher)
         {
             lock (ThisLock)
@@ -351,25 +344,17 @@ namespace CoreWCF
                 channelDispatcher.Faulted += new EventHandler(OnChannelDispatcherFaulted);
             }
         }
-
-        protected override Task OnCloseAsync(CancellationToken cancellationToken)
-        {
-            throw new PlatformNotSupportedException();
-        }
-
-        protected override Task OnOpenAsync(CancellationToken cancellationToken)
-        {
-            throw new PlatformNotSupportedException();
-        }
-
-        protected override void OnClosed()
+        ServiceCredentials EnsureCredentials(ServiceDescription description)
         {
-            throw new PlatformNotSupportedException();
-        }
+            Fx.Assert(this.State == CommunicationState.Created || this.State == CommunicationState.Opening, "");
+            ServiceCredentials c = description.Behaviors.Find<ServiceCredentials>();
+            if (c == null)
+            {
+                c = new ServiceCredentials();
+                description.Behaviors.Add(c);
+            }
 
-        protected override void OnOpened()
-        {
-            throw new PlatformNotSupportedException();
+            return c;
         }
 
         internal void OnRemoveChannelDispatcher(ChannelDispatcherBase channelDispatcher)
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/ServiceHostObjectModel.cs b/src/CoreWCF.Primitives/src/CoreWCF/ServiceHostObjectModel.cs
index 4107fd6..99e2e79 100644
--- a/src/CoreWCF.Primitives/src/CoreWCF/ServiceHostObjectModel.cs
+++ b/src/CoreWCF.Primitives/src/CoreWCF/ServiceHostObjectModel.cs
@@ -7,19 +7,27 @@ using CoreWCF.Collections.Generic;
 using CoreWCF.Channels;
 using CoreWCF.Description;
 using Microsoft.Extensions.DependencyInjection;
+using Microsoft.AspNetCore.Hosting.Server.Features;
+using Microsoft.AspNetCore.Hosting.Server;
+using System.Threading.Tasks;
+using System.Threading;
+using CoreWCF.Configuration;
+using System.Linq;
 
 namespace CoreWCF
 {
-    internal class ServiceHostObjectModel<TService> : ServiceHostBase where TService : class
+    public class ServiceHostObjectModel<TService> : ServiceHostBase where TService : class
     {
         private IDisposable _disposableInstance;
         private TService _singletonInstance;
         private readonly IServiceProvider _serviceProvider;
+        private IServerAddressesFeature _serverAddresses;
 
-        public ServiceHostObjectModel(IServiceProvider serviceProvider, Uri[] baseAddresses)
+        public ServiceHostObjectModel(IServiceProvider serviceProvider, IServer server, IServiceBuilder serviceBuilder)
         {
             _serviceProvider = serviceProvider;
-            InitializeDescription(new UriSchemeKeyedCollection(baseAddresses));
+            _serverAddresses = server.Features.Get<IServerAddressesFeature>();
+            InitializeDescription(new UriSchemeKeyedCollection(serviceBuilder.BaseAddresses.ToArray()));
         }
 
         public TService SingletonInstance { get; private set; }
@@ -216,6 +224,7 @@ namespace CoreWCF
 
         internal Uri MakeAbsoluteUri(Uri uri, Binding binding)
         {
+            EnsureBaseAddresses();
             Uri result = uri;
             if (!result.IsAbsoluteUri)
             {
@@ -223,15 +232,50 @@ namespace CoreWCF
                 {
                     throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.SFxCustomBindingWithoutTransport));
                 }
+
                 result = GetVia(binding.Scheme, result, InternalBaseAddresses);
                 if (result == null)
                 {
-                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.SFxEndpointNoMatchingScheme, binding.Scheme, binding.Name, GetBaseAddressSchemes(InternalBaseAddresses))));
+                    UriBuilder listenUriBuilder = new UriBuilder(binding.Scheme, DnsCache.MachineName);
+                    result = new Uri(listenUriBuilder.Uri, uri);
                 }
             }
+
             return result;
         }
 
+        private void EnsureBaseAddresses()
+        {
+            if (_serverAddresses != null)
+            {
+                foreach(var addr in _serverAddresses.Addresses)
+                {
+                    var uri = new Uri(addr);
+                    bool skip = false;
+                    foreach(var baseAddress in InternalBaseAddresses)
+                    {
+                        if (baseAddress.Port == uri.Port && baseAddress.Scheme != uri.Scheme)
+                        {
+                            // ASP.NET Core adds net.tcp uri's as http{s} uri's
+                            skip = true;
+                            break;
+                        }
+                    }
+                    if (!skip && !InternalBaseAddresses.Contains(uri))
+                    {
+
+                        InternalBaseAddresses.Add(uri);
+                    }
+                }
+
+                if (_serverAddresses.Addresses.Count > 0)
+                {
+                    // It was populated by ASP.NET Core so can skip re-adding in future.
+                    _serverAddresses = null;
+                }
+            }
+        }
+
         internal static String GetBaseAddressSchemes(UriSchemeKeyedCollection uriSchemeKeyedCollection)
         {
             StringBuilder buffer = new StringBuilder();
@@ -295,5 +339,16 @@ namespace CoreWCF
             return new Uri(baseUri, path);
         }
 
+        protected override void OnAbort() { }
+
+        protected override Task OnCloseAsync(CancellationToken token)
+        {
+            return Task.CompletedTask;
+        }
+
+        protected override Task OnOpenAsync(CancellationToken token)
+        {
+            return Task.CompletedTask;
+        }
     }
 }
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/ServiceModelDictionary.cs b/src/CoreWCF.Primitives/src/CoreWCF/ServiceModelDictionary.cs
index 859b5a2..25ebbd4 100644
--- a/src/CoreWCF.Primitives/src/CoreWCF/ServiceModelDictionary.cs
+++ b/src/CoreWCF.Primitives/src/CoreWCF/ServiceModelDictionary.cs
@@ -4,7 +4,7 @@ using System.Xml;
 
 namespace CoreWCF
 {
-    class ServiceModelDictionary : IXmlDictionary
+   internal class ServiceModelDictionary : IXmlDictionary
     {
         static public readonly ServiceModelDictionary Version1 = new ServiceModelDictionary(new ServiceModelStringsVersion1());
         readonly ServiceModelStrings _strings;
diff --git a/src/CoreWCF.Primitives/src/CoreWCF/XD.cs b/src/CoreWCF.Primitives/src/CoreWCF/XD.cs
index b3a608a..fa889d4 100644
--- a/src/CoreWCF.Primitives/src/CoreWCF/XD.cs
+++ b/src/CoreWCF.Primitives/src/CoreWCF/XD.cs
@@ -1,4 +1,5 @@
-﻿using System.Xml;
+﻿using CoreWCF.IdentityModel;
+using System.Xml;
 
 namespace CoreWCF
 {
@@ -957,7 +958,7 @@ namespace CoreWCF
         }
     }
 
-    class SecureConversationDictionary
+   public class SecureConversationDictionary
     {
         public XmlDictionaryString Namespace;
         public XmlDictionaryString DerivedKeyToken;
@@ -983,10 +984,10 @@ namespace CoreWCF
         public SecureConversationDictionary()
         {
         }
-
-        public SecureConversationDictionary(ServiceModelDictionary dictionary)
+        internal SecureConversationDictionary(ServiceModelDictionary dictionary)
         {
         }
+
     }
 
     class SecureConversationApr2004Dictionary : SecureConversationDictionary
@@ -1016,6 +1017,7 @@ namespace CoreWCF
             RenewNeededFaultCode = dictionary.CreateString(ServiceModelStringsVersion1.String127, 127);
             BadContextTokenFaultCode = dictionary.CreateString(ServiceModelStringsVersion1.String128, 128);
         }
+
     }
 
     class SecureConversationFeb2005Dictionary : SecureConversationDictionary
@@ -1299,7 +1301,7 @@ namespace CoreWCF
         }
     }
 
-    class TrustDictionary
+   internal class TrustDictionary
     {
         public XmlDictionaryString RequestSecurityTokenResponseCollection;
         public XmlDictionaryString Namespace;
@@ -2486,6 +2488,8 @@ namespace CoreWCF
         public const string X509SerialNumber = ServiceModelStringsVersion1.String326;
         public const string X509Certificate = ServiceModelStringsVersion1.String327;
         // String constants
+        public const string SecurityJan2004Namespace = "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd";
+        public const string SecurityJan2004Prefix = "o";
         public const string X509Ski = "X509SKI";
         public const string TransformationParameters = "TransformationParameters";
     }
diff --git a/src/CoreWCF.Primitives/src/Resources/Strings.resx b/src/CoreWCF.Primitives/src/Resources/Strings.resx
index cb3ffa1..24791fb 100644
--- a/src/CoreWCF.Primitives/src/Resources/Strings.resx
+++ b/src/CoreWCF.Primitives/src/Resources/Strings.resx
@@ -7984,4 +7984,7 @@
   <data name="UserNameCannotBeEmpty" xml:space="preserve">
     <value>The username cannot be empty.</value>
   </data>
+    <data name="TimeSpanMustbeGreaterThanTimeSpanZero" xml:space="preserve">
+    <value>TimeSpan must be greater than TimeSpan.Zero</value>
+  </data>
 </root>
\ No newline at end of file
diff --git a/src/CoreWCF.Primitives/tests/BasicFaultTest.cs b/src/CoreWCF.Primitives/tests/BasicFaultTest.cs
new file mode 100644
index 0000000..605afd3
--- /dev/null
+++ b/src/CoreWCF.Primitives/tests/BasicFaultTest.cs
@@ -0,0 +1,89 @@
+﻿using CoreWCF.Channels;
+using System;
+using System.Collections.Generic;
+using Xunit;
+using Xunit.Abstractions;
+
+namespace CoreWCF.Primitives.Tests
+{
+    public class BasicFaultTest
+    {
+        [Fact]
+        public void RunBasicFaultTest()
+        {
+            for
+            (
+                MessageVersion version = MessageVersion.Soap11;
+                version != null;
+                version = (version == MessageVersion.Soap11) ? MessageVersion.Soap12WSAddressing10 : null
+            )
+            {
+                var translations = new List<FaultReasonText>();
+                translations.Add(new FaultReasonText("Reason: auto-generated fault for testing.", "en-us"));
+                translations.Add(new FaultReasonText("Raison: auto-generat error pour examiner.", "fr"));
+
+                var reason = new FaultReason(translations);
+                Object detail = "Sample fault detail content.";
+
+                MessageFault fault = MessageFault.CreateFault(new FaultCode("Sender"), reason, detail, new System.Runtime.Serialization.DataContractSerializer(typeof(string)), "", "");
+                Message message = Message.CreateMessage(MessageVersion.Soap12WSAddressing10, fault, "http://www.w3.org/2005/08/addressing/fault");
+                Message m2 = MessageTestUtilities.SendAndReceiveMessage(message);
+                MessageFault f2 = MessageFault.CreateFault(m2, int.MaxValue);
+
+                IsFaultEqual(fault, f2);
+            }
+        }
+
+        private void IsFaultEqual(MessageFault f1, MessageFault f2)
+        {
+            if (f1.Code.Name != f2.Code.Name)
+            {
+                throw new ApplicationException("Message Fault Names are not equal");
+            }
+
+            if (f1.Reason.ToString() != f2.Reason.ToString())
+            {
+                throw new ApplicationException("Message Fault Reason are not equal");
+            }
+
+            if (f1.Node != f2.Node)
+            {
+                throw new ApplicationException("Message Fault Node are not equal");
+            }
+
+            if (f1.Actor != f2.Actor)
+            {
+                throw new ApplicationException("Message Fault Actor are not equal");
+            }
+
+            if (!(f1.HasDetail ^ f2.HasDetail))
+            {
+                if (f1.GetDetail<String>() != f2.GetDetail<String>())
+                {
+                    throw new ApplicationException("Message Fault Detail are not equal");
+                }
+            }
+        }
+    }
+
+    internal class MessageTestUtilities
+    {
+        public static Message SendAndReceiveMessage(Message toSend)
+        {
+            MessageEncoder encoder = null;
+            if (toSend.Version.Envelope == EnvelopeVersion.Soap11)
+            {
+                encoder = new TextMessageEncodingBindingElement(toSend.Version, System.Text.Encoding.UTF8).CreateMessageEncoderFactory().Encoder;
+            }
+            else
+            {
+                encoder = new BinaryMessageEncodingBindingElement().CreateMessageEncoderFactory().Encoder;
+            }
+            BufferManager bufferManager = BufferManager.CreateBufferManager(int.MaxValue, int.MaxValue);
+            ArraySegment<byte> encodedMessage = encoder.WriteMessage(toSend, int.MaxValue, bufferManager);
+
+            Message r = encoder.ReadMessage(encodedMessage, bufferManager);
+            return r;
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/CoreWCF.Primitives/tests/DispatcherClient/DispatcherClientRequestContext.cs b/src/CoreWCF.Primitives/tests/DispatcherClient/DispatcherClientRequestContext.cs
index adf4dba..5b0607e 100644
--- a/src/CoreWCF.Primitives/tests/DispatcherClient/DispatcherClientRequestContext.cs
+++ b/src/CoreWCF.Primitives/tests/DispatcherClient/DispatcherClientRequestContext.cs
@@ -9,8 +9,8 @@ namespace DispatcherClient
 {
     public class DispatcherClientRequestContext : RequestContext
     {
-        private MessageBuffer _bufferedCopy;
         private TaskCompletionSource<Message> _replyMessage;
+        private MessageBuffer _bufferedCopy;
 
         public DispatcherClientRequestContext(Message requestMessage)
         {
@@ -18,12 +18,7 @@ namespace DispatcherClient
             _replyMessage = new TaskCompletionSource<Message>();
         }
 
-
-        public DispatcherClientRequestContext(System.ServiceModel.Channels.Message requestMessage)
-        {
-            RequestMessage = TestHelper.ConvertMessage(requestMessage);
-            _replyMessage = new TaskCompletionSource<Message>();
-        }
+        public DispatcherClientRequestContext(System.ServiceModel.Channels.Message requestMessage) : this(TestHelper.ConvertMessage(requestMessage)) { }
 
         public override Message RequestMessage { get; }
 
@@ -42,27 +37,18 @@ namespace DispatcherClient
             }
         }
 
-        private void SetReplyMessage(Message reply)
-        {
-            _bufferedCopy = reply.CreateBufferedCopy(int.MaxValue);
-            _replyMessage.TrySetResult(_bufferedCopy.CreateMessage());
-        }
-
         public override void Abort()
         {
-            _replyMessage.TrySetException(new CommunicationException("Request aborted"));
-            return;
+            _replyMessage.TrySetException(new CommunicationException("Aborted"));
         }
 
         public override Task CloseAsync()
         {
-            _replyMessage.TrySetException(new CommunicationException("Request aborted"));
             return Task.CompletedTask;
         }
 
         public override Task CloseAsync(CancellationToken token)
         {
-            _replyMessage.TrySetException(new CommunicationException("Request aborted"));
             return Task.CompletedTask;
         }
 
@@ -73,7 +59,8 @@ namespace DispatcherClient
 
         public override Task ReplyAsync(Message message, CancellationToken token)
         {
-            SetReplyMessage(message);
+            _bufferedCopy = message.CreateBufferedCopy(int.MaxValue);
+            _replyMessage.TrySetResult(_bufferedCopy.CreateMessage());
             return Task.CompletedTask;
         }
     }
diff --git a/src/CoreWCF.Primitives/tests/Helpers/MockReplyChannel.cs b/src/CoreWCF.Primitives/tests/Helpers/MockReplyChannel.cs
index 1200083..95cb3b7 100644
--- a/src/CoreWCF.Primitives/tests/Helpers/MockReplyChannel.cs
+++ b/src/CoreWCF.Primitives/tests/Helpers/MockReplyChannel.cs
@@ -23,14 +23,12 @@ namespace Helpers
         public CommunicationState State { get; set; } = CommunicationState.Opened;
         public IServiceChannelDispatcher ChannelDispatcher { get; set; }
 
-#pragma warning disable CS0067 // "The event is never used"
         // These are required to implement IReplyChannel
         public event EventHandler Closed;
         public event EventHandler Closing;
         public event EventHandler Faulted;
         public event EventHandler Opened;
         public event EventHandler Opening;
-#pragma warning restore CS0067
 
         public void Abort()
         {
diff --git a/src/Samples/DesktopClient/Program.cs b/src/Samples/DesktopClient/Program.cs
index 5f65f5e..ba64163 100644
--- a/src/Samples/DesktopClient/Program.cs
+++ b/src/Samples/DesktopClient/Program.cs
@@ -9,7 +9,7 @@ namespace DesktopClient
         private readonly static string _basicHttpEndPointAddress = @"http://localhost:8080/basichttp";
         private readonly static string _soapEnvelopeContent = "<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\"><soapenv:Body><Echo xmlns = \"http://tempuri.org/\" ><text>Hello</text></Echo></soapenv:Body></soapenv:Envelope>";
 
-        static void Main(string[] args)
+        static void NO_Main(string[] args)
         {
             var factory = new ChannelFactory<Contract.IEchoService>(new NetTcpBinding(), new EndpointAddress("net.tcp://localhost:8808/nettcp"));
             factory.Open();
diff --git a/src/Samples/DesktopClient/ProgramForWSHTTP.cs b/src/Samples/DesktopClient/ProgramForWSHTTP.cs
new file mode 100644
index 0000000..e63bc73
--- /dev/null
+++ b/src/Samples/DesktopClient/ProgramForWSHTTP.cs
@@ -0,0 +1,46 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.ServiceModel;
+using System.ServiceModel.Configuration;
+using System.ServiceModel.Description;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace DesktopClient
+{
+    class ProgramForWSHTTP
+    {
+        private readonly static string _basicHttpEndPointAddress = @"https://localhost:8000/basichttp";
+        private readonly static string _soapEnvelopeContent = "<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\"><soapenv:Body><Echo xmlns = \"http://tempuri.org/\" ><text>Hello</text></Echo></soapenv:Body></soapenv:Envelope>";
+
+        static void Main(string[] args)
+        {
+            System.Net.ServicePointManager.ServerCertificateValidationCallback =
+((sender, certificate, chain, sslPolicyErrors) => true);
+            WSHttpBinding bind = new WSHttpBinding(SecurityMode.TransportWithMessageCredential);
+
+            bind.SendTimeout = bind.ReceiveTimeout = bind.OpenTimeout
+                = bind.CloseTimeout = new TimeSpan(0, 30, 0);
+            bind.Security.Message.ClientCredentialType = MessageCredentialType.UserName;
+            var factory = new ChannelFactory<Contract.IEchoService>(bind, new EndpointAddress(_basicHttpEndPointAddress));
+            var endpointClientbehavior = new ClientCredentials();
+            endpointClientbehavior.UserName.UserName = "biroj";
+            ClientCredentials behav = (ClientCredentials)factory.Endpoint.EndpointBehaviors[1];
+            // behav.use
+            behav.UserName.UserName = "Administrator";
+            behav.UserName.Password = "fakeone";
+            var channel = factory.CreateChannel();
+            ((IClientChannel)channel).Open();
+                Console.WriteLine("http Echo(\"Hello\") => " + channel.Echo("Hello"));
+            ((IClientChannel)channel).Close();
+            factory.Close();
+
+            // Complex type testing
+           
+
+            Console.WriteLine("Hit enter to exit");
+            Console.ReadLine();
+        }
+    }
+}
diff --git a/src/Samples/DesktopServer/CustomValidator.cs b/src/Samples/DesktopServer/CustomValidator.cs
new file mode 100644
index 0000000..a93920d
--- /dev/null
+++ b/src/Samples/DesktopServer/CustomValidator.cs
@@ -0,0 +1,18 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using System.IdentityModel.Selectors;
+using System.ServiceModel;
+
+namespace DesktopServer
+{
+    public class CustomValidator : UserNamePasswordValidator
+    {
+        public override void Validate(string userName, string password)
+        {
+            return;
+        }
+    }
+}
diff --git a/src/Samples/DesktopServer/DesktopServer.csproj b/src/Samples/DesktopServer/DesktopServer.csproj
index a9080d1..9a146b2 100644
--- a/src/Samples/DesktopServer/DesktopServer.csproj
+++ b/src/Samples/DesktopServer/DesktopServer.csproj
@@ -7,9 +7,14 @@
   <ItemGroup>
     <Reference Include="System" />
     <Reference Include="System.Core" />
+    <Reference Include="System.IdentityModel" />
+    <Reference Include="System.IdentityModel.Selectors" />
     <Reference Include="System.ServiceModel" />
   </ItemGroup>
   <ItemGroup>
     <None Include="App.config" />
   </ItemGroup>
+  <ItemGroup>
+    <PackageReference Include="Newtonsoft.Json" Version="12.0.3" />
+  </ItemGroup>
 </Project>
\ No newline at end of file
diff --git a/src/Samples/DesktopServer/Program.cs b/src/Samples/DesktopServer/Program.cs
index a378321..00a1494 100644
--- a/src/Samples/DesktopServer/Program.cs
+++ b/src/Samples/DesktopServer/Program.cs
@@ -9,13 +9,13 @@ namespace DesktopServer
 {
     class Program
     {
-        static void Main(string[] args)
+        static void N_Main(string[] args)
         {
             var host = new ServiceHost(typeof(EchoService), 
                 new Uri("net.tcp://localhost:8808/"), 
-                new Uri("http://localhost:8080/"));
+                new Uri("https://localhost:8080/"));
             host.AddServiceEndpoint(typeof(Contract.IEchoService), new NetTcpBinding(), "/nettcp");
-            host.AddServiceEndpoint(typeof(Contract.IEchoService), new BasicHttpBinding(), "/basichttp");
+            host.AddServiceEndpoint(typeof(Contract.IEchoService), new BasicHttpBinding( BasicHttpSecurityMode.TransportWithMessageCredential), "/basichttp");
             host.Open();
             foreach(var endpoint in host.Description.Endpoints)
             {
diff --git a/src/Samples/DesktopServer/ProgramForWSHTTP.cs b/src/Samples/DesktopServer/ProgramForWSHTTP.cs
new file mode 100644
index 0000000..f2a3419
--- /dev/null
+++ b/src/Samples/DesktopServer/ProgramForWSHTTP.cs
@@ -0,0 +1,39 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.ServiceModel;
+using System.ServiceModel.Description;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace DesktopServer
+{
+    class ProgramForWSHTTP
+    {
+        static void Main(string[] args)
+        {
+            var host = new ServiceHost(typeof(EchoService),
+                //new Uri("net.tcp://localhost:8808/"),
+                new Uri("https://localhost:8000/"));
+            WSHttpBinding binding = new WSHttpBinding(SecurityMode.TransportWithMessageCredential);
+            binding.Security.Message.ClientCredentialType = MessageCredentialType.UserName;
+            //  host.AddServiceEndpoint(typeof(Contract.IEchoService), binding, "/nettcp");
+            host.AddServiceEndpoint(typeof(Contract.IEchoService), binding, "/basichttp");
+            var srvCredentials = new ServiceCredentials();
+            srvCredentials.UserNameAuthentication.UserNamePasswordValidationMode
+                = System.ServiceModel.Security.UserNamePasswordValidationMode.Custom;
+            srvCredentials.UserNameAuthentication.CustomUserNamePasswordValidator
+                = new CustomValidator();
+            host.Description.Behaviors.Add(srvCredentials);
+            host.Open();
+
+            foreach (var endpoint in host.Description.Endpoints)
+            {
+                Console.WriteLine("Listening on " + endpoint.ListenUri.ToString());
+            }
+            Console.WriteLine("Hit enter to close");
+            Console.ReadLine();
+            host.Close();
+        }
+    }
+}
diff --git a/src/Samples/NetCoreServer/Program.cs b/src/Samples/NetCoreServer/Program.cs
index bb66494..5537281 100644
--- a/src/Samples/NetCoreServer/Program.cs
+++ b/src/Samples/NetCoreServer/Program.cs
@@ -15,8 +15,8 @@ namespace NetCoreServer
 
         public static IWebHostBuilder CreateWebHostBuilder(string[] args) =>
             WebHost.CreateDefaultBuilder(args)
-            .UseKestrel(options => { options.ListenLocalhost(8080); })
-            .UseUrls("http://localhost:8080")
+            .UseKestrel(options => { options.ListenLocalhost(8000); })
+            .UseUrls("https://localhost:8000")
             .UseNetTcp(8808)
             .UseStartup<Startup>();
     }
diff --git a/stash.txt b/stash.txt
new file mode 100644
index 0000000..30bb277
--- /dev/null
+++ b/stash.txt
@@ -0,0 +1,845 @@
+diff --git a/src/CoreWCF.Http/src/CoreWCF/Channels/HttpTransportBindingElement.cs b/src/CoreWCF.Http/src/CoreWCF/Channels/HttpTransportBindingElement.cs
+index a28183a..6ae76e3 100644
+--- a/src/CoreWCF.Http/src/CoreWCF/Channels/HttpTransportBindingElement.cs
++++ b/src/CoreWCF.Http/src/CoreWCF/Channels/HttpTransportBindingElement.cs
+@@ -1,8 +1,7 @@
+-using CoreWCF.Configuration;
+-using Microsoft.AspNetCore.Builder;
+ using System;
+ using System.ComponentModel;
+ using System.Net;
++using System.Security.Authentication.ExtendedProtection;
+ 
+ namespace CoreWCF.Channels
+ {
+@@ -13,6 +12,7 @@ namespace CoreWCF.Channels
+         private string _realm;
+         private TransferMode _transferMode;
+         private WebSocketTransportSettings _webSocketSettings;
++        private ExtendedProtectionPolicy _extendedProtectionPolicy;
+ 
+         //HttpAnonymousUriPrefixMatcher _anonymousUriPrefixMatcher;
+ 
+@@ -130,46 +130,13 @@ namespace CoreWCF.Channels
+             return new HttpTransportBindingElement(this);
+         }
+ 
+-        public override IServiceDispatcher BuildServiceDispatcher<TChannel>(BindingContext context, IServiceDispatcher innerDispatcher)
+-        {
+-            var app = context.BindingParameters.Find<IApplicationBuilder>();
+-            if (app == null)
+-            {
+-                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgument(nameof(IApplicationBuilder));
+-            }
+-
+-            // Wire up inner dispatcher to ServiceModelHttpMiddleware so that incoming requests get dispatched
+-            //ServiceModelHttpMiddleware.ConfigureDispatcher(app, innerDispatcher);
+-            // Return the previous inner dispatcher as we don't create a wrapping dispatcher here.
+-            return innerDispatcher;
+-        }
+-
+-        public override bool CanBuildServiceDispatcher<TChannel>(BindingContext context)
+-        {
+-            if (typeof(TChannel) == typeof(IReplyChannel))
+-            {
+-                return this.WebSocketSettings.TransportUsage != WebSocketTransportUsage.Always;
+-            }
+-            else if (typeof(TChannel) == typeof(IDuplexSessionChannel))
+-            {
+-                return this.WebSocketSettings.TransportUsage != WebSocketTransportUsage.Never;
+-            }
+-
+-            return false;
+-        }
+-
+         public override T GetProperty<T>(BindingContext context)
+         {
+             if (context == null)
+             {
+                 throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(context));
+             }
+-
+-            if (typeof(T) == typeof(ITransportServiceBuilder))
+-            {
+-                return (T)(object)new HttpTransportServiceBuilder();
+-            }
+-            //else if (typeof(T) == typeof(ISecurityCapabilities))
++            //if (typeof(T) == typeof(ISecurityCapabilities))
+             //{
+             //    AuthenticationSchemes effectiveAuthenticationSchemes = HttpTransportBindingElement.GetEffectiveAuthenticationSchemes(this.AuthenticationScheme,
+             //        context.BindingParameters);
+@@ -184,7 +151,7 @@ namespace CoreWCF.Channels
+             //{
+             //    return (T)(object)new BindingDeliveryCapabilitiesHelper();
+             //}
+-            else if (typeof(T) == typeof(TransferMode))
++            /*else*/ if (typeof(T) == typeof(TransferMode))
+             {
+                 return (T)(object)TransferMode;
+             }
+@@ -257,5 +224,29 @@ namespace CoreWCF.Channels
+                 return currentAuthenticationSchemes & hostSupportedAuthenticationSchemes;
+             //}
+         }
++        public ExtendedProtectionPolicy ExtendedProtectionPolicy
++        {
++            get
++            {
++                return _extendedProtectionPolicy;
++            }
++            set
++            {
++                if (value == null)
++                {
++                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(value));
++                }
++
++                if (value.PolicyEnforcement == PolicyEnforcement.Always &&
++                    !System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.OSSupportsExtendedProtection)
++                {
++                    // ExceptionHelper.PlatformNotSupported(SR.ExtendedProtectionNotSupported);
++                }
++
++                _extendedProtectionPolicy = value;
++            }
++        }
++
++        public override Type MiddlewareType => typeof(ServiceModelHttpMiddleware);
+     }
+ }
+\ No newline at end of file
+diff --git a/src/CoreWCF.Http/src/CoreWCF/Channels/RequestDelegateHandler.cs b/src/CoreWCF.Http/src/CoreWCF/Channels/RequestDelegateHandler.cs
+index 67a79fc..15596bc 100644
+--- a/src/CoreWCF.Http/src/CoreWCF/Channels/RequestDelegateHandler.cs
++++ b/src/CoreWCF.Http/src/CoreWCF/Channels/RequestDelegateHandler.cs
+@@ -2,6 +2,7 @@
+ using Microsoft.Extensions.DependencyInjection;
+ using CoreWCF.Runtime;
+ using CoreWCF.Configuration;
++using CoreWCF.Dispatcher;
+ using System;
+ using System.Threading;
+ using System.Threading.Tasks;
+@@ -94,6 +95,7 @@ namespace CoreWCF.Channels
+ 
+         internal async Task HandleRequest(HttpContext context)
+         {
++
+             if (!context.WebSockets.IsWebSocketRequest)
+             {
+                 if (_replyChannelDispatcher == null)
+diff --git a/src/CoreWCF.Http/tests/Helpers/ClientHelper.cs b/src/CoreWCF.Http/tests/Helpers/ClientHelper.cs
+index 0c711c0..dae5813 100644
+--- a/src/CoreWCF.Http/tests/Helpers/ClientHelper.cs
++++ b/src/CoreWCF.Http/tests/Helpers/ClientHelper.cs
+@@ -16,6 +16,13 @@ namespace Helpers
+             return binding;
+         }
+ 
++        public static WSHttpBinding GetBufferedModeWSHttpBinding(SecurityMode securityMode = SecurityMode.None)
++        {
++            var binding = new WSHttpBinding(securityMode);
++            ApplyDebugTimeouts(binding);
++            return binding;
++        }
++
+         public static BasicHttpsBinding GetBufferedModeHttpsBinding()
+         {
+             var binding = new BasicHttpsBinding();
+diff --git a/src/CoreWCF.Primitives/src/CoreWCF.Primitives.csproj b/src/CoreWCF.Primitives/src/CoreWCF.Primitives.csproj
+index fcc4c37..5e73d8d 100644
+--- a/src/CoreWCF.Primitives/src/CoreWCF.Primitives.csproj
++++ b/src/CoreWCF.Primitives/src/CoreWCF.Primitives.csproj
+@@ -12,6 +12,7 @@
+     <PackageReference Include="Microsoft.Extensions.DependencyInjection.Abstractions" Version="2.1.1" />
+     <PackageReference Include="Microsoft.Extensions.Logging.Abstractions" Version="2.1.1" />
+     <PackageReference Include="System.DirectoryServices" Version="4.5.0" />
++    <PackageReference Include="System.Security.Cryptography.Xml" Version="4.5.0" />
+     <PackageReference Include="System.Security.Principal.Windows" Version="4.5.1" />
+     <PackageReference Include="System.Reflection.DispatchProxy" Version="4.5.1" />
+     <PackageReference Include="System.Threading.Tasks.Extensions" Version="4.5.3" />
+diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Channels/BindingContext.cs b/src/CoreWCF.Primitives/src/CoreWCF/Channels/BindingContext.cs
+index d3bb7f4..e5f1057 100644
+--- a/src/CoreWCF.Primitives/src/CoreWCF/Channels/BindingContext.cs
++++ b/src/CoreWCF.Primitives/src/CoreWCF/Channels/BindingContext.cs
+@@ -2,17 +2,25 @@ using System;
+ using System.Globalization;
+ using System.Text;
+ using CoreWCF.Configuration;
++using CoreWCF.Description;
+ 
+ namespace CoreWCF.Channels
+ {
+     public class BindingContext
+     {
++        CustomBinding _binding;
++        BindingParameterCollection _bindingParameters;
++        Uri _listenUriBaseAddress;
++        ListenUriMode _listenUriMode;
++        string _listenUriRelativeAddress;
++        BindingElementCollection _remainingBindingElements;  // kept to ensure each BE builds itself once
++
+         public BindingContext(CustomBinding binding, BindingParameterCollection parameters)
+-            : this(binding, parameters, null, string.Empty)
++            : this(binding, parameters, null, string.Empty, ListenUriMode.Explicit)
+         {
+         }
+ 
+-        public BindingContext(CustomBinding binding, BindingParameterCollection parameters, Uri listenUriBaseAddress, string listenUriRelativeAddress)
++        public BindingContext(CustomBinding binding, BindingParameterCollection parameters, Uri listenUriBaseAddress, string listenUriRelativeAddress, ListenUriMode listenUriMode)
+         {
+             if (binding == null)
+             {
+@@ -22,60 +30,68 @@ namespace CoreWCF.Channels
+             {
+                 listenUriRelativeAddress = string.Empty;
+             }
++            if (!ListenUriModeHelper.IsDefined(listenUriMode))
++            {
++                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(listenUriMode)));
++            }
+ 
+-            Initialize(binding, binding.Elements, parameters, listenUriBaseAddress, listenUriRelativeAddress);
++            Initialize(binding, binding.Elements, parameters, listenUriBaseAddress, listenUriRelativeAddress, listenUriMode);
+         }
+ 
+-        private BindingContext(CustomBinding binding,
++        BindingContext(CustomBinding binding,
+                BindingElementCollection remainingBindingElements,
+                BindingParameterCollection parameters,
+                Uri listenUriBaseAddress,
+-               string listenUriRelativeAddress)
++               string listenUriRelativeAddress,
++               ListenUriMode listenUriMode)
+         {
+-            Initialize(binding, remainingBindingElements, parameters, listenUriBaseAddress, listenUriRelativeAddress);
++            Initialize(binding, remainingBindingElements, parameters, listenUriBaseAddress, listenUriRelativeAddress, listenUriMode);
+         }
+ 
+         private void Initialize(CustomBinding binding,
+                 BindingElementCollection remainingBindingElements,
+                 BindingParameterCollection parameters,
+                 Uri listenUriBaseAddress,
+-                string listenUriRelativeAddress)
++                string listenUriRelativeAddress,
++                ListenUriMode listenUriMode)
+         {
+-            Binding = binding;
++            _binding = binding;
+ 
+-            RemainingBindingElements = new BindingElementCollection(remainingBindingElements);
+-            BindingParameters = new BindingParameterCollection(parameters);
+-            ListenUriBaseAddress = listenUriBaseAddress;
+-            ListenUriRelativeAddress = listenUriRelativeAddress;
++            _remainingBindingElements = new BindingElementCollection(remainingBindingElements);
++            _bindingParameters = new BindingParameterCollection(parameters);
++            _listenUriBaseAddress = listenUriBaseAddress;
++            _listenUriRelativeAddress = listenUriRelativeAddress;
++            _listenUriMode = listenUriMode;
+         }
+ 
+-        public CustomBinding Binding { get; private set; }
+-
+-        public BindingParameterCollection BindingParameters { get; private set; }
++        public CustomBinding Binding => _binding;
+ 
+-        public Uri ListenUriBaseAddress { get; set; }
++        public BindingParameterCollection BindingParameters => _bindingParameters;
+ 
+-        public string ListenUriRelativeAddress { get; set; }
+-
+-        public BindingElementCollection RemainingBindingElements { get; private set; }
++        public Uri ListenUriBaseAddress
++        {
++            get { return _listenUriBaseAddress; }
++            set { _listenUriBaseAddress = value; }
++        }
+ 
+-        public IServiceDispatcher BuildNextServiceDispatcher<TChannel>(IServiceDispatcher innerDispatcher)
+-    where TChannel : class, IChannel
++        public ListenUriMode ListenUriMode
+         {
+-            return this.RemoveNextElement().BuildServiceDispatcher<TChannel>(this, innerDispatcher);
++            get { return _listenUriMode; }
++            set { _listenUriMode = value; }
+         }
+ 
+-        public bool CanBuildNextServiceDispatcher<TChannel>()
+-    where TChannel : class, IChannel
++        public string ListenUriRelativeAddress
+         {
+-            BindingContext clone = this.Clone();
+-            return clone.RemoveNextElement().CanBuildServiceDispatcher<TChannel>(clone);
++            get { return _listenUriRelativeAddress; }
++            set { _listenUriRelativeAddress = value; }
+         }
+ 
++        public BindingElementCollection RemainingBindingElements => _remainingBindingElements;
++
+         public T GetInnerProperty<T>()
+             where T : class
+         {
+-            if (RemainingBindingElements.Count == 0)
++            if (_remainingBindingElements.Count == 0)
+             {
+                 return null;
+             }
+@@ -87,17 +103,29 @@ namespace CoreWCF.Channels
+         }
+         public BindingContext Clone()
+         {
+-            return new BindingContext(Binding, RemainingBindingElements, BindingParameters,
+-                ListenUriBaseAddress, ListenUriRelativeAddress);
++            return new BindingContext(_binding, _remainingBindingElements, _bindingParameters,
++                _listenUriBaseAddress, _listenUriRelativeAddress, _listenUriMode);
++        }
++        public IServiceDispatcher BuildNextServiceDispatcher<TChannel>(IServiceDispatcher innerDispatcher)
++where TChannel : class, IChannel
++        {
++            return this.RemoveNextElement().BuildServiceDispatcher<TChannel>(this, innerDispatcher);
++        }
++
++        public bool CanBuildNextServiceDispatcher<TChannel>()
++    where TChannel : class, IChannel
++        {
++            BindingContext clone = this.Clone();
++            return clone.RemoveNextElement().CanBuildServiceDispatcher<TChannel>(clone);
+         }
+ 
+-        private BindingElement RemoveNextElement()
++        BindingElement RemoveNextElement()
+         {
+-            BindingElement element = RemainingBindingElements.Remove<BindingElement>();
++            BindingElement element = _remainingBindingElements.Remove<BindingElement>();
+             if (element != null)
+                 return element;
+             throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(
+-                SR.NoChannelBuilderAvailable, Binding.Name, Binding.Namespace)));
++                SR.NoChannelBuilderAvailable, _binding.Name, _binding.Namespace)));
+         }
+ 
+         internal void ValidateBindingElementsConsumed()
+diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Channels/BindingElement.cs b/src/CoreWCF.Primitives/src/CoreWCF/Channels/BindingElement.cs
+index a56821f..1cc0b95 100644
+--- a/src/CoreWCF.Primitives/src/CoreWCF/Channels/BindingElement.cs
++++ b/src/CoreWCF.Primitives/src/CoreWCF/Channels/BindingElement.cs
+@@ -22,6 +22,12 @@ namespace CoreWCF.Channels
+             return GetProperty<T>(new BindingContext(new CustomBinding(), new BindingParameterCollection()));
+         }
+ 
++        //TODO: Move back to internal
++        protected virtual bool IsMatch(BindingElement b)
++        {
++            Fx.Assert(true, "Should not be called unless this binding element is used in one of the standard bindings. In which case, please re-implement the IsMatch() method.");
++            return false;
++        }
+         public virtual IServiceDispatcher BuildServiceDispatcher<TChannel>(BindingContext context, IServiceDispatcher innerDispatcher) where TChannel : class, IChannel
+         {
+             if (context == null)
+@@ -41,11 +47,5 @@ namespace CoreWCF.Channels
+             return context.CanBuildNextServiceDispatcher<TChannel>();
+         }
+ 
+-        //TODO: Move back to internal
+-        protected virtual bool IsMatch(BindingElement b)
+-        {
+-            Fx.Assert(true, "Should not be called unless this binding element is used in one of the standard bindings. In which case, please re-implement the IsMatch() method.");
+-            return false;
+-        }
+     }
+ }
+\ No newline at end of file
+diff --git a/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/SecurityUtils.cs b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/SecurityUtils.cs
+index 9320fed..5df1c43 100644
+--- a/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/SecurityUtils.cs
++++ b/src/CoreWCF.Primitives/src/CoreWCF/IdentityModel/SecurityUtils.cs
+@@ -46,6 +46,8 @@ namespace CoreWCF.IdentityModel
+             }
+         }
+ 
++        public static bool RequiresFipsCompliance { get; internal set; }
++
+         internal static IIdentity CreateIdentity(string name, string authenticationType)
+         {
+             return new GenericIdentity(name, authenticationType);
+@@ -80,6 +82,35 @@ namespace CoreWCF.IdentityModel
+             return certificateId;
+         }
+ 
++        internal static bool MatchesBuffer(byte[] src, byte[] dst)
++        {
++            return MatchesBuffer(src, 0, dst, 0);
++        }
++
++        internal static bool MatchesBuffer(byte[] src, int srcOffset, byte[] dst, int dstOffset)
++        {
++            DiagnosticUtility.DebugAssert(dstOffset >= 0, "Negative dstOffset passed to MatchesBuffer.");
++            DiagnosticUtility.DebugAssert(srcOffset >= 0, "Negative srcOffset passed to MatchesBuffer.");
++
++            // defensive programming
++            if ((dstOffset < 0) || (srcOffset < 0))
++                return false;
++
++            if (src == null || srcOffset >= src.Length)
++                return false;
++            if (dst == null || dstOffset >= dst.Length)
++                return false;
++            if ((src.Length - srcOffset) != (dst.Length - dstOffset))
++                return false;
++
++            for (int i = srcOffset, j = dstOffset; i < src.Length; i++, j++)
++            {
++                if (src[i] != dst[j])
++                    return false;
++            }
++            return true;
++        }
++
+         internal static void ResetCertificate(X509Certificate2 certificate)
+         {
+             // Check that Dispose() and Reset() do the same thing
+diff --git a/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityUtils.cs b/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityUtils.cs
+index a6e9588..2a0d8a3 100644
+--- a/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityUtils.cs
++++ b/src/CoreWCF.Primitives/src/CoreWCF/Security/SecurityUtils.cs
+@@ -19,6 +19,12 @@ using CoreWCF.Channels;
+ using System.DirectoryServices.ActiveDirectory;
+ using CoreWCF.Runtime;
+ using System.Collections.Generic;
++using CoreWCF.IdentityModel;
++using System.Security.Authentication.ExtendedProtection;
++using System.Xml;
++using CoreWCF.Dispatcher;
++using System.Xml.Serialization;
++using CoreWCF.Security.Tokens;
+ 
+ namespace CoreWCF.Security
+ {
+@@ -99,12 +105,39 @@ namespace CoreWCF.Security
+             }
+         }
+     }
++    internal class ServiceModelDictionaryManager
++    {
++        static DictionaryManager dictionaryManager;
++
++        public static DictionaryManager Instance
++        {
++            get
++            {
++                if (dictionaryManager == null)
++                    dictionaryManager = new DictionaryManager((ServiceModelDictionary) BinaryMessageEncoderFactory.XmlDictionary);
++
++                return dictionaryManager;
++            }
++        }
++    }
+ 
+     internal class SecurityUtils
+     {
+         public const string Principal = "Principal";
+         public const string Identities = "Identities";
++
++        internal static byte[] ReadContentAsBase64(XmlDictionaryReader reader, long maxBufferSize)
++        {
++            throw new NotImplementedException();
++        }
++
+         static bool computedDomain;
++
++        internal static byte[] EncryptKey(SecurityToken wrappingToken, string wrappingAlgorithm, byte[] keyToWrap)
++        {
++            throw new NotImplementedException();
++        }
++
+         static string currentDomain;
+         static IIdentity anonymousIdentity;
+         static X509SecurityTokenAuthenticator nonValidatingX509Authenticator;
+@@ -133,6 +166,23 @@ namespace CoreWCF.Security
+             }
+         }
+ 
++        public static DateTime MinUtcDateTime 
++        { get
++            { return new DateTime(DateTime.MinValue.Ticks + TimeSpan.TicksPerDay, DateTimeKind.Utc); } 
++        }
++        public static DateTime MaxUtcDateTime {
++            get
++            {
++                // + and -  TimeSpan.TicksPerDay is to compensate the DateTime.ParseExact (to localtime) overflow.
++                return new DateTime(DateTime.MaxValue.Ticks - TimeSpan.TicksPerDay, DateTimeKind.Utc);
++            }
++        }
++
++        internal static ReadOnlyCollection<SecurityKey> CreateSymmetricSecurityKeys(byte[] keyToWrap)
++        {
++            throw new NotImplementedException();
++        }
++
+         internal static IIdentity CreateIdentity(string name)
+         {
+             return new GenericIdentity(name);
+@@ -353,6 +403,204 @@ namespace CoreWCF.Security
+             return canDoKeyExchange;
+         }
+ 
++        internal static MessageFault CreateSecurityMessageFault(Exception e, SecurityStandardsManager standardsManager)
++        {
++            throw new NotImplementedException();
++        }
++
++        internal static string GenerateId()
++        {
++            return SecurityUniqueId.Create().Value;
++        }
++
++        internal static byte[] GenerateDerivedKey(SecurityToken tokenToDerive, string derivationAlgorithm, byte[] label, byte[] nonce,
++    int keySize, int offset)
++        {
++            SymmetricSecurityKey symmetricSecurityKey = SecurityUtils.GetSecurityKey<SymmetricSecurityKey>(tokenToDerive);
++            if (symmetricSecurityKey == null || !symmetricSecurityKey.IsSupportedAlgorithm(derivationAlgorithm))
++            {
++                throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new MessageSecurityException(SR.Format(SR.CannotFindMatchingCrypto, derivationAlgorithm)));
++            }
++            return symmetricSecurityKey.GenerateDerivedKey(derivationAlgorithm, label, nonce, keySize, offset);
++        }
++       public static bool TryCreateKeyFromIntrinsicKeyClause(SecurityKeyIdentifierClause keyIdentifierClause, SecurityTokenResolver resolver, out SecurityKey key)
++        {
++            key = null;
++            if (keyIdentifierClause.CanCreateKey)
++            {
++                key = keyIdentifierClause.CreateKey();
++                return true;
++            }
++            if (keyIdentifierClause is EncryptedKeyIdentifierClause)
++            {
++                EncryptedKeyIdentifierClause keyClause = (EncryptedKeyIdentifierClause)keyIdentifierClause;
++                // PreSharp Bug: Parameter 'keyClause' to this public method must be validated: A null-dereference can occur here.
++#pragma warning suppress 56506 // keyClause will not be null due to the if condition above.
++                for (int i = 0; i < keyClause.EncryptingKeyIdentifier.Count; i++)
++                {
++                    SecurityKey unwrappingSecurityKey = null;
++                    //TODO
++                 /*   if (resolver.TryResolveSecurityKey(keyClause.EncryptingKeyIdentifier[i], out unwrappingSecurityKey))
++                    {
++                        byte[] wrappedKey = keyClause.GetEncryptedKey();
++                        string wrappingAlgorithm = keyClause.EncryptionMethod;
++                        byte[] unwrappedKey = unwrappingSecurityKey.DecryptKey(wrappingAlgorithm, wrappedKey);
++                        key = new InMemorySymmetricSecurityKey(unwrappedKey, false);
++                        return true;
++                    }*/
++                }
++            }
++            return false;
++        }
++
++        internal static bool HasSymmetricSecurityKey(SecurityToken sourceEncryptionToken)
++        {
++            return GetSecurityKey<SymmetricSecurityKey>(sourceEncryptionToken) != null;
++        }
++
++        internal static byte[] CloneBuffer(byte[] buffer)
++        {
++            byte[] copy = Fx.AllocateByteArray(buffer.Length);
++            Buffer.BlockCopy(buffer, 0, copy, 0, buffer.Length);
++            return copy;
++        }
++        internal static bool IsSupportedAlgorithm(string algorithm, SecurityToken token)
++        {
++            if (token.SecurityKeys == null)
++            {
++                return false;
++            }
++            for (int i = 0; i < token.SecurityKeys.Count; ++i)
++            {
++                if (token.SecurityKeys[i].IsSupportedAlgorithm(algorithm))
++                {
++                    return true;
++                }
++            }
++            return false;
++        }
++        internal static T GetSecurityKey<T>(SecurityToken token)
++    where T : SecurityKey
++        {
++            T result = null;
++            if (token.SecurityKeys != null)
++            {
++                for (int i = 0; i < token.SecurityKeys.Count; ++i)
++                {
++                    T temp = (token.SecurityKeys[i] as T);
++                    if (temp != null)
++                    {
++                        if (result != null)
++                        {
++                            throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new MessageSecurityException(SR.Format(SR.MultipleMatchingCryptosFound, typeof(T).ToString())));
++                        }
++                        else
++                        {
++                            result = temp;
++                        }
++                    }
++                }
++            }
++            return result;
++        }
++
++        internal static bool TryCreateX509CertificateFromRawData(byte[] rawData, out X509Certificate2 certificate)
++        {
++            throw new NotImplementedException();
++        }
++
++        internal static string GetKeyDerivationAlgorithm(SecureConversationVersion version)
++        {
++            string derivationAlgorithm = null;
++            if (version == SecureConversationVersion.WSSecureConversationFeb2005)
++            {
++                derivationAlgorithm = SecurityAlgorithms.Psha1KeyDerivation;
++            }
++            else if (version == SecureConversationVersion.WSSecureConversation13)
++            {
++                derivationAlgorithm = SecurityAlgorithms.Psha1KeyDerivationDec2005;
++            }
++            else
++            {
++                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new NotSupportedException());
++            }
++
++            return derivationAlgorithm;
++        }
++
++        internal static ReadOnlyCollection<IAuthorizationPolicy> CloneAuthorizationPoliciesIfNecessary(ReadOnlyCollection<IAuthorizationPolicy> authorizationPolicies)
++        {
++            if (authorizationPolicies != null && authorizationPolicies.Count > 0)
++            {
++                bool clone = false;
++                for (int i = 0; i < authorizationPolicies.Count; ++i)
++                {
++                    UnconditionalPolicy policy = authorizationPolicies[i] as UnconditionalPolicy;
++                    if (policy != null && policy.IsDisposable)
++                    {
++                        clone = true;
++                        break;
++                    }
++                }
++                if (clone)
++                {
++                    List<IAuthorizationPolicy> ret = new List<IAuthorizationPolicy>(authorizationPolicies.Count);
++                    for (int i = 0; i < authorizationPolicies.Count; ++i)
++                    {
++                        UnconditionalPolicy policy = authorizationPolicies[i] as UnconditionalPolicy;
++                        if (policy != null)
++                        {
++                            ret.Add(policy.Clone());
++                        }
++                        else
++                        {
++                            ret.Add(authorizationPolicies[i]);
++                        }
++                    }
++                    return ret.AsReadOnly();
++                }
++            }
++            return authorizationPolicies;
++        }
++        public static void DisposeAuthorizationPoliciesIfNecessary(ReadOnlyCollection<IAuthorizationPolicy> authorizationPolicies)
++        {
++            if (authorizationPolicies != null && authorizationPolicies.Count > 0)
++            {
++                for (int i = 0; i < authorizationPolicies.Count; ++i)
++                {
++                    DisposeIfNecessary(authorizationPolicies[i] as UnconditionalPolicy);
++                }
++            }
++        }
++
++        public static void DisposeIfNecessary(IDisposable obj)
++        {
++            if (obj != null)
++            {
++                obj.Dispose();
++            }
++        }
++
++        public static ChannelBinding GetChannelBindingFromMessage(Message message)
++        {
++            if (message == null)
++            {
++                return null;
++            }
++
++            ChannelBindingMessageProperty channelBindingMessageProperty = null;
++            ChannelBindingMessageProperty.TryGet(message, out channelBindingMessageProperty);
++            ChannelBinding channelBinding = null;
++
++            if (channelBindingMessageProperty != null)
++            {
++                channelBinding = channelBindingMessageProperty.ChannelBinding;
++            }
++
++            return channelBinding;
++        }
++
++
+         internal static NetworkCredential GetNetworkCredentialsCopy(NetworkCredential networkCredential)
+         {
+             NetworkCredential result;
+@@ -367,6 +615,11 @@ namespace CoreWCF.Security
+             return result;
+         }
+ 
++        internal static void CloseTokenAuthenticatorIfRequired(SecurityTokenAuthenticator tokenAuthenticator, TimeSpan timeSpan)
++        {
++            throw new NotImplementedException();
++        }
++
+         static class NetworkCredentialHelper
+         {
+             static internal bool IsNullOrEmpty(NetworkCredential credential)
+@@ -476,6 +729,11 @@ namespace CoreWCF.Security
+             }
+         }
+ 
++        internal static UniqueId GenerateUniqueId()
++        {
++            return new UniqueId();
++        }
++
+         // This is the workaround, Since store.Certificates returns a full collection
+         // of certs in store.  These are holding native resources.
+         internal static void ResetAllCertificates(X509Certificate2Collection certificates)
+@@ -489,6 +747,11 @@ namespace CoreWCF.Security
+             }
+         }
+ 
++        internal static void ErasePasswordInUsernameTokenIfPresent(SecurityMessageProperty bootstrapMessageProperty)
++        {
++            throw new NotImplementedException();
++        }
++
+         internal static void ResetCertificate(X509Certificate2 certificate)
+         {
+             certificate.Reset();
+@@ -534,6 +797,10 @@ namespace CoreWCF.Security
+                 }
+             }
+         }
++        internal static Task OpenTokenAuthenticatorIfRequiredAsync(SecurityTokenAuthenticator tokenAuthenticator, CancellationToken token)
++        {
++           return OpenCommunicationObjectAsync(tokenAuthenticator as ICommunicationObject , token) ;
++        }
+ 
+         internal static Task OpenTokenProviderIfRequiredAsync(SecurityTokenProvider tokenProvider, CancellationToken token)
+         {
+@@ -555,10 +822,6 @@ namespace CoreWCF.Security
+             CloseCommunicationObjectAsync(tokenProvider, true, CancellationToken.None).GetAwaiter().GetResult();
+         }
+ 
+-        internal static Task OpenTokenAuthenticatorIfRequiredAsync(SecurityTokenAuthenticator tokenAuthenticator, CancellationToken token)
+-        {
+-            return OpenCommunicationObjectAsync(tokenAuthenticator as ICommunicationObject, token);
+-        }
+ 
+         internal static Task CloseTokenAuthenticatorIfRequiredAsync(SecurityTokenAuthenticator tokenAuthenticator, CancellationToken token)
+         {
+@@ -659,5 +922,87 @@ namespace CoreWCF.Security
+             policies.Add(new UnconditionalPolicy(SecurityUtils.CreateIdentity(principalName), new DefaultClaimSet(ClaimSet.Anonymous, claims)));
+             return policies.AsReadOnly();
+         }
++
++        internal static void OpenTokenProviderIfRequired(SecurityTokenProvider provider, TimeSpan timeout)
++        {
++            throw new NotImplementedException();
++        }
++        public static SecurityBindingElement GetIssuerSecurityBindingElement(ServiceModelSecurityTokenRequirement requirement)
++        {
++            SecurityBindingElement bindingElement = requirement.SecureConversationSecurityBindingElement;
++            if (bindingElement != null)
++            {
++                return bindingElement;
++            }
++
++            Binding binding = requirement.IssuerBinding;
++            if (binding == null)
++            {
++                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgument(SR.Format(SR.IssuerBindingNotPresentInTokenRequirement, requirement));
++            }
++            BindingElementCollection bindingElements = binding.CreateBindingElements();
++            return bindingElements.Find<SecurityBindingElement>();
++        }
++
++        internal static SecurityStandardsManager CreateSecurityStandardsManager(MessageSecurityVersion securityVersion, SecurityTokenManager tokenManager)
++        {
++            SecurityTokenSerializer tokenSerializer = tokenManager.CreateSecurityTokenSerializer(securityVersion.SecurityTokenVersion);
++            return new SecurityStandardsManager(securityVersion, tokenSerializer);
++        }
++
++        internal static SecurityStandardsManager CreateSecurityStandardsManager(SecurityTokenRequirement requirement, SecurityTokenManager tokenManager)
++        {
++            MessageSecurityTokenVersion securityVersion = (MessageSecurityTokenVersion)requirement.GetProperty<MessageSecurityTokenVersion>(ServiceModelSecurityTokenRequirement.MessageSecurityVersionProperty);
++            if (securityVersion == MessageSecurityTokenVersion.WSSecurity10WSTrustFebruary2005WSSecureConversationFebruary2005BasicSecurityProfile10)
++                return CreateSecurityStandardsManager(MessageSecurityVersion.WSSecurity10WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11BasicSecurityProfile10, tokenManager);
++            else if (securityVersion == MessageSecurityTokenVersion.WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005)
++                return CreateSecurityStandardsManager(MessageSecurityVersion.WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11, tokenManager);
++            else if (securityVersion == MessageSecurityTokenVersion.WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005BasicSecurityProfile10)
++                return CreateSecurityStandardsManager(MessageSecurityVersion.WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11BasicSecurityProfile10, tokenManager);
++            else if (securityVersion == MessageSecurityTokenVersion.WSSecurity10WSTrust13WSSecureConversation13BasicSecurityProfile10)
++                return CreateSecurityStandardsManager(MessageSecurityVersion.WSSecurity10WSTrust13WSSecureConversation13WSSecurityPolicy12BasicSecurityProfile10, tokenManager);
++            else if (securityVersion == MessageSecurityTokenVersion.WSSecurity11WSTrust13WSSecureConversation13)
++                return CreateSecurityStandardsManager(MessageSecurityVersion.WSSecurity11WSTrust13WSSecureConversation13WSSecurityPolicy12, tokenManager);
++            else if (securityVersion == MessageSecurityTokenVersion.WSSecurity11WSTrust13WSSecureConversation13BasicSecurityProfile10)
++                return CreateSecurityStandardsManager(MessageSecurityVersion.WSSecurity11WSTrust13WSSecureConversation13WSSecurityPolicy12BasicSecurityProfile10, tokenManager);
++            else
++                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new NotSupportedException());
++        }
++
++        internal static SecurityStandardsManager CreateSecurityStandardsManager(MessageSecurityVersion messageSecurityVersion, SecurityTokenSerializer securityTokenSerializer)
++        {
++            if (messageSecurityVersion == null)
++            {
++                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException("securityVersion"));
++            }
++            if (securityTokenSerializer == null)
++            {
++                throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("securityTokenSerializer");
++            }
++            return new SecurityStandardsManager(messageSecurityVersion, securityTokenSerializer);
++        }
++
++        internal static void MatchRstWithEndpointFilter(Message request, IMessageFilterTable<EndpointAddress> endpointFilterTable, Uri listenUri)
++        {
++            if (endpointFilterTable == null)
++            {
++                return;
++            }
++            Collection<EndpointAddress> result = new Collection<EndpointAddress>();
++            if (!endpointFilterTable.GetMatchingValues(request, result))
++            {
++                throw new SecurityNegotiationException(SR.Format(SR.RequestSecurityTokenDoesNotMatchEndpointFilters, listenUri)); 
++            }
++        }
++
++        internal static bool IsEqual(byte[] rawData1, byte[] rawData2)
++        {
++            throw new NotImplementedException();
++        }
++
++        internal static bool IsCurrentlyTimeEffective(DateTime validFrom, DateTime validTo, TimeSpan clockSkew)
++        {
++            throw new NotImplementedException();
++        }
+     }
+ }
+\ No newline at end of file
+diff --git a/src/Samples/DesktopServer/DesktopServer.csproj b/src/Samples/DesktopServer/DesktopServer.csproj
+index a9080d1..319eef0 100644
+--- a/src/Samples/DesktopServer/DesktopServer.csproj
++++ b/src/Samples/DesktopServer/DesktopServer.csproj
+@@ -7,6 +7,7 @@
+   <ItemGroup>
+     <Reference Include="System" />
+     <Reference Include="System.Core" />
++    <Reference Include="System.IdentityModel" />
+     <Reference Include="System.ServiceModel" />
+   </ItemGroup>
+   <ItemGroup>
