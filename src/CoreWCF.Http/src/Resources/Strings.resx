<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="RequiredAttributeMissing" xml:space="preserve">
    <value>Attribute '{0}' is required on element '{1}'.</value>
  </data>
  <data name="UnsupportedCryptoAlgorithm" xml:space="preserve">
    <value>Crypto algorithm {0} not supported in this context.</value>
  </data>
  <data name="CustomCryptoAlgorithmIsNotValidHashAlgorithm" xml:space="preserve">
    <value>The custom crypto algorithm '{0}' obtained using CryptoConfig is not a valid or supported hash algorithm.</value>
  </data>
  <data name="CustomCryptoAlgorithmIsNotValidAsymmetricSignature" xml:space="preserve">
    <value>The custom crypto algorithm '{0}' obtained using CryptoConfig is not a valid or supported asymmetric signature algorithm.</value>
  </data>
  <data name="IssuerBindingNotPresentInTokenRequirement" xml:space="preserve">
    <value>The key length '{0}' is not a multiple of 8 for symmetric keys.</value>
  </data>
  <data name="SecurityTokenManagerCannotCreateProviderForRequirement" xml:space="preserve">
    <value>The security token manager cannot create a token provider for requirement '{0}'.</value>
  </data>
  <data name="SecurityTokenManagerCannotCreateAuthenticatorForRequirement" xml:space="preserve">
    <value>The security token manager cannot create a token authenticator for requirement '{0}'.</value>
  </data>
  <data name="SecurityTokenManagerCannotCreateSerializerForVersion" xml:space="preserve">
    <value>The security token manager cannot create a token serializer for security token version '{0}'.</value>
  </data>
  <data name="SupportingSignatureIsNotDerivedFrom" xml:space="preserve">
    <value>The supporting signature is not signed with a derived key. The binding's supporting token parameter '{0}' requires key derivation.</value>
  </data>
  <data name="PrimarySignatureWasNotSignedByDerivedKey" xml:space="preserve">
    <value>The primary signature is not signed with a derived key. The binding's primary token parameter '{0}' requires key derivation.</value>
  </data>
  <data name="PrimarySignatureWasNotSignedByDerivedWrappedKey" xml:space="preserve">
    <value>The primary signature is not signed with a key derived from the encrypted key. The binding's token parameter '{0}' requires key derivation.</value>
  </data>
  <data name="MessageWasNotEncryptedByDerivedWrappedKey" xml:space="preserve">
    <value>The message is not encrypted with a key derived from the encrypted key. The binding's token parameter '{0}' requires key derivation.</value>
  </data>
  <data name="SecurityStateEncoderDecodingFailure" xml:space="preserve">
    <value>The DataProtectionSecurityStateEncoder is unable to decode the byte array. Ensure that a 'UserProfile' is loaded, if this is a 'web farm scenario' ensure all servers are running as the same user with the roaming profiles or provide a custom SecurityStateEncoder'.</value>
  </data>
  <data name="SecurityStateEncoderEncodingFailure" xml:space="preserve">
    <value>The DataProtectionSecurityStateEncoder is unable to encode the byte array. Ensure that a 'UserProfile' is loaded, if this is a 'web farm scenario' ensure all servers are running as the same user with the roaming profiles or provide a custom SecurityStateEncoder'.</value>
  </data>
  <data name="MessageWasNotEncryptedByDerivedEncryptionToken" xml:space="preserve">
    <value>The message is not encrypted with a key derived from the encryption token. The binding's token parameter '{0}' requires key derivation.</value>
  </data>
  <data name="TokenAuthenticatorRequiresSecurityBindingElement" xml:space="preserve">
    <value>The security token manager requires the security binding element to be specified in order to create a token authenticator for requirement '{0}'.</value>
  </data>
  <data name="UnexpectedSecuritySessionCloseResponse" xml:space="preserve">
    <value>The security session received an unexpected close response from the other party.</value>
  </data>
  <data name="EncodingBindingElementDoesNotHandleReaderQuotas" xml:space="preserve">
    <value>Unable to obtain XmlDictionaryReaderQuotas from the Binding. If you have specified a custom EncodingBindingElement, verify that the EncodingBindingElement can handle XmlDictionaryReaderQuotas in its GetProperty&lt;T&gt;() method.</value>
  </data>
  <data name="DecryptionFailed" xml:space="preserve">
    <value>Unable to decrypt an encrypted data block. Please verify that the encryption algorithm and keys used by the sender and receiver match.</value>
  </data>
  <data name="AuthenticationManagerShouldNotReturnNull" xml:space="preserve">
    <value>The authenticate method in the ServiceAuthenticationManager returned null. If you do not want to return any authorization policies in the collection then return an empty ReadOnlyCollection instead. </value>
  </data>
  <data name="ErrorSerializingSecurityToken" xml:space="preserve">
    <value>There was an error serializing the security token. Please see the inner exception for more details.</value>
  </data>
  <data name="ErrorDeserializingKeyIdentifierClauseFromTokenXml" xml:space="preserve">
    <value>There was an error creating the security key identifier clause from the security token XML. Please see the inner exception for more details.</value>
  </data>
  <data name="ErrorDeserializingTokenXml" xml:space="preserve">
    <value>There was an error deserializing the security token XML. Please see the inner exception for more details.</value>
  </data>
  <data name="DerivedKeyNotInitialized" xml:space="preserve">
    <value>The derived key has not been computed for the security token.</value>
  </data>
  <data name="MultipleSecurityCredentialsManagersInServiceBindingParameters" xml:space="preserve">
    <value>The ServiceCredentials cannot be added to the binding parameters because the binding parameters already contains a SecurityCredentialsManager '{0}'. If you are configuring custom credentials for the service, please first remove any existing ServiceCredentials from the behaviors collection before adding the custom credential.</value>
  </data>
  <data name="NegotiationQuotasExceededFaultReason" xml:space="preserve">
    <value>There are too many active security negotiations or secure conversations at the service. Please retry later.</value>
  </data>
  <data name="PendingSessionsExceededFaultReason" xml:space="preserve">
    <value>There are too many pending secure conversations on the server. Please retry later.</value>
  </data>
  <data name="RequestSecurityTokenDoesNotMatchEndpointFilters" xml:space="preserve">
    <value>The RequestSecurityToken message does not match the endpoint filters the service '{0}' is expecting incoming messages to match. This may be because the RequestSecurityToken was intended to be sent to a different service.</value>
  </data>
  <data name="SecuritySessionRequiresIssuanceAuthenticator" xml:space="preserve">
    <value>The security session requires a security token authenticator that implements '{0}'. '{1}' does not implement '{0}'.</value>
  </data>
  <data name="SecuritySessionRequiresSecurityContextTokenCache" xml:space="preserve">
    <value>The security session requires a security token resolver that implements '{1}'. The security token resolver '{0}' does not implement '{1}'.</value>
  </data>
  <data name="SessionTokenIsNotSecurityContextToken" xml:space="preserve">
    <value>The session security token authenticator returned a token of type '{0}'. The token type expected is '{1}'.</value>
  </data>
  <data name="SecurityStandardsManagerNotSet" xml:space="preserve">
    <value>The security standards manager was not specified on  '{0}'.</value>
  </data>
  <data name="SecurityNegotiationMessageTooLarge" xml:space="preserve">
    <value>The security negotiation message with action '{0}' is larger than the maximum allowed buffer size '{1}'. If you are using a streamed transport consider increasing the maximum buffer size on the transport.</value>
  </data>
  <data name="SecurityChannelListenerNotSet" xml:space="preserve">
    <value>The security channel listener was not specified on  '{0}'.</value>
  </data>
  <data name="SecuritySettingsLifetimeManagerNotSet" xml:space="preserve">
    <value>The security settings lifetime manager was not specified on  '{0}'.</value>
  </data>
  <data name="SecurityListenerClosing" xml:space="preserve">
    <value>The listener is not accepting new secure conversations because it is closing.</value>
  </data>
  <data name="SecurityListenerClosingFaultReason" xml:space="preserve">
    <value>The server is not accepting new secure conversations currently because it is closing. Please retry later.</value>
  </data>
  <data name="DerivedKeyTokenNonceTooLong" xml:space="preserve">
    <value>The length ('{0}' bytes) of the derived key's Nonce exceeds the maximum length ('{1}' bytes) allowed.</value>
  </data>
  <data name="DerivedKeyTokenLabelTooLong" xml:space="preserve">
    <value>The length ('{0}' bytes) of the derived key's Label exceeds the maximum length ('{1}' bytes) allowed.</value>
  </data>
  <data name="DerivedKeyTokenOffsetTooHigh" xml:space="preserve">
    <value>The derived key's Offset ('{0}' bytes) exceeds the maximum offset ('{1}' bytes) allowed.</value>
  </data>
  <data name="DerivedKeyTokenGenerationAndLengthTooHigh" xml:space="preserve">
    <value>The derived key's generation ('{0}') and length ('{1}' bytes) result in a key derivation offset that is greater than the maximum offset ('{2}' bytes) allowed.</value>
  </data>
  <data name="DerivedKeyLimitExceeded" xml:space="preserve">
    <value>The number of derived keys in the message has exceeded the maximum allowed number '{0}'.</value>
  </data>
  <data name="WrappedKeyLimitExceeded" xml:space="preserve">
    <value>The number of encrypted keys in the message has exceeded the maximum allowed number '{0}'.</value>
  </data>
  <data name="IssuedTokenCacheNotSet" xml:space="preserve">
    <value>The issued token cache was not specified on '{0}'.</value>
  </data>
  <data name="SecurityAlgorithmSuiteNotSet" xml:space="preserve">
    <value>The security algorithm suite was not specified on '{0}'.</value>
  </data>
  <data name="SecureConversationCancelNotAllowedFaultReason" xml:space="preserve">
    <value>A secure conversation cancellation is not allowed by the binding.</value>
  </data>
  <data name="BootstrapSecurityBindingElementNotSet" xml:space="preserve">
    <value>The security binding element for bootstrap security was not specified on '{0}'.</value>
  </data>
  <data name="IssuerBuildContextNotSet" xml:space="preserve">
    <value>The context for building the issuer channel was  not specified on '{0}'.</value>
  </data>
  <data name="SslCertMayNotDoKeyExchange" xml:space="preserve">
    <value>It is likely that certificate '{0}' may not have a private key that is capable of key exchange or the process may not have access rights for the private key. Please see inner exception for detail.</value>
  </data>
  <data name="Psha1KeyLengthInvalid" xml:space="preserve">
    <value>The PSHA1 key length '{0}' is invalid.</value>
  </data>
  <data name="CloneNotImplementedCorrectly" xml:space="preserve">
    <value>Clone() was not implemented properly by '{0}'. The cloned object was '{1}'.</value>
  </data>
  <data name="BadIssuedTokenType" xml:space="preserve">
    <value>The issued token is of unexpected type '{0}'. Expected token type '{1}'.</value>
  </data>
  <data name="RstrHasMultipleIssuedTokens" xml:space="preserve">
    <value>The RequestSecurityTokenResponse has multiple RequestedSecurityToken elements.</value>
  </data>
  <data name="RstrHasMultipleProofTokens" xml:space="preserve">
    <value>The RequestSecurityTokenResponse has multiple RequestedProofToken elements.</value>
  </data>
  <data name="ProofTokenXmlUnexpectedInRstr" xml:space="preserve">
    <value>The proof token XML element is not expected in the response.</value>
  </data>
  <data name="InvalidKeyLengthRequested" xml:space="preserve">
    <value>The key length '{0}' requested is invalid.</value>
  </data>
  <data name="IssuedSecurityTokenParametersNotSet" xml:space="preserve">
    <value>The security token parameters to use for the issued token are not set on '{0}'.</value>
  </data>
  <data name="InvalidOrUnrecognizedAction" xml:space="preserve">
    <value>The message could not be processed because the action '{0}' is invalid or unrecognized.</value>
  </data>
  <data name="UnsupportedTokenInclusionMode" xml:space="preserve">
    <value>Token inclusion mode '{0}' is not supported.</value>
  </data>
  <data name="ClientCredentialTypeMustBeSpecifiedForMixedMode" xml:space="preserve">
    <value>ClientCredentialType.None is not valid for the TransportWithMessageCredential security mode. Specify a message credential type or use a different security mode.</value>
  </data>
  <data name="SecuritySessionIdAlreadyPresentInFilterTable" xml:space="preserve">
    <value>The security session id '{0}' is already present in the filter table.</value>
  </data>
  <data name="SupportingTokenNotProvided" xml:space="preserve">
    <value>A supporting token that satisfies parameters '{0}' and attachment mode '{1}' was not provided.</value>
  </data>
  <data name="SupportingTokenIsNotEndorsing" xml:space="preserve">
    <value>The supporting token provided for parameters '{0}' did not endorse the primary signature.</value>
  </data>
  <data name="SupportingTokenIsNotSigned" xml:space="preserve">
    <value>The supporting token provided for parameters '{0}' was not signed as part of the primary signature.</value>
  </data>
  <data name="SupportingTokenIsNotEncrypted" xml:space="preserve">
    <value>The supporting token provided for parameters '{0}' was not encrypted.</value>
  </data>
  <data name="BasicTokenNotExpected" xml:space="preserve">
    <value>A basic token is not expected in the security header in this context.</value>
  </data>
  <data name="FailedAuthenticationTrustFaultCode" xml:space="preserve">
    <value>The request for security token could not be satisfied because authentication failed.</value>
  </data>
  <data name="AuthenticationOfClientFailed" xml:space="preserve">
    <value>The caller was not authenticated by the service.</value>
  </data>
  <data name="InvalidRequestTrustFaultCode" xml:space="preserve">
    <value>The request for security token has invalid or malformed elements.</value>
  </data>
  <data name="SignedSupportingTokenNotExpected" xml:space="preserve">
    <value>A signed supporting token is not expected in the security header in this context.</value>
  </data>
  <data name="SenderSideSupportingTokensMustSpecifySecurityTokenParameters" xml:space="preserve">
    <value>Security token parameters must be specified with supporting tokens for each message.</value>
  </data>
  <data name="SignatureAndEncryptionTokenMismatch" xml:space="preserve">
    <value>The signature token '{0}' is not the same token as the encryption token '{1}'.</value>
  </data>
  <data name="UnknownSupportingToken" xml:space="preserve">
    <value>Unrecognized supporting token '{0}' was encountered.</value>
  </data>
  <data name="MoreThanOneSupportingSignature" xml:space="preserve">
    <value>More than one supporting signature was encountered using the same supporting token '{0}'.</value>
  </data>
  <data name="FailedAuthenticationFaultReason" xml:space="preserve">
    <value>At least one security token in the message could not be validated.</value>
  </data>
  <data name="BadContextTokenOrActionFaultReason" xml:space="preserve">
    <value>The message could not be processed. This is most likely because the action '{0}' is incorrect or because the message contains an invalid or expired security context token or because there is a mismatch between bindings. The security context token would be invalid if the service aborted the channel due to inactivity. To prevent the service from aborting idle sessions prematurely increase the Receive timeout on the service endpoint's binding.</value>
  </data>
  <data name="BadContextTokenFaultReason" xml:space="preserve">
    <value>The security context token is expired or is not valid. The message was not processed.</value>
  </data>
  <data name="NegotiationFailedIO" xml:space="preserve">
    <value>Transport security negotiation failed due to an underlying IO error: {0}.</value>
  </data>
  <data name="InvalidSecurityTokenFaultReason" xml:space="preserve">
    <value>An error occurred when processing the security tokens in the message.</value>
  </data>
  <data name="InvalidSecurityFaultReason" xml:space="preserve">
    <value>An error occurred when verifying security for the message.</value>
  </data>
  <data name="AnonymousLogonsAreNotAllowed" xml:space="preserve">
    <value>The service does not allow you to log on anonymously.</value>
  </data>
  <data name="MultipleSupportingAuthenticatorsOfSameType" xml:space="preserve">
    <value>Multiple supporting token authenticators with the token parameter type equal to '{0}' cannot be specified. If more than one Supporting Token of the same type is expected in the response, then configure the supporting token collection with just one entry for that SecurityTokenParameters. The SecurityTokenAuthenticator that gets created from the SecurityTokenParameters will be used to authenticate multiple tokens. It is not possible to add SecurityTokenParameters of the same type in the SupportingTokenParameters collection or repeat it across EndpointSupportingTokenParameters and OperationSupportingTokenParameters.</value>
  </data>
  <data name="UnknownTokenAuthenticatorUsedInTokenProcessing" xml:space="preserve">
    <value>An unrecognized token authenticator '{0}' was used for token processing.</value>
  </data>
  <data name="TokenMustBeNullWhenTokenParametersAre" xml:space="preserve">
    <value>The SecurityTokenParameters and SecurityToken tuple specified for use in the security header must both be null or must both be non-null.</value>
  </data>
  <data name="SecurityTokenParametersCloneInvalidResult" xml:space="preserve">
    <value>The CloneCore method of {0} type returned an invalid result. </value>
  </data>
  <data name="CertificateUnsupportedForHttpTransportCredentialOnly" xml:space="preserve">
    <value>Certificate-based client authentication is not supported in TransportCredentialOnly security mode. Select the Transport security mode.</value>
  </data>
  <data name="EntropyModeRequiresRequestorEntropy" xml:space="preserve">
    <value>The client must provide key entropy in key entropy mode '{0}'.</value>
  </data>
  <data name="BearerKeyTypeCannotHaveProofKey" xml:space="preserve">
    <value>A Proof Token was found in the response that was returned by the Security Token Service for a Bearer Key Type token request. Note that Proof Tokens should not be generated when a Bearer Key Type request is made.</value>
  </data>
  <data name="BearerKeyIncompatibleWithWSFederationHttpBinding" xml:space="preserve">
    <value>Bearer Key Type is not supported with WSFederationHttpBinding. Please use WS2007FederationHttpBinding.</value>
  </data>
  <data name="UnableToCreateKeyTypeElementForUnknownKeyType" xml:space="preserve">
    <value>Unable to create Key Type element for the Key Type '{0}'. This might be due to a wrong version of MessageSecurityVersion set on the SecurityBindingElement.</value>
  </data>
  <data name="EntropyModeCannotHaveProofTokenOrIssuerEntropy" xml:space="preserve">
    <value>The issuer cannot provide key entropy or a proof token in key entropy mode '{0}'.</value>
  </data>
  <data name="EntropyModeCannotHaveRequestorEntropy" xml:space="preserve">
    <value>The client cannot provide key entropy in key entropy mode '{0}'.</value>
  </data>
  <data name="EntropyModeRequiresProofToken" xml:space="preserve">
    <value>The issuer must provide a proof token in key entropy mode '{0}'.</value>
  </data>
  <data name="EntropyModeRequiresComputedKey" xml:space="preserve">
    <value>The issuer must provide a computed key in key entropy mode '{0}'.</value>
  </data>
  <data name="EntropyModeRequiresIssuerEntropy" xml:space="preserve">
    <value>The issuer must provide key entropy in key entropy mode '{0}'.</value>
  </data>
  <data name="EntropyModeCannotHaveComputedKey" xml:space="preserve">
    <value>The issuer cannot provide a computed key in key entropy mode '{0}'.</value>
  </data>
  <data name="UnknownComputedKeyAlgorithm" xml:space="preserve">
    <value>The computed key algorithm '{0}' is not supported.</value>
  </data>
  <data name="NoncesCachedInfinitely" xml:space="preserve">
    <value>The ReplayWindow and ClockSkew cannot be the maximum possible value when replay detection is enabled.</value>
  </data>
  <data name="DownlevelNameCannotMapToUpn" xml:space="preserve">
    <value>Cannot map Windows user '{0}' to a UserPrincipalName that can be used for S4U impersonation.</value>
  </data>
  <data name="ResolvingExternalTokensRequireSecurityTokenParameters" xml:space="preserve">
    <value>Resolving an External reference token requires appropriate SecurityTokenParameters to be specified.</value>
  </data>
  <data name="SecurityRenewFaultReason" xml:space="preserve">
    <value>The SecurityContextSecurityToken's key needs to be renewed.</value>
  </data>
  <data name="ServiceSecurityCloseOutputSessionTimeout" xml:space="preserve">
    <value>The service's security session was not able to close its output session within the configured timeout ({0}).</value>
  </data>
  <data name="ServiceSecurityCloseTimeout" xml:space="preserve">
    <value>The service's security session did not receive a 'close' message from the client within the configured timeout ({0}).</value>
  </data>
  <data name="SctCookieXmlParseError" xml:space="preserve">
    <value>Error parsing SecurityContextSecurityToken Cookie XML.</value>
  </data>
  <data name="SctCookieValueMissingOrIncorrect" xml:space="preserve">
    <value>The SecurityContextSecurityToken's Cookie element either does not contain '{0}' or has a wrong value for it.</value>
  </data>
  <data name="SctCookieBlobDecodeFailure" xml:space="preserve">
    <value>Error decoding the Cookie element of SecurityContextSecurityToken.</value>
  </data>
  <data name="SctCookieNotSupported" xml:space="preserve">
    <value>Issuing cookie SecurityContextSecurityToken is not supported.</value>
  </data>
  <data name="SignatureConfirmationsNotExpected" xml:space="preserve">
    <value>Signature confirmation is not expected in the security header.</value>
  </data>
  <data name="SignatureConfirmationsOccursAfterPrimarySignature" xml:space="preserve">
    <value>The signature confirmation elements cannot occur after the primary signature.</value>
  </data>
  <data name="SignatureConfirmationWasExpected" xml:space="preserve">
    <value>Signature confirmation was expected to be present in the security header.</value>
  </data>
  <data name="SignatureConfirmationRequiresRequestReply" xml:space="preserve">
    <value>The protocol factory must support Request/Reply security in order to offer signature confirmation.</value>
  </data>
  <data name="TooManyPendingSessionKeys" xml:space="preserve">
    <value>There are too many renewed session keys that have not been used.</value>
  </data>
  <data name="SecuritySessionKeyIsStale" xml:space="preserve">
    <value>The session key must be renewed before it can secure application messages.</value>
  </data>
  <data name="MultipleMatchingCryptosFound" xml:space="preserve">
    <value>The token's crypto collection has multiple objects of type '{0}'.</value>
  </data>
  <data name="CannotFindMatchingCrypto" xml:space="preserve">
    <value>The token's crypto collection does not support algorithm '{0}'.</value>
  </data>
  <data name="CachedNegotiationStateQuotaReached" xml:space="preserve">
    <value>The service cannot cache the negotiation state as the capacity '{0}' has been reached. Retry the request.</value>
  </data>
  <data name="KeyRolloverGreaterThanKeyRenewal" xml:space="preserve">
    <value>The key rollover interval cannot be greater than the key renewal interval.</value>
  </data>
  <data name="CurrentSessionTokenNotRenewed" xml:space="preserve">
    <value>The supporting token in the renew message has a different generation '{0}' than the current session token's generation '{1}'.</value>
  </data>
  <data name="SecuritySessionAbortedFaultReason" xml:space="preserve">
    <value>The security session was terminated This may be because no messages were received on the session for too long.</value>
  </data>
  <data name="NoAppliesToPresent" xml:space="preserve">
    <value>No AppliesTo element is present in the deserialized RequestSecurityToken/RequestSecurityTokenResponse.</value>
  </data>
  <data name="UnsupportedKeyLength" xml:space="preserve">
    <value>Symmetric Key length {0} is not supported by the algorithm suite '{1}'.</value>
  </data>
  <data name="ForReplayDetectionToBeDoneRequireIntegrityMustBeSet" xml:space="preserve">
    <value>For replay detection to be done ProtectionLevel must be Sign or EncryptAndSign.</value>
  </data>
  <data name="CantInferReferenceForToken" xml:space="preserve">
    <value>Can't infer an external reference for '{0}' token type.</value>
  </data>
  <data name="TrustDriverIsUnableToCreatedNecessaryAttachedOrUnattachedReferences" xml:space="preserve">
    <value>Unable to create Attached or Unattached reference for '{0}'.</value>
  </data>
  <data name="TrustDriverVersionDoesNotSupportSession" xml:space="preserve">
    <value>The configured Trust version does not support sessions. Use WSTrustFeb2005 or above.</value>
  </data>
  <data name="TrustDriverVersionDoesNotSupportIssuedTokens" xml:space="preserve">
    <value>The configured WS-Trust version does not support issued tokens. WS-Trust February 2005 or later is required.</value>
  </data>
  <data name="SecureConversationRequiredByReliableSession" xml:space="preserve">
    <value>Cannot establish a reliable session without secure conversation. Enable secure conversation.</value>
  </data>
  <data name="SignatureConfirmationNotSupported" xml:space="preserve">
    <value>The configured SecurityVersion does not support signature confirmation. Use WsSecurity11 or above.</value>
  </data>
  <data name="SecureConversationDriverVersionDoesNotSupportSession" xml:space="preserve">
    <value>The configured SecureConversation version does not support sessions. Use WSSecureConversationFeb2005 or above.</value>
  </data>
  <data name="CannotFindSecuritySession" xml:space="preserve">
    <value>Cannot find the security session with the ID '{0}'.</value>
  </data>
  <data name="SecurityContextKeyExpired" xml:space="preserve">
    <value>The SecurityContextSecurityToken with Context-id={0} (generation-id={1}) has expired.</value>
  </data>
  <data name="SecurityContextKeyExpiredNoKeyGeneration" xml:space="preserve">
    <value>The SecurityContextSecurityToken with Context-id={0} (no key generation-id) has expired.</value>
  </data>
  <data name="RequiredTimestampMissingInSecurityHeader" xml:space="preserve">
    <value>Required timestamp missing in security header.</value>
  </data>
  <data name="ReceivedMessageInRequestContextNull" xml:space="preserve">
    <value>The request message in the request context received from channel '{0}' is null.</value>
  </data>
  <data name="KeyLifetimeNotWithinTokenLifetime" xml:space="preserve">
    <value>The key effective and expiration times must be bounded by the token effective and expiration times.</value>
  </data>
  <data name="EffectiveGreaterThanExpiration" xml:space="preserve">
    <value>The valid from time is greater than the valid to time.</value>
  </data>
  <data name="NoSessionTokenPresentInMessage" xml:space="preserve">
    <value>No session token was present in the message.</value>
  </data>
  <data name="KeyLengthMustBeMultipleOfEight" xml:space="preserve">
    <value>Key length '{0}' is not a multiple of 8 for symmetric keys.</value>
  </data>
  <data name="InvalidX509RawData" xml:space="preserve">
    <value>Invalid binary representation of an X.509 certificate.</value>
  </data>
  <data name="ExportOfBindingWithTransportSecurityBindingElementAndNoTransportSecurityNotSupported" xml:space="preserve">
    <value>Security policy export failed. The binding contains a TransportSecurityBindingElement but no transport binding element that implements ITransportTokenAssertionProvider. Policy export for such a binding is not supported. Make sure the transport binding element in the binding implements the ITransportTokenAssertionProvider interface.</value>
  </data>
  <data name="NoTransportTokenAssertionProvided" xml:space="preserve">
    <value>The security policy expert failed. The provided transport token assertion of type '{0}' did not create a transport token assertion to include the sp:TransportBinding security policy assertion.</value>
  </data>
  <data name="PrimarySignatureIsRequiredToBeEncrypted" xml:space="preserve">
    <value>The primary signature must be encrypted.</value>
  </data>
  <data name="TokenCannotCreateSymmetricCrypto" xml:space="preserve">
    <value>A symmetric crypto could not be created from token '{0}'.</value>
  </data>
  <data name="TokenDoesNotMeetKeySizeRequirements" xml:space="preserve">
    <value>The key size requirements for the '{0}' algorithm suite are not met by the '{1}' token which has key size of '{2}'.</value>
  </data>
  <data name="MessageProtectionOrderMismatch" xml:space="preserve">
    <value>The received message does not meet the required message protection order '{0}'.</value>
  </data>
  <data name="PrimarySignatureMustBeComputedBeforeSupportingTokenSignatures" xml:space="preserve">
    <value>Primary signature must be computed before supporting token signatures.</value>
  </data>
  <data name="ElementToSignMustHaveId" xml:space="preserve">
    <value>Element to sign must have id.</value>
  </data>
  <data name="StandardsManagerCannotWriteObject" xml:space="preserve">
    <value>The token Serializer cannot serialize '{0}'.  If this is a custom type you must supply a custom serializer.</value>
  </data>
  <data name="SigningWithoutPrimarySignatureRequiresTimestamp" xml:space="preserve">
    <value>Signing without primary signature requires timestamp.</value>
  </data>
  <data name="OperationCannotBeDoneAfterProcessingIsStarted" xml:space="preserve">
    <value>This operation cannot be done after processing is started.</value>
  </data>
  <data name="ClientCredentialsUnableToCreateLocalTokenProvider" xml:space="preserve">
    <value>ClientCredentials cannot create a local token provider for token requirement {0}.</value>
  </data>
  <data name="ConfigurationSchemaInsuffientForSecurityBindingElementInstance" xml:space="preserve">
    <value>The configuration schema is insufficient to describe the non-standard configuration of the following security binding element: </value>
  </data>
  <data name="ConfigurationSchemaContainsX509IssuerSerialReference" xml:space="preserve">
    <value>The wsdl schema that was used to create this configuration file contained a 'RequireIssuerSerialReference' assertion for a X509Token.  This can not be represented in configuration, you will need to programatically adjust the appropriate X509SecurityTokenParameters.X509KeyIdentifierClauseType to X509KeyIdentifierClauseType.IssuerSerial.  The default of X509KeyIdentifierClauseType.Thumbprint will be used, which may cause interop issues.</value>
  </data>
  <data name="SecurityProtocolCannotDoReplayDetection" xml:space="preserve">
    <value>The security protocol '{0}' cannot do replay detection.</value>
  </data>
  <data name="UnableToFindSecurityHeaderInMessage" xml:space="preserve">
    <value>Security processor was unable to find a security header with actor '{0}' in the message. This might be because the message is an unsecured fault or because there is a binding mismatch between the communicating parties.  This can occur if the service is configured for security and the client is not using security.</value>
  </data>
  <data name="UnableToFindSecurityHeaderInMessageNoActor" xml:space="preserve">
    <value>Security processor was unable to find a security header in the message. This might be because the message is an unsecured fault or because there is a binding mismatch between the communicating parties.   This can occur if the service is configured for security and the client is not using security.</value>
  </data>
  <data name="NoPrimarySignatureAvailableForSupportingTokenSignatureVerification" xml:space="preserve">
    <value>No primary signature available for supporting token signature verification.</value>
  </data>
  <data name="SupportingTokenSignaturesNotExpected" xml:space="preserve">
    <value>Supporting token signatures not expected.</value>
  </data>
  <data name="CannotReadToken" xml:space="preserve">
    <value>Cannot read the token from the '{0}' element with the '{1}' namespace for BinarySecretSecurityToken, with a '{2}' ValueType. If this element is expected to be valid, ensure that security is configured to consume tokens with the name, namespace and value type specified.</value>
  </data>
  <data name="ExpectedElementMissing" xml:space="preserve">
    <value>Element '{0}' with namespace '{1}' not found.</value>
  </data>
  <data name="ExpectedOneOfTwoElementsFromNamespace" xml:space="preserve">
    <value>Expected element '{0}' or element '{1}' (from namespace '{2}').</value>
  </data>
  <data name="RequiredSignatureMissing" xml:space="preserve">
    <value>The signature must be in the security header.</value>
  </data>
  <data name="RequiredMessagePartNotSigned" xml:space="preserve">
    <value>The '{0}' required message part was not signed.</value>
  </data>
  <data name="RequiredMessagePartNotSignedNs" xml:space="preserve">
    <value>The '{0}', '{1}' required message part  was not signed.</value>
  </data>
  <data name="RequiredMessagePartNotEncrypted" xml:space="preserve">
    <value>The '{0}' required message part was not encrypted.</value>
  </data>
  <data name="RequiredMessagePartNotEncryptedNs" xml:space="preserve">
    <value>The '{0}', '{1}' required message part  was not encrypted.</value>
  </data>
  <data name="SignatureVerificationFailed" xml:space="preserve">
    <value>Signature verification failed.</value>
  </data>
  <data name="CannotIssueRstTokenType" xml:space="preserve">
    <value>Cannot issue the token type '{0}'.</value>
  </data>
  <data name="NegotiationIsNotCompleted" xml:space="preserve">
    <value>The negotiation has not yet completed.</value>
  </data>
  <data name="MissingMessageID" xml:space="preserve">
    <value>Request Message is missing a MessageID header. One is required to correlate a reply.</value>
  </data>
  <data name="SecuritySessionLimitReached" xml:space="preserve">
    <value>Cannot create a security session. Retry later.</value>
  </data>
  <data name="SecuritySessionAlreadyPending" xml:space="preserve">
    <value>The security session with id '{0}' is already pending.</value>
  </data>
  <data name="SecuritySessionNotPending" xml:space="preserve">
    <value>No security session with id '{0}' is pending.</value>
  </data>
  <data name="ProtocolMustBeRecipient" xml:space="preserve">
    <value>'{0}' protocol can only be used at the Recipient.</value>
  </data>
  <data name="OnlyBodyReturnValuesSupported" xml:space="preserve">
    <value>Only body return values are supported currently for protection, MessagePartDescription was specified.</value>
  </data>
  <data name="UnknownTokenAttachmentMode" xml:space="preserve">
    <value>Unknown token attachment mode: {0}.</value>
  </data>
  <data name="ProtocolMisMatch" xml:space="preserve">
    <value>Security protocol must be '{0}', type is: '{1}'.;</value>
  </data>
  <data name="ServerReceivedCloseMessageStateIsCreated" xml:space="preserve">
    <value>{0}.OnCloseMessageReceived when state == Created.</value>
  </data>
  <data name="ShutdownRequestWasNotReceived" xml:space="preserve">
    <value>Shutdown request was not received.</value>
  </data>
  <data name="UnknownFilterType" xml:space="preserve">
    <value>Unknown filter type: '{0}'.</value>
  </data>
  <data name="StandardsManagerDoesNotMatch" xml:space="preserve">
    <value>Standards manager of filter does not match that of filter table.  Can not have two different filters.</value>
  </data>
  <data name="FilterStrictModeDifferent" xml:space="preserve">
    <value>Session filter's isStrictMode differs from filter table's isStrictMode.</value>
  </data>
  <data name="TokenManagerCouldNotReadToken" xml:space="preserve">
    <value>Security token manager could not parse token with name '{0}', namespace '{1}', valueType '{2}'.</value>
  </data>
  <data name="InvalidActionForNegotiationMessage" xml:space="preserve">
    <value>Security negotiation message has incorrect action '{0}'.</value>
  </data>
  <data name="InvalidKeySizeSpecifiedInNegotiation" xml:space="preserve">
    <value>The specified key size {0} is invalid. The key size must be between {1} and {2}.</value>
  </data>
  <data name="UnexpectedEndOfFile" xml:space="preserve">
    <value>Unexpected end of file.</value>
  </data>
  <data name="TimeStampHasCreationAheadOfExpiry" xml:space="preserve">
    <value>The security timestamp is invalid because its creation time ('{0}') is greater than or equal to its expiration time ('{1}').</value>
  </data>
  <data name="TimeStampHasExpiryTimeInPast" xml:space="preserve">
    <value>The security timestamp is stale because its expiration time ('{0}') is in the past. Current time is '{1}' and allowed clock skew is '{2}'.</value>
  </data>
  <data name="TimeStampHasCreationTimeInFuture" xml:space="preserve">
    <value>The security timestamp is invalid because its creation time ('{0}') is in the future. Current time is '{1}' and allowed clock skew is '{2}'.</value>
  </data>
  <data name="TimeStampWasCreatedTooLongAgo" xml:space="preserve">
    <value>The security timestamp is stale because its creation time ('{0}') is too far back in the past. Current time is '{1}', maximum timestamp lifetime is '{2}' and allowed clock skew is '{3}'.</value>
  </data>
  <data name="InvalidOrReplayedNonce" xml:space="preserve">
    <value>The nonce is invalid or replayed.</value>
  </data>
  <data name="MessagePartSpecificationMustBeImmutable" xml:space="preserve">
    <value>Message part specification must be made constant before being set.</value>
  </data>
  <data name="UnsupportedIssuerEntropyType" xml:space="preserve">
    <value>Issuer entropy is not BinarySecretSecurityToken or WrappedKeySecurityToken.</value>
  </data>
  <data name="NoRequestSecurityTokenResponseElements" xml:space="preserve">
    <value>No RequestSecurityTokenResponse elements were found.</value>
  </data>
  <data name="NoCookieInSct" xml:space="preserve">
    <value>The SecurityContextSecurityToken does not have a cookie.</value>
  </data>
  <data name="ItemNotAvailableInDeserializedRST" xml:space="preserve">
    <value>{0} is not available in deserialized RequestSecurityToken.</value>
  </data>
  <data name="ItemAvailableInDeserializedRSTOnly" xml:space="preserve">
    <value>{0} is only available in a deserialized RequestSecurityToken.</value>
  </data>
  <data name="ItemNotAvailableInDeserializedRSTR" xml:space="preserve">
    <value>{0} is not available in deserialized RequestSecurityTokenResponse.</value>
  </data>
  <data name="ItemAvailableInDeserializedRSTROnly" xml:space="preserve">
    <value>{0} is only available in a deserialized RequestSecurityTokenResponse.</value>
  </data>
  <data name="Hosting_NotSupportedProtocol" xml:space="preserve">
    <value>The protocol '{0}' is not supported.</value>
  </data>
  <data name="Hosting_BaseUriDeserializedNotValid" xml:space="preserve">
    <value>The BaseUriWithWildcard object has invalid fields after deserialization.</value>
  </data>
  <data name="SecureConversationNeedsBootstrapSecurity" xml:space="preserve">
    <value>Cannot create security binding element based on the configuration data. When secure conversation authentication mode is selected, the secure conversation bootstrap binding element must also be specified. </value>
  </data>
  <data name="Hosting_MisformattedPort" xml:space="preserve">
    <value>The '{0}' protocol binding '{1}' specifies an invalid port number '{2}'.</value>
  </data>
  <data name="Hosting_MisformattedBinding" xml:space="preserve">
    <value>The protocol binding '{0}' does not conform to the syntax for '{1}'. The following is an example of valid '{1}' protocol bindings: '{2}'.</value>
  </data>
  <data name="Hosting_MisformattedBindingData" xml:space="preserve">
    <value>The protocol binding '{0}' is not valid for '{1}'.  This might be because the port number is out of range.</value>
  </data>
  <data name="Hosting_ServiceActivationFailed" xml:space="preserve">
    <value>The requested service, '{0}' could not be activated. See the server's diagnostic trace logs for more information.</value>
  </data>
  <data name="Sharing_ConnectionDispatchFailed" xml:space="preserve">
    <value>The message could not be dispatched to the service at address '{0}'. Refer to the server Event Log for more details</value>
  </data>
  <data name="Sharing_EndpointUnavailable" xml:space="preserve">
    <value>The message could not be dispatched because the service at the endpoint address '{0}' is unavailable for the protocol of the address.</value>
  </data>
  <data name="UnexpectedEmptyElementExpectingClaim" xml:space="preserve">
    <value>The '{0}' from the '{1}' namespace is empty and does not specify a valid identity claim. </value>
  </data>
  <data name="UnexpectedElementExpectingElement" xml:space="preserve">
    <value>'{0}' from namespace '{1}' is not expected. Expecting element '{2}' from namespace '{3}'</value>
  </data>
  <data name="UnexpectedDuplicateElement" xml:space="preserve">
    <value>'{0}' from namespace '{1}' is not expected to appear more than once</value>
  </data>
  <data name="MultipleIdentities" xml:space="preserve">
    <value>The extensions cannot contain an Identity if one is supplied as a constructor argument.</value>
  </data>
  <data name="InvalidUriValue" xml:space="preserve">
    <value>Value '{0}' provided for '{1}' from namespace '{2}' is an invalid absolute URI.</value>
  </data>
  <data name="UnsupportedChannelInterfaceType" xml:space="preserve">
    <value>Channel interface type '{0}' is not supported.</value>
  </data>
  <data name="UnrecognizedIdentityType" xml:space="preserve">
    <value>Unrecognized identity type Name='{0}', Namespace='{1}'.</value>
  </data>
  <data name="InvalidIdentityElement" xml:space="preserve">
    <value>Cannot read the Identity element. The Identity type is not supported or the Identity element is empty.</value>
  </data>
  <data name="UnrecognizedClaimTypeForIdentity" xml:space="preserve">
    <value>The ClaimType '{0}' is not recognized. Expected ClaimType '{1}'.</value>
  </data>
  <data name="SendCannotBeCalledAfterCloseOutputSession" xml:space="preserve">
    <value>You cannot Send messages on a channel after CloseOutputSession has been called.</value>
  </data>
  <data name="CommunicationObjectCannotBeModifiedInState" xml:space="preserve">
    <value>The communication object, {0}, cannot be modified while it is in the {1} state.</value>
  </data>
  <data name="CommunicationObjectFaulted1" xml:space="preserve">
    <value>The communication object, {0}, cannot be used for communication because it is in the Faulted state.</value>
  </data>
  <data name="CommunicationObjectAborted1" xml:space="preserve">
    <value>The communication object, {0}, cannot be used for communication because it has been Aborted.</value>
  </data>
  <data name="CommunicationObjectBaseClassMethodNotCalled" xml:space="preserve">
    <value>The communication object, {0}, has overridden the virtual function {1} but it does not call version defined in the base class.</value>
  </data>
  <data name="ChannelTypeNotSupported" xml:space="preserve">
    <value>The specified channel type {0} is not supported by this channel manager.</value>
  </data>
  <data name="SecurityContextMissing" xml:space="preserve">
    <value>SecurityContext for the UltimateReceiver role is missing from the SecurityContextProperty of the request message with action '{0}'.</value>
  </data>
  <data name="SecurityContextDoesNotAllowImpersonation" xml:space="preserve">
    <value>Cannot start impersonation because the SecurityContext for the UltimateReceiver role from the request message with the '{0}' action is not mapped to a Windows identity.</value>
  </data>
  <data name="InvalidEnumValue" xml:space="preserve">
    <value>Unexpected internal enum value: {0}.</value>
  </data>
  <data name="InvalidDecoderStateMachine" xml:space="preserve">
    <value>Invalid decoder state machine.</value>
  </data>
  <data name="ObjectDisposed" xml:space="preserve">
    <value>The {0} object has been disposed.</value>
  </data>
  <data name="InvalidReaderPositionOnCreateMessage" xml:space="preserve">
    <value>The XmlReader used for the body of the message must be positioned on an element.</value>
  </data>
  <data name="DuplicateMessageProperty" xml:space="preserve">
    <value>A property with the name '{0}' already exists.</value>
  </data>
  <data name="MessagePropertyNotFound" xml:space="preserve">
    <value>A property with the name '{0}' is not present.</value>
  </data>
  <data name="HeaderAlreadyUnderstood" xml:space="preserve">
    <value>The message header with name '{0}' and namespace '{1}' is already present in the set of understood headers.</value>
  </data>
  <data name="HeaderAlreadyNotUnderstood" xml:space="preserve">
    <value>The message header with name '{0}' and namespace '{1}' is not present in the set of understood headers.</value>
  </data>
  <data name="MultipleMessageHeaders" xml:space="preserve">
    <value>Multiple headers with name '{0}' and namespace '{1}' found.</value>
  </data>
  <data name="MultipleMessageHeadersWithActor" xml:space="preserve">
    <value>Multiple headers with name '{0}' and namespace '{1}' and role '{2}' found.</value>
  </data>
  <data name="MultipleRelatesToHeaders" xml:space="preserve">
    <value> Multiple RelatesTo headers with relationship '{0}' found.  Only one is allowed per relationship.</value>
  </data>
  <data name="ExtraContentIsPresentInFaultDetail" xml:space="preserve">
    <value>Additional XML content is present in the fault detail element. Only a single element is allowed.</value>
  </data>
  <data name="MessageIsEmpty" xml:space="preserve">
    <value>The body of the message cannot be read because it is empty.</value>
  </data>
  <data name="MessageClosed" xml:space="preserve">
    <value>Message is closed.</value>
  </data>
  <data name="BodyWriterReturnedIsNotBuffered" xml:space="preserve">
    <value>The body writer returned from OnCreateBufferedCopy was not buffered.</value>
  </data>
  <data name="BodyWriterCanOnlyBeWrittenOnce" xml:space="preserve">
    <value>The body writer does not support writing more than once because it is not buffered.</value>
  </data>
  <data name="RstrKeySizeNotProvided" xml:space="preserve">
    <value>KeySize element not present in RequestSecurityTokenResponse.</value>
  </data>
  <data name="RequestMessageDoesNotHaveAMessageID" xml:space="preserve">
    <value>A reply message cannot be created because the request message does not have a MessageID.</value>
  </data>
  <data name="HeaderNotFound" xml:space="preserve">
    <value>There is not a header with name {0} and namespace {1} in the message.</value>
  </data>
  <data name="MessageBufferIsClosed" xml:space="preserve">
    <value>MessageBuffer is closed.</value>
  </data>
  <data name="MessageTextEncodingNotSupported" xml:space="preserve">
    <value>The text encoding '{0}' used in the text message format is not supported.</value>
  </data>
  <data name="AtLeastOneFaultReasonMustBeSpecified" xml:space="preserve">
    <value>At least one fault reason must be specified.</value>
  </data>
  <data name="NoNullTranslations" xml:space="preserve">
    <value>The translation set cannot contain nulls.</value>
  </data>
  <data name="FaultDoesNotHaveAnyDetail" xml:space="preserve">
    <value>The fault does not have detail information.</value>
  </data>
  <data name="InvalidXmlQualifiedName" xml:space="preserve">
    <value>Expected XML qualified name, found '{0}'.</value>
  </data>
  <data name="UnboundPrefixInQName" xml:space="preserve">
    <value>Unbound prefix used in qualified name '{0}'.</value>
  </data>
  <data name="MessageBodyIsUnknown" xml:space="preserve">
    <value>...</value>
  </data>
  <data name="MessageBodyIsStream" xml:space="preserve">
    <value>... stream ...</value>
  </data>
  <data name="MessageBodyToStringError" xml:space="preserve">
    <value>... Error reading body: {0}: {1} ...</value>
  </data>
  <data name="NoMatchingTranslationFoundForFaultText" xml:space="preserve">
    <value>The fault reason does not contain any text translations.</value>
  </data>
  <data name="CannotDetermineSPNBasedOnAddress" xml:space="preserve">
    <value>Client cannot determine the Service Principal Name based on the identity in the target address '{0}' for the purpose of SspiNegotiation/Kerberos. The target address identity must be a UPN identity (like acmedomain\\alice) or SPN identity (like host/bobs-machine).</value>
  </data>
  <data name="XmlLangAttributeMissing" xml:space="preserve">
    <value>Required xml:lang attribute value is missing.</value>
  </data>
  <data name="EncoderUnrecognizedCharSet" xml:space="preserve">
    <value>Unrecognized charSet '{0}' in contentType.</value>
  </data>
  <data name="EncoderUnrecognizedContentType" xml:space="preserve">
    <value>Unrecognized contentType ({0}). Expected: {1}.</value>
  </data>
  <data name="EncoderBadContentType" xml:space="preserve">
    <value>Cannot process contentType.</value>
  </data>
  <data name="EncoderEnvelopeVersionMismatch" xml:space="preserve">
    <value>The envelope version of the incoming message ({0}) does not match that of the encoder ({1}). Make sure the binding is configured with the same version as the expected messages.</value>
  </data>
  <data name="EncoderMessageVersionMismatch" xml:space="preserve">
    <value>The message version of the outgoing message ({0}) does not match that of the encoder ({1}). Make sure the binding is configured with the same version as the message.</value>
  </data>
  <data name="MtomEncoderBadMessageVersion" xml:space="preserve">
    <value>MessageVersion '{0}' not supported by MTOM encoder.</value>
  </data>
  <data name="ReadNotSupported" xml:space="preserve">
    <value>Read is not supported on this stream.</value>
  </data>
  <data name="SeekNotSupported" xml:space="preserve">
    <value>Seek is not supported on this stream.</value>
  </data>
  <data name="PipeNameCanNotBeAccessed" xml:space="preserve">
    <value>The pipe name could not be obtained for the pipe URI: {0}</value>
  </data>
  <data name="PipeNameCanNotBeAccessed2" xml:space="preserve">
    <value>The pipe name could not be obtained for {0}.</value>
  </data>
  <data name="PipeListenFailed" xml:space="preserve">
    <value>Cannot listen on pipe '{0}': {1}</value>
  </data>
  <data name="PipeNameInUse" xml:space="preserve">
    <value>Cannot listen on pipe name '{0}' because another pipe endpoint is already listening on that name.</value>
  </data>
  <data name="PipeNameCantBeReserved" xml:space="preserve">
    <value>Cannot listen on pipe '{0}' because the pipe name could not be reserved: {1}</value>
  </data>
  <data name="PipeUriSchemeWrong" xml:space="preserve">
    <value>URIs used with pipes must use the scheme: 'net.pipe'.</value>
  </data>
  <data name="PipeWriteError" xml:space="preserve">
    <value>There was an error writing to the pipe: {0}.</value>
  </data>
  <data name="PipeUnknownWin32Error" xml:space="preserve">
    <value>Unrecognized error {0} (0x{1})</value>
  </data>
  <data name="PipeKnownWin32Error" xml:space="preserve">
    <value>{0} ({1}, 0x{2})</value>
  </data>
  <data name="FramingError" xml:space="preserve">
    <value>Error while reading message framing format at position {0} of stream (state: {1})</value>
  </data>
  <data name="FramingPrematureEOF" xml:space="preserve">
    <value>More data was expected, but EOF was reached.</value>
  </data>
  <data name="FramingRecordTypeMismatch" xml:space="preserve">
    <value>Expected record type '{0}', found '{1}'.</value>
  </data>
  <data name="FramingVersionNotSupported" xml:space="preserve">
    <value>Framing major version {0} is not supported.</value>
  </data>
  <data name="FramingModeNotSupported" xml:space="preserve">
    <value>Framing mode {0} is not supported.</value>
  </data>
  <data name="FramingSizeTooLarge" xml:space="preserve">
    <value>Specified size is too large for this implementation.</value>
  </data>
  <data name="FramingViaTooLong" xml:space="preserve">
    <value>The framing via size ({0}) exceeds the quota.</value>
  </data>
  <data name="FramingViaNotUri" xml:space="preserve">
    <value>The framing via ({0}) is not a valid URI.</value>
  </data>
  <data name="FramingFaultTooLong" xml:space="preserve">
    <value>The framing fault size ({0}) exceeds the quota.</value>
  </data>
  <data name="FramingContentTypeTooLong" xml:space="preserve">
    <value>The framing content type size ({0}) exceeds the quota.</value>
  </data>
  <data name="FramingValueNotAvailable" xml:space="preserve">
    <value>The value cannot be accessed because it has not yet been fully decoded.</value>
  </data>
  <data name="FramingAtEnd" xml:space="preserve">
    <value>An attempt was made to decode a value after the framing stream was ended.</value>
  </data>
  <data name="RemoteSecurityNotNegotiatedOnStreamUpgrade" xml:space="preserve">
    <value>Stream Security is required at {0}, but no security context was negotiated. This is likely caused by the remote endpoint missing a StreamSecurityBindingElement from its binding.</value>
  </data>
  <data name="BinaryEncoderSessionTooLarge" xml:space="preserve">
    <value>The binary encoder session information exceeded the maximum size quota ({0}). To increase this quota, use the MaxSessionSize property on the BinaryMessageEncodingBindingElement.</value>
  </data>
  <data name="BinaryEncoderSessionInvalid" xml:space="preserve">
    <value>The binary encoder session is not valid. There was an error decoding a previous message.</value>
  </data>
  <data name="BinaryEncoderSessionMalformed" xml:space="preserve">
    <value>The binary encoder session information is not properly formed.</value>
  </data>
  <data name="ReceiveShutdownReturnedFault" xml:space="preserve">
    <value>The channel received an unexpected fault input message while closing. The fault reason given is: '{0}'</value>
  </data>
  <data name="ReceiveShutdownReturnedLargeFault" xml:space="preserve">
    <value>The channel received an unexpected fault input message with Action = '{0}' while closing. You should only close your channel when you are not expecting any more input messages.</value>
  </data>
  <data name="ReceiveShutdownReturnedMessage" xml:space="preserve">
    <value>The channel received an unexpected input message with Action '{0}' while closing. You should only close your channel when you are not expecting any more input messages.</value>
  </data>
  <data name="MaxReceivedMessageSizeExceeded" xml:space="preserve">
    <value>The maximum message size quota for incoming messages ({0}) has been exceeded. To increase the quota, use the MaxReceivedMessageSize property on the appropriate binding element.</value>
  </data>
  <data name="MaxSentMessageSizeExceeded" xml:space="preserve">
    <value>The maximum message size quota for outgoing messages ({0}) has been exceeded.</value>
  </data>
  <data name="FramingMaxMessageSizeExceeded" xml:space="preserve">
    <value>The maximum message size quota for incoming messages has been exceeded for the remote channel. See the server logs for more details.</value>
  </data>
  <data name="StreamDoesNotSupportTimeout" xml:space="preserve">
    <value>TimeoutStream requires an inner Stream that supports timeouts; its CanTimeout property must be true.</value>
  </data>
  <data name="FilterExists" xml:space="preserve">
    <value>The filter already exists in the filter table.</value>
  </data>
  <data name="ActionFilterEmptyList" xml:space="preserve">
    <value>The set of actions cannot be empty.</value>
  </data>
  <data name="FilterMultipleMatches" xml:space="preserve">
    <value>Multiple filters matched.</value>
  </data>
  <data name="FilterTableTypeMismatch" xml:space="preserve">
    <value>The type of IMessageFilterTable created for a particular Filter type must always be the same.</value>
  </data>
  <data name="FilterTableInvalidForLookup" xml:space="preserve">
    <value>The MessageFilterTable state is corrupt. The requested lookup cannot be performed.</value>
  </data>
  <data name="FilterBadTableType" xml:space="preserve">
    <value>The IMessageFilterTable created for a Filter cannot be a MessageFilterTable or a subclass of MessageFilterTable.</value>
  </data>
  <data name="QueryItemAlreadyExists" xml:space="preserve">
    <value>An internal error has occurred. Item already exists.</value>
  </data>
  <data name="MessageVersionToStringFormat" xml:space="preserve">
    <value>{0} {1}</value>
  </data>
  <data name="Addressing10ToStringFormat" xml:space="preserve">
    <value>Addressing10 ({0})</value>
  </data>
  <data name="Addressing200408ToStringFormat" xml:space="preserve">
    <value>Addressing200408 ({0})</value>
  </data>
  <data name="AddressingNoneToStringFormat" xml:space="preserve">
    <value>AddressingNone ({0})</value>
  </data>
  <data name="AddressingVersionNotSupported" xml:space="preserve">
    <value>Addressing Version '{0}' is not supported.</value>
  </data>
  <data name="Soap11ToStringFormat" xml:space="preserve">
    <value>Soap11 ({0})</value>
  </data>
  <data name="Soap12ToStringFormat" xml:space="preserve">
    <value>Soap12 ({0})</value>
  </data>
  <data name="EnvelopeNoneToStringFormat" xml:space="preserve">
    <value>EnvelopeNone ({0})</value>
  </data>
  <data name="MessagePropertyReturnedNullCopy" xml:space="preserve">
    <value>The IMessageProperty could not be copied. CreateCopy returned null.</value>
  </data>
  <data name="MessageVersionUnknown" xml:space="preserve">
    <value>Unrecognized message version.</value>
  </data>
  <data name="EnvelopeVersionUnknown" xml:space="preserve">
    <value>Unrecognized envelope version: {0}.</value>
  </data>
  <data name="EnvelopeVersionNotSupported" xml:space="preserve">
    <value>Envelope Version '{0}' is not supported.</value>
  </data>
  <data name="CannotDetectAddressingVersion" xml:space="preserve">
    <value>Cannot detect WS-Addressing version. EndpointReference does not start with an Element.</value>
  </data>
  <data name="HeadersCannotBeAddedToEnvelopeVersion" xml:space="preserve">
    <value>Envelope Version '{0}' does not support adding Message Headers.</value>
  </data>
  <data name="AddressingHeadersCannotBeAddedToAddressingVersion" xml:space="preserve">
    <value>Addressing Version '{0}' does not support adding WS-Addressing headers.</value>
  </data>
  <data name="AddressingExtensionInBadNS" xml:space="preserve">
    <value>The element '{0}' in namespace '{1}' is not valid. This either means that element '{0}' is a duplicate element, or that it is not a legal extension because extension elements cannot be in the addressing namespace.</value>
  </data>
  <data name="MessageHeaderVersionNotSupported" xml:space="preserve">
    <value>The '{0}' header cannot be added because it does not support the specified message version '{1}'.</value>
  </data>
  <data name="MessageHasBeenCopied" xml:space="preserve">
    <value>This message cannot support the operation because it has been copied.</value>
  </data>
  <data name="MessageHasBeenWritten" xml:space="preserve">
    <value>This message cannot support the operation because it has been written.</value>
  </data>
  <data name="MessageHasBeenRead" xml:space="preserve">
    <value>This message cannot support the operation because it has been read.</value>
  </data>
  <data name="InvalidMessageState" xml:space="preserve">
    <value>An internal error has occurred. Invalid MessageState.</value>
  </data>
  <data name="MessageBodyReaderInvalidReadState" xml:space="preserve">
    <value>The body reader is in ReadState '{0}' and cannot be consumed.</value>
  </data>
  <data name="XmlBufferQuotaExceeded" xml:space="preserve">
    <value>The size necessary to buffer the XML content exceeded the buffer quota.</value>
  </data>
  <data name="XmlBufferInInvalidState" xml:space="preserve">
    <value>An internal error has occurred. The XML buffer is not in the correct state to perform the operation.</value>
  </data>
  <data name="MessageBodyMissing" xml:space="preserve">
    <value>A body element was not found inside the message envelope.</value>
  </data>
  <data name="MessageHeaderVersionMismatch" xml:space="preserve">
    <value>The version of the header(s) ({0}) differs from the version of the message ({1}).</value>
  </data>
  <data name="ReceiveTimedOut2" xml:space="preserve">
    <value>Receive timed out after {0}. The time allotted to this operation may have been a portion of a longer timeout.</value>
  </data>
  <data name="WaitForMessageTimedOut" xml:space="preserve">
    <value>WaitForMessage timed out after {0}. The time allotted to this operation may have been a portion of a longer timeout.</value>
  </data>
  <data name="ReceiveRequestTimedOutNoLocalAddress" xml:space="preserve">
    <value>Receive request timed out after {0}. The time allotted to this operation may have been a portion of a longer timeout.</value>
  </data>
  <data name="SendToViaTimedOut" xml:space="preserve">
    <value>Sending to via {0} timed out after {1}. The time allotted to this operation may have been a portion of a longer timeout.</value>
  </data>
  <data name="CloseTimedOut" xml:space="preserve">
    <value>Close timed out after {0}.  Increase the timeout value passed to the call to Close or increase the CloseTimeout value on the Binding. The time allotted to this operation may have been a portion of a longer timeout.</value>
  </data>
  <data name="HttpSoapActionMismatchFault" xml:space="preserve">
    <value>The SOAP action specified on the message, '{0}', does not match the HTTP SOAP Action, '{1}'. </value>
  </data>
  <data name="ReceiveContextCannotBeUsed" xml:space="preserve">
    <value>The receive context, {0}, is in the {1} state.  Receive contexts cannot be used for sending delayed acks unless they are in the Received state.</value>
  </data>
  <data name="ReceiveContextInInvalidState" xml:space="preserve">
    <value>The receive context, {0}, is in an unsupported state '{1}'.  This indicates an internal error in the implementation of that receive context.</value>
  </data>
  <data name="ReceiveContextFaulted" xml:space="preserve">
    <value>The receive context, {0}, cannot be used for sending delayed acks because it is in the Faulted state.</value>
  </data>
  <data name="IssueSessionTokenHandlerNotSet" xml:space="preserve">
    <value>There is no handler registered for session token issuance event.</value>
  </data>
  <data name="RenewSessionTokenHandlerNotSet" xml:space="preserve">
    <value>There is no handler registered for session token renew event.</value>
  </data>
  <data name="WrongIdentityRenewingToken" xml:space="preserve">
    <value>The identity of the security session renew message does not match the identity of the session token.</value>
  </data>
  <data name="InvalidRstRequestType" xml:space="preserve">
    <value>The RequestSecurityToken has an invalid or unspecified RequestType '{0}'.</value>
  </data>
  <data name="NoCloseTargetSpecified" xml:space="preserve">
    <value>The RequestSecurityToken must specify a CloseTarget.</value>
  </data>
  <data name="BadCloseTarget" xml:space="preserve">
    <value>The CloseTarget specified '{0}' does not identify the security token that signed the message.</value>
  </data>
  <data name="RenewSessionMissingSupportingToken" xml:space="preserve">
    <value>The renew security session message does not have the session token as a supporting token.</value>
  </data>
  <data name="NoRenewTargetSpecified" xml:space="preserve">
    <value>The RequestSecurityToken must specify a RenewTarget.</value>
  </data>
  <data name="BadRenewTarget" xml:space="preserve">
    <value>There is no endorsing session token that matches the specified RenewTarget '{0}'.</value>
  </data>
  <data name="BadEncryptionState" xml:space="preserve">
    <value>The EncryptedData or EncryptedKey is in an invalid state for this operation.</value>
  </data>
  <data name="NoSignaturePartsSpecified" xml:space="preserve">
    <value>No signature message parts were specified for messages with the '{0}' action.</value>
  </data>
  <data name="NoEncryptionPartsSpecified" xml:space="preserve">
    <value>No encryption message parts were specified for messages with the '{0}' action.</value>
  </data>
  <data name="SecureConversationBootstrapCannotUseSecureConversation" xml:space="preserve">
    <value>Cannot create security binding element based on configuration data. The secure conversation bootstrap requires another secure conversation which is not supported. </value>
  </data>
  <data name="SecurityProtocolFactoryShouldBeSetBeforeThisOperation" xml:space="preserve">
    <value>The security protocol factory must be set before this operation is performed.</value>
  </data>
  <data name="SecuritySessionProtocolFactoryShouldBeSetBeforeThisOperation" xml:space="preserve">
    <value>Security session protocol factory must be set before this operation is performed.</value>
  </data>
  <data name="SecureConversationSecurityTokenParametersRequireBootstrapBinding" xml:space="preserve">
    <value>Security channel or listener factory creation failed. Secure conversation security token parameters do not specify the bootstrap security binding element.</value>
  </data>
  <data name="PropertySettingErrorOnProtocolFactory" xml:space="preserve">
    <value>The required '{0}' property on the '{1}' security protocol factory is not set or has an invalid value.</value>
  </data>
  <data name="ProtocolFactoryCouldNotCreateProtocol" xml:space="preserve">
    <value>The protocol factory cannot create a protocol.</value>
  </data>
  <data name="IdentityCheckFailedForOutgoingMessage" xml:space="preserve">
    <value>The identity check failed for the outgoing message. The expected identity is '{0}' for the '{1}' target endpoint.</value>
  </data>
  <data name="IdentityCheckFailedForIncomingMessage" xml:space="preserve">
    <value>The identity check failed for the incoming message. The expected identity is '{0}' for the '{1}' target endpoint.</value>
  </data>
  <data name="DnsIdentityCheckFailedForIncomingMessageLackOfDnsClaim" xml:space="preserve">
    <value>The Identity check failed for the incoming message. The remote endpoint did not provide a domain name system (DNS) claim and therefore did not satisfied DNS identity '{0}'. This may be caused by lack of DNS or CN name in the remote endpoint X.509 certificate's distinguished name.</value>
  </data>
  <data name="DnsIdentityCheckFailedForOutgoingMessageLackOfDnsClaim" xml:space="preserve">
    <value>The Identity check failed for the outgoing message. The remote endpoint did not provide a domain name system (DNS) claim and therefore did not satisfied DNS identity '{0}'. This may be caused by lack of DNS or CN name in the remote endpoint X.509 certificate's distinguished name.</value>
  </data>
  <data name="DnsIdentityCheckFailedForIncomingMessage" xml:space="preserve">
    <value>Identity check failed for incoming message. The expected DNS identity of the remote endpoint was '{0}' but the remote endpoint provided DNS claim '{1}'. If this is a legitimate remote endpoint, you can fix the problem by explicitly specifying DNS identity '{1}' as the Identity property of EndpointAddress when creating channel proxy. </value>
  </data>
  <data name="DnsIdentityCheckFailedForOutgoingMessage" xml:space="preserve">
    <value>Identity check failed for outgoing message. The expected DNS identity of the remote endpoint was '{0}' but the remote endpoint provided DNS claim '{1}'. If this is a legitimate remote endpoint, you can fix the problem by explicitly specifying DNS identity '{1}' as the Identity property of EndpointAddress when creating channel proxy. </value>
  </data>
  <data name="SerializedTokenVersionUnsupported" xml:space="preserve">
    <value>The serialized token version {0} is unsupported.</value>
  </data>
  <data name="ClientCertificateNotProvidedOnServiceCredentials" xml:space="preserve">
    <value>The client certificate is not provided. Specify a client certificate in ServiceCredentials. </value>
  </data>
  <data name="ServiceCertificateNotProvidedOnServiceCredentials" xml:space="preserve">
    <value>The service certificate is not provided. Specify a service certificate in ServiceCredentials. </value>
  </data>
  <data name="ObjectIsReadOnly" xml:space="preserve">
    <value>Object is read-only.</value>
  </data>
  <data name="EmptyXmlElementError" xml:space="preserve">
    <value>Element {0} cannot be empty.</value>
  </data>
  <data name="UnexpectedXmlChildNode" xml:space="preserve">
    <value>XML child node {0} of type {1} is unexpected for element {2}.</value>
  </data>
  <data name="ContextAlreadyRegistered" xml:space="preserve">
    <value>The context-id={0} (generation-id={1}) is already registered with SecurityContextSecurityTokenAuthenticator.</value>
  </data>
  <data name="ContextAlreadyRegisteredNoKeyGeneration" xml:space="preserve">
    <value>The context-id={0} (no key generation-id) is already registered with SecurityContextSecurityTokenAuthenticator.</value>
  </data>
  <data name="ContextNotPresent" xml:space="preserve">
    <value>There is no SecurityContextSecurityToken with context-id={0} (generation-id={1}) registered with SecurityContextSecurityTokenAuthenticator.</value>
  </data>
  <data name="ContextNotPresentNoKeyGeneration" xml:space="preserve">
    <value>There is no SecurityContextSecurityToken with context-id={0} (no key generation-id) registered with SecurityContextSecurityTokenAuthenticator.</value>
  </data>
  <data name="InvalidSecurityContextCookie" xml:space="preserve">
    <value>The SecurityContextSecurityToken has an invalid Cookie. The following error occurred when processing the Cookie: '{0}'.</value>
  </data>
  <data name="SecurityContextNotRegistered" xml:space="preserve">
    <value>The SecurityContextSecurityToken with context-id={0} (key generation-id={1}) is not registered.</value>
  </data>
  <data name="SecurityContextExpired" xml:space="preserve">
    <value>The SecurityContextSecurityToken with context-id={0} (key generation-id={1}) has expired.</value>
  </data>
  <data name="SecurityContextExpiredNoKeyGeneration" xml:space="preserve">
    <value>The SecurityContextSecurityToken with context-id={0} (no key generation-id) has expired.</value>
  </data>
  <data name="NoSecurityContextIdentifier" xml:space="preserve">
    <value>The SecurityContextSecurityToken does not have a context-id.</value>
  </data>
  <data name="TokenProviderCannotGetTokensForTarget" xml:space="preserve">
    <value>The token provider cannot get tokens for target '{0}'.</value>
  </data>
  <data name="UnsupportedKeyDerivationAlgorithm" xml:space="preserve">
    <value>Key derivation algorithm '{0}' is not supported.</value>
  </data>
  <data name="EncryptionNotExpected" xml:space="preserve">
    <value>Encryption not expected for this message.</value>
  </data>
  <data name="SignatureNotExpected" xml:space="preserve">
    <value>A signature is not expected for this message.</value>
  </data>
  <data name="InvalidQName" xml:space="preserve">
    <value>The QName is invalid.</value>
  </data>
  <data name="UnknownICryptoType" xml:space="preserve">
    <value>The ICrypto implementation '{0}' is not supported.</value>
  </data>
  <data name="SuiteDoesNotAcceptAlgorithm" xml:space="preserve">
    <value>The algorithm '{0}' is not accepted for operation '{1}' by algorithm suite {2}.</value>
  </data>
  <data name="TokenDoesNotSupportKeyIdentifierClauseCreation" xml:space="preserve">
    <value>'{0}' does not support '{1}' creation.</value>
  </data>
  <data name="UnableToCreateICryptoFromTokenForSignatureVerification" xml:space="preserve">
    <value>Cannot create an ICrypto interface from the '{0}' token for signature verification.</value>
  </data>
  <data name="MessageSecurityVerificationFailed" xml:space="preserve">
    <value>Message security verification failed.</value>
  </data>
  <data name="TransportSecurityRequireToHeader" xml:space="preserve">
    <value>Transport secured messages should have the 'To' header specified.</value>
  </data>
  <data name="TransportSecuredMessageHasMoreThanOneToHeader" xml:space="preserve">
    <value>More than one 'To' header specified in a message secured by Transport Security.</value>
  </data>
  <data name="CannotFindCert" xml:space="preserve">
    <value>Cannot find the X.509 certificate using the following search criteria: StoreName '{0}', StoreLocation '{1}', FindType '{2}', FindValue '{3}'.</value>
  </data>
  <data name="CannotFindCertForTarget" xml:space="preserve">
    <value>Cannot find The X.509 certificate using the following search criteria: StoreName '{0}', StoreLocation '{1}', FindType '{2}', FindValue '{3}' for target '{4}'.</value>
  </data>
  <data name="FoundMultipleCerts" xml:space="preserve">
    <value>Found multiple X.509 certificates using the following search criteria: StoreName '{0}', StoreLocation '{1}', FindType '{2}', FindValue '{3}'. Provide a more specific find value.</value>
  </data>
  <data name="FoundMultipleCertsForTarget" xml:space="preserve">
    <value>Found multiple X.509 certificates using the following search criteria: StoreName '{0}', StoreLocation '{1}', FindType '{2}', FindValue '{3}' for target '{4}'. Provide a more specific find value.</value>
  </data>
  <data name="MissingKeyInfoInEncryptedKey" xml:space="preserve">
    <value>The KeyInfo clause is missing or empty in EncryptedKey.</value>
  </data>
  <data name="EncryptedKeyWasNotEncryptedWithTheRequiredEncryptingToken" xml:space="preserve">
    <value>The EncryptedKey clause was not wrapped with the required encryption token '{0}'.</value>
  </data>
  <data name="TimestampMustOccurFirstInSecurityHeaderLayout" xml:space="preserve">
    <value>The timestamp must occur first in this security header layout.</value>
  </data>
  <data name="TimestampMustOccurLastInSecurityHeaderLayout" xml:space="preserve">
    <value>The timestamp must occur last in this security header layout.</value>
  </data>
  <data name="AtMostOnePrimarySignatureInReceiveSecurityHeader" xml:space="preserve">
    <value>Only one primary signature is allowed in a security header.</value>
  </data>
  <data name="SigningTokenHasNoKeys" xml:space="preserve">
    <value>The signing token {0} has no keys. The security token is used in a context that requires it to perform cryptographic operations, but the token contains no cryptographic keys. Either the token type does not support cryptographic operations, or the particular token instance does not contain cryptographic keys. Check your configuration to ensure that cryptographically disabled token types (for example, UserNameSecurityToken) are not specified in a context that requires cryptographic operations (for example, an endorsing supporting token).</value>
  </data>
  <data name="SigningTokenHasNoKeysSupportingTheAlgorithmSuite" xml:space="preserve">
    <value>The signing token {0} has no key that supports the algorithm suite {1}.</value>
  </data>
  <data name="DelayedSecurityApplicationAlreadyCompleted" xml:space="preserve">
    <value>Delayed security application has already been completed.</value>
  </data>
  <data name="UnableToResolveKeyInfoClauseInDerivedKeyToken" xml:space="preserve">
    <value>Cannot resolve KeyInfo in derived key token for resolving source token: KeyInfoClause '{0}'.</value>
  </data>
  <data name="UnableToDeriveKeyFromKeyInfoClause" xml:space="preserve">
    <value>KeyInfo clause '{0}' resolved to token '{1}', which does not contain a Symmetric key that can be used for derivation.</value>
  </data>
  <data name="UnableToResolveKeyInfoForVerifyingSignature" xml:space="preserve">
    <value>Cannot resolve KeyInfo for verifying signature: KeyInfo '{0}', available tokens '{1}'.</value>
  </data>
  <data name="UnableToResolveKeyInfoForUnwrappingToken" xml:space="preserve">
    <value>Cannot resolve KeyInfo for unwrapping key: KeyInfo '{0}', available tokens '{1}'.</value>
  </data>
  <data name="EmptyBase64Attribute" xml:space="preserve">
    <value>An empty value was found for the required base-64 attribute name '{0}', namespace '{1}'.</value>
  </data>
  <data name="RequiredSecurityHeaderElementNotSigned" xml:space="preserve">
    <value>The security header element '{0}' with the '{1}' id must be signed.</value>
  </data>
  <data name="RequiredSecurityTokenNotSigned" xml:space="preserve">
    <value>The '{0}' security token with the '{1}' attachment mode must be signed.</value>
  </data>
  <data name="RequiredSecurityTokenNotEncrypted" xml:space="preserve">
    <value>The '{0}' security token with the '{1}' attachment mode must be encrypted.</value>
  </data>
  <data name="MessageBodyOperationNotValidInBodyState" xml:space="preserve">
    <value>Operation '{0}' is not valid in message body state '{1}'.</value>
  </data>
  <data name="EncryptedKeyWithReferenceListNotAllowed" xml:space="preserve">
    <value>EncryptedKey with ReferenceList is not allowed according to the current settings.</value>
  </data>
  <data name="UnableToFindTokenAuthenticator" xml:space="preserve">
    <value>Cannot find a token authenticator for the '{0}' token type. Tokens of that type cannot be accepted according to current security settings.</value>
  </data>
  <data name="NoPartsOfMessageMatchedPartsToSign" xml:space="preserve">
    <value>No signature was created because not part of the message matched the supplied message part specification.</value>
  </data>
  <data name="BasicTokenCannotBeWrittenWithoutEncryption" xml:space="preserve">
    <value>Supporting SecurityToken cannot be written without encryption.</value>
  </data>
  <data name="DuplicateIdInMessageToBeVerified" xml:space="preserve">
    <value>The '{0}' id occurred twice in the message that is supplied for verification.</value>
  </data>
  <data name="UnsupportedCanonicalizationAlgorithm" xml:space="preserve">
    <value>Canonicalization algorithm '{0}' is not supported.</value>
  </data>
  <data name="NoKeyInfoInEncryptedItemToFindDecryptingToken" xml:space="preserve">
    <value>The KeyInfo value was not found in the encrypted item to find the decrypting token.</value>
  </data>
  <data name="NoKeyInfoInSignatureToFindVerificationToken" xml:space="preserve">
    <value>No KeyInfo in signature to find verification token.</value>
  </data>
  <data name="SecurityHeaderIsEmpty" xml:space="preserve">
    <value>Security header is empty.</value>
  </data>
  <data name="AtMostOneReferenceListIsSupportedWithDefaultPolicyCheck" xml:space="preserve">
    <value>At most one reference list is supported with default policy check.</value>
  </data>
  <data name="AtMostOneSignatureIsSupportedWithDefaultPolicyCheck" xml:space="preserve">
    <value>At most one signature is supported with default policy check.</value>
  </data>
  <data name="MissingIdInEncryptedElement" xml:space="preserve">
    <value>Id is missing in encrypted item in security header.</value>
  </data>
  <data name="TokenManagerCannotCreateTokenReference" xml:space="preserve">
    <value>The supplied token manager cannot create a token reference.</value>
  </data>
  <data name="TimestampToSignHasNoId" xml:space="preserve">
    <value>The timestamp element added to security header to sign has no id.</value>
  </data>
  <data name="TimestampAlreadySetForSecurityHeader" xml:space="preserve">
    <value>A timestamp element has already been set for this security header.</value>
  </data>
  <data name="DuplicateTimestampInSecurityHeader" xml:space="preserve">
    <value>More than one Timestamp element was present in security header.</value>
  </data>
  <data name="MismatchInSecurityOperationToken" xml:space="preserve">
    <value>The incoming message was signed with a token which was different from what used to encrypt the body.  This was not expected.</value>
  </data>
  <data name="UnknownEncodingInBinarySecurityToken" xml:space="preserve">
    <value>Unrecognized encoding occurred while reading the binary security token.</value>
  </data>
  <data name="UnableToResolveReferenceUriForSignature" xml:space="preserve">
    <value>Cannot resolve reference URI '{0}' in signature to compute digest.</value>
  </data>
  <data name="NoTimestampAvailableInSecurityHeaderToDoReplayDetection" xml:space="preserve">
    <value>No timestamp is available in the security header to do replay detection.</value>
  </data>
  <data name="NoSignatureAvailableInSecurityHeaderToDoReplayDetection" xml:space="preserve">
    <value>No signature is available in the security header to provide the nonce for replay detection.</value>
  </data>
  <data name="CouldNotFindNamespaceForPrefix" xml:space="preserve">
    <value>There is no namespace binding for prefix '{0}' in scope.</value>
  </data>
  <data name="DerivedKeyCannotDeriveFromSecret" xml:space="preserve">
    <value>Derived Key Token cannot derive key from the secret.</value>
  </data>
  <data name="DerivedKeyPosAndGenBothSpecified" xml:space="preserve">
    <value>Both offset and generation cannot be specified for Derived Key Token.</value>
  </data>
  <data name="DerivedKeyPosAndGenNotSpecified" xml:space="preserve">
    <value>Either offset or generation must be specified for Derived Key Token.</value>
  </data>
  <data name="DerivedKeyTokenRequiresTokenReference" xml:space="preserve">
    <value>DerivedKeyToken requires a reference to a token.</value>
  </data>
  <data name="DerivedKeyLengthTooLong" xml:space="preserve">
    <value>DerivedKey length ({0}) exceeds the allowed settings ({1}).</value>
  </data>
  <data name="DerivedKeyLengthSpecifiedInImplicitDerivedKeyClauseTooLong" xml:space="preserve">
    <value>The Implicit derived key clause '{0}' specifies a derivation key length ({1}) which exceeds the allowed maximum length ({2}).</value>
  </data>
  <data name="DerivedKeyInvalidOffsetSpecified" xml:space="preserve">
    <value>The received derived key token has a invalid offset value specified. Value: {0}. The value should be greater than or equal to zero.</value>
  </data>
  <data name="DerivedKeyInvalidGenerationSpecified" xml:space="preserve">
    <value>The received derived key token has a invalid generation value specified. Value: {0}. The value should be greater than or equal to zero.</value>
  </data>
  <data name="ChildNodeTypeMissing" xml:space="preserve">
    <value>The XML element {0} does not have a child of type {1}.</value>
  </data>
  <data name="NoLicenseXml" xml:space="preserve">
    <value>RequestedSecurityToken not specified in RequestSecurityTokenResponse.</value>
  </data>
  <data name="UnsupportedBinaryEncoding" xml:space="preserve">
    <value>Binary encoding {0} is not supported.</value>
  </data>
  <data name="BadKeyEncryptionAlgorithm" xml:space="preserve">
    <value>Invalid key encryption algorithm {0}.</value>
  </data>
  <data name="UnableToCreateTokenReference" xml:space="preserve">
    <value>Unable to create token reference.</value>
  </data>
  <data name="NoBinaryNegoToSend" xml:space="preserve">
    <value>There is no binary negotiation to send to the other party.</value>
  </data>
  <data name="BadSecurityNegotiationContext" xml:space="preserve">
    <value>Security negotiation failure because an incorrect Context attribute specified in RequestSecurityToken/RequestSecurityTokenResponse from the other party.</value>
  </data>
  <data name="NoBinaryNegoToReceive" xml:space="preserve">
    <value>No binary negotiation was received from the other party.</value>
  </data>
  <data name="InvalidSspiNegotiation" xml:space="preserve">
    <value>The Security Support Provider Interface (SSPI) negotiation failed.</value>
  </data>
  <data name="IncorrectBinaryNegotiationValueType" xml:space="preserve">
    <value>Incoming binary negotiation has invalid ValueType {0}.</value>
  </data>
  <data name="MessageSecurityVersionOutOfRange" xml:space="preserve">
    <value>SecurityVersion must be WsSecurity10 or WsSecurity11.</value>
  </data>
  <data name="CreationTimeUtcIsAfterExpiryTime" xml:space="preserve">
    <value>Creation time must be before expiration time.</value>
  </data>
  <data name="NegotiationStateAlreadyPresent" xml:space="preserve">
    <value>Negotiation state already exists for context '{0}'.</value>
  </data>
  <data name="CannotFindNegotiationState" xml:space="preserve">
    <value>Cannot find the negotiation state for the context '{0}'.</value>
  </data>
  <data name="OutputNotExpected" xml:space="preserve">
    <value>Send cannot be called when the session does not expect output.</value>
  </data>
  <data name="CacheQuotaReached" xml:space="preserve">
    <value>The item cannot be added. The maximum cache size is ({0} items).</value>
  </data>
  <data name="UnexpectedBinarySecretType" xml:space="preserve">
    <value>Expected binary secret of type {0} but got secret of type {1}.</value>
  </data>
  <data name="UnsupportedPasswordType" xml:space="preserve">
    <value>The '{0}' username token has an unsupported password type.</value>
  </data>
  <data name="UnrecognizedIdentityPropertyType" xml:space="preserve">
    <value>Unrecognized identity property type: '{0}'.</value>
  </data>
  <data name="UnableToDemuxChannel" xml:space="preserve">
    <value>There was no channel that could accept the message with action '{0}'.</value>
  </data>
  <data name="EndpointNotFound" xml:space="preserve">
    <value>There was no endpoint listening at {0} that could accept the message. This is often caused by an incorrect address or SOAP action. See InnerException, if present, for more details.</value>
  </data>
  <data name="MaxReceivedMessageSizeMustBeInIntegerRange" xml:space="preserve">
    <value>This factory buffers messages, so the message sizes must be in the range of an integer value.</value>
  </data>
  <data name="InValidateIdPrefix" xml:space="preserve">
    <value>Expecting first char - c - to be in set [Char.IsLetter(c) &amp;&amp; c == '_', found '{0}'.</value>
  </data>
  <data name="InValidateId" xml:space="preserve">
    <value>Expecting all chars - c - of id to be in set [Char.IsLetter(c), Char.IsNumber(c), '.', '_', '-'], found '{0}'.</value>
  </data>
  <data name="HttpContentLengthIncorrect" xml:space="preserve">
    <value>The number of bytes available is inconsistent with the HTTP Content-Length header.  There may have been a network error or the client may be sending invalid requests.</value>
  </data>
  <data name="HttpAddressingNoneHeaderOnWire" xml:space="preserve">
    <value>The incoming message contains a SOAP header representing the WS-Addressing '{0}', yet the HTTP transport is configured with AddressingVersion.None.  As a result, the message is being dropped.  If this is not desired, then update your HTTP binding to support a different AddressingVersion.</value>
  </data>
  <data name="MessageXmlProtocolError" xml:space="preserve">
    <value>There is a problem with the XML that was received from the network. See inner exception for more details.</value>
  </data>
  <data name="TcpTransferError" xml:space="preserve">
    <value>A TCP error ({0}: {1}) occurred while transmitting data.</value>
  </data>
  <data name="TcpLocalConnectionAborted" xml:space="preserve">
    <value>The socket connection was aborted by your local machine. This could be caused by a channel Abort(), or a transmission error from another thread using this socket.</value>
  </data>
  <data name="TcpConnectionResetError" xml:space="preserve">
    <value>The socket connection was aborted. This could be caused by an error processing your message or a receive timeout being exceeded by the remote host, or an underlying network resource issue. Local socket timeout was '{0}'.</value>
  </data>
  <data name="TcpConnectionTimedOut" xml:space="preserve">
    <value>The socket transfer timed out after {0}. You have exceeded the timeout set on your binding. The time allotted to this operation may have been a portion of a longer timeout.</value>
  </data>
  <data name="HttpContentTypeHeaderRequired" xml:space="preserve">
    <value>An HTTP Content-Type header is required for SOAP messaging and none was found.</value>
  </data>
  <data name="ContentTypeMismatch" xml:space="preserve">
    <value>Content Type {0} was sent to a service expecting {1}.  The client and service bindings may be mismatched.</value>
  </data>
  <data name="ResponseContentTypeNotSupported" xml:space="preserve">
    <value>The content type {0} of the message is not supported by the encoder.</value>
  </data>
  <data name="FramingContentTypeMismatch" xml:space="preserve">
    <value>Content Type {0} was not supported by service {1}.  The client and service bindings may be mismatched.</value>
  </data>
  <data name="FramingFaultUnrecognized" xml:space="preserve">
    <value>Server faulted with code '{0}'.</value>
  </data>
  <data name="FramingContentTypeTooLongFault" xml:space="preserve">
    <value>Content type '{0}' is too long to be processed by the remote host. See the server logs for more details.</value>
  </data>
  <data name="FramingViaTooLongFault" xml:space="preserve">
    <value>Via '{0}' is too long to be processed by the remote host. See the server logs for more details.</value>
  </data>
  <data name="FramingModeNotSupportedFault" xml:space="preserve">
    <value>The .Net Framing mode being used is not supported by '{0}'. See the server logs for more details.</value>
  </data>
  <data name="FramingVersionNotSupportedFault" xml:space="preserve">
    <value>The .Net Framing version being used is not supported by '{0}'. See the server logs for more details.</value>
  </data>
  <data name="FramingUpgradeInvalid" xml:space="preserve">
    <value>The requested upgrade is not supported by '{0}'. This could be due to mismatched bindings (for example security enabled on the client and not on the server).</value>
  </data>
  <data name="ServerTooBusy" xml:space="preserve">
    <value>Server '{0}' is too busy to process this request. Try again later.</value>
  </data>
  <data name="UpgradeProtocolNotSupported" xml:space="preserve">
    <value>Protocol Type {0} was sent to a service that does not support that type of upgrade.</value>
  </data>
  <data name="UpgradeRequestToNonupgradableService" xml:space="preserve">
    <value>.Net Framing upgrade request for {0} was sent to a service that is not setup to receive upgrades.</value>
  </data>
  <data name="PreambleAckIncorrect" xml:space="preserve">
    <value>You have tried to create a channel to a service that does not support .Net Framing. </value>
  </data>
  <data name="PreambleAckIncorrectMaybeHttp" xml:space="preserve">
    <value>You have tried to create a channel to a service that does not support .Net Framing. It is possible that you are encountering an HTTP endpoint.</value>
  </data>
  <data name="InvalidTokenProvided" xml:space="preserve">
    <value>The token provider of type '{0}' did not return a token of type '{1}'. Check the credential configuration.</value>
  </data>
  <data name="UriGeneratorSchemeMustNotBeEmpty" xml:space="preserve">
    <value>The scheme parameter must not be empty.</value>
  </data>
  <data name="UnsupportedSslProtectionLevel" xml:space="preserve">
    <value>The protection level '{0}' was specified, yet SSL transport security only supports EncryptAndSign.</value>
  </data>
  <data name="TimeoutServiceChannelConcurrentOpen1" xml:space="preserve">
    <value>Opening the channel timed out after {0}. The time allotted to this operation may have been a portion of a longer timeout.</value>
  </data>
  <data name="TimeoutServiceChannelConcurrentOpen2" xml:space="preserve">
    <value>Opening the {0} channel timed out after {1}. The time allotted to this operation may have been a portion of a longer timeout.</value>
  </data>
  <data name="TimeSpanCannotBeLessThanTimeSpanZero" xml:space="preserve">
    <value>TimeSpan cannot be less than TimeSpan.Zero.</value>
  </data>
  <data name="ValueMustBeGreaterThanZero" xml:space="preserve">
    <value>The value of this argument must be greater than 0.</value>
  </data>
  <data name="ValueMustBeInRange" xml:space="preserve">
    <value>The value of this argument must fall within the range {0} to {1}.</value>
  </data>
  <data name="OffsetExceedsBufferBound" xml:space="preserve">
    <value>The specified offset exceeds the upper bound of the buffer ({0}).</value>
  </data>
  <data name="OffsetExceedsBufferSize" xml:space="preserve">
    <value>The specified offset exceeds the buffer size ({0} bytes).</value>
  </data>
  <data name="SizeExceedsRemainingBufferSpace" xml:space="preserve">
    <value>The specified size exceeds the remaining buffer space ({0} bytes).</value>
  </data>
  <data name="SpaceNeededExceedsMessageFrameOffset" xml:space="preserve">
    <value>The space needed for encoding ({0} bytes) exceeds the message frame offset.</value>
  </data>
  <data name="FaultConverterDidNotCreateFaultMessage" xml:space="preserve">
    <value>{0} returned true from OnTryCreateFaultMessage, but did not return a fault message.</value>
  </data>
  <data name="FaultConverterCreatedFaultMessage" xml:space="preserve">
    <value>{0} returned false from OnTryCreateFaultMessage, but returned a non-null fault message.</value>
  </data>
  <data name="FaultConverterDidNotCreateException" xml:space="preserve">
    <value>{0} returned true from OnTryCreateException, but did not return an Exception.</value>
  </data>
  <data name="FaultConverterCreatedException" xml:space="preserve">
    <value>{0} returned false from OnTryCreateException, but returned a non-null Exception (See InnerException for details).</value>
  </data>
  <data name="UnsupportedUpgradeAcceptor" xml:space="preserve">
    <value>The StreamUpgradeAcceptor specified ({0}) is not supported by this IStreamUpgradeChannelBindingProvider  implementation.  The most likely cause of this is passing a StreamUpgradeAcceptor that was not created by the StreamUpgradeProvider associated with this IStreamUpgradeChannelBindingProvider  implementation.</value>
  </data>
  <data name="StreamUpgradeUnsupportedChannelBindingKind" xml:space="preserve">
    <value>The StreamUpgradeProvider {0} does not support the specified ChannelBindingKind ({1}). </value>
  </data>
  <data name="ExtendedProtectionNotSupported" xml:space="preserve">
    <value>Extended protection is not supported on this platform.  Please install the appropriate patch or change the ExtendedProtectionPolicy on the Binding or BindingElement to a value with a PolicyEnforcement value of "Never" or "WhenSupported".</value>
  </data>
  <data name="SecurityTokenProviderIncludeWindowsGroupsInconsistent" xml:space="preserve">
    <value>When authentication schemes 'Basic' and also '{0}' are enabled, the value of IncludeWindowsGroups for Windows ('{1}') and UserName authentication ('{2}') must match. Please consider using the same value in both places.</value>
  </data>
  <data name="TransportDoesNotSupportCompression" xml:space="preserve">
    <value>The transport configured on this binding does not appear to support the CompressionFormat specified ({0}) on the message encoder.  To resolve this issue, set the CompressionFormat on the {1} to '{2}' or use a different transport.</value>
  </data>
  <data name="UnsupportedSecuritySetting" xml:space="preserve">
    <value>The value '{1}' is not supported in this context for the binding security property '{0}'.</value>
  </data>
  <data name="TimeoutOnOperation" xml:space="preserve">
    <value>The operation did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.</value>
  </data>
  <data name="SFxActionDemuxerDuplicate" xml:space="preserve">
    <value>The operations {0} and {1} have the same action ({2}).  Every operation must have a unique action value.</value>
  </data>
  <data name="SFxActionMismatch" xml:space="preserve">
    <value>Cannot create a typed message due to action mismatch, expecting {0} encountered {1}</value>
  </data>
  <data name="SFxAnonymousTypeNotSupported" xml:space="preserve">
    <value>Part {1} in message {0} cannot be exported with RPC or encoded since its type is anonymous.</value>
  </data>
  <data name="SFXBindingNameCannotBeNullOrEmpty" xml:space="preserve">
    <value>Binding name cannot be null or empty.</value>
  </data>
  <data name="SFXUnvalidNamespaceValue" xml:space="preserve">
    <value>Value '{0}' provided for {1} property is an invalid URI.</value>
  </data>
  <data name="SFXUnvalidNamespaceParam" xml:space="preserve">
    <value>Parameter value '{0}' is an invalid URI.</value>
  </data>
  <data name="SFXHeaderNameCannotBeNullOrEmpty" xml:space="preserve">
    <value>Header name cannot be null or empty.</value>
  </data>
  <data name="SFxEndpointNoMatchingScheme" xml:space="preserve">
    <value>Could not find a base address that matches scheme {0} for the endpoint with binding {1}. Registered base address schemes are [{2}].</value>
  </data>
  <data name="SFxBadByReferenceParameterMetadata" xml:space="preserve">
    <value>Method '{0}' in class '{1}' has bad parameter metadata: a pass-by-reference parameter is marked with the 'in' but not the 'out' parameter mode.</value>
  </data>
  <data name="SFxBadByValueParameterMetadata" xml:space="preserve">
    <value>Method '{0}' in class '{1}' has bad parameter metadata: a pass-by-value parameter is marked with the 'out' parameter mode.</value>
  </data>
  <data name="SFxBadMetadataMustBePolicy" xml:space="preserve">
    <value>When calling the CreateFromPolicy method, the policy argument must be an XmlElement instance with LocalName '{1}' and NamespaceUri '{0}'. This XmlElement has LocalName '{3}' and NamespaceUri '{2}'. </value>
  </data>
  <data name="SFxBadMetadataLocationUri" xml:space="preserve">
    <value>The URI supplied to ServiceMetadataBehavior via the ExternalMetadataLocation property or the externalMetadataLocation attribute in the serviceMetadata section in config must be a relative URI or an absolute URI with an http or https scheme. '{0}' was specified, which is a absolute URI with {1} scheme.</value>
  </data>
  <data name="SFxBadMetadataLocationNoAppropriateBaseAddress" xml:space="preserve">
    <value>The URL supplied to ServiceMetadataBehavior via the ExternalMetadataLocation property or the externalMetadataLocation attribute in the serviceMetadata section in config was a relative URL and there is no base address with which to resolve it. '{0}' was specified.</value>
  </data>
  <data name="SFxBindingMustContainTransport2" xml:space="preserve">
    <value>The binding (Name={0}, Namespace={1}) does not contain a TransportBindingElement.</value>
  </data>
  <data name="SFxBodyCannotBeNull" xml:space="preserve">
    <value>Body object cannot be null in message {0}</value>
  </data>
  <data name="SFxBodyObjectTypeCannotBeInherited" xml:space="preserve">
    <value>Type {0} cannot inherit from any class other than object to be used as body object in RPC style.</value>
  </data>
  <data name="SFxBodyObjectTypeCannotBeInterface" xml:space="preserve">
    <value>Type {0} implements interface {1} which is not supported for body object in RPC style.</value>
  </data>
  <data name="SFxCallbackRequestReplyInOrder1" xml:space="preserve">
    <value>This operation would deadlock because the reply cannot be received until the current Message completes processing. If you want to allow out-of-order message processing, specify ConcurrencyMode of Reentrant or Multiple on {0}.</value>
  </data>
  <data name="SFxCannotActivateCallbackInstace" xml:space="preserve">
    <value>The dispatch instance for duplex callbacks cannot be activated - you must provide an instance.</value>
  </data>
  <data name="SFxCannotCallAddBaseAddress" xml:space="preserve">
    <value>ServiceHostBase's AddBaseAddress method cannot be called after the InitializeDescription method has completed.</value>
  </data>
  <data name="SFxCannotCallAutoOpenWhenExplicitOpenCalled" xml:space="preserve">
    <value>Cannot make a call on this channel because a call to Open() is in progress.</value>
  </data>
  <data name="SFxCannotRequireBothSessionAndDatagram3" xml:space="preserve">
    <value>There are two contracts listening on the same binding ({2}) and address with conflicting settings.  Specifically, the contract '{0}' specifies SessionMode.NotAllowed while the contract '{1}' specifies SessionMode.Required.  You should either change one of the SessionMode values or specify a different address (or ListenUri) for each endpoint.</value>
  </data>
  <data name="SFxCannotSetExtensionsByIndex" xml:space="preserve">
    <value>This collection does not support setting extensions by index.  Please consider using the InsertItem or RemoveItem methods.</value>
  </data>
  <data name="SFxChannelDispatcherDifferentHost0" xml:space="preserve">
    <value>This ChannelDispatcher is not currently attached to the provided ServiceHost.</value>
  </data>
  <data name="SFxChannelDispatcherMultipleHost0" xml:space="preserve">
    <value>Cannot add a ChannelDispatcher to more than one ServiceHost.</value>
  </data>
  <data name="SFxChannelFactoryTypeMustBeInterface" xml:space="preserve">
    <value>The type argument passed to the generic ChannelFactory class must be an interface type.</value>
  </data>
  <data name="SFxChannelTerminated0" xml:space="preserve">
    <value>An operation marked as IsTerminating has already been invoked on this channel, causing the channel's connection to terminate.  No more operations may be invoked on this channel.  Please re-create the channel to continue communication.</value>
  </data>
  <data name="SFxCollectionDoesNotSupportSet0" xml:space="preserve">
    <value>This collection does not support setting items by index.</value>
  </data>
  <data name="SFxConflictingGlobalElement" xml:space="preserve">
    <value>Top level XML element with name {0} in namespace {1} cannot reference {2} type because it already references a different type ({3}). Use a different operation name or MessageBodyMemberAttribute to specify a different name for the Message or Message parts.</value>
  </data>
  <data name="SFxConflictingGlobalType" xml:space="preserve">
    <value>Duplicate top level XML Schema type with name {0} in namespace {1}.</value>
  </data>
  <data name="SFxContractDescriptionNameCannotBeEmpty" xml:space="preserve">
    <value>ContractDescription's Name must be a non-empty string.</value>
  </data>
  <data name="SFxContractHasZeroOperations" xml:space="preserve">
    <value>ContractDescription '{0}' has zero operations; a contract must have at least one operation.</value>
  </data>
  <data name="SFxContractHasZeroInitiatingOperations" xml:space="preserve">
    <value>ContractDescription '{0}' has zero IsInitiating=true operations; a contract must have at least one IsInitiating=true operation.</value>
  </data>
  <data name="SFxContractInheritanceRequiresInterfaces" xml:space="preserve">
    <value>The service class of type {0} both defines a ServiceContract and inherits a ServiceContract from type {1}. Contract inheritance can only be used among interface types.  If a class is marked with ServiceContractAttribute, it must be the only type in the hierarchy with ServiceContractAttribute.  Consider moving the ServiceContractAttribute on type {1} to a separate interface that type {1} implements.</value>
  </data>
  <data name="SFxContractInheritanceRequiresInterfaces2" xml:space="preserve">
    <value>The service class of type {0} both defines a ServiceContract and inherits a ServiceContract from type {1}. Contract inheritance can only be used among interface types.  If a class is marked with ServiceContractAttribute, then another service class cannot derive from it.</value>
  </data>
  <data name="SFxCustomBindingNeedsTransport1" xml:space="preserve">
    <value>The CustomBinding on the ServiceEndpoint with contract '{0}' lacks a TransportBindingElement.  Every binding must have at least one binding element that derives from TransportBindingElement.</value>
  </data>
  <data name="SFxCustomBindingWithoutTransport" xml:space="preserve">
    <value>The Scheme cannot be computed for this binding because this CustomBinding lacks a TransportBindingElement.  Every binding must have at least one binding element that derives from TransportBindingElement.</value>
  </data>
  <data name="SFxDeserializationFailed1" xml:space="preserve">
    <value>The formatter threw an exception while trying to deserialize the message: {0}</value>
  </data>
  <data name="SFxDisallowedAttributeCombination" xml:space="preserve">
    <value>The type or member named '{0}' could not be loaded because it has two incompatible attributes: '{1}' and '{2}'. To fix the problem, remove one of the attributes from the type or member.</value>
  </data>
  <data name="SFxDocExt_NoMetadataSection1" xml:space="preserve">
    <value>This is a Windows&amp;#169; Communication Foundation service.&lt;BR/&gt;&lt;BR/&gt;&lt;B&gt;Metadata publishing for this service is currently disabled.&lt;/B&gt;&lt;BR/&gt;&lt;BR/&gt;If you have access to the service, you can enable metadata publishing by completing the following steps to modify your web or application configuration file:&lt;BR/&gt;&lt;BR/&gt;1. Create the following service behavior configuration, or add the &amp;lt;serviceMetadata&amp;gt; element to an existing service behavior configuration:</value>
  </data>
  <data name="SFxDocExt_NoMetadataSection2" xml:space="preserve">
    <value>2. Add the behavior configuration to the service:</value>
  </data>
  <data name="SFxDocExt_NoMetadataSection3" xml:space="preserve">
    <value>Note: the service name must match the configuration name for the service implementation.&lt;BR/&gt;&lt;BR/&gt;3. Add the following endpoint to your service configuration:</value>
  </data>
  <data name="SFxDocExt_NoMetadataSection4" xml:space="preserve">
    <value>Note: your service must have an http base address to add this endpoint.&lt;BR/&gt;&lt;BR/&gt;The following is an example service configuration file with metadata publishing enabled:</value>
  </data>
  <data name="SFxDocExt_NoMetadataSection5" xml:space="preserve">
    <value>For more information on publishing metadata please see the following documentation: &lt;a href="http://go.microsoft.com/fwlink/?LinkId=65455"&gt;http://go.microsoft.com/fwlink/?LinkId=65455&lt;/a&gt;.</value>
  </data>
  <data name="SFxDocExt_NoMetadataConfigComment1" xml:space="preserve">
    <value>Note: the service name must match the configuration name for the service implementation.</value>
  </data>
  <data name="SFxDocExt_NoMetadataConfigComment2" xml:space="preserve">
    <value>Add the following endpoint. </value>
  </data>
  <data name="SFxDocExt_NoMetadataConfigComment3" xml:space="preserve">
    <value>Note: your service must have an http base address to add this endpoint.</value>
  </data>
  <data name="SFxDocExt_NoMetadataConfigComment4" xml:space="preserve">
    <value>Add the following element to your service behavior configuration.</value>
  </data>
  <data name="SFxDocExt_MainPageTitleNoServiceName" xml:space="preserve">
    <value>Service</value>
  </data>
  <data name="SFxDocExt_MainPageTitle" xml:space="preserve">
    <value>{0} Service</value>
  </data>
  <data name="SFxDocExt_MainPageIntro1a" xml:space="preserve">
    <value>You have created a service.&lt;P class='intro'&gt;To test this service, you will need to create a client and use it to call the service. You can do this using the svcutil.exe tool from the command line with the following syntax:&lt;/P&gt; </value>
  </data>
  <data name="SFxDocExt_MainPageIntro1b" xml:space="preserve">
    <value>You have created a service.&lt;P class='intro'&gt;To test this service, you will need to create a client and use it to call the service; however, metadata publishing via ?WSDL is currently disabled. This can be enabled via the service's configuration file. &lt;/P&gt;</value>
  </data>
  <data name="SFxDocExt_MainPageIntro2" xml:space="preserve">
    <value>This will generate a configuration file and a code file that contains the client class. Add the two files to your client application and use the generated client class to call the Service. For example:&lt;BR/&gt;</value>
  </data>
  <data name="SFxDocExt_MainPageComment" xml:space="preserve">
    <value>Use the 'client' variable to call operations on the service.</value>
  </data>
  <data name="SFxDocExt_MainPageComment2" xml:space="preserve">
    <value>Always close the client.</value>
  </data>
  <data name="SFxDocExt_Error" xml:space="preserve">
    <value>The service encountered an error.</value>
  </data>
  <data name="SFxDocEncodedNotSupported" xml:space="preserve">
    <value>Operation '{0}' could not be loaded as it uses an unsupported combination of Use and Style settings: Document with Encoded. To fix the problem, change the Use setting to Literal or change the Style setting to Rpc.</value>
  </data>
  <data name="SFxDuplicateMessageParts" xml:space="preserve">
    <value>Message part {0} in namespace {1} appears more than once in Message.</value>
  </data>
  <data name="SFxDuplicateInitiatingActionAtSameVia" xml:space="preserve">
    <value>This service has multiple endpoints listening at '{0}' which share the same initiating action '{1}'.  As a result, messages with this action would be dropped since the dispatcher would not be able to determine the correct endpoint for handling the message.  Please consider hosting these Endpoints at separate ListenUris.</value>
  </data>
  <data name="SFxEndpointDispatcherMultipleChannelDispatcher0" xml:space="preserve">
    <value>Cannot add EndpointDispatcher to more than one ChannelDispatcher.</value>
  </data>
  <data name="SFxEndpointDispatcherDifferentChannelDispatcher0" xml:space="preserve">
    <value>This EndpointDispatcher is not currently attached to the provided ChannelDispatcher.</value>
  </data>
  <data name="SFxErrorCreatingMtomReader" xml:space="preserve">
    <value>Error creating a reader for the MTOM message</value>
  </data>
  <data name="SFxErrorDeserializingRequestBody" xml:space="preserve">
    <value>Error in deserializing body of request message for operation '{0}'.</value>
  </data>
  <data name="SFxErrorDeserializingRequestBodyMore" xml:space="preserve">
    <value>Error in deserializing body of request message for operation '{0}'. {1}</value>
  </data>
  <data name="SFxErrorDeserializingReplyBody" xml:space="preserve">
    <value>Error in deserializing body of reply message for operation '{0}'.</value>
  </data>
  <data name="SFxErrorDeserializingReplyBodyMore" xml:space="preserve">
    <value>Error in deserializing body of reply message for operation '{0}'. {1}</value>
  </data>
  <data name="SFxErrorSerializingBody" xml:space="preserve">
    <value>There was an error in serializing body of message {0}: '{1}'.  Please see InnerException for more details.</value>
  </data>
  <data name="SFxErrorDeserializingHeader" xml:space="preserve">
    <value>There was an error in deserializing one of the headers in message {0}.  Please see InnerException for more details.</value>
  </data>
  <data name="SFxErrorSerializingHeader" xml:space="preserve">
    <value>There was an error in serializing one of the headers in message {0}: '{1}'.  Please see InnerException for more details.</value>
  </data>
  <data name="SFxErrorDeserializingFault" xml:space="preserve">
    <value>Server returned an invalid SOAP Fault.  Please see InnerException for more details.</value>
  </data>
  <data name="SFxErrorReflectingOnType2" xml:space="preserve">
    <value>An error occurred while loading attribute '{0}' on type '{1}'.  Please see InnerException for more details.</value>
  </data>
  <data name="SFxErrorReflectingOnMethod3" xml:space="preserve">
    <value>An error occurred while loading attribute '{0}' on method '{1}' in type '{2}'.  Please see InnerException for more details.</value>
  </data>
  <data name="SFxErrorReflectingOnParameter4" xml:space="preserve">
    <value>An error occurred while loading attribute '{0}' on parameter {1} of method '{2}' in type '{3}'.  Please see InnerException for more details.</value>
  </data>
  <data name="SFxErrorReflectionOnUnknown1" xml:space="preserve">
    <value>An error occurred while loading attribute '{0}'.  Please see InnerException for more details.</value>
  </data>
  <data name="SFxExceptionDetailEndOfInner" xml:space="preserve">
    <value>--- End of inner ExceptionDetail stack trace ---</value>
  </data>
  <data name="SFxExceptionDetailFormat" xml:space="preserve">
    <value>An ExceptionDetail, likely created by IncludeExceptionDetailInFaults=true, whose value is:</value>
  </data>
  <data name="SFxExportMustHaveType" xml:space="preserve">
    <value>The specified ContractDescription could not be exported to WSDL because the Type property of the MessagePartDescription with name '{1}' in the OperationDescription with name '{0}' is not set.  The Type property must be set in order to create WSDL.</value>
  </data>
  <data name="SFxFaultContractDuplicateDetailType" xml:space="preserve">
    <value>In operation {0}, more than one fault is declared with detail type {1}</value>
  </data>
  <data name="SFxFaultContractDuplicateElement" xml:space="preserve">
    <value>In operation {0}, more than one fault is declared with element name {1} in namespace {2}</value>
  </data>
  <data name="SFxFaultExceptionToString3" xml:space="preserve">
    <value>{0}: {1} (Fault Detail is equal to {2}).</value>
  </data>
  <data name="SFxFaultReason" xml:space="preserve">
    <value>The creator of this fault did not specify a Reason.</value>
  </data>
  <data name="SFxFaultTypeAnonymous" xml:space="preserve">
    <value>In operation {0}, the schema type corresponding to the fault detail type {1} is anonymous. Please set Fault name explicitly to export anonymous types.</value>
  </data>
  <data name="SFxHeaderNameMismatchInMessageContract" xml:space="preserve">
    <value>Header name mismatch in member {1} of type {0}. The header name found in the description is {2}. The element name deduced by the formatter is {3}. This mismatch can happen if the ElementName specified in XmlElementAttribute or XmlArrayAttribute does not match the name specified in the MessageHeaderAttribute or MessageHeaderArrayAttribute or the member name.</value>
  </data>
  <data name="SFxHeaderNameMismatchInOperation" xml:space="preserve">
    <value>Header name mismatch in operation {0} from contract {1}:{2}. The header name found in the description is {3}. The element name deduced by the formatter is {4}. This mismatch can happen if the ElementName specified in XmlElementAttribute or XmlArrayAttribute does not match the name specified in the MessageHeaderAttribute or MessageHeaderArrayAttribute or the member name.</value>
  </data>
  <data name="SFxHeaderNamespaceMismatchInMessageContract" xml:space="preserve">
    <value>Header namespace mismatch in member {1} of type {0}. The header namespace found in the description is {2}. The element namespace deduced by the formatter is {3}. This mismatch can happen if the Namespace specified in XmlElementAttribute or XmlArrayAttribute does not match the namespace specified in the MessageHeaderAttribute or MessageHeaderArrayAttribute or the contract namespace.</value>
  </data>
  <data name="SFxHeaderNamespaceMismatchInOperation" xml:space="preserve">
    <value>Header namespace mismatch in operation {0} from contract {1}:{2}. The header namespace found in the description is {3}. The element namespace deduced by the formatter is {4}. This mismatch can happen if the Namespace specified in XmlElementAttribute or XmlArrayAttribute does not match the namespace specified in the MessageHeaderAttribute or MessageHeaderArrayAttribute or the contract namespace.</value>
  </data>
  <data name="SFxHeaderNotUnderstood" xml:space="preserve">
    <value>The header '{0}' from the namespace '{1}' was not understood by the recipient of this message, causing the message to not be processed.  This error typically indicates that the sender of this message has enabled a communication protocol that the receiver cannot process.  Please ensure that the configuration of the client's binding is consistent with the service's binding. </value>
  </data>
  <data name="SFxHeadersAreNotSupportedInEncoded" xml:space="preserve">
    <value>Message {0} must not have headers to be used in RPC encoded style.</value>
  </data>
  <data name="SFxImmutableServiceHostBehavior0" xml:space="preserve">
    <value>This value cannot be changed after the ServiceHost has opened.</value>
  </data>
  <data name="SFxImmutableChannelFactoryBehavior0" xml:space="preserve">
    <value>This value cannot be changed after the ChannelFactory has opened.</value>
  </data>
  <data name="SFxImmutableThrottle1" xml:space="preserve">
    <value>{0} cannot be changed after the ServiceHost has opened.</value>
  </data>
  <data name="SFxInputParametersToServiceInvalid" xml:space="preserve">
    <value>Service implementation object invoked with wrong number of input parameters, operation expects {0} parameters but was called with {1} parameters.</value>
  </data>
  <data name="SFxInputParametersToServiceNull" xml:space="preserve">
    <value>Service implementation object invoked with null input parameters, but operation expects {0} parameters.</value>
  </data>
  <data name="SFxInstanceNotInitialized" xml:space="preserve">
    <value>The InstanceContext has no provider for creating Service implementation objects.</value>
  </data>
  <data name="SFxInternalServerError" xml:space="preserve">
    <value>The server was unable to process the request due to an internal error.  For more information about the error, either turn on IncludeExceptionDetailInFaults (either from ServiceBehaviorAttribute or from the &lt;serviceDebug&gt; configuration behavior) on the server in order to send the exception information back to the client, or turn on tracing as per the Microsoft .NET Framework SDK documentation and inspect the server trace logs.</value>
  </data>
  <data name="SFxInternalCallbackError" xml:space="preserve">
    <value>The client was unable to process the callback request due to an internal error.  For more information about the error, either turn on IncludeExceptionDetailInFaults (either from CallbackBehaviorAttribute or from the &lt;clientDebug&gt; configuration behavior) on the client in order to send the exception information back to the server, or turn on tracing as per the Microsoft .NET Framework SDK documentation and inspect the client trace logs.</value>
  </data>
  <data name="SFxInvalidCallbackContractType" xml:space="preserve">
    <value>The CallbackContract {0} is invalid because it is not an interface type.</value>
  </data>
  <data name="SFxInvalidChannelToOperationContext" xml:space="preserve">
    <value>Invalid IContextChannel passed to OperationContext. Must be either a server dispatching channel or a client proxy channel.</value>
  </data>
  <data name="SFxInvalidMessageBody" xml:space="preserve">
    <value>OperationFormatter encountered an invalid Message body. Expected to find node type 'Element' with name '{0}' and namespace '{1}'. Found node type '{2}' with name '{3}' and namespace '{4}'</value>
  </data>
  <data name="SFxInvalidMessageBodyEmptyMessage" xml:space="preserve">
    <value>The OperationFormatter could not deserialize any information from the Message because the Message is empty (IsEmpty = true).</value>
  </data>
  <data name="SFxInvalidMessageBodyErrorSerializingParameter" xml:space="preserve">
    <value>There was an error while trying to serialize parameter {0}:{1}. The InnerException message was '{2}'.  Please see InnerException for more details.</value>
  </data>
  <data name="SFxInvalidMessageBodyErrorDeserializingParameter" xml:space="preserve">
    <value>There was an error while trying to deserialize parameter {0}:{1}.  Please see InnerException for more details.</value>
  </data>
  <data name="SFxInvalidMessageBodyErrorDeserializingParameterMore" xml:space="preserve">
    <value>There was an error while trying to deserialize parameter {0}:{1}. The InnerException message was '{2}'.  Please see InnerException for more details.</value>
  </data>
  <data name="SFxInvalidMessageContractSignature" xml:space="preserve">
    <value>The operation {0} either has a parameter or a return type that is attributed with MessageContractAttribute.  In order to represent the request message using a Message Contract, the operation must have a single parameter attributed with MessageContractAttribute.  In order to represent the response message using a Message Contract, the operation's return value must be a type that is attributed with MessageContractAttribute and the operation may not have any out or ref parameters.</value>
  </data>
  <data name="SFxInvalidMessageHeaderArrayType" xml:space="preserve">
    <value>MessageHeaderArrayAttribute found on member {0} is not a single dimensional array.</value>
  </data>
  <data name="SFxInvalidRequestAction" xml:space="preserve">
    <value>Outgoing request message for operation '{0}' specified Action='{1}', but contract for that operation specifies Action='{2}'.  The Action specified in the Message must match the Action in the contract, or the operation contract must specify Action='*'.</value>
  </data>
  <data name="SFxInvalidReplyAction" xml:space="preserve">
    <value>Outgoing reply message for operation '{0}' specified Action='{1}', but contract for that operation specifies ReplyAction='{2}'.    The Action specified in the Message must match the ReplyAction in the contract, or the operation contract must specify ReplyAction='*'.</value>
  </data>
  <data name="SFxInvalidStreamInTypedMessage" xml:space="preserve">
    <value>In order to use Streams with the MessageContract programming model, the type {0} must have a single member with MessageBodyMember attribute and the member type must be Stream.</value>
  </data>
  <data name="SFxInvalidStreamInRequest" xml:space="preserve">
    <value>For request in operation {0} to be a stream the operation must have a single parameter whose type is Stream.</value>
  </data>
  <data name="SFxInvalidStreamInResponse" xml:space="preserve">
    <value>For response in operation {0} to be a stream the operation must have a single out parameter or return value whose type is Stream.</value>
  </data>
  <data name="SFxInvalidStreamOffsetLength" xml:space="preserve">
    <value>Buffer size must be at least {0} bytes.</value>
  </data>
  <data name="SFxInvalidUseOfPrimitiveOperationFormatter" xml:space="preserve">
    <value>The PrimitiveOperationFormatter was given a parameter or return type which it does not support.</value>
  </data>
  <data name="SFxInvalidSoapAttribute" xml:space="preserve">
    <value>XmlSerializer attribute {0} is not valid in {1}. Only SoapElement attribute is supported.</value>
  </data>
  <data name="SFxInvalidXmlAttributeInBare" xml:space="preserve">
    <value>XmlSerializer attribute {0} is not valid in {1}. Only XmlElement, XmlArray, XmlArrayItem and XmlAnyElement attributes are supported in MessageContract when IsWrapped is false.</value>
  </data>
  <data name="SFxInvalidXmlAttributeInWrapped" xml:space="preserve">
    <value>XmlSerializer attribute {0} is not valid in {1}. Only XmlElement, XmlArray, XmlArrayItem, XmlAnyAttribute and XmlAnyElement attributes are supported when IsWrapped is true.</value>
  </data>
  <data name="SFxKnownTypeAttributeInvalid1" xml:space="preserve">
    <value>{0} must contain either a single ServiceKnownTypeAttribute that refers to a method or a set of ServiceKnownTypeAttributes, each specifying a valid type</value>
  </data>
  <data name="SFxKnownTypeAttributeReturnType3" xml:space="preserve">
    <value>The return type of method {1} in type {2} must be IEnumerable&lt;Type&gt; to be used by ServiceKnownTypeAttribute in {0}</value>
  </data>
  <data name="SFxKnownTypeAttributeUnknownMethod3" xml:space="preserve">
    <value>ServiceKnownTypeAttribute in {0} refers to a method {1} that does not exist in type {2}</value>
  </data>
  <data name="SFxKnownTypeNull" xml:space="preserve">
    <value>KnownType cannot be null in operation {0}</value>
  </data>
  <data name="SFxMessageContractBaseTypeNotValid" xml:space="preserve">
    <value>The type {1} defines a MessageContract but also derives from a type {0} that does not define a MessageContract.  All of the objects in the inheritance hierarchy of {1} must defines a MessageContract.</value>
  </data>
  <data name="SFxMessageContractRequiresDefaultConstructor" xml:space="preserve">
    <value>The message cannot be deserialized into MessageContract type {0} since it does not have a default (parameterless) constructor.</value>
  </data>
  <data name="SFxMessageOperationFormatterCannotSerializeFault" xml:space="preserve">
    <value>MessageOperationFormatter cannot serialize faults.</value>
  </data>
  <data name="SFxMetadataReferenceInvalidLocation" xml:space="preserve">
    <value>The value '{0}' is not valid for the Location property. The Location property must be a valid absolute or relative URI.</value>
  </data>
  <data name="SFxMethodNotSupportedOnCallback1" xml:space="preserve">
    <value>Callback method {0} is not supported, this can happen if the method is not marked with OperationContractAttribute or if its interface type is not the target of the ServiceContractAttribute's CallbackContract.</value>
  </data>
  <data name="SFxMethodNotSupportedByType2" xml:space="preserve">
    <value>ServiceHost implementation type {0} does not implement ServiceContract {1}.</value>
  </data>
  <data name="SFxMismatchedOperationParent" xml:space="preserve">
    <value>A DispatchOperation (or ClientOperation) can only be added to its parent DispatchRuntime (or ClientRuntime).</value>
  </data>
  <data name="SFxMissingActionHeader" xml:space="preserve">
    <value>No Action header was found with namespace '{0}' for the given message.</value>
  </data>
  <data name="SFxMultipleUnknownHeaders" xml:space="preserve">
    <value>Method {0} in type {1} has more than one header part of type array of XmlElement.</value>
  </data>
  <data name="SFxMultipleContractStarOperations0" xml:space="preserve">
    <value>A ServiceContract has more the one operation with an Action of "*".  A ServiceContract can have at most one operation an Action = "*".</value>
  </data>
  <data name="SFxMultipleContractsWithSameName" xml:space="preserve">
    <value>The Service contains multiple ServiceEndpoints with different ContractDescriptions which each have Name='{0}' and Namespace='{1}'.  Either provide ContractDescriptions with unique Name and Namespaces, or ensure the ServiceEndpoints have the same ContractDescription instance.</value>
  </data>
  <data name="SFxMultiplePartsNotAllowedInEncoded" xml:space="preserve">
    <value>Part {1}:{0} is repeating and is not supported in Soap Encoding.</value>
  </data>
  <data name="SFxNameCannotBeEmpty" xml:space="preserve">
    <value>The Name property must be a non-empty string.</value>
  </data>
  <data name="SFxConfigurationNameCannotBeEmpty" xml:space="preserve">
    <value>The ConfigurationName property must be a non-empty string.</value>
  </data>
  <data name="SFxNeedProxyBehaviorOperationSelector2" xml:space="preserve">
    <value>Cannot handle invocation of {0} on interface {1} because the OperationSelector on ClientRuntime is null.</value>
  </data>
  <data name="SFxNoDefaultConstructor" xml:space="preserve">
    <value>The service type provided could not be loaded as a service because it does not have a default (parameter-less) constructor. To fix the problem, add a default constructor to the type, or register a service of the type (e.g. IServiceCollection.AddSingleton&lt;ServiceType&gt;()).</value>
  </data>
  <data name="SFxNoMostDerivedContract" xml:space="preserve">
    <value>The contract specified by type '{0}' is ambiguous.  The type derives from at least two different types that each define its own service contract.  For this type to be used as a contract type, exactly one of its inherited contracts must be more derived than any of the others.</value>
  </data>
  <data name="SFxNullReplyFromExtension2" xml:space="preserve">
    <value>Extension {0} prevented call to operation '{1}' from replying by setting the reply to null.</value>
  </data>
  <data name="SFxNullReplyFromFormatter2" xml:space="preserve">
    <value>Formatter {0} returned a null reply message for call to operation '{1}'.</value>
  </data>
  <data name="SFxServiceChannelIdleAborted" xml:space="preserve">
    <value>The operation '{0}' could not be completed because the sessionful channel timed out waiting to receive a message.  To increase the timeout, either set the receiveTimeout property on the binding in your configuration file, or set the ReceiveTimeout property on the Binding directly.</value>
  </data>
  <data name="SFxServiceMetadataBehaviorUrlMustBeHttpOrRelative" xml:space="preserve">
    <value>{0} must be a relative URI or an absolute URI with scheme '{1}'.  '{2}' is an absolute URI with scheme '{3}'. </value>
  </data>
  <data name="SFxServiceTypeNotCreatable" xml:space="preserve">
    <value>Service implementation type is an interface or abstract class and no implementation object was provided.</value>
  </data>
  <data name="SFxSetEnableFaultsOnChannelDispatcher0" xml:space="preserve">
    <value>This property sets EnableFaults on the client. To set EnableFaults on the server, use ChannelDispatcher's EnableFaults.</value>
  </data>
  <data name="SFxSetManualAddressingOnChannelDispatcher0" xml:space="preserve">
    <value>This property sets ManualAddressing on the client. To set ManualAddressing on the server, use ChannelDispatcher's ManualAddressing.</value>
  </data>
  <data name="SFxNoServiceObject" xml:space="preserve">
    <value>The service implementation object was not initialized or is not available.</value>
  </data>
  <data name="SFxNone2004" xml:space="preserve">
    <value>The WS-Addressing "none" value is not valid for the August 2004 version of WS-Addressing.</value>
  </data>
  <data name="SFxNonExceptionThrown" xml:space="preserve">
    <value>An object that is not an exception was thrown.</value>
  </data>
  <data name="SFxNonInitiatingOperation1" xml:space="preserve">
    <value>The operation '{0}' cannot be the first operation to be called because IsInitiating is false.</value>
  </data>
  <data name="SFxOneWayMessageToTwoWayMethod0" xml:space="preserve">
    <value>The incoming message with action could not be processed because it is targeted at a request-reply operation, but cannot be replied to as the MessageId property is not set.</value>
  </data>
  <data name="SFxOperationBehaviorAttributeOnlyOnServiceClass" xml:space="preserve">
    <value>OperationBehaviorAttribute can only go on the service class, it cannot be put on the ServiceContract interface. Method '{0}' on type '{1}' violates this.</value>
  </data>
  <data name="SFxOperationBehaviorAttributeReleaseInstanceModeDoesNotApplyToCallback" xml:space="preserve">
    <value>The ReleaseInstanceMode property on OperationBehaviorAttribute can only be set on non-callback operations. Method '{0}' violates this.</value>
  </data>
  <data name="SFxOperationContractOnNonServiceContract" xml:space="preserve">
    <value>Method '{0}' has OperationContractAttribute, but enclosing type '{1}' does not have ServiceContractAttribute. OperationContractAttribute can only be used on methods in ServiceContractAttribute types or on their CallbackContract types.</value>
  </data>
  <data name="SFxOperationContractProviderOnNonServiceContract" xml:space="preserve">
    <value>Method '{1}' has {0}, but enclosing type '{2}' does not have ServiceContractAttribute. {0} can only be used on methods in ServiceContractAttribute types.</value>
  </data>
  <data name="SFxOperationDescriptionNameCannotBeEmpty" xml:space="preserve">
    <value>OperationDescription's Name must be a non-empty string.</value>
  </data>
  <data name="SFxParameterNameCannotBeNull" xml:space="preserve">
    <value>All parameter names used in operations that make up a service contract must not be null.</value>
  </data>
  <data name="SFxOperationMustHaveOneOrTwoMessages" xml:space="preserve">
    <value>OperationDescription '{0}' is invalid because its Messages property contains an invalid number of MessageDescription instances. Each OperationDescription must have one or two messages.</value>
  </data>
  <data name="SFxParameterCountMismatch" xml:space="preserve">
    <value>There was a mismatch between the number of supplied arguments and the number of expected arguments.  Specifically, the argument '{0}' has '{1}' elements while the argument '{2}' has '{3}' elements.</value>
  </data>
  <data name="SFxParameterMustBeMessage" xml:space="preserve">
    <value>The 'parameters' argument must be an array that contains a single Message object.</value>
  </data>
  <data name="SFxParametersMustBeEmpty" xml:space="preserve">
    <value>The 'parameters' argument must be either null or an empty array.</value>
  </data>
  <data name="SFxParameterMustBeArrayOfOneElement" xml:space="preserve">
    <value>The 'parameters' argument must be an array of one element.</value>
  </data>
  <data name="SFxPartNameMustBeUniqueInRpc" xml:space="preserve">
    <value>Message part name {0} is not unique in an RPC Message.</value>
  </data>
  <data name="SFxRequestHasInvalidReplyToOnServer" xml:space="preserve">
    <value>The request message has ReplyTo='{0}' but IContextChannel.RemoteAddress is '{1}'.  When ManualAddressing is false, these values must be the same, null, or EndpointAddress.AnonymousAddress because sending a reply to a different address than the original sender can create a security risk.  If you want to process such messages, enable ManualAddressing.</value>
  </data>
  <data name="SFxRequestHasInvalidFaultToOnServer" xml:space="preserve">
    <value>The request message has FaultTo='{0}' but IContextChannel.RemoteAddress is '{1}'.  When ManualAddressing is false, these values must be the same, null, or EndpointAddress.AnonymousAddress because sending a reply to a different address than the original sender can create a security risk.  If you want to process such messages, enable ManualAddressing.</value>
  </data>
  <data name="SFxRequestHasInvalidFromOnServer" xml:space="preserve">
    <value>The request message has From='{0}' but IContextChannel.RemoteAddress is '{1}'.  When ManualAddressing is false, these values must be the same, null, or EndpointAddress.AnonymousAddress because sending a reply to a different address than the original sender can create a security risk.  If you want to process such messages, enable ManualAddressing.</value>
  </data>
  <data name="SFxRequestReplyNone" xml:space="preserve">
    <value>A message was received with a WS-Addressing ReplyTo or FaultTo header targeted at the "None" address.  These values are not valid for request-reply operations.  Please consider using a one-way operation or enabling ManualAddressing if you need to support ReplyTo or FaultTo values of "None."</value>
  </data>
  <data name="SFxRequestTimedOut1" xml:space="preserve">
    <value>This request operation did not receive a reply within the configured timeout ({0}).  The time allotted to this operation may have been a portion of a longer timeout.  This may be because the service is still processing the operation or because the service was unable to send a reply message.  Please consider increasing the operation timeout (by casting the channel/proxy to IContextChannel and setting the OperationTimeout property) and ensure that the service is able to connect to the client.</value>
  </data>
  <data name="SFxRequestTimedOut2" xml:space="preserve">
    <value>This request operation sent to {0} did not receive a reply within the configured timeout ({1}).  The time allotted to this operation may have been a portion of a longer timeout.  This may be because the service is still processing the operation or because the service was unable to send a reply message.  Please consider increasing the operation timeout (by casting the channel/proxy to IContextChannel and setting the OperationTimeout property) and ensure that the service is able to connect to the client.</value>
  </data>
  <data name="SFxReplyActionMismatch3" xml:space="preserve">
    <value>A reply message was received for operation '{0}' with action '{1}'. However, your client code requires action '{2}'.</value>
  </data>
  <data name="SFxRequiredRuntimePropertyMissing" xml:space="preserve">
    <value>Required runtime property '{0}' is not initialized on DispatchRuntime. Do not remove ServiceBehaviorAttribute from ServiceDescription.Behaviors or ensure that you include a third-party service behavior that supplies this value.</value>
  </data>
  <data name="SFxResultMustBeMessage" xml:space="preserve">
    <value>The 'result' argument must be of type Message.</value>
  </data>
  <data name="SFxRpcMessageBodyPartNameInvalid" xml:space="preserve">
    <value>RPC Message {1} in operation {0} has an invalid body name {2}. It must be {3}</value>
  </data>
  <data name="SFxRpcMessageMustHaveASingleBody" xml:space="preserve">
    <value>RPC Message {1} in operation {0} must have a single MessageBodyMember.</value>
  </data>
  <data name="SFxSecurityContextPropertyMissingFromRequestMessage" xml:space="preserve">
    <value>SecurityContextProperty is missing from the request Message, this may indicate security is configured incorrectly.</value>
  </data>
  <data name="SFxServerDidNotReply" xml:space="preserve">
    <value>The server did not provide a meaningful reply; this might be caused by a contract mismatch, a premature session shutdown or an internal server error.</value>
  </data>
  <data name="SFxServiceHostBaseCannotApplyConfigurationWithoutDescription" xml:space="preserve">
    <value>ApplyConfiguration requires that the Description property be initialized. Either provide a valid ServiceDescription in the CreateDescription method or override the ApplyConfiguration method to provide an alternative implementation.</value>
  </data>
  <data name="SFxStaticMessageHeaderPropertiesNotAllowed" xml:space="preserve">
    <value>Header properties cannot be set in MessageHeaderAttribute of {0} as its type is MessageHeader&lt;T&gt;.</value>
  </data>
  <data name="SFxStreamIOException" xml:space="preserve">
    <value>An exception has been thrown when reading the stream.</value>
  </data>
  <data name="SFxStreamRequestMessageClosed" xml:space="preserve">
    <value>The message containing this stream has been closed. Note that request streams cannot be accessed after the service operation returns.</value>
  </data>
  <data name="SFxStreamResponseMessageClosed" xml:space="preserve">
    <value>The message containing this stream has been closed. </value>
  </data>
  <data name="SFxTerminatingOperationAlreadyCalled1" xml:space="preserve">
    <value>This channel cannot send any more messages because IsTerminating operation '{0}' has already been called.</value>
  </data>
  <data name="SFxThrottleLimitMustBeGreaterThanZero0" xml:space="preserve">
    <value>Throttle limit must be greater than zero. To disable, set to Int32.MaxValue.</value>
  </data>
  <data name="SFxTooManyPartsWithSameName" xml:space="preserve">
    <value>Cannot create a unique part name for {0}.</value>
  </data>
  <data name="SFxNonConcurrentOrEnsureOrderedDispatch" xml:space="preserve">
    <value>The '{0}' service is configured with EnsureOrderedDispatch set to true, but the ConcurrencyMode is not set to Single. EnsureOrderedDispatch requires the use of ConcurrencyMode.Single.</value>
  </data>
  <data name="SfxDispatchRuntimeNonConcurrentOrEnsureOrderedDispatch" xml:space="preserve">
    <value>The DispatchRuntime.EnsureOrderedDispatch property is set to true, but the DispatchRuntime.ConcurrencyMode is not set to Single. EnsureOrderedDispatch requires the use of ConcurrencyMode.Single.</value>
  </data>
  <data name="SFxTypedMessageCannotBeNull" xml:space="preserve">
    <value>Internal Error: The instance of the MessageContract cannot be null in {0}.</value>
  </data>
  <data name="SFxTypedMessageCannotBeRpcLiteral" xml:space="preserve">
    <value>The operation '{0}' could not be loaded because it specifies "rpc-style" in "literal" mode, but uses message contract types or the CoreWCF.Channels.Message. This combination is disallowed -- specify a different value for style or use parameters other than message contract types or System.ServiceModel.Channels.Message.</value>
  </data>
  <data name="SFxTypedOrUntypedMessageCannotBeMixedWithParameters" xml:space="preserve">
    <value>The operation '{0}' could not be loaded because it has a parameter or return type of type CoreWCF.Channels.Message or a type that has MessageContractAttribute and other parameters of different types. When using System.ServiceModel.Channels.Message or types with MessageContractAttribute, the method must not use any other types of parameters.</value>
  </data>
  <data name="SFxTypedOrUntypedMessageCannotBeMixedWithVoidInRpc" xml:space="preserve">
    <value>When using the rpc-encoded style, message contract types or the CoreWCF.Channels.Message type cannot be used if the operation has no parameters or has a void return value. Add a blank message contract type as a parameter or return type to operation '{0}'.</value>
  </data>
  <data name="SFxUnknownFaultNoMatchingTranslation1" xml:space="preserve">
    <value>This fault did not provide a matching translation: {0}</value>
  </data>
  <data name="SFxUnknownFaultNullReason0" xml:space="preserve">
    <value>This fault did not provide a reason (MessageFault.Reason was null).</value>
  </data>
  <data name="SFxUnknownFaultZeroReasons0" xml:space="preserve">
    <value>This fault did not provide a reason (MessageFault.Reason.Translations.Count was 0).</value>
  </data>
  <data name="SFxWellKnownNonSingleton0" xml:space="preserve">
    <value>In order to use one of the ServiceHost constructors that takes a service instance, the InstanceContextMode of the service must be set to InstanceContextMode.Single.  This can be configured via the ServiceBehaviorAttribute.  Otherwise, please consider using the ServiceHost constructors that take a Type argument.</value>
  </data>
  <data name="SFxVersionMismatchInOperationContextAndMessage2" xml:space="preserve">
    <value>Cannot add outgoing headers to message as MessageVersion in OperationContext.Current '{0}' does not match with the header version of message being processed '{1}'.</value>
  </data>
  <data name="SFxWhenMultipleEndpointsShareAListenUriTheyMustHaveSameIdentity" xml:space="preserve">
    <value>When multiple endpoints on a service share the same ListenUri, those endpoints must all have the same Identity in their EndpointAddress. The endpoints at ListenUri '{0}' do not meet this criteria.</value>
  </data>
  <data name="SFxWrapperNameCannotBeEmpty" xml:space="preserve">
    <value>Wrapper element name cannot be empty.</value>
  </data>
  <data name="SFxXmlArrayNotAllowedForMultiple" xml:space="preserve">
    <value>XmlArrayAttribute cannot be used in repeating part {1}:{0}.</value>
  </data>
  <data name="SFxCloseTimedOut1" xml:space="preserve">
    <value>The ServiceHost close operation timed out after {0}.  This could be because a client failed to close a sessionful channel within the required time.  The time allotted to this operation may have been a portion of a longer timeout.</value>
  </data>
  <data name="SfxCloseTimedOutWaitingForDispatchToComplete" xml:space="preserve">
    <value>Close process timed out waiting for service dispatch to complete.</value>
  </data>
  <data name="SFxProxyRuntimeMessageCannotBeNull" xml:space="preserve">
    <value>In operation '{0}', cannot pass null to methods that take Message as input parameter.</value>
  </data>
  <data name="SFxDispatchRuntimeMessageCannotBeNull" xml:space="preserve">
    <value>In operation '{0}', cannot return null from methods that return Message.</value>
  </data>
  <data name="SfxReflectedContractKeyNotFound2" xml:space="preserve">
    <value>The contract name '{0}' could not be found in the list of contracts implemented by the service '{1}'.</value>
  </data>
  <data name="SfxReflectedContractKeyNotFoundEmpty" xml:space="preserve">
    <value>In order to add an endpoint to the service '{0}', a non-empty contract name must be specified.</value>
  </data>
  <data name="SFxMessagePartDescriptionMissingType" xml:space="preserve">
    <value>Instance of MessagePartDescription Name='{0}' Namespace='{1}' cannot be used in this context: required 'Type' property was not set.</value>
  </data>
  <data name="SFxMessageContractAttributeRequired" xml:space="preserve">
    <value>Cannot create a typed message from type '{0}'.  The functionality only valid for types decorated with MessageContractAttribute.</value>
  </data>
  <data name="AChannelServiceEndpointIsNull0" xml:space="preserve">
    <value>A Channel/Service Endpoint is null.</value>
  </data>
  <data name="AChannelServiceEndpointSBindingIsNull0" xml:space="preserve">
    <value>A Channel/Service endpoint's Binding is null.</value>
  </data>
  <data name="AChannelServiceEndpointSContractIsNull0" xml:space="preserve">
    <value>A Channel/Service endpoint's Contract is null.</value>
  </data>
  <data name="AChannelServiceEndpointSContractSNameIsNull0" xml:space="preserve">
    <value>A Channel/Service endpoint's Contract's name is null or empty.</value>
  </data>
  <data name="AChannelServiceEndpointSContractSNamespace0" xml:space="preserve">
    <value>A Channel/Service endpoint's Contract's namespace is null.</value>
  </data>
  <data name="ServiceHasZeroAppEndpoints" xml:space="preserve">
    <value>Service '{0}' has zero application (non-infrastructure) endpoints. This might be because no configuration file was found for your application, or because no service element matching the service name could be found in the configuration file, or because no endpoints were defined in the service element.</value>
  </data>
  <data name="SFxNoEndpointMatchingContract" xml:space="preserve">
    <value>The message with Action '{0}' cannot be processed at the receiver, due to a ContractFilter mismatch at the EndpointDispatcher. This may be because of either a contract mismatch (mismatched Actions between sender and receiver) or a binding/security mismatch between the sender and the receiver.  Check that sender and receiver have the same contract and the same binding (including security requirements, e.g. Message, Transport, None).</value>
  </data>
  <data name="SFxNoEndpointMatchingAddress" xml:space="preserve">
    <value>The message with To '{0}' cannot be processed at the receiver, due to an AddressFilter mismatch at the EndpointDispatcher.  Check that the sender and receiver's EndpointAddresses agree.</value>
  </data>
  <data name="SFxNoEndpointMatchingAddressForConnectionOpeningMessage" xml:space="preserve">
    <value>The message with Action '{0}' cannot be processed at the receiver because this Action is reserved for the connection opening messages only and cannot be sent from client to server. To invoke this operation on the server, call the '{1}' method on the client proxy instead.</value>
  </data>
  <data name="SFxServiceChannelCannotBeCalledBecauseIsSessionOpenNotificationEnabled" xml:space="preserve">
    <value>The operation '{0}' could not be invoked because the property '{1}' on the OperationContract is set to '{2}'. To invoke this operation on the server, call the '{3}' method on the client proxy instead.</value>
  </data>
  <data name="EndMethodsCannotBeDecoratedWithOperationContractAttribute" xml:space="preserve">
    <value>When using the IAsyncResult design pattern, the End method cannot be decorated with OperationContractAttribute. Only the corresponding Begin method can be decorated with OperationContractAttribute; that attribute will apply to the Begin-End pair of methods. Method '{0}' in type '{1}' violates this.</value>
  </data>
  <data name="DispatchRuntimeRequiresFormatter0" xml:space="preserve">
    <value>The DispatchOperation '{0}' requires Formatter, since DeserializeRequest and SerializeReply are not both false.</value>
  </data>
  <data name="ClientRuntimeRequiresFormatter0" xml:space="preserve">
    <value>The ClientOperation '{0}' requires Formatter, since SerializeRequest and DeserializeReply are not both false.</value>
  </data>
  <data name="RuntimeRequiresInvoker0" xml:space="preserve">
    <value>DispatchOperation requires Invoker.</value>
  </data>
  <data name="CouldnTCreateChannelForType2" xml:space="preserve">
    <value>Channel requirements cannot be met by the ChannelFactory for Binding '{0}' since the contract requires support for one of these channel types '{1}' but the binding doesn't support any of them.</value>
  </data>
  <data name="BindingDoesnTSupportSessionButContractRequires1" xml:space="preserve">
    <value>Contract requires Session, but Binding '{0}' doesn't support it or isn't configured properly to support it.</value>
  </data>
  <data name="BindingDoesntSupportDatagramButContractRequires" xml:space="preserve">
    <value>Contract does not allow Session, but Binding '{0}' does not support Datagram or is not configured properly to support it.</value>
  </data>
  <data name="BindingDoesnTSupportOneWayButContractRequires1" xml:space="preserve">
    <value>Contract requires OneWay, but Binding '{0}' doesn't support it or isn't configured properly to support it.</value>
  </data>
  <data name="BindingDoesnTSupportTwoWayButContractRequires1" xml:space="preserve">
    <value>Contract requires TwoWay (either request-reply or duplex), but Binding '{0}' doesn't support it or isn't configured properly to support it.</value>
  </data>
  <data name="BindingDoesnTSupportRequestReplyButContract1" xml:space="preserve">
    <value>Contract requires Request/Reply, but Binding '{0}' doesn't support it or isn't configured properly to support it.</value>
  </data>
  <data name="BindingDoesnTSupportDuplexButContractRequires1" xml:space="preserve">
    <value>Contract requires Duplex, but Binding '{0}' doesn't support it or isn't configured properly to support it.</value>
  </data>
  <data name="BindingDoesnTSupportAnyChannelTypes1" xml:space="preserve">
    <value>Binding '{0}' doesn't support creating any channel types. This often indicates that the BindingElements in a CustomBinding have been stacked incorrectly or in the wrong order. A Transport is required at the bottom of the stack. The recommended order for BindingElements is: TransactionFlow, ReliableSession, Security, CompositeDuplex, OneWay, StreamSecurity, MessageEncoding, Transport. </value>
  </data>
  <data name="ContractIsNotSelfConsistentItHasOneOrMore2" xml:space="preserve">
    <value>The contract '{0}' is not self-consistent -- it has one or more IsTerminating or non-IsInitiating operations, but it does not have the SessionMode property set to SessionMode.Required.  The IsInitiating and IsTerminating attributes can only be used in the context of a session.</value>
  </data>
  <data name="InstanceSettingsMustHaveTypeOrWellKnownObject0" xml:space="preserve">
    <value>The ServiceHost must be configured with either a serviceType or a serviceInstance.  Both of these values are currently null.</value>
  </data>
  <data name="TheServiceMetadataExtensionInstanceCouldNot2_0" xml:space="preserve">
    <value>The ServiceMetadataExtension instance could not be added to the ServiceHost instance because it has already been added to another ServiceHost instance.</value>
  </data>
  <data name="TheServiceMetadataExtensionInstanceCouldNot3_0" xml:space="preserve">
    <value>The ServiceMetadataExtension instance could not be removed from the ServiceHost instance because it has not been added to any ServiceHost instance.</value>
  </data>
  <data name="TheServiceMetadataExtensionInstanceCouldNot4_0" xml:space="preserve">
    <value>The ServiceMetadataExtension instance could not be removed from the ServiceHost instance because it has already been added to a different ServiceHost instance.</value>
  </data>
  <data name="SynchronizedCollectionWrongType1" xml:space="preserve">
    <value>A value of type '{0}' cannot be added to the generic collection, because the collection has been parameterized with a different type.</value>
  </data>
  <data name="SynchronizedCollectionWrongTypeNull" xml:space="preserve">
    <value>A null value cannot be added to the generic collection, because the collection has been parameterized with a value type.</value>
  </data>
  <data name="CannotAddTwoItemsWithTheSameKeyToSynchronizedKeyedCollection0" xml:space="preserve">
    <value>Cannot add two items with the same key to SynchronizedKeyedCollection.</value>
  </data>
  <data name="ItemDoesNotExistInSynchronizedKeyedCollection0" xml:space="preserve">
    <value>Item does not exist in SynchronizedKeyedCollection.</value>
  </data>
  <data name="SuppliedMessageIsNotAReplyItHasNoRelatesTo0" xml:space="preserve">
    <value>A reply message was received without a valid RelatesTo header.  This may have been caused by a missing RelatesTo header or a RelatesTo header with an invalid WS-Addressing Relationship type.</value>
  </data>
  <data name="channelIsNotAvailable0" xml:space="preserve">
    <value>Internal Error: The InnerChannel property is null.</value>
  </data>
  <data name="channelDoesNotHaveADuplexSession0" xml:space="preserve">
    <value>The current channel does not support closing the output session as this channel does not implement ISessionChannel&lt;IDuplexSession&gt;.</value>
  </data>
  <data name="EndpointsMustHaveAValidBinding1" xml:space="preserve">
    <value>The ServiceEndpoint with name '{0}' could not be exported to WSDL because the Binding property is null. To fix this, set the Binding property to a valid Binding instance.</value>
  </data>
  <data name="ABindingInstanceHasAlreadyBeenAssociatedTo1" xml:space="preserve">
    <value>A binding instance has already been associated to listen URI '{0}'. If two endpoints want to share the same ListenUri, they must also share the same binding object instance. The two conflicting endpoints were either specified in AddServiceEndpoint() calls, in a config file, or a combination of AddServiceEndpoint() and config. </value>
  </data>
  <data name="WsdlExporterIsFaulted" xml:space="preserve">
    <value>A previous call to this WsdlExporter left it in a faulted state. It is no longer usable.</value>
  </data>
  <data name="PolicyExtensionExportError" xml:space="preserve">
    <value>An exception was thrown in a call to a policy export extension.\r\nExtension: {0}\r\nError: {1}</value>
  </data>
  <data name="MultipleCallsToExportContractWithSameContract" xml:space="preserve">
    <value>Calling IWsdlExportExtension.ExportContract twice with the same ContractDescription is not supported.</value>
  </data>
  <data name="DuplicateContractQNameNameOnExport" xml:space="preserve">
    <value>Duplicate contract XmlQualifiedNames are not supported.\r\nAnother ContractDescription with the Name: {0} and Namespace: {1} has already been exported.</value>
  </data>
  <data name="WarnDuplicateBindingQNameNameOnExport" xml:space="preserve">
    <value>Similar ServiceEndpoints were exported. The WSDL export process was forced to suffix wsdl:binding names to avoid naming conflicts.\r\n Similar ServiceEndpoints means different binding instances having the Name: {0} and Namespace: {1} and either the same ContractDescription or at least the same contract Name: {2}.</value>
  </data>
  <data name="WsdlExtensionContractExportError" xml:space="preserve">
    <value>An exception was thrown in a call to a WSDL export extension: {0}\r\n contract: {1}</value>
  </data>
  <data name="WsdlExtensionEndpointExportError" xml:space="preserve">
    <value>An exception was thrown in a call to a WSDL export extension: {0}\r\n Endpoint: {1}</value>
  </data>
  <data name="UnsupportedEnvelopeVersion" xml:space="preserve">
    <value>The {0} binding element requires envelope version '{1}' It doesn't support '{2}'.</value>
  </data>
  <data name="ServicesWithoutAServiceContractAttributeCan2" xml:space="preserve">
    <value>The {0} declared on method '{1}' in type '{2}' is invalid. {0}s are only valid on methods that are declared in a type that has ServiceContractAttribute. Either add ServiceContractAttribute to type '{2}' or remove {0} from method '{1}'.</value>
  </data>
  <data name="tooManyAttributesOfTypeOn2" xml:space="preserve">
    <value>Too many attributes of type {0} on {1}.</value>
  </data>
  <data name="couldnTFindRequiredAttributeOfTypeOn2" xml:space="preserve">
    <value>Couldn't find required attribute of type {0} on {1}.</value>
  </data>
  <data name="AttemptedToGetContractTypeForButThatTypeIs1" xml:space="preserve">
    <value>Attempted to get contract type for {0}, but that type is not a ServiceContract, nor does it inherit a ServiceContract.</value>
  </data>
  <data name="NoEndMethodFoundForAsyncBeginMethod3" xml:space="preserve">
    <value>OperationContract method '{0}' in type '{1}' does not properly implement the async pattern, as no corresponding method '{2}' could be found. Either provide a method called '{2}' or set the AsyncPattern property on method '{0}' to false.</value>
  </data>
  <data name="MoreThanOneEndMethodFoundForAsyncBeginMethod3" xml:space="preserve">
    <value>OperationContract method '{0}' in type '{1}' does not properly implement the async pattern, as more than one corresponding method '{2}' was found. When using the async pattern, exactly one end method must be provided. Either remove or rename one or more of the '{2}' methods such that there is just one, or set the AsyncPattern property on method '{0}' to false.</value>
  </data>
  <data name="InvalidAsyncEndMethodSignatureForMethod2" xml:space="preserve">
    <value>Invalid async End method signature for method {0} in ServiceContract type {1}. Your end method must take an IAsyncResult as the last argument.</value>
  </data>
  <data name="InvalidAsyncBeginMethodSignatureForMethod2" xml:space="preserve">
    <value>Invalid async Begin method signature for method {0} in ServiceContract type {1}. Your begin method must take an AsyncCallback and an object as the last two arguments and return an IAsyncResult.</value>
  </data>
  <data name="InAContractInheritanceHierarchyIfParentHasCallbackChildMustToo" xml:space="preserve">
    <value>Because base ServiceContract '{0}' has a CallbackContract '{1}', derived ServiceContract '{2}' must also specify either '{1}' or a derived type as its CallbackContract.</value>
  </data>
  <data name="InAContractInheritanceHierarchyTheServiceContract3_2" xml:space="preserve">
    <value>In a contract inheritance hierarchy, the ServiceContract's CallbackContract must be a subtype of the CallbackContracts of all of the CallbackContracts of the ServiceContracts inherited by the original ServiceContract, Types {0} and {1} violate this rule.</value>
  </data>
  <data name="CannotHaveTwoOperationsWithTheSameName3" xml:space="preserve">
    <value>Cannot have two operations in the same contract with the same name, methods {0} and {1} in type {2} violate this rule. You can change the name of one of the operations by changing the method name or by using the Name property of OperationContractAttribute.</value>
  </data>
  <data name="CannotHaveTwoOperationsWithTheSameElement5" xml:space="preserve">
    <value>The {0}.{1} operation references a message element [{2}] that has already been exported from the {3}.{4} operation. You can change the name of one of the operations by changing the method name or using the Name property of OperationContractAttribute. Alternatively, you can control the element name in greater detail using the MessageContract programming model.</value>
  </data>
  <data name="CannotInheritTwoOperationsWithTheSameName3" xml:space="preserve">
    <value>Cannot inherit two different operations with the same name, operation '{0}' from contracts '{1}' and '{2}' violate this rule. You can change the name of one of the operations by changing the method name or by using the Name property of OperationContractAttribute.</value>
  </data>
  <data name="SyncAsyncMatchConsistency_Parameters5" xml:space="preserve">
    <value>The synchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a synchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must define the same number and types of parameters. In this case, some of the arguments are different. To fix it, ensure that the OperationContracts define the same number and types of arguments, in the same order. Alternatively, changing the name of one of the methods will prevent matching. </value>
  </data>
  <data name="SyncTaskMatchConsistency_Parameters5" xml:space="preserve">
    <value>The synchronous OperationContract method '{0}' in type '{1}' was matched with the task-based asynchronous OperationContract method '{2}' because they have the same operation name '{3}'. When a synchronous OperationContract method is matched to a task-based asynchronous OperationContract method, the two OperationContracts must define the same number and types of parameters. In this case, some of the arguments are different. To fix it, ensure that the OperationContracts define the same number and types of arguments, in the same order. Alternatively, changing the name of one of the methods will prevent matching. </value>
  </data>
  <data name="TaskAsyncMatchConsistency_Parameters5" xml:space="preserve">
    <value>The task-based asynchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a task-based asynchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must define the same number and types of parameters. In this case, some of the arguments are different. To fix it, ensure that the OperationContracts define the same number and types of arguments, in the same order. Alternatively, changing the name of one of the methods will prevent matching.</value>
  </data>
  <data name="SyncAsyncMatchConsistency_ReturnType5" xml:space="preserve">
    <value>The synchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a synchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must define the same return type. In this case, the return types are different. To fix it, ensure that method '{0}' and method '{3}' have the same return type. Alternatively, changing the name of one of the methods will prevent matching. </value>
  </data>
  <data name="SyncTaskMatchConsistency_ReturnType5" xml:space="preserve">
    <value>The synchronous OperationContract method '{0}' in type '{1}' was matched with the task-based asynchronous OperationContract method '{2}' because they have the same operation name '{3}'. When a synchronous OperationContract method is matched to a task-based asynchronous OperationContract method, the two OperationContracts must define the same return type. In this case, the return types are different. To fix it, ensure that method '{0}' and method '{2}' have the same return type. Alternatively, changing the name of one of the methods will prevent matching. </value>
  </data>
  <data name="TaskAsyncMatchConsistency_ReturnType5" xml:space="preserve">
    <value>The task-based asynchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a synchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must define the same return type. In this case, the return types are different. To fix it, ensure that method '{0}' and method '{3}' have the same return type. Alternatively, changing the name of one of the methods will prevent matching. </value>
  </data>
  <data name="SyncAsyncMatchConsistency_Attributes6" xml:space="preserve">
    <value>The synchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a synchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, any additional attributes must be declared on the synchronous OperationContract method. In this case, the asynchronous OperationContract method '{2}' has one or more attributes of type '{5}'. To fix it, remove the '{5}' attribute or attributes from method '{2}'. Alternatively, changing the name of one of the methods will prevent matching. </value>
  </data>
  <data name="SyncTaskMatchConsistency_Attributes6" xml:space="preserve">
    <value>The synchronous OperationContract method '{0}' in type '{1}' was matched with the task-based asynchronous OperationContract method '{2}' because they have the same operation name '{3}'. When a synchronous OperationContract method is matched to a task-based asynchronous OperationContract method, any additional attributes must be declared on the synchronous OperationContract method. In this case, the task-based asynchronous OperationContract method '{2}' has one or more attributes of type '{4}'. To fix it, remove the '{4}' attribute or attributes from method '{2}'. Alternatively, changing the name of one of the methods will prevent matching. </value>
  </data>
  <data name="TaskAsyncMatchConsistency_Attributes6" xml:space="preserve">
    <value>The task-based asynchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a task-based asynchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, any additional attributes must be declared on the task-based asynchronous OperationContract method. In this case, the asynchronous OperationContract method '{2}' has one or more attributes of type '{5}'. To fix it, remove the '{5}' attribute or attributes from method '{2}'. Alternatively, changing the name of one of the methods will prevent matching. </value>
  </data>
  <data name="SyncAsyncMatchConsistency_Property6" xml:space="preserve">
    <value>The synchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract  methods '{2}' and '{3}' because they have the same operation name '{4}'. When a synchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must have the same value for the '{5}' property. In this case, the values are different. To fix it, change the '{5} property of one of the OperationContracts to match the other. Alternatively, changing the name of one of the methods will prevent matching. </value>
  </data>
  <data name="SyncTaskMatchConsistency_Property6" xml:space="preserve">
    <value>The synchronous OperationContract method '{0}' in type '{1}' was matched with the task-based asynchronous OperationContract  method '{2}' because they have the same operation name '{3}'. When a synchronous OperationContract method is matched to a task-based asynchronous OperationContract method, the two OperationContracts must have the same value for the '{4}' property. In this case, the values are different. To fix it, change the '{4} property of one of the OperationContracts to match the other. Alternatively, changing the name of one of the methods will prevent matching. </value>
  </data>
  <data name="TaskAsyncMatchConsistency_Property6" xml:space="preserve">
    <value>The task-based asynchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract  methods '{2}' and '{3}' because they have the same operation name '{4}'. When a task-based asynchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must have the same value for the '{5}' property. In this case, the values are different. To fix it, change the '{5} property of one of the OperationContracts to match the other. Alternatively, changing the name of one of the methods will prevent matching. </value>
  </data>
  <data name="ServiceOperationsMarkedWithIsOneWayTrueMust0" xml:space="preserve">
    <value>Operations marked with IsOneWay=true must not declare output parameters, by-reference parameters or return values.</value>
  </data>
  <data name="OneWayOperationShouldNotSpecifyAReplyAction1" xml:space="preserve">
    <value>One way operation {0} cannot not specify a reply action.</value>
  </data>
  <data name="OneWayAndFaultsIncompatible2" xml:space="preserve">
    <value>The method '{1}' in type '{0}' is marked IsOneWay=true and declares one or more FaultContractAttributes. One-way methods cannot declare FaultContractAttributes. To fix it, change IsOneWay to false or remove the FaultContractAttributes.</value>
  </data>
  <data name="MessageHeaderIsNull0" xml:space="preserve">
    <value>The value of the addressHeaders argument is invalid because the collection contains null values. Null is not a valid value for the AddressHeaderCollection.</value>
  </data>
  <data name="MessagePropertiesArraySize0" xml:space="preserve">
    <value>The array passed does not have enough space to hold all the properties contained by this collection.</value>
  </data>
  <data name="DuplicateBehavior1" xml:space="preserve">
    <value>The value could not be added to the collection, as the collection already contains an item of the same type: '{0}'. This collection only supports one instance of each type.</value>
  </data>
  <data name="MsmqPoisonMessage" xml:space="preserve">
    <value>The transport channel detected a poison message. This occurred because the message exceeded the maximum number of delivery attempts or because the channel detected a fundamental problem with the message. The inner exception may contain additional information.</value>
  </data>
  <data name="NoChannelBuilderAvailable" xml:space="preserve">
    <value>The binding (Name={0}, Namespace={1}) cannot be used to create a ChannelFactory or a ChannelListener because it appears to be missing a TransportBindingElement.  Every binding must have at least one binding element that derives from TransportBindingElement.</value>
  </data>
  <data name="InvalidBindingScheme" xml:space="preserve">
    <value>The TransportBindingElement of type '{0}' in this CustomBinding returned a null or empty string for the Scheme. TransportBindingElement's Scheme must be a non-empty string.</value>
  </data>
  <data name="CustomBindingRequiresTransport" xml:space="preserve">
    <value>Binding '{0}' lacks a TransportBindingElement.  Every binding must have a binding element that derives from TransportBindingElement. This binding element must appear last in the BindingElementCollection.</value>
  </data>
  <data name="TransportBindingElementMustBeLast" xml:space="preserve">
    <value>In Binding '{0}', TransportBindingElement '{1}' does not appear last in the BindingElementCollection.  Please change the order of elements such that the TransportBindingElement is last.</value>
  </data>
  <data name="MessageVersionMissingFromBinding" xml:space="preserve">
    <value>None of the binding elements in binding '{0}' define a message version. At least one binding element must define a message version and return it from the GetProperty&lt;MessageVersion&gt; method.</value>
  </data>
  <data name="NotAllBindingElementsBuilt" xml:space="preserve">
    <value>Some of the binding elements in this binding were not used when building the ChannelFactory / ChannelListener.  This may be have been caused by the binding elements being misordered.  The recommended order for binding elements is: TransactionFlow, ReliableSession, Security, CompositeDuplex, OneWay, StreamSecurity, MessageEncoding, Transport.  Note that the TransportBindingElement must be last.  The following binding elements were not built: {0}.</value>
  </data>
  <data name="MultipleStreamUpgradeProvidersInParameters" xml:space="preserve">
    <value>More than one IStreamUpgradeProviderElement was found in the BindingParameters of the BindingContext.  This usually is caused by having multiple IStreamUpgradeProviderElements in a CustomBinding. Remove all but one of these elements.</value>
  </data>
  <data name="SecurityCapabilitiesMismatched" xml:space="preserve">
    <value>The security capabilities of binding '{0}' do not match those of the generated runtime object. Most likely this means the binding contains a StreamSecurityBindingElement, but lacks a TransportBindingElement that supports Stream Security (such as TCP or Named Pipes). Either remove the unused StreamSecurityBindingElement or use a transport that supports this element.</value>
  </data>
  <data name="BaseAddressMustBeAbsolute" xml:space="preserve">
    <value>Only an absolute Uri can be used as a base address.</value>
  </data>
  <data name="BaseAddressDuplicateScheme" xml:space="preserve">
    <value>This collection already contains an address with scheme {0}.  There can be at most one address per scheme in this collection. If your service is being hosted in IIS you can fix the problem by setting 'system.serviceModel/serviceHostingEnvironment/multipleSiteBindingsEnabled' to true or specifying 'system.serviceModel/serviceHostingEnvironment/baseAddressPrefixFilters'.</value>
  </data>
  <data name="BaseAddressCannotHaveUserInfo" xml:space="preserve">
    <value>A base address cannot contain a Uri user info section.</value>
  </data>
  <data name="TransportBindingElementNotFound" xml:space="preserve">
    <value>The binding does not contain a TransportBindingElement.</value>
  </data>
  <data name="BaseAddressCannotHaveQuery" xml:space="preserve">
    <value>A base address cannot contain a Uri query string.</value>
  </data>
  <data name="BaseAddressCannotHaveFragment" xml:space="preserve">
    <value>A base address cannot contain a Uri fragment.</value>
  </data>
  <data name="UriMustBeAbsolute" xml:space="preserve">
    <value>The given URI must be absolute.</value>
  </data>
  <data name="ConfigDuplicateItem" xml:space="preserve">
    <value>An extension named {0} already appears in the {1}. Extension names must be unique.</value>
  </data>
  <data name="ConfigDuplicateExtensionName" xml:space="preserve">
    <value> An extension of name '{0}' already appears in extension collection. Extension names must be unique.</value>
  </data>
  <data name="ConfigDuplicateExtensionType" xml:space="preserve">
    <value>An extension of type '{0}' already appears in extension collection. Extension types must be unique.</value>
  </data>
  <data name="ConfigDuplicateKey" xml:space="preserve">
    <value>A child element with the element name '{0}' already exists.  Child elements can only be added once.</value>
  </data>
  <data name="ConfigElementTypeNotAllowed" xml:space="preserve">
    <value>Extension element '{0}' cannot be added to this element.  Verify that the extension is registered in the extension collection at system.serviceModel/extensions/{1}.</value>
  </data>
  <data name="ConfigInvalidClassFactoryValue" xml:space="preserve">
    <value>The value '{0}' is not a valid instance of type '{1}'.</value>
  </data>
  <data name="ConfigInvalidClassInstanceValue" xml:space="preserve">
    <value>The instance is not a valid configurable value of type '{0}'.</value>
  </data>
  <data name="ConfigInvalidEncodingValue" xml:space="preserve">
    <value>{0} is not a valid encoding string for System.Text.Encoding.GetEncoding(string).</value>
  </data>
  <data name="ConfigInvalidExtensionElement" xml:space="preserve">
    <value>Invalid element in configuration. The extension '{0}' does not derive from correct extension base type '{1}'. </value>
  </data>
  <data name="ConfigInvalidExtensionElementName" xml:space="preserve">
    <value>Invalid element in configuration. The extension name '{0}' is not registered in the collection at system.serviceModel/extensions/{1}. </value>
  </data>
  <data name="ConfigInvalidExtensionType" xml:space="preserve">
    <value>The '{0}' type must derive from {1} to be used in the {2} collection.</value>
  </data>
  <data name="ConfigInvalidStartValue" xml:space="preserve">
    <value>Start must be between 0 and {0}. Value passed in is {1}.</value>
  </data>
  <data name="ConfigInvalidType" xml:space="preserve">
    <value>The type '{0}' registered for extension '{1}' could not be loaded.</value>
  </data>
  <data name="ConfigInvalidTypeForBinding" xml:space="preserve">
    <value>Invalid binding type for binding extension configuration object.  This binding extension manages configuration of binding type '{0}' and cannot act upon type '{1}'.</value>
  </data>
  <data name="ConfigMessageEncodingAlreadyInBinding" xml:space="preserve">
    <value>Cannot add the message encoding element '{0}'. Another message encoding element already exists in the binding '{1}'. There can only be one message encoding element for each binding.</value>
  </data>
  <data name="ConfigReadOnly" xml:space="preserve">
    <value>The configuration is read only.</value>
  </data>
  <data name="ConfigStreamUpgradeElementAlreadyInBinding" xml:space="preserve">
    <value>Cannot add stream upgrade element '{0}'. Another stream upgrade element already exists in the binding '{1}'. There can only be one stream update element per binding.</value>
  </data>
  <data name="ConfigTransportAlreadyInBinding" xml:space="preserve">
    <value>Cannot add the transport element '{0}'. Another transport element already exists in the binding '{1}'. There can only be one transport element for each binding.</value>
  </data>
  <data name="ConfigXmlElementMustBeSet" xml:space="preserve">
    <value>The XmlElement must contain XML content.</value>
  </data>
  <data name="GeneralSchemaValidationError" xml:space="preserve">
    <value>There was an error verifying some XML Schemas generated during export:\r\n{0}</value>
  </data>
  <data name="SchemaValidationError" xml:space="preserve">
    <value>There was a validation error on a schema generated during export:\r\n    Source: {0}\r\n    Line: {1} Column: {2}\r\n   Validation Error: {3}</value>
  </data>
  <data name="ClaimTypeCannotBeEmpty" xml:space="preserve">
    <value>The claimType cannot be an empty string.</value>
  </data>
  <data name="MissingCustomCertificateValidator" xml:space="preserve">
    <value>X509CertificateValidationMode.Custom requires a CustomCertificateValidator. Specify the CustomCertificateValidator property.</value>
  </data>
  <data name="MissingCustomUserNamePasswordValidator" xml:space="preserve">
    <value>UserNamePasswordValidationMode.Custom requires a CustomUserNamePasswordValidator. Specify the CustomUserNamePasswordValidator property.</value>
  </data>
  <data name="PublicKeyNotRSA" xml:space="preserve">
    <value>The public key is not an RSA key.</value>
  </data>
  <data name="NoPrincipalSpecifiedInAuthorizationContext" xml:space="preserve">
    <value>No custom principal is specified in the authorization context.</value>
  </data>
  <data name="AccessDenied" xml:space="preserve">
    <value>Access is denied.</value>
  </data>
  <data name="UTTMustBeAbsolute" xml:space="preserve">
    <value>Parameter 'baseAddress' must an absolute uri.</value>
  </data>
  <data name="UTTBaseAddressMustBeAbsolute" xml:space="preserve">
    <value>BaseAddress must an absolute uri.</value>
  </data>
  <data name="UTTCannotChangeBaseAddress" xml:space="preserve">
    <value>Cannot change BaseAddress after calling MakeReadOnly.</value>
  </data>
  <data name="UTTMultipleMatches" xml:space="preserve">
    <value>There were multiple UriTemplateMatch results, but MatchSingle was called.</value>
  </data>
  <data name="UTTBaseAddressNotSet" xml:space="preserve">
    <value>BaseAddress has not been set. Set the BaseAddress property before calling MakeReadOnly, Match, or MatchSingle.</value>
  </data>
  <data name="UTTEmptyKeyValuePairs" xml:space="preserve">
    <value>KeyValuePairs must have at least one element.</value>
  </data>
  <data name="UTBindByPositionWrongCount" xml:space="preserve">
    <value>UriTemplate '{0}' contains {1} path variables and {2} query variables but {3} values were passed to the BindByPosition method. The number of values passed to BindByPosition should be greater than or equal to the number of path variables in the template and cannot be greater than the total number of variables in the template.</value>
  </data>
  <data name="UTBadBaseAddress" xml:space="preserve">
    <value>baseAddress must an absolute Uri.</value>
  </data>
  <data name="UTQueryNamesMustBeUnique" xml:space="preserve">
    <value>The UriTemplate '{0}' is not valid; each portion of the query string must be of the form 'name' or of the form 'name=value', where each name is unique. Note that the names are case-insensitive. See the documentation for UriTemplate for more details.</value>
  </data>
  <data name="UTQueryCannotEndInAmpersand" xml:space="preserve">
    <value>The UriTemplate '{0}' is not valid; the query string cannot end with '&amp;amp;'. See the documentation for UriTemplate for more details.</value>
  </data>
  <data name="UTQueryCannotHaveEmptyName" xml:space="preserve">
    <value>The UriTemplate '{0}' is not valid; each portion of the query string must be of the form 'name' or of the form 'name=value'. See the documentation for UriTemplate for more details.</value>
  </data>
  <data name="UTVarNamesMustBeUnique" xml:space="preserve">
    <value>The UriTemplate '{0}' is not valid; the UriTemplate variable named '{1}' appears multiple times in the template. Note that UriTemplate variable names are case-insensitive. See the documentation for UriTemplate for more details.</value>
  </data>
  <data name="UTTAmbiguousQueries" xml:space="preserve">
    <value>UriTemplateTable does not support '{0}' and '{1}' since they are not equivalent, but cannot be disambiguated because they have equivalent paths and the same common literal values for the query string. See the documentation for UriTemplateTable for more detail.</value>
  </data>
  <data name="UTTOtherAmbiguousQueries" xml:space="preserve">
    <value>UriTemplateTable does not support multiple templates that have equivalent path as template '{0}' but have different query strings, where the query strings cannot all be disambiguated via literal values. See the documentation for UriTemplateTable for more detail.</value>
  </data>
  <data name="UTTDuplicate" xml:space="preserve">
    <value>UriTemplateTable (with allowDuplicateEquivalentUriTemplates = false) does not support both '{0}' and '{1}', since they are equivalent. Call MakeReadOnly with allowDuplicateEquivalentUriTemplates = true to use both of these UriTemplates in the same table. See the documentation for UriTemplateTable for more detail.</value>
  </data>
  <data name="UTInvalidFormatSegmentOrQueryPart" xml:space="preserve">
    <value>UriTemplate does not support '{0}' as a valid format for a segment or a query part.</value>
  </data>
  <data name="BindUriTemplateToNullOrEmptyPathParam" xml:space="preserve">
    <value>The path variable '{0}' in the UriTemplate must be bound to a non-empty string value.</value>
  </data>
  <data name="UTBindByPositionNoVariables" xml:space="preserve">
    <value>UriTemplate '{0}' contains no variables; yet the BindByPosition method was called with {1} values.</value>
  </data>
  <data name="UTCSRLookupBeforeMatch" xml:space="preserve">
    <value>UTCSR - Lookup was called before match</value>
  </data>
  <data name="UTDoesNotSupportAdjacentVarsInCompoundSegment" xml:space="preserve">
    <value>The UriTemplate '{0}' is not valid; UriTemplate does not support two adjacent variables with no literal in compound segments, such as in the segment '{1}'.</value>
  </data>
  <data name="UTQueryCannotHaveCompoundValue" xml:space="preserve">
    <value>The UriTemplate '{0}' is not valid; each portion of the query string must be of the form 'name=value', when value cannot be a compound segment. See the documentation for UriTemplate for more details.</value>
  </data>
  <data name="UTQueryMustHaveLiteralNames" xml:space="preserve">
    <value>The UriTemplate '{0}' is not valid; each portion of the query string must be of the form 'name' or of the form 'name=value', where name is a simple literal. See the documentation for UriTemplate for more details.</value>
  </data>
  <data name="UTAdditionalDefaultIsInvalid" xml:space="preserve">
    <value>Changing an inline default value with information from the additional default values is not supported; the default value to the variable '{0}' was already provided as part of the UriTemplate '{1}'. See the documentation for UriTemplate for more details.</value>
  </data>
  <data name="UTDefaultValuesAreImmutable" xml:space="preserve">
    <value>The default values of UriTemplate are immutable; they cannot be modified after the construction of the UriTemplate instance. See the documentation of UriTemplate for more details.</value>
  </data>
  <data name="UTDefaultValueToCompoundSegmentVar" xml:space="preserve">
    <value>The UriTemplate '{0}' is not valid; the UriTemplate compound path segment '{1}' provides a default value to variable '{2}'. Note that UriTemplate doesn't support default values to variables in compound segments. See the documentation for UriTemplate for more details.</value>
  </data>
  <data name="UTDefaultValueToQueryVar" xml:space="preserve">
    <value>The UriTemplate '{0}' is not valid; the UriTemplate variable declaration '{1}' provides a default value to query variable '{2}'. Note that UriTemplate doesn't support default values to query variables. See the documentation for UriTemplate for more details.</value>
  </data>
  <data name="UTInvalidDefaultPathValue" xml:space="preserve">
    <value>The UriTemplate '{0}' is not valid; the UriTemplate variable declaration '{1}' provides an empty default value to path variable '{2}'. Note that UriTemplate path variables cannot be bound to a null or empty value. See the documentation for UriTemplate for more details.</value>
  </data>
  <data name="UTInvalidVarDeclaration" xml:space="preserve">
    <value>The UriTemplate '{0}' is not valid; the UriTemplate variable declaration '{1}' isn't a valid variable construct. Note that UriTemplate variable definitions are either a simple, non-empty, variable name or a 'name=value' format, where the name must not be empty and the value provides a default value to the variable. See the documentation for UriTemplate for more details.</value>
  </data>
  <data name="UTInvalidWildcardInVariableOrLiteral" xml:space="preserve">
    <value>The UriTemplate '{0}' is not valid; the wildcard ('{1}') cannot appear in a variable name or literal, unless as a construct for a wildcard segment. Note that a wildcard segment, either a literal or a variable, is valid only as the last path segment in the template; the wildcard can appear only once. See the documentation for UriTemplate for more details.</value>
  </data>
  <data name="UTStarVariableWithDefaults" xml:space="preserve">
    <value>The UriTemplate '{0}' is not valid; the UriTemplate last path segment '{1}' provides a default value to final star variable '{2}'. Note that UriTemplate doesn't support default values to final star variable. See the documentation for UriTemplate for more details.</value>
  </data>
  <data name="UTDefaultValueToCompoundSegmentVarFromAdditionalDefaults" xml:space="preserve">
    <value>The UriTemplate '{0}' is not valid; the path variable '{1}', defined as part of a compound path segment has been provided with a default value as part of the additional defaults. Note that UriTemplate doesn't support default values to variables in compound segments. See the documentation for UriTemplate for more details.</value>
  </data>
  <data name="UTDefaultValueToQueryVarFromAdditionalDefaults" xml:space="preserve">
    <value>The UriTemplate '{0}' is not valid; the query variable '{1}' has been provided a default value as part of the additional defaults. Note that UriTemplate doesn't support default values to query variables. See the documentation for UriTemplate for more details.</value>
  </data>
  <data name="UTNullableDefaultAtAdditionalDefaults" xml:space="preserve">
    <value>The UriTemplate '{0}' is not valid; the additional default value '{1}' has a null value as default value. Note that null default values must be only provided to concrete path variables. See the documentation for UriTemplate for more details.</value>
  </data>
  <data name="UTNullableDefaultMustBeFollowedWithNullables" xml:space="preserve">
    <value>The UriTemplate '{0}' is not valid; the UriTemplate path variable '{1}' has a null default value while following path variable '{2}' has no defaults or provides a non-null default value. Note that UriTemplate path variable with null default value must be followed only with other path variables with null defaulted values. See the documentation for UriTemplate for more details.</value>
  </data>
  <data name="UTNullableDefaultMustNotBeFollowedWithLiteral" xml:space="preserve">
    <value>The UriTemplate '{0}' is not valid; the UriTemplate path variable '{1}' has a null default value while the following path segment '{2}' is not a variable segment with a null default value. Note that UriTemplate path variable with null default values must be followed only with other path variables with null defaulted value. See the documentation for UriTemplate for more details.</value>
  </data>
  <data name="UTNullableDefaultMustNotBeFollowedWithWildcard" xml:space="preserve">
    <value>The UriTemplate '{0}' is not valid; the UriTemplate path variable '{1}' has a null default value while the template is finished with a wildcard. Note that UriTemplate path variable with null default values must be followed only with other path variables with null defaulted value. See the documentation for UriTemplate for more details.</value>
  </data>
  <data name="UTStarVariableWithDefaultsFromAdditionalDefaults" xml:space="preserve">
    <value>The UriTemplate '{0}' is not valid; the UriTemplate final star variable '{1}' has been provides a default value as part of the additional defaults information. Note that UriTemplate doesn't support default values to final star variable. See the documentation for UriTemplate for more details.</value>
  </data>
  <data name="UTTInvalidTemplateKey" xml:space="preserve">
    <value>An invalid template '{0}' was passed as the key in a pair of template and its associated object. UriTemplateTable Key-Value pairs must always contain a valid UriTemplate object as key; note that UriTemplateTable doesn't support templates that are ignoring the trailing slash in respect to matching. See the documentation for UriTemplateTable for more details.</value>
  </data>
  <data name="UTTNullTemplateKey" xml:space="preserve">
    <value>A null UriTemplate was passed as the key in a pair of template and its associated object. UriTemplateTable Key-Value pairs must always contain a valid UriTemplate object as key. See the documentation for UriTemplateTable for more details.</value>
  </data>
  <data name="UTBindByNameCalledWithEmptyKey" xml:space="preserve">
    <value>The BindByName method of UriTemplate was called with an empty name in the collection of arguments for the bind. Note that the NameValueCollection or the Dictionary passed to BindByName cannot contain an empty (or null) name as a key. See the documentation of UriTemplate for more details.</value>
  </data>
  <data name="UTBothLiteralAndNameValueCollectionKey" xml:space="preserve">
    <value>The UriTemplate contains a literal value for query key '{0}', but that key also is present in the NameValueCollection. Either remove that key from the NameValueCollection, or else change the UriTemplate to not have a query literal for that key.</value>
  </data>
  <data name="UnableToImpersonateWhileSerializingReponse" xml:space="preserve">
    <value>Failed to impersonate client identity during serialization of the response message.</value>
  </data>
  <data name="XmlLineInfo" xml:space="preserve">
    <value>Line {0}, position {1}.</value>
  </data>
  <data name="SingleWsdlNotGenerated" xml:space="preserve">
    <value>A single WSDL document could not be generated for this service. Multiple service contract namespaces were found ({0}). Ensure that all your service contracts have the same namespace.</value>
  </data>
  <data name="SFxDocExt_MainPageIntroSingleWsdl" xml:space="preserve">
    <value>You can also access the service description as a single file:</value>
  </data>
  <data name="TaskMethodParameterNotSupported" xml:space="preserve">
    <value>The use of '{0}' on the task-based asynchronous method is not supported.</value>
  </data>
  <data name="TaskMethodMustNotHaveOutParameter" xml:space="preserve">
    <value>Client side task-based asynchronous method must not have any out or ref parameters. Any data that would have been returned through an out or ref parameter should instead be returned as part of the TResult in the resulting task.</value>
  </data>
  <data name="ID0020" xml:space="preserve">
    <value>ID0020: The collection is empty.</value>
  </data>
  <data name="ID4008" xml:space="preserve">
    <value>ID4008: '{0}' does not provide an implementation for '{1}'.</value>
  </data>
  <data name="ID4053" xml:space="preserve">
    <value>ID4053: The token has WS-SecureConversation version '{0}'.  Version '{1}' was expected.</value>
  </data>
  <data name="ID4072" xml:space="preserve">
    <value>ID4072: The SecurityTokenHandler '{0}' registered for TokenType '{1}' must derive from '{2}'.</value>
  </data>
  <data name="ID4101" xml:space="preserve">
    <value>ID4101: The token cannot be validated because it is not a SamlSecurityToken or a Saml2SecurityToken. Token type: '{0}'</value>
  </data>
  <data name="ID4192" xml:space="preserve">
    <value>ID4192: The reader is not positioned on a KeyInfo element that can be read.</value>
  </data>
  <data name="ID4240" xml:space="preserve">
    <value>ID4240: The tokenRequirement must derived from 'RecipientServiceModelSecurityTokenRequirement' for SecureConversationSecurityTokens. The tokenRequirement is of type '{0}'.</value>
  </data>
  <data name="ID4244" xml:space="preserve">
    <value>ID4244: Internal error: sessionAuthenticator must support IIssuanceSecurityTokenAuthenticator.</value>
  </data>
  <data name="ID4245" xml:space="preserve">
    <value>ID4245: Internal error: sessionAuthenticator must support ICommunicationObject.</value>
  </data>
  <data name="ID4268" xml:space="preserve">
    <value>ID4268: MergeClaims must have at least one identity that is not null.</value>
  </data>
  <data name="ID4271" xml:space="preserve">
    <value>ID4271: No IAuthorizationPolicy was found for the Transport security token '{0}'.</value>
  </data>
  <data name="ID4274" xml:space="preserve">
    <value>ID4274: The Configuration property of this SecurityTokenHandler is set to null. Tokens cannot be read or validated in this state. Set this property or add this SecurityTokenHandler to a SecurityTokenHandlerCollection with a valid Configuration property.</value>
  </data>
  <data name="ID4285" xml:space="preserve">
    <value>ID4285: Cannot replace SecurityToken with Id '{0}' in cache with new one. Token must exist in cache to be replaced.</value>
  </data>
  <data name="ID4287" xml:space="preserve">
    <value>ID4287: The SecurityTokenRequirement '{0}' doesn't contain a ListenUri.</value>
  </data>
  <data name="WebSocketInvalidProtocolNotInClientList" xml:space="preserve">
    <value>The subprotocol '{0}' was not requested by the client. The client requested the following subprotocol(s): '{1}'.</value>
  </data>
  <data name="WebSocketInvalidProtocolInvalidCharInProtocolString" xml:space="preserve">
    <value>The subprotocol '{0}' is invalid because it contains the invalid character '{1}'.</value>
  </data>
  <data name="WebSocketInvalidProtocolContainsMultipleSubProtocolString" xml:space="preserve">
    <value>The value specified ('{0}') contains more than one subprotocol which is not supported.</value>
  </data>
  <data name="WebSocketInvalidProtocolEmptySubprotocolString" xml:space="preserve">
    <value>Empty string is not a valid subprotocol value. Please use "null" to specify no value.</value>
  </data>
  <data name="WebSocketEndpointOnlySupportWebSocketError" xml:space="preserve">
    <value>This service only supports WebSocket connections.</value>
  </data>
  <data name="WebSocketContextWebSocketCannotBeAccessedError" xml:space="preserve">
    <value>WebSocket object cannot be accessed directly.</value>
  </data>
  <data name="WebSocketUnexpectedCloseMessageError" xml:space="preserve">
    <value>Unexpected WebSocket close message received when receiving a message.</value>
  </data>
  <data name="WebSocketStreamWriteCalledAfterEOMSent" xml:space="preserve">
    <value>Cannot write to the stream because the end of the stream marker was already written.</value>
  </data>
  <data name="WebSocketOpeningHandshakePropertiesNotAvailable" xml:space="preserve">
    <value>The opening handshake properties associated with the current WebSocket connection are not available. The most likely cause is that the property '{0}' on the '{1}' object returned from the custom '{2}' is not set.</value>
  </data>
  <data name="AcceptWebSocketTimedOutError" xml:space="preserve">
    <value>The operation to establish the WebSocket connection timed out. To increase this time limit, use the OpenTimeout property on the service endpoint's binding.</value>
  </data>
  <data name="WebSocketSendTimedOut" xml:space="preserve">
    <value>The Send operation timed out after '{0}'. Increase the SendTimeout value on the Binding. The time allotted to this operation may have been a portion of a longer timeout.</value>
  </data>
  <data name="WebSocketReceiveTimedOut" xml:space="preserve">
    <value>The Receive operation timed out after '{0}'. For duplex sessionful channels, the receive timeout is also the idle timeout for the channel, so consider setting a suitably large value for the ReceiveTimeout value on the Binding. The time allotted to this operation may have been a portion of a longer timeout.</value>
  </data>
  <data name="WebSocketOperationTimedOut" xml:space="preserve">
    <value>The '{0}' operation timed out after '{1}'. The time allotted to this operation may have been a portion of a longer timeout.</value>
  </data>
  <data name="BufferedOutputStreamQuotaExceeded" xml:space="preserve">
    <value>The size quota for this stream ({0}) has been exceeded.</value>
  </data>
  <data name="BufferIsNotRightSizeForBufferManager" xml:space="preserve">
    <value>This buffer cannot be returned to the buffer manager because it is the wrong size.</value>
  </data>
  <data name="ArgumentCannotBeEmptyString" xml:space="preserve">
    <value>The argument must be a non-empty string.</value>
  </data>
  <data name="ActionItemIsAlreadyScheduled" xml:space="preserve">
    <value>The ActionItem was already scheduled for execution that hasn't been completed yet.</value>
  </data>
  <data name="TimeoutInputQueueDequeue" xml:space="preserve">
    <value>A Dequeue operation timed out after {0}. The time allotted to this operation may have been a portion of a longer timeout.</value>
  </data>
  <data name="Xml_InvalidNodeType" xml:space="preserve">
    <value>'{0}' is an invalid XmlNodeType.</value>
  </data>
  <data name="InvalidSemaphoreExit" xml:space="preserve">
    <value>Object synchronization method was called from an unsynchronized block of code.</value>
  </data>
  <data name="InvalidTypedProxyMethodHandle" xml:space="preserve">
    <value>The specified method handle is incorrect for the proxy of type '{0}'</value>
  </data>
  <data name="FailedToCreateTypedProxy" xml:space="preserve">
    <value>Failed to create a typed proxy for type '{0}'</value>
  </data>
  <data name="XmlInvalidStream" xml:space="preserve">
    <value>Stream returned by OperationStreamProvider cannot be null.</value>
  </data>
  <data name="XmlInvalidConversion" xml:space="preserve">
    <value>The value '{0}' cannot be parsed as the type '{1}'.</value>
  </data>
</root>