// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

using System.Collections.Generic;
using System.Security.Claims;
using System.Threading.Tasks;
using CoreWCF.Channels;
using CoreWCF.Configuration;
using Microsoft.AspNetCore.Authentication;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.DependencyInjection;

namespace CoreWCF.Http.Tests.Authorization;

public class AuthorizationStartup
{
    public void ConfigureServices(IServiceCollection services)
    {
        services.AddAuthorization(options =>
        {
            options.AddPolicy(Policies.Write,
                policy => policy.RequireClaim("scope", new[] { DefinedScopes.Write, DefinedScopes.Admin }));
            options.AddPolicy(Policies.AdminOnly,
                policy => policy.RequireClaim("scope", new[] { DefinedScopes.Admin }));
        });
        services.AddServiceModelServices();
    }

    public void Configure(IApplicationBuilder app)
    {
        app.UseServiceModel(builder =>
        {
            builder.AddService<SecuredService>();
            builder.AddServiceEndpoint<SecuredService, ISecuredService>(new BasicHttpBinding
            {
                Security = new BasicHttpSecurity
                {
                    Mode = BasicHttpSecurityMode.TransportCredentialOnly,
                    Transport = new HttpTransportSecurity
                    {
                        ClientCredentialType = HttpClientCredentialType.InheritedFromHost
                    }
                }
            }, "/BasicWcfService/basichttp.svc");
            builder.AddServiceEndpoint<SecuredService, ISecuredService>(new BasicHttpBinding
            {
                Security = new BasicHttpSecurity
                {
                    Mode = BasicHttpSecurityMode.Transport,
                    Transport = new HttpTransportSecurity
                    {
                        ClientCredentialType = HttpClientCredentialType.InheritedFromHost
                    }
                }
            }, "/BasicWcfService/basichttp.svc");
        });
    }
}

[ServiceContract]
public interface ISecuredService
{
    [OperationContract]
    string Default(string text);

    [OperationContract]
    string AdminOnly(string text);

    [OperationContract]
    Task<string> Write(string text);

    [OperationContract]
    Task<string> Generated(string text);
}

[ServiceBehavior(IncludeExceptionDetailInFaults = true)]
public partial class SecuredService : ISecuredService
{
    // No attribute => defaults to the builtin default policy which is RequireAuthenticatedUser
    public string Default(string text) => text;

    [Authorize(Policy = Policies.AdminOnly)]
    public string AdminOnly(string text) => text;

    [Authorize(Policy = Policies.Write)]
    public Task<string> Write(string text) => Task.FromResult(text);

    [Authorize(Policy = Policies.AdminOnly)]
    public Task<string> Generated(string text, [Injected] HttpContext httpContext) => Task.FromResult(text);
}

// simulate what is generated by OperationParameterInjectorGenerator
public partial class SecuredService
{
    [AuthorizeAttribute(Policy = "AdminOnly")]
    public Task<string> Generated(string text) => Task.FromResult(text);
}

internal static class Policies
{
    public const string AdminOnly = nameof(AdminOnly);
    public const string Write = nameof(Write);
}

internal static class DefinedScopes
{
    public const string Admin = nameof(Admin);
    public const string Read = nameof(Read);
    public const string Write = nameof(Write);
}

public class AuthorizationServiceInterceptor : IAuthorizationService
{
    private readonly IAuthorizationService _authorizationService;

    public bool IsAuthorizeAsyncCalled { get; private set; }

    public AuthorizationServiceInterceptor(IAuthorizationService authorizationService)
    {
        _authorizationService = authorizationService;
    }

    public async Task<AuthorizationResult> AuthorizeAsync(ClaimsPrincipal user, object resource,
        IEnumerable<IAuthorizationRequirement> requirements)
    {
        var result = await _authorizationService.AuthorizeAsync(user, resource, requirements);
        IsAuthorizeAsyncCalled = true;
        return result;
    }

    public async Task<AuthorizationResult> AuthorizeAsync(ClaimsPrincipal user, object resource, string policyName)
    {
        var result = await _authorizationService.AuthorizeAsync(user, resource, policyName);
        IsAuthorizeAsyncCalled = true;
        return result;
    }
}

public class AuthenticationServiceInterceptor : IAuthenticationService
{
    private readonly IAuthenticationService _authenticationService;

    public bool IsAuthenticateAsyncCalled { get; private set; }

    public AuthenticationServiceInterceptor(IAuthenticationService authenticationService)
    {
        _authenticationService = authenticationService;
    }

    public async Task<AuthenticateResult> AuthenticateAsync(HttpContext context, string scheme)
    {
        var result = await _authenticationService.AuthenticateAsync(context, scheme);
        IsAuthenticateAsyncCalled = true;
        return result;
    }

    public Task ChallengeAsync(HttpContext context, string scheme, AuthenticationProperties properties)
        => _authenticationService.ChallengeAsync(context, scheme, properties);

    public Task ForbidAsync(HttpContext context, string scheme, AuthenticationProperties properties)
        => _authenticationService.ForbidAsync(context, scheme, properties);

    public Task SignInAsync(HttpContext context, string scheme, ClaimsPrincipal principal,
        AuthenticationProperties properties)
        => _authenticationService.SignInAsync(context, scheme, principal, properties);

    public Task SignOutAsync(HttpContext context, string scheme, AuthenticationProperties properties)
        => _authenticationService.SignOutAsync(context, scheme, properties);
}
